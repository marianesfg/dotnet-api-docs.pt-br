<Type Name="MethodBase" FullName="System.Reflection.MethodBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="cc835ba89554a81318a5948b06c2447df89fe759" />
    <Meta Name="ms.sourcegitcommit" Value="254e16ae65e82f4aa59360cd8572b36b6b5b2f80" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/05/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodBase extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._MethodBase" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodBase&#xA;Inherits MemberInfo&#xA;Implements _MethodBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodBase abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_MethodBase" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodBase</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="8549a-101">Fornece informações sobre os métodos e construtores.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8549a-101">Provides information about methods and constructors.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-102">`MethodBase` é a classe base de <xref:System.Reflection.MethodInfo> e <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="8549a-102">`MethodBase` is the base class of <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="8549a-103">para confiança total de herdeiros.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8549a-103">for full trust for inheritors.</span>
      </span>
      <span data-ttu-id="8549a-104">Esta classe não pode ser herdada pelo código parcialmente confiável.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8549a-104">This class cannot be inherited by partially trusted code.</span>
      </span>
    </permission>
    <threadsafe>
      <span data-ttu-id="8549a-105">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="8549a-105">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="8549a-106">Ao herdar de <see langword="MethodBase" />, você deve substituir os seguintes membros: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /> , <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, e <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="8549a-106">When you inherit from <see langword="MethodBase" />, you must override the following members: <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodBase ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-107">Inicializa uma nova instância da classe <see cref="T:System.Reflection.MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-107">Initializes a new instance of the <see cref="T:System.Reflection.MethodBase" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-108">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-108">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-109">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-109">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As MethodAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::MethodAttributes Attributes { System::Reflection::MethodAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-110">Obtém os atributos associados a esse método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-110">Gets the attributes associated with this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-111">Um dos valores de <see cref="T:System.Reflection.MethodAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-111">One of the <see cref="T:System.Reflection.MethodAttributes" /> values.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-112">Todos os membros têm um conjunto de atributos que são definidos em relação do tipo específico de membro.</span><span class="sxs-lookup"><span data-stu-id="8549a-112">All members have a set of attributes, which are defined in relation to the specific type of member.</span></span>  
  
 <span data-ttu-id="8549a-113">Para obter o <xref:System.Reflection.MethodAttributes>, primeiro obtenha o tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-113">To get the <xref:System.Reflection.MethodAttributes>, first get the type.</span></span> <span data-ttu-id="8549a-114">Do tipo, o método get.</span><span class="sxs-lookup"><span data-stu-id="8549a-114">From the type, get the method.</span></span> <span data-ttu-id="8549a-115">O método de obter o <xref:System.Reflection.MethodAttributes>.</span><span class="sxs-lookup"><span data-stu-id="8549a-115">From the method, get the <xref:System.Reflection.MethodAttributes>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-116">O exemplo de código a seguir exibe os atributos do método definido pelo usuário Meumetodo.</span><span class="sxs-lookup"><span data-stu-id="8549a-116">The following code example displays the attributes of the user-defined method Mymethod.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 <span data-ttu-id="8549a-117">Esse código gera a seguinte saída:</span><span class="sxs-lookup"><span data-stu-id="8549a-117">This code produces the following output:</span></span>  
  
 <span data-ttu-id="8549a-118">Exemplo de Reflection.MethodBase.Attributes</span><span class="sxs-lookup"><span data-stu-id="8549a-118">Reflection.MethodBase.Attributes Sample</span></span>  
  
 <span data-ttu-id="8549a-119">Mymethodbase = Meumetodo Void (Int32, ByRef de System. String, System. String ByRef)</span><span class="sxs-lookup"><span data-stu-id="8549a-119">Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</span></span>  
  
 <span data-ttu-id="8549a-120">PrivateScope</span><span class="sxs-lookup"><span data-stu-id="8549a-120">PrivateScope</span></span>  
  
 <span data-ttu-id="8549a-121">FamANDAssem</span><span class="sxs-lookup"><span data-stu-id="8549a-121">FamANDAssem</span></span>  
  
 <span data-ttu-id="8549a-122">Família</span><span class="sxs-lookup"><span data-stu-id="8549a-122">Family</span></span>  
  
 <span data-ttu-id="8549a-123">Público</span><span class="sxs-lookup"><span data-stu-id="8549a-123">Public</span></span>  
  
 <span data-ttu-id="8549a-124">HideBySig</span><span class="sxs-lookup"><span data-stu-id="8549a-124">HideBySig</span></span>  
  
 <span data-ttu-id="8549a-125">ReuseSlot</span><span class="sxs-lookup"><span data-stu-id="8549a-125">ReuseSlot</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="8549a-126">Use o <see cref="P:System.Reflection.MethodBase.Attributes" /> propriedade para determinar se um método é <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />e assim por diante.</span>
            <span class="sxs-lookup">
              <span data-stu-id="8549a-126">Use the <see cref="P:System.Reflection.MethodBase.Attributes" /> property to determine whether a method is <see langword="public" />, <see langword="private" />, <see langword="final" />, <see langword="virtual" />, and so on.</span>
            </span>
          </para>
        </block>
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="CallingConvention">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.CallingConventions CallingConvention { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.CallingConventions CallingConvention" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.CallingConvention" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CallingConvention As CallingConventions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::CallingConventions CallingConvention { System::Reflection::CallingConventions get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.CallingConvention</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.CallingConventions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-127">Obtém um valor que indica as convenções de chamada deste método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-127">Gets a value indicating the calling conventions for this method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-128">As <see cref="T:System.Reflection.CallingConventions" /> deste método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-128">The <see cref="T:System.Reflection.CallingConventions" /> for this method.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Reflection.CallingConventions" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-129">Obtém um valor que indica se o método genérico contém parâmetros de tipo genérico não atribuídos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-129">Gets a value indicating whether the generic method contains unassigned generic type parameters.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-130">
            <see langword="true" /> Se o atual <see cref="T:System.Reflection.MethodBase" /> objeto representa um método genérico que contém parâmetros de tipo genérico não atribuídos; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-130">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents a generic method that contains unassigned generic type parameters; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-131">Um método genérico pode ser chamado somente se não houver nenhuma definição de tipo genérico ou tipos construídos abertos em argumentos de tipo do método próprio ou em qualquer tipo de delimitador.</span><span class="sxs-lookup"><span data-stu-id="8549a-131">A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</span></span> <span data-ttu-id="8549a-132">Como tipos podem ser arbitrariamente complexos, é difícil fazer essa determinação recursiva.</span><span class="sxs-lookup"><span data-stu-id="8549a-132">Because types can be arbitrarily complex, making this recursive determination is difficult.</span></span> <span data-ttu-id="8549a-133">Para sua conveniência e para reduzir a chance de erro, o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade fornece uma maneira padrão para distinguir entre os métodos construídos fechados, que podem ser chamados, e abrir construída métodos, que não é possível.</span><span class="sxs-lookup"><span data-stu-id="8549a-133">For convenience, and to reduce the chance of error, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="8549a-134">Se o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade retorna `true`, o método não pode ser invocado.</span><span class="sxs-lookup"><span data-stu-id="8549a-134">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, the method cannot be invoked.</span></span>  
  
 <span data-ttu-id="8549a-135">O <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade pesquisa recursivamente para parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-135">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="8549a-136">Por exemplo, ele retorna `true` para qualquer método em um tipo aberto `A<T>` (`A(Of T)` no Visual Basic), mesmo que o próprio método não é genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-136">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="8549a-137">Compare isso com o comportamento do <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriedade, que retorna `false` para tal método.</span><span class="sxs-lookup"><span data-stu-id="8549a-137">Contrast this with the behavior of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property, which returns `false` for such a method.</span></span>  
  
 <span data-ttu-id="8549a-138">Da mesma forma, o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> retorna o parâmetro de propriedade `true` para nenhum construtor em um tipo aberto, mesmo que construtores não podem ter parâmetros de tipo de seus próprios.</span><span class="sxs-lookup"><span data-stu-id="8549a-138">Similarly, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property parameter returns `true` for any constructor in an open type, even though constructors cannot have type parameters of their own.</span></span>  
  
 <span data-ttu-id="8549a-139">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-139">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="8549a-140">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-140">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="8549a-141">Um objeto a ser comparado com essa instância ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-141">An object to compare with this instance, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-142">Retorna um valor que indica se essa instância é igual a um objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-142">Returns a value that indicates whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-143">
            <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-143">
              <see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentMethod">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetCurrentMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetCurrentMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetCurrentMethod" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentMethod () As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetCurrentMethod();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-144">Retorna um objeto <see langword="MethodBase" /> que representa o método em execução no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-144">Returns a <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-145">
            <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> é um método estático que é chamado de um método em execução e que retorna informações sobre esse método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-145">
              <see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /> is a static method that is called from within an executing method and that returns information about that method.</span>
          </span>
          <span data-ttu-id="8549a-146">Um objeto <see langword="MethodBase" /> que representa o método em execução no momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-146">A <see langword="MethodBase" /> object representing the currently executing method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-147">Se o método atualmente em execução é definido em um tipo genérico, o <xref:System.Reflection.MethodInfo> que é retornado por <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> é obtido da definição de tipo genérico (ou seja, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> retorna `true`).</span><span class="sxs-lookup"><span data-stu-id="8549a-147">If the currently executing method is defined on a generic type, the <xref:System.Reflection.MethodInfo> that is returned by <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is obtained from the generic type definition (that is, <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType> returns `true`).</span></span> <span data-ttu-id="8549a-148">Portanto, não reflete os argumentos de tipo que foram usados quando o método foi chamado.</span><span class="sxs-lookup"><span data-stu-id="8549a-148">Therefore, it does not reflect the type arguments that were used when the method was called.</span></span> <span data-ttu-id="8549a-149">Por exemplo, se um método `M()` é definido em um tipo genérico `C<T>` (`C(Of T)` no Visual Basic), e <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> é chamado de `C<string>.M()`, em seguida, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> retorna `C<T>.M()` (`C(Of T).M()` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8549a-149">For example, if a method `M()` is defined on a generic type `C<T>` (`C(Of T)` in Visual Basic), and <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> is called from `C<string>.M()`, then <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns `C<T>.M()` (`C(Of T).M()` in Visual Basic).</span></span>  
  
 <span data-ttu-id="8549a-150">Se o método de execução no momento é um método genérico, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> retorna a definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-150">If the currently executing method is a generic method, <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> returns the generic method definition.</span></span> <span data-ttu-id="8549a-151">Se o método genérico está definido em um tipo genérico, o <xref:System.Reflection.MethodInfo> é obtido da definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-151">If the generic method is defined on a generic type, the <xref:System.Reflection.MethodInfo> is obtained from the generic type definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-152">O exemplo a seguir define dois tipos.</span><span class="sxs-lookup"><span data-stu-id="8549a-152">The following example defines two types.</span></span> <span data-ttu-id="8549a-153">A primeira é uma classe não-genérica, `TestClass`, inclui um construtor, um método chamado `GetValue`e uma propriedade de leitura-gravação chamada `GetValue`.</span><span class="sxs-lookup"><span data-stu-id="8549a-153">The first is a non-generic class, `TestClass`, includes a constructor, a method named `GetValue`, and a read-write property named `GetValue`.</span></span> <span data-ttu-id="8549a-154">O segundo é uma classe genérica denominada `TestClass<T>` que inclui um construtor, um `GetValue` método e um método genérico, `ConvertValue<Y>`.</span><span class="sxs-lookup"><span data-stu-id="8549a-154">The second is a generic class named `TestClass<T>` that includes a constructor, a `GetValue` method, and a generic method, `ConvertValue<Y>`.</span></span> <span data-ttu-id="8549a-155">Cada construtor, um método e um acessador de propriedade incluem uma chamada para o <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="8549a-155">Each constructor, method, and property accessor includes a call to the <xref:System.Reflection.MethodBase.GetCurrentMethod%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/cs/GetCurentMethod1.cs#1)]
 [!code-vb[System.Reflection.MethodBase.GetCurrentMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Reflection.MethodBase.GetCurrentMethod/vb/GetCurentMethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="8549a-156">Este membro foi invocado com um mecanismo de associação tardia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-156">This member was invoked with a late-binding mechanism.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-157">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-157">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-158">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-158">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-159">Retorna uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-159">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-160">Uma matriz de objetos <see cref="T:System.Type" /> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-160">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span>
          </span>
          <span data-ttu-id="8549a-161">Retornará uma matriz vazia se o método atual não for um método genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-161">Returns an empty array if the current method is not a generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-162">Os elementos da matriz retornada estão na ordem em que aparecem na lista de parâmetros de tipo para o método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-162">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="8549a-163">Se o método atual é um método de construído fechado (ou seja, o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade retorna `false`), a matriz retornada pelo <xref:System.Reflection.MethodBase.GetGenericArguments%2A> método contém os tipos que foram atribuídos a parâmetros de tipo genérico de definição de método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-163">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="8549a-164">Se o método atual é uma definição de método genérico, a matriz contém os parâmetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-164">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="8549a-165">Se o método atual é um método construído open (ou seja, o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade retorna `true`) em que tipos específicos foram atribuídos a alguns parâmetros de tipo e parâmetros de tipo de delimitador tipos genéricos foram atribuídos a outros parâmetros de tipo, a matriz contém tipos e tipo de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="8549a-165">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="8549a-166">Use o <xref:System.Type.IsGenericParameter%2A> propriedade distingui-los.</span><span class="sxs-lookup"><span data-stu-id="8549a-166">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="8549a-167">Para ver uma demonstração desse cenário, consulte o exemplo de código fornecido para o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-167">For a demonstration of this scenario, see the code example provided for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="8549a-168">Não há suporte para construtores genéricos no .NET Framework versão 2.0.</span><span class="sxs-lookup"><span data-stu-id="8549a-168">Generic constructors are not supported in the .NET Framework version 2.0.</span></span> <span data-ttu-id="8549a-169">Essa propriedade gerará <xref:System.NotSupportedException> se não for substituída em uma classe derivada, então uma exceção será lançada se a instância atual é do tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="8549a-169">This property throws <xref:System.NotSupportedException> if not overridden in a derived class, so an exception is thrown if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="8549a-170">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-170">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="8549a-171">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-171">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8549a-172">O objeto atual é um <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-172">The current object is a <see cref="T:System.Reflection.ConstructorInfo" />.</span>
          </span>
          <span data-ttu-id="8549a-173">Não há suporte para construtores genéricos no .NET Framework versão 2.0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-173">Generic constructors are not supported in the .NET Framework version 2.0.</span>
          </span>
          <span data-ttu-id="8549a-174">Essa exceção será o comportamento padrão se esse método não for substituído em uma classe derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-174">This exception is the default behavior if this method is not overridden in a derived class.</span>
          </span>
        </exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericArguments" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-175">Retorna o código hash para essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-175">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-176">Um código de hash do inteiro assinado de 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-176">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodBody">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBody GetMethodBody ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBody GetMethodBody() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodBody" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMethodBody () As MethodBody" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodBody ^ GetMethodBody();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBody</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-177">Quando substituído em uma classe derivada, obtém um objeto <see cref="T:System.Reflection.MethodBody" /> que fornece acesso ao fluxo MSIL, variáveis locais e exceções para o método atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-177">When overridden in a derived class, gets a <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-178">Um objeto <see cref="T:System.Reflection.MethodBody" /> que fornece acesso ao fluxo MSIL, variáveis locais e exceções para o método atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-178">A <see cref="T:System.Reflection.MethodBody" /> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-179">Você não precisa substituir o <xref:System.Reflection.MethodBase.GetMethodBody%2A> para usá-lo.</span><span class="sxs-lookup"><span data-stu-id="8549a-179">You do not have to override the <xref:System.Reflection.MethodBase.GetMethodBody%2A> in order to use it.</span></span> <span data-ttu-id="8549a-180">Você pode chamar o <xref:System.Reflection.MethodBase.GetMethodBody%2A> método <xref:System.Reflection.MethodInfo> e <xref:System.Reflection.ConstructorInfo> objetos, porque o método é substituído nas versões em tempo de execução dessas classes.</span><span class="sxs-lookup"><span data-stu-id="8549a-180">You can call the <xref:System.Reflection.MethodBase.GetMethodBody%2A> method on <xref:System.Reflection.MethodInfo> and <xref:System.Reflection.ConstructorInfo> objects, because the method is overridden in the runtime versions of these classes.</span></span> <span data-ttu-id="8549a-181">Por exemplo, a versão de tempo de execução do <xref:System.Reflection.MethodInfo> classe deriva o <xref:System.Reflection.MethodInfo> classe, que por sua vez deriva o <xref:System.Reflection.MethodBase> classe.</span><span class="sxs-lookup"><span data-stu-id="8549a-181">For example, the runtime version of the <xref:System.Reflection.MethodInfo> class derives from the <xref:System.Reflection.MethodInfo> class, which in turn derives from the <xref:System.Reflection.MethodBase> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-182">O exemplo de código a seguir define um método de teste chamado `MethodBodyExample` e exibe suas informações de variáveis locais e cláusulas de tratamento de exceção.</span><span class="sxs-lookup"><span data-stu-id="8549a-182">The following code example defines a test method named `MethodBodyExample` and displays its local variable information and exception-handling clauses.</span></span> <span data-ttu-id="8549a-183">O <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> método é usado para obter um <xref:System.Reflection.MethodBody> objeto para o método de teste.</span><span class="sxs-lookup"><span data-stu-id="8549a-183">The <xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType> method is used to obtain a <xref:System.Reflection.MethodBody> object for the test method.</span></span>  
  
 <span data-ttu-id="8549a-184">O <xref:System.Reflection.MethodBody.LocalVariables%2A> propriedade é usada para obter uma lista de <xref:System.Reflection.LocalVariableInfo> objetos e exibir seus tipos e ordem de índice.</span><span class="sxs-lookup"><span data-stu-id="8549a-184">The <xref:System.Reflection.MethodBody.LocalVariables%2A> property is used to obtain a list of <xref:System.Reflection.LocalVariableInfo> objects and display their types and index order.</span></span> <span data-ttu-id="8549a-185">O <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> propriedade é usada para obter uma lista de cláusulas de tratamento de exceção.</span><span class="sxs-lookup"><span data-stu-id="8549a-185">The <xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A> property is used to obtain a list of exception-handling clauses.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-186">Nem todos os idiomas do computador podem gerar <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> cláusulas.</span><span class="sxs-lookup"><span data-stu-id="8549a-186">Not all computer languages can generate <xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType> clauses.</span></span> <span data-ttu-id="8549a-187">O exemplo do Visual Basic mostra uma cláusula de filtro, usando um Visual Basic `When` expressão, que é omitido dos exemplos para outros idiomas.</span><span class="sxs-lookup"><span data-stu-id="8549a-187">The Visual Basic example shows a filter clause, using a Visual Basic `When` expression, which is omitted from the examples for other languages.</span></span>  
  
 [!code-cpp[MethodBody#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodBody/cpp/source.cpp#1)]
 [!code-csharp[MethodBody#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodBody/CS/source.cs#1)]
 [!code-vb[MethodBody#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodBody/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8549a-188">Esse método é inválido, a menos que seja substituído em uma classe derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-188">This method is invalid unless overridden in a derived class.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-189">para o acesso aos metadados para membros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-189">for the access to metadata for members.</span>
          </span>
          <span data-ttu-id="8549a-190">Valor de permissão: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-190">Permission value: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethodFromHandle">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-191">Obtém informações sobre o método usando o identificador especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-191">Gets method information using the specified handle.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="8549a-192">O identificador do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-192">The method's handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-193">Obtém informações de método usando a representação de metadados internos do método (identificador).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-193">Gets method information by using the method's internal metadata representation (handle).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-194">Um <see langword="MethodBase" /> que contém informações sobre o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-194">A <see langword="MethodBase" /> containing information about the method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-195">Identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</span><span class="sxs-lookup"><span data-stu-id="8549a-195">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8549a-196">
            <paramref name="handle" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-196">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-197">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-197">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-198">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-198">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodFromHandle">
      <MemberSignature Language="C#" Value="public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.MethodBase GetMethodFromHandle(valuetype System.RuntimeMethodHandle handle, valuetype System.RuntimeTypeHandle declaringType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetMethodFromHandle (handle As RuntimeMethodHandle, declaringType As RuntimeTypeHandle) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::MethodBase ^ GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeMethodHandle" />
        <Parameter Name="declaringType" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="8549a-199">Um identificador para a representação de metadados internos de um construtor ou método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-199">A handle to the internal metadata representation of a constructor or method.</span>
          </span>
        </param>
        <param name="declaringType">
          <span data-ttu-id="8549a-200">Um identificador para o tipo genérico que define o construtor ou método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-200">A handle to the generic type that defines the constructor or method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-201">Obtém um objeto <see cref="T:System.Reflection.MethodBase" /> para o construtor ou método representado pelo identificador especificado, para o tipo genérico especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-201">Gets a <see cref="T:System.Reflection.MethodBase" /> object for the constructor or method represented by the specified handle, for the specified generic type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-202">Um objeto <see cref="T:System.Reflection.MethodBase" /> que representa o método ou o construtor especificado por <paramref name="handle" />, no tipo genérico especificado por <paramref name="declaringType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-202">A <see cref="T:System.Reflection.MethodBase" /> object representing the method or constructor specified by <paramref name="handle" />, in the generic type specified by <paramref name="declaringType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-203">Identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</span><span class="sxs-lookup"><span data-stu-id="8549a-203">Handles are valid only in the application domain in which they were obtained.</span></span>  
  
 <span data-ttu-id="8549a-204">Um <xref:System.RuntimeMethodHandle> estrutura para um construtor ou método de um tipo genérico pode representar diferentes <xref:System.Reflection.MethodBase> objetos, dependendo dos tipos especificados para os parâmetros de tipo do tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-204">A <xref:System.RuntimeMethodHandle> structure for a constructor or method of a generic type can represent different <xref:System.Reflection.MethodBase> objects, depending on the types specified for the type parameters of the generic type.</span></span> <span data-ttu-id="8549a-205">Por exemplo, se `class G<T>` (`class G(Of T)` no Visual Basic, `generic <T> ref class G` em C++) tem um método que retorna tipo `T`, o <xref:System.Reflection.MethodBase> objeto para o método em uma classe construído como `G<int>` é diferente do <xref:System.Reflection.MethodBase> objeto para esse método de definição de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-205">For example, if `class G<T>` (`class G(Of T)` in Visual Basic, `generic <T> ref class G` in C++) has a method that returns type `T`, the <xref:System.Reflection.MethodBase> object for that method in a constructed class such as `G<int>` is different from the <xref:System.Reflection.MethodBase> object for that method in the generic type definition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8549a-206">
            <paramref name="handle" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-206">
              <paramref name="handle" /> is invalid.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-207">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-207">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-208">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-208">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImplementationFlags">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.MethodImplAttributes GetMethodImplementationFlags() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethodImplementationFlags () As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodImplAttributes GetMethodImplementationFlags();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetMethodImplementationFlags</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-209">Quando substituído em uma classe derivada, retorna os sinalizadores <see cref="T:System.Reflection.MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-209">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodImplAttributes" /> flags.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-210">Os sinalizadores <see langword="MethodImplAttributes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-210">The <see langword="MethodImplAttributes" /> flags.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8549a-211">O exemplo a seguir define um construtor em um assembly dinâmico e, em seguida, usa o <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> método para exibir os sinalizadores de implementação de método são definidos por padrão.</span><span class="sxs-lookup"><span data-stu-id="8549a-211">The following example defines a constructor in a dynamic assembly and then uses the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method to display the method implementation flags that are set by default.</span></span>  
  
 [!code-cpp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/cpp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CPP/constructorbuilder_getmodule_4.cpp#3)]
 [!code-csharp[ConstructorBuilder_GetModule_4#3](~/samples/snippets/csharp/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/CS/constructorbuilder_getmodule_4.cs#3)]
 [!code-vb[ConstructorBuilder_GetModule_4#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ConstructorBuilder_GetModule_4/VB/constructorbuilder_getmodule_4.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-212">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-212">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-213">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-213">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodImplAttributes" />
      </Docs>
    </Member>
    <Member MemberName="GetParameters">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ParameterInfo[] GetParameters ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ParameterInfo[] GetParameters() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.GetParameters" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetParameters () As ParameterInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ParameterInfo ^&gt; ^ GetParameters();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetParameters</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-214">Quando substituído em uma classe derivada, obtém os parâmetros do método ou do construtor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-214">When overridden in a derived class, gets the parameters of the specified method or constructor.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-215">Uma matriz do tipo <see langword="ParameterInfo" /> que contém informações que correspondem à assinatura do método (ou do construtor) refletido por essa instância <see langword="MethodBase" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-215">An array of type <see langword="ParameterInfo" /> containing information that matches the signature of the method (or constructor) reflected by this <see langword="MethodBase" /> instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="8549a-216">O exemplo a seguir usa o <xref:System.Reflection.MethodBase.GetParameters%2A> método para recuperar os parâmetros do `Invoke` método de um representante.</span><span class="sxs-lookup"><span data-stu-id="8549a-216">The following example uses the <xref:System.Reflection.MethodBase.GetParameters%2A> method to retrieve the parameters of the `Invoke` method of a delegate.</span></span>  
  
 <span data-ttu-id="8549a-217">O exemplo define um delegado chamado `MyDelegate` e um evento chamado `ev` do tipo `MyDelegate`.</span><span class="sxs-lookup"><span data-stu-id="8549a-217">The example defines a delegate named `MyDelegate` and an event named `ev` of type `MyDelegate`.</span></span> <span data-ttu-id="8549a-218">O código de `Main` método descobre a assinatura de evento, fazendo com que o tipo delegado do evento, obtendo o `Invoke` método do tipo delegado e, em seguida, recuperar e exibir os parâmetros.</span><span class="sxs-lookup"><span data-stu-id="8549a-218">The code in the `Main` method discovers the event signature by getting the delegate type of the event, getting the `Invoke` method of the delegate type, and then retrieving and displaying the parameters.</span></span>  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-219">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-219">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-220">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-220">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.ParameterInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-221">Invoca o método ou construtor refletido por esta instância <see langword="MethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-221">Invokes the method or constructor reflected by this <see langword="MethodInfo" /> instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="8549a-222">O objeto no qual o método ou o construtor será invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-222">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="8549a-223">Se um método for estático, esse argumento será ignorado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-223">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="8549a-224">Se um construtor for estático, esse argumento deverá ser <see langword="null" /> ou uma instância da classe que define o construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-224">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="8549a-225">Uma lista de argumentos para o construtor ou método invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-225">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="8549a-226">Esta é uma matriz de objetos com o mesmo número, ordem e tipo que os parâmetros do método ou do construtor a ser invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-226">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="8549a-227">Se não houver nenhum parâmetro, <c>parameters</c> deverá ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-227">If there are no parameters, <c>parameters</c> should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8549a-228">Se o método ou construtor representado por esta instância usar um parâmetro <see langword="ref" /> (<see langword="ByRef" /> no Visual Basic), nenhum atributo especial será necessário para esse parâmetro, a fim de invocar o método ou construtor com o uso dessa função.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-228">If the method or constructor represented by this instance takes a <see langword="ref" /> parameter (<see langword="ByRef" /> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="8549a-229">Qualquer objeto nesta matriz que não for inicializado explicitamente com um valor conterá o valor padrão desse tipo de objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-229">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="8549a-230">Para elementos de tipo de referência, esse valor é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-230">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8549a-231">Para elementos de tipo de valor, esse valor é 0, 0,0, ou <see langword="false" />, dependendo do tipo de elemento específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-231">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-232">Invoca o método ou o construtor representado pela instância atual, usando os parâmetros especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-232">Invokes the method or constructor represented by the current instance, using the specified parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-233">Um objeto que contém o valor retornado do método invocado, ou <see langword="null" /> no caso de um construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-233">An object containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-234">Este é um método prático que chama o <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> sobrecarga do método, passando <xref:System.Reflection.BindingFlags.Default> para `invokeAttr` e `null` para `binder` e `culture`.</span><span class="sxs-lookup"><span data-stu-id="8549a-234">This is a convenience method that calls the <xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29> method overload, passing <xref:System.Reflection.BindingFlags.Default> for `invokeAttr` and `null` for `binder` and `culture`.</span></span>  
  
 <span data-ttu-id="8549a-235">Se o método invocado lança uma exceção, o <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> método retorna a exceção.</span><span class="sxs-lookup"><span data-stu-id="8549a-235">If the invoked method throws an exception, the <xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType> method returns the exception.</span></span>  
  
 <span data-ttu-id="8549a-236">Para invocar um método estático usando seu <xref:System.Reflection.MethodInfo> de objeto, passe `null` para `obj`.</span><span class="sxs-lookup"><span data-stu-id="8549a-236">To invoke a static method using its <xref:System.Reflection.MethodInfo> object, pass `null` for `obj`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-237">Se essa sobrecarga de método é usada para chamar um construtor de instância, o objeto fornecido para `obj` é reinicializada; ou seja, todos os inicializadores de instância são executados.</span><span class="sxs-lookup"><span data-stu-id="8549a-237">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="8549a-238">O valor retornado é `null`.</span><span class="sxs-lookup"><span data-stu-id="8549a-238">The return value is `null`.</span></span> <span data-ttu-id="8549a-239">Se um construtor de classe é chamado, a classe é reiniciada; ou seja, todos os inicializadores de classe são executados.</span><span class="sxs-lookup"><span data-stu-id="8549a-239">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="8549a-240">O valor retornado é `null`.</span><span class="sxs-lookup"><span data-stu-id="8549a-240">The return value is `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-241">Começando por [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="8549a-241">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="8549a-242">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="8549a-242">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="8549a-243">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="8549a-243">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 <span data-ttu-id="8549a-244">Se um parâmetro do método atual é um tipo de valor e o argumento correspondente em `parameters` é `null`, o tempo de execução passa uma instância inicializada do zero, o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="8549a-244">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-245">O exemplo de código a seguir demonstra a pesquisa de método dinâmico usando a reflexão.</span><span class="sxs-lookup"><span data-stu-id="8549a-245">The following code example demonstrates dynamic method lookup using reflection.</span></span> <span data-ttu-id="8549a-246">Observe que você não pode usar o <xref:System.Reflection.MethodInfo> objeto da classe base para invocar o método substituído na classe derivada, porque a associação tardia não é possível resolver as substituições.</span><span class="sxs-lookup"><span data-stu-id="8549a-246">Note that you cannot use the <xref:System.Reflection.MethodInfo> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</span></span>  
  
 [!code-cpp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Invoke1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Invoke1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="8549a-247">No [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture <see cref="T:System.Exception" /> em vez disso.</span>
              <span class="sxs-lookup">
                <span data-stu-id="8549a-247">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch <see cref="T:System.Exception" /> instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="8549a-248">O parâmetro <paramref name="obj" /> é <see langword="null" /> e o método não é estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-248">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="8549a-249">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-249">-or-</span>
          </span>
          <span data-ttu-id="8549a-250">O método não está declarado nem é herdado pela classe de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-250">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="8549a-251">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-251">-or-</span>
          </span>
          <span data-ttu-id="8549a-252">Um construtor estático é invocado, e <paramref name="obj" /> não é <see langword="null" /> nem uma instância da classe que declarou o construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-252">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8549a-253">Os elementos da matriz <paramref name="parameters" /> não correspondem à assinatura do método ou do construtor refletida por essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-253">The elements of the <paramref name="parameters" /> array do not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="8549a-254">O método ou o construtor invocado gera uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-254">The invoked method or constructor throws an exception.</span>
          </span>
          <span data-ttu-id="8549a-255">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-255">-or-</span>
          </span>
          <span data-ttu-id="8549a-256">A instância atual é um <see cref="T:System.Reflection.Emit.DynamicMethod" /> que contém um código não verificável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-256">The current instance is a <see cref="T:System.Reflection.Emit.DynamicMethod" /> that contains unverifiable code.</span>
          </span>
          <span data-ttu-id="8549a-257">Consulte a seção “Verificação” em Comentários de <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-257">See the "Verification" section in Remarks for <see cref="T:System.Reflection.Emit.DynamicMethod" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="8549a-258">A matriz <paramref name="parameters" /> não tem o número correto de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-258">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="8549a-259">Em vez disso, no [.NET para aplicativos da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.MemberAccessException" />.</span>
              <span class="sxs-lookup">
                <span data-stu-id="8549a-259">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.MemberAccessException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="8549a-260">O chamador não tem permissão para executar o método ou um construtor representado pela instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-260">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8549a-261">O tipo que declara o método é um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-261">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="8549a-262">Ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" /> para o tipo declarativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-262">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="8549a-263">A instância atual é um <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-263">The current instance is a <see cref="T:System.Reflection.Emit.MethodBuilder" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-264">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-264">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-265">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-265">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Missing" />
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object[] parameters, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ Invoke(System::Object ^ obj, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ parameters, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="parameters" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="8549a-266">O objeto no qual o método ou o construtor será invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-266">The object on which to invoke the method or constructor.</span>
          </span>
          <span data-ttu-id="8549a-267">Se um método for estático, esse argumento será ignorado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-267">If a method is static, this argument is ignored.</span>
          </span>
          <span data-ttu-id="8549a-268">Se um construtor for estático, esse argumento deverá ser <see langword="null" /> ou uma instância da classe que define o construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-268">If a constructor is static, this argument must be <see langword="null" /> or an instance of the class that defines the constructor.</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="8549a-269">Um bitmask que é uma combinação de 0 ou mais sinalizadores de bit de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-269">A bitmask that is a combination of 0 or more bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span>
          </span>
          <span data-ttu-id="8549a-270">Se <c>associador</c> for <see langword="null" />, este parâmetro receberá o valor <see cref="F:System.Reflection.BindingFlags.Default" />; portanto, tudo o que você passar será ignorado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-270">If <c>binder</c> is <see langword="null" />, this parameter is assigned the value <see cref="F:System.Reflection.BindingFlags.Default" />; thus, whatever you pass in is ignored.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="8549a-271">Um objeto que permite a associação, a coerção de tipos de argumentos, invocação de membros e a recuperação de objetos <see langword="MemberInfo" /> por meio de reflexão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-271">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span>
          </span>
          <span data-ttu-id="8549a-272">Se o <c>associador</c> for <see langword="null" />, o associador padrão será usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-272">If <c>binder</c> is <see langword="null" />, the default binder is used.</span>
          </span>
        </param>
        <param name="parameters">
          <span data-ttu-id="8549a-273">Uma lista de argumentos para o construtor ou método invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-273">An argument list for the invoked method or constructor.</span>
          </span>
          <span data-ttu-id="8549a-274">Esta é uma matriz de objetos com o mesmo número, ordem e tipo que os parâmetros do método ou do construtor a ser invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-274">This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</span>
          </span>
          <span data-ttu-id="8549a-275">Se não houver nenhum parâmetro, isso deverá ser <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-275">If there are no parameters, this should be <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8549a-276">Se o método ou construtor representado por esta instância usar um parâmetro ByRef, não será necessário nenhum atributo especial para esse parâmetro a fim de invocar o método ou o construtor que usa essa função.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-276">If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</span>
          </span>
          <span data-ttu-id="8549a-277">Qualquer objeto nesta matriz que não for inicializado explicitamente com um valor conterá o valor padrão desse tipo de objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-277">Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</span>
          </span>
          <span data-ttu-id="8549a-278">Para elementos de tipo de referência, esse valor é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-278">For reference-type elements, this value is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="8549a-279">Para elementos de tipo de valor, esse valor é 0, 0,0, ou <see langword="false" />, dependendo do tipo de elemento específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-279">For value-type elements, this value is 0, 0.0, or <see langword="false" />, depending on the specific element type.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="8549a-280">Uma instância de <see langword="CultureInfo" /> usada para determinar a coerção de tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-280">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span>
          </span>
          <span data-ttu-id="8549a-281">Se isso for <see langword="null" />, será usado o <see langword="CultureInfo" /> para o thread atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-281">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="8549a-282">(Isso é necessário para converter um <see langword="String" /> que representa 1000 para um valor <see langword="Double" />, por exemplo, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-282">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-283">Quando substituído em uma classe derivada, invoca o método ou o construtor refletido com parâmetros especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-283">When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-284">Um <see langword="Object" /> que contém o valor retornado do método invocado, ou <see langword="null" />, no caso de um construtor, ou <see langword="null" />, se o tipo de retorno do método for <see langword="void" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-284">An <see langword="Object" /> containing the return value of the invoked method, or <see langword="null" /> in the case of a constructor, or <see langword="null" /> if the method's return type is <see langword="void" />.</span>
          </span>
          <span data-ttu-id="8549a-285">Antes de chamar o método ou o construtor, o <see langword="Invoke" /> verifica se o usuário tem permissão de acesso e verifica se os parâmetros são válidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-285">Before calling the method or constructor, <see langword="Invoke" /> checks to see if the user has access permission and verifies that the parameters are valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-286">Dinamicamente invoca o método refletido por esta instância `obj`e passa os parâmetros especificados.</span><span class="sxs-lookup"><span data-stu-id="8549a-286">Dynamically invokes the method reflected by this instance on `obj`, and passes along the specified parameters.</span></span> <span data-ttu-id="8549a-287">Se o método é estático, o `obj` parâmetro é ignorado.</span><span class="sxs-lookup"><span data-stu-id="8549a-287">If the method is static, the `obj` parameter is ignored.</span></span> <span data-ttu-id="8549a-288">Para métodos de não-estático, `obj` deve ser uma instância de uma classe que herda ou declara o método e deve ser o mesmo tipo que essa classe.</span><span class="sxs-lookup"><span data-stu-id="8549a-288">For non-static methods, `obj` should be an instance of a class that inherits or declares the method and must be the same type as this class.</span></span> <span data-ttu-id="8549a-289">Se o método não tem parâmetros, o valor de `parameters` devem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="8549a-289">If the method has no parameters, the value of `parameters` should be `null`.</span></span> <span data-ttu-id="8549a-290">Caso contrário, o número, tipo e ordem dos elementos no `parameters` devem ser idênticos para o número, tipo e ordem de parâmetros para o método refletido por esta instância.</span><span class="sxs-lookup"><span data-stu-id="8549a-290">Otherwise, the number, type, and order of elements in `parameters` should be identical to the number, type, and order of parameters for the method reflected by this instance.</span></span>  
  
 <span data-ttu-id="8549a-291">Você não pode omitir os parâmetros opcionais em chamadas para `Invoke`.</span><span class="sxs-lookup"><span data-stu-id="8549a-291">You may not omit optional parameters in calls to `Invoke`.</span></span> <span data-ttu-id="8549a-292">Para invocar um método de omissão de parâmetros opcionais, você deve chamar `Type.InvokeMember` em vez disso.</span><span class="sxs-lookup"><span data-stu-id="8549a-292">To invoke a method omitting optional parameters, you should call `Type.InvokeMember` instead.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-293">Se essa sobrecarga de método é usada para chamar um construtor de instância, o objeto fornecido para `obj` é reinicializada; ou seja, todos os inicializadores de instância são executados.</span><span class="sxs-lookup"><span data-stu-id="8549a-293">If this method overload is used to invoke an instance constructor, the object supplied for `obj` is reinitialized; that is, all instance initializers are executed.</span></span> <span data-ttu-id="8549a-294">O valor retornado é `null`.</span><span class="sxs-lookup"><span data-stu-id="8549a-294">The return value is `null`.</span></span> <span data-ttu-id="8549a-295">Se um construtor de classe é chamado, a classe é reiniciada; ou seja, todos os inicializadores de classe são executados.</span><span class="sxs-lookup"><span data-stu-id="8549a-295">If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</span></span> <span data-ttu-id="8549a-296">O valor retornado é `null`.</span><span class="sxs-lookup"><span data-stu-id="8549a-296">The return value is `null`.</span></span>  
  
 <span data-ttu-id="8549a-297">Para parâmetros de passagem-por-valor primitivo, widening normal é executada (Int16 -> Int32, por exemplo).</span><span class="sxs-lookup"><span data-stu-id="8549a-297">For pass-by-value primitive parameters, normal widening is performed (Int16 -> Int32, for example).</span></span> <span data-ttu-id="8549a-298">Para parâmetros de referência de passagem-por-valor, a referência normal de ampliação é permitida (classe derivada para a classe base e a classe base para o tipo de interface).</span><span class="sxs-lookup"><span data-stu-id="8549a-298">For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</span></span> <span data-ttu-id="8549a-299">No entanto, para parâmetros de primitivos de passagem-por-referência, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="8549a-299">However, for pass-by-reference primitive parameters, the types must match exactly.</span></span> <span data-ttu-id="8549a-300">Para parâmetros de referência de passagem-por-referência, a ampliação normal ainda se aplica.</span><span class="sxs-lookup"><span data-stu-id="8549a-300">For pass-by-reference reference parameters, the normal widening still applies.</span></span>  
  
 <span data-ttu-id="8549a-301">Por exemplo, se o método refletido por esta instância é declarada como `public boolean Compare(String a, String b)`, em seguida, `parameters` devem ser uma matriz de `Objects` com comprimento 2, de modo que `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span><span class="sxs-lookup"><span data-stu-id="8549a-301">For example, if the method reflected by this instance is declared as `public boolean Compare(String a, String b)`, then `parameters` should be an array of `Objects` with length 2 such that `parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`.</span></span>  
  
 <span data-ttu-id="8549a-302">Se um parâmetro do método atual é um tipo de valor e o argumento correspondente em `parameters` é `null`, o tempo de execução passa uma instância inicializada do zero, o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="8549a-302">If a parameter of the current method is a value type, and the corresponding argument in `parameters` is `null`, the runtime passes a zero-initialized instance of the value type.</span></span>  
  
 <span data-ttu-id="8549a-303">Reflexão usa a pesquisa de método dinâmico ao chamar métodos virtuais.</span><span class="sxs-lookup"><span data-stu-id="8549a-303">Reflection uses dynamic method lookup when invoking virtual methods.</span></span> <span data-ttu-id="8549a-304">Por exemplo, suponha que a classe B herda da classe A, e ambos implementam um método virtual denominado M. Agora suponha que você tenha um `MethodInfo` objeto que representa o M na classe A. Se você usar o `Invoke` método a ser invocado M em um objeto do tipo B, em seguida, reflexão usarão a implementação fornecida pela classe B. Mesmo se o objeto do tipo B é convertido para um, a implementação fornecida pela classe B é usada (veja o exemplo de código abaixo).</span><span class="sxs-lookup"><span data-stu-id="8549a-304">For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a `MethodInfo` object that represents M on class A. If you use the `Invoke` method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</span></span>  
  
 <span data-ttu-id="8549a-305">Por outro lado, se o método é não virtual, em seguida, reflexão usarão a implementação fornecida pelo tipo do qual o `MethodInfo` foi obtido, independentemente do tipo de objeto passado como o destino.</span><span class="sxs-lookup"><span data-stu-id="8549a-305">On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the `MethodInfo` was obtained, regardless of the type of the object passed as the target.</span></span>  
  
 <span data-ttu-id="8549a-306">Restrições de acesso são ignoradas por código totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="8549a-306">Access restrictions are ignored for fully trusted code.</span></span> <span data-ttu-id="8549a-307">Ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e por meio de reflexão são invocadas sempre que o código é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="8549a-307">That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="8549a-308">Se o método invocado lança uma exceção, `TargetInvocationException.GetException` retorna a exceção.</span><span class="sxs-lookup"><span data-stu-id="8549a-308">If the invoked method throws an exception, `TargetInvocationException.GetException` returns the exception.</span></span> <span data-ttu-id="8549a-309">Esta implementação lança um `NotSupportedException`.</span><span class="sxs-lookup"><span data-stu-id="8549a-309">This implementation throws a `NotSupportedException`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-310">Começando por [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="8549a-310">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="8549a-311">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="8549a-311">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="8549a-312">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="8549a-312">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-313">O exemplo a seguir demonstra todos os membros de <xref:System.Reflection.Binder?displayProperty=nameWithType> classe usando uma sobrecarga de <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8549a-313">The following example demonstrates all members of the <xref:System.Reflection.Binder?displayProperty=nameWithType> class using an overload of <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="8549a-314">O método particular `CanConvertFrom` localiza tipos compatíveis para um determinado tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-314">The private method `CanConvertFrom` finds compatible types for a given type.</span></span> <span data-ttu-id="8549a-315">Outro exemplo de invocação de membros em um cenário de associação personalizada, consulte [Carregando dinamicamente e usando tipos](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-315">For another example of invoking members in a custom binding scenario, see [Dynamically Loading and Using Types](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md).</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="8549a-316">O parâmetro <paramref name="obj" /> é <see langword="null" /> e o método não é estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-316">The <paramref name="obj" /> parameter is <see langword="null" /> and the method is not static.</span>
          </span>
          <span data-ttu-id="8549a-317">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-317">-or-</span>
          </span>
          <span data-ttu-id="8549a-318">O método não está declarado nem é herdado pela classe de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-318">The method is not declared or inherited by the class of <paramref name="obj" />.</span>
          </span>
          <span data-ttu-id="8549a-319">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-319">-or-</span>
          </span>
          <span data-ttu-id="8549a-320">Um construtor estático é invocado, e <paramref name="obj" /> não é <see langword="null" /> nem uma instância da classe que declarou o construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-320">A static constructor is invoked, and <paramref name="obj" /> is neither <see langword="null" /> nor an instance of the class that declared the constructor.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="8549a-321">O tipo do parâmetro <paramref name="parameters" /> não corresponde à assinatura do método ou do construtor refletida por essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-321">The type of the <paramref name="parameters" /> parameter does not match the signature of the method or constructor reflected by this instance.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetParameterCountException">
          <span data-ttu-id="8549a-322">A matriz <paramref name="parameters" /> não tem o número correto de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-322">The <paramref name="parameters" /> array does not have the correct number of arguments.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="8549a-323">O método ou o construtor invocado gera uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-323">The invoked method or constructor throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="8549a-324">O chamador não tem permissão para executar o método ou um construtor representado pela instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-324">The caller does not have permission to execute the method or constructor that is represented by the current instance.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="8549a-325">O tipo que declara o método é um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-325">The type that declares the method is an open generic type.</span>
          </span>
          <span data-ttu-id="8549a-326">Ou seja, a propriedade <see cref="P:System.Type.ContainsGenericParameters" /> retorna <see langword="true" /> para o tipo declarativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-326">That is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" /> for the declaring type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="8549a-327">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-327">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="8549a-328">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-328">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-329">Obtém um valor que indica se o método é abstrato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-329">Gets a value indicating whether the method is abstract.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-330">
            <see langword="true" /> Se o método é abstract; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-330">
              <see langword="true" /> if the method is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-331">Um membro abstrato é declarado em uma classe base e não forneceu nenhuma implementação.</span><span class="sxs-lookup"><span data-stu-id="8549a-331">An abstract member is declared on a base class and has no implementation supplied.</span></span>  
  
 <span data-ttu-id="8549a-332">Para obter o <xref:System.Reflection.MethodBase>, primeiro obtenha o tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-332">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="8549a-333">Do tipo, o método get.</span><span class="sxs-lookup"><span data-stu-id="8549a-333">From the type, get the method.</span></span> <span data-ttu-id="8549a-334">O método de obter o `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="8549a-334">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="8549a-335">Se o `MethodBase` ou construtor for diferente de público, ele é protegido e não pode ser acessado prontamente.</span><span class="sxs-lookup"><span data-stu-id="8549a-335">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="8549a-336">Para acessar um método não público, defina o <xref:System.Reflection.BindingFlags> máscara para `NonPublic` em `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="8549a-336">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-337">O exemplo a seguir determina se especificado, o método é abstract e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="8549a-337">The following example determines whether specified the method is abstract and displays the result.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAbstract Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAbstract Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsAssembly">
      <MemberSignature Language="C#" Value="public bool IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-338">Obtém um valor que indica se a visibilidade potencial deste método ou construtor é descrita por <see cref="F:System.Reflection.MethodAttributes.Assembly" />; ou seja, o construtor ou método é visível no máximo para outros tipos no mesmo assembly e não é visível a tipos derivados fora do assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-338">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-339">
            <see langword="true" /> Se a visibilidade deste método ou construtor exatamente é descrita por <see cref="F:System.Reflection.MethodAttributes.Assembly" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-339">
              <see langword="true" /> if the visibility of this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Assembly" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-340">A visibilidade real de um método é limitada pela visibilidade de seu tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-340">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="8549a-341">O <xref:System.Reflection.MethodBase.IsAssembly%2A> propriedade pode ser `true` para um método, mas se ele é um método de um tipo aninhado particular e em seguida, o método não é visível fora do tipo recipiente.</span><span class="sxs-lookup"><span data-stu-id="8549a-341">The <xref:System.Reflection.MethodBase.IsAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="8549a-342">A visibilidade de um método ou construtor exatamente é descrita por <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> se o modificador de visibilidade só é `internal` (`Friend` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="8549a-342">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType> if the only visibility modifier is `internal` (`Friend` in Visual Basic).</span></span> <span data-ttu-id="8549a-343">Esta propriedade é `false` para métodos que são `protected internal` em c# (`Protected Friend` no Visual Basic, `protected public` em C++); use o <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriedade para identificar esses métodos.</span><span class="sxs-lookup"><span data-stu-id="8549a-343">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-344">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="8549a-344">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-345">As linguagens Visual Basic e c#, não é possível definir métodos com <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidade; que o nível de acesso aparece somente no exemplo C++.</span><span class="sxs-lookup"><span data-stu-id="8549a-345">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructedGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsConstructor">
      <MemberSignature Language="C#" Value="public bool IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsConstructor" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsConstructor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-346">Obtém um valor que indica se o método é um construtor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-346">Gets a value indicating whether the method is a constructor.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-347">
            <see langword="true" /> Se esse método é um construtor representado por um <see cref="T:System.Reflection.ConstructorInfo" /> objeto (consulte a observação em comentários <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objetos); caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-347">
              <see langword="true" /> if this method is a constructor represented by a <see cref="T:System.Reflection.ConstructorInfo" /> object (see note in Remarks about <see cref="T:System.Reflection.Emit.ConstructorBuilder" /> objects); otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="8549a-348">O <xref:System.Reflection.MethodBase.IsConstructor%2A> propriedade retorna `false` para um <xref:System.Reflection.Emit.ConstructorBuilder> do objeto em um tipo dinâmico, a menos que o <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> sinalizador foi incluído no `attributes` parâmetro quando o construtor foi definido.</span><span class="sxs-lookup"><span data-stu-id="8549a-348">The <xref:System.Reflection.MethodBase.IsConstructor%2A> property returns `false` for a <xref:System.Reflection.Emit.ConstructorBuilder> object in a dynamic type, unless the <xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType> flag was included in the `attributes` parameter when the constructor was defined.</span></span> <span data-ttu-id="8549a-349">A omissão de <xref:System.Reflection.MethodAttributes.RTSpecialName> sinalizador não afeta a exatidão do construtor emitido.</span><span class="sxs-lookup"><span data-stu-id="8549a-349">Omitting the <xref:System.Reflection.MethodAttributes.RTSpecialName> flag does not affect the correctness of the emitted constructor.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsFamily">
      <MemberSignature Language="C#" Value="public bool IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-350">Obtém um valor que indica se a visibilidade deste método ou construtor é descrita por <see cref="F:System.Reflection.MethodAttributes.Family" />; ou seja, o método ou o construtor é visível somente dentro de sua classe e de classes derivadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-350">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.Family" />; that is, the method or constructor is visible only within its class and derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-351">
            <see langword="true" /> Se o acesso a este método ou construtor exatamente é descrito por <see cref="F:System.Reflection.MethodAttributes.Family" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-351">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.Family" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-352">A visibilidade de um método ou construtor exatamente é descrita por <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> se o modificador de visibilidade só é `protected`.</span><span class="sxs-lookup"><span data-stu-id="8549a-352">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType> if the only visibility modifier is `protected`.</span></span> <span data-ttu-id="8549a-353">Esta propriedade é `false` para métodos que são `protected internal` em c# (`Protected Friend` no Visual Basic, `protected public` em C++); use o <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriedade para identificar esses métodos.</span><span class="sxs-lookup"><span data-stu-id="8549a-353">This property is `false` for methods that are `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++); use the <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property to identify such methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-354">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="8549a-354">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-355">As linguagens Visual Basic e c#, não é possível definir métodos com <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidade; que o nível de acesso aparece somente no exemplo C++.</span><span class="sxs-lookup"><span data-stu-id="8549a-355">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyAndAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-356">Obtém um valor que indica se a visibilidade deste método ou construtor é descrita por <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; ou seja, o método ou o construtor pode ser chamado por classes derivadas, mas apenas se estiverem no mesmo assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-356">Gets a value indicating whether the visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-357">
            <see langword="true" /> Se o acesso a este método ou construtor exatamente é descrito por <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-357">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamANDAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-358">A visibilidade de um método ou construtor exatamente é descrita por <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> se o modificador de visibilidade é `protected private` em C++.</span><span class="sxs-lookup"><span data-stu-id="8549a-358">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> if the visibility modifier is `protected private` in C++.</span></span> <span data-ttu-id="8549a-359">Métodos com essa visibilidade não podem ser definidos no Visual Basic ou c#.</span><span class="sxs-lookup"><span data-stu-id="8549a-359">Methods with this visibility cannot be defined in Visual Basic or C#.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-360">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="8549a-360">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-361">As linguagens Visual Basic e c#, não é possível definir métodos com <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidade; que o nível de acesso aparece somente no exemplo C++.</span><span class="sxs-lookup"><span data-stu-id="8549a-361">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
      </Docs>
    </Member>
    <Member MemberName="IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="public bool IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFamilyOrAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-362">Obtém um valor que indica se a visibilidade potencial deste método ou construtor é descrita por <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; ou seja, o método ou o construtor pode ser chamado por classes derivadas, não importa em que lugar elas estejam e por classes no mesmo assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-362">Gets a value indicating whether the potential visibility of this method or constructor is described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-363">
            <see langword="true" /> Se o acesso a este método ou construtor exatamente é descrito por <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-363">
              <see langword="true" /> if access to this method or constructor is exactly described by <see cref="F:System.Reflection.MethodAttributes.FamORAssem" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-364">Se um membro de tipo tem <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibilidade, ele pode ser chamado de qualquer membro em uma classe derivada ou qualquer membro no mesmo assembly, mas não a partir de qualquer outro tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-364">If a type member has <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</span></span>  
  
 <span data-ttu-id="8549a-365">A visibilidade real de um método é limitada pela visibilidade de seu tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-365">The actual visibility of a method is limited by the visibility of its type.</span></span> <span data-ttu-id="8549a-366">O <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> propriedade pode ser `true` para um método, mas se ele é um método de um tipo aninhado particular e em seguida, o método não é visível fora do tipo recipiente.</span><span class="sxs-lookup"><span data-stu-id="8549a-366">The <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A> property might be `true` for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</span></span>  
  
 <span data-ttu-id="8549a-367">A visibilidade de um método ou construtor exatamente é descrita por <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> se o modificador de visibilidade é `protected internal` em c# (`Protected Friend` no Visual Basic, `protected public` em C++).</span><span class="sxs-lookup"><span data-stu-id="8549a-367">The visibility of a method or constructor is exactly described by <xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType> if the visibility modifier is `protected internal` in C# (`Protected Friend` in Visual Basic, `protected public` in C++).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-368">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, e <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> propriedades.</span><span class="sxs-lookup"><span data-stu-id="8549a-368">The following code example defines methods with varying levels of visibility, and displays the values of their <xref:System.Reflection.MethodBase.IsAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamily%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, and <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A> properties.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-369">As linguagens Visual Basic e c#, não é possível definir métodos com <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibilidade; que o nível de acesso aparece somente no exemplo C++.</span><span class="sxs-lookup"><span data-stu-id="8549a-369">The Visual Basic and C# languages cannot define methods with <xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType> visibility; that access level appears only in the C++ example.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsAssembly Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsAssembly Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodAttributes" />
        <altmember cref="P:System.Reflection.MethodBase.IsAssembly" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamily" />
        <altmember cref="P:System.Reflection.MethodBase.IsFamilyAndAssembly" />
      </Docs>
    </Member>
    <Member MemberName="IsFinal">
      <MemberSignature Language="C#" Value="public bool IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsFinal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFinal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-370">Obtém um valor que indica se esse método é <see langword="final" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-370">Gets a value indicating whether this method is <see langword="final" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-371">
            <see langword="true" /> se esse método for <see langword="final" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-371">
              <see langword="true" /> if this method is <see langword="final" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-372">Para determinar se um método substituível, não é suficiente verificar se <xref:System.Reflection.MethodBase.IsVirtual%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-372">To determine if a method is overridable, it is not sufficient to check that <xref:System.Reflection.MethodBase.IsVirtual%2A> is `true`.</span></span> <span data-ttu-id="8549a-373">Para um método substituível, `IsVirtual` devem ser `true` e `IsFinal` devem ser `false`.</span><span class="sxs-lookup"><span data-stu-id="8549a-373">For a method to be overridable, `IsVirtual` must be `true` and `IsFinal` must be `false`.</span></span> <span data-ttu-id="8549a-374">Por exemplo, um método pode ser não-virtual, mas ele implementa um método de interface.</span><span class="sxs-lookup"><span data-stu-id="8549a-374">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="8549a-375">O common language runtime requer que todos os métodos que implementam membros de interface devem ser marcados como `virtual`; portanto, o compilador marca o método `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="8549a-375">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="8549a-376">Portanto, há casos em que um método é marcado como `virtual` , mas ainda não substituível.</span><span class="sxs-lookup"><span data-stu-id="8549a-376">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="8549a-377">Para estabelecer com certeza se um método é substituível, use um código como este:</span><span class="sxs-lookup"><span data-stu-id="8549a-377">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
 `if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)`  
  
 <span data-ttu-id="8549a-378">Se `IsVirtual` é `false` ou `IsFinal` é `true`, em seguida, o método não pode ser substituído.</span><span class="sxs-lookup"><span data-stu-id="8549a-378">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-379">O exemplo a seguir exibe `false` para `IsFinal`, que pode levar você acha que Meumetodo é substituível.</span><span class="sxs-lookup"><span data-stu-id="8549a-379">The following example displays `false` for `IsFinal`, which might lead you to think that MyMethod is overridable.</span></span> <span data-ttu-id="8549a-380">Imprime o código `false` mesmo que não está marcado como Meumetodo `virtual` e, portanto, não pode ser substituído.</span><span class="sxs-lookup"><span data-stu-id="8549a-380">The code prints `false` even though MyMethod is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-381">Obtém um valor que indica se o método é genérico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-381">Gets a value indicating whether the method is generic.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-382">
            <see langword="true" /> Se o atual <see cref="T:System.Reflection.MethodBase" /> representa um método genérico; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-382">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> represents a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-383">Use o <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriedade para determinar se o atual <xref:System.Reflection.MethodBase> objeto representa um método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-383">Use the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents a generic method.</span></span> <span data-ttu-id="8549a-384">Use o <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propriedade para determinar se o atual <xref:System.Reflection.MethodBase> objeto representa um método construído aberto ou um método construído fechado.</span><span class="sxs-lookup"><span data-stu-id="8549a-384">Use the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property to determine whether the current <xref:System.Reflection.MethodBase> object represents an open constructed method or a closed constructed method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-385">Não há suporte para genéricos por padrão. Essa propriedade retorna `false` se não for substituída em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="8549a-385">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="8549a-386">Construtores genéricos não têm suporte no .NET Framework versão 2.0, para que essa propriedade retorna `false` se a instância atual é do tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="8549a-386">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
<span data-ttu-id="8549a-387">A tabela a seguir resume as condições invariáveis para termos específicos para os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="8549a-387">The following table summarizes the invariant conditions for terms specific to generic methods.</span></span> <span data-ttu-id="8549a-388">Para outros termos usados em reflexão genérico, como *parâmetro de tipo genérico* e *tipo genérico*, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-388">For other terms used in generic reflection, such as *generic type parameter* and *generic type*, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>   

|<span data-ttu-id="8549a-389">Termo</span><span class="sxs-lookup"><span data-stu-id="8549a-389">Term</span></span>|<span data-ttu-id="8549a-390">Condição invariável</span><span class="sxs-lookup"><span data-stu-id="8549a-390">Invariant condition</span></span>| 
|---|---| 
|<span data-ttu-id="8549a-391">definição de método genérico</span><span class="sxs-lookup"><span data-stu-id="8549a-391">generic method definition</span></span>| <span data-ttu-id="8549a-392">A propriedade <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-392">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition> property is `true`.</span></span> <br /><span data-ttu-id="8549a-393">Define um método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-393">Defines a generic method.</span></span> <span data-ttu-id="8549a-394">Um método construído é criado chamando o <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> método em um <xref:System.Reflection.MethodInfo> do objeto que representa uma definição de método genérico e especificando uma matriz de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-394">A constructed method is created by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method on a <xref:System.Reflection.MethodInfo> object that represents a generic method definition, and specifying an array of type arguments.</span></span> <br /><span data-ttu-id="8549a-395">O <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método pode ser chamado apenas em definições de método genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-395">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be called only on generic method definitions.</span></span> <br/><span data-ttu-id="8549a-396">Qualquer definição de método genérico é um método genérico, mas o contrário não é válido.</span><span class="sxs-lookup"><span data-stu-id="8549a-396">Any generic method definition is a generic method, but the converse is not true.</span></span>|    
|<span data-ttu-id="8549a-397">método genérico</span><span class="sxs-lookup"><span data-stu-id="8549a-397">generic method</span></span>|<span data-ttu-id="8549a-398">A propriedade `IsGenericMethod` é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-398">The `IsGenericMethod` property is `true`.</span></span> <br/> <span data-ttu-id="8549a-399">Pode ser uma definição de método genérico, um método construído aberto ou um método construído fechado.</span><span class="sxs-lookup"><span data-stu-id="8549a-399">Can be a generic method definition, an open constructed method, or a closed constructed method.</span></span>| 
|<span data-ttu-id="8549a-400">método construído Open</span><span class="sxs-lookup"><span data-stu-id="8549a-400">open constructed method</span></span>|<span data-ttu-id="8549a-401">A propriedade <xref:System.Reflection.MethodBase.ContainsGenericParameters> é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-401">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `true`.</span></span> <br/><span data-ttu-id="8549a-402">Não é possível chamar um método construído aberto.</span><span class="sxs-lookup"><span data-stu-id="8549a-402">It is not possible to invoke an open constructed method.</span></span>|  
|<span data-ttu-id="8549a-403">método construído fechado</span><span class="sxs-lookup"><span data-stu-id="8549a-403">closed constructed method</span></span>|<span data-ttu-id="8549a-404">A propriedade <xref:System.Reflection.MethodBase.ContainsGenericParameters> é `false`.</span><span class="sxs-lookup"><span data-stu-id="8549a-404">The <xref:System.Reflection.MethodBase.ContainsGenericParameters> property is `false`.</span></span> <br/><span data-ttu-id="8549a-405">Quando examinada recursivamente, o método não tem nenhum parâmetro genérico não atribuído.</span><span class="sxs-lookup"><span data-stu-id="8549a-405">When examined recursively, the method has no unassigned generic parameters.</span></span> <span data-ttu-id="8549a-406">O tipo de conteúdo não tem nenhum parâmetro de tipo genérico e nenhum dos argumentos de tipo tem parâmetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="8549a-406">The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</span></span> <br/><span data-ttu-id="8549a-407">O método pode ser chamado.</span><span class="sxs-lookup"><span data-stu-id="8549a-407">The method can be invoked.</span></span>|   

 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Type.IsGenericType" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-408">Obtém um valor que indica se o método é uma definição de método genérica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-408">Gets a value indicating whether the method is a generic method definition.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-409">
            <see langword="true" /> Se o atual <see cref="T:System.Reflection.MethodBase" /> objeto representa a definição de um método genérico; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-409">
              <see langword="true" /> if the current <see cref="T:System.Reflection.MethodBase" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-410">Se o atual <xref:System.Reflection.MethodBase> representa uma definição de método genérico, então:</span><span class="sxs-lookup"><span data-stu-id="8549a-410">If the current <xref:System.Reflection.MethodBase> represents a generic method definition, then:</span></span>  
  
-   <span data-ttu-id="8549a-411">A propriedade <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-411">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property is `true`.</span></span>  
  
-   <span data-ttu-id="8549a-412">Para cada <xref:System.Type> objeto na matriz retornada pelo <xref:System.Reflection.MethodBase.GetGenericArguments%2A> método:</span><span class="sxs-lookup"><span data-stu-id="8549a-412">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodBase.GetGenericArguments%2A> method:</span></span>  
  
    -   <span data-ttu-id="8549a-413">A propriedade <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-413">The <xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType> property is `true`.</span></span>  
  
    -   <span data-ttu-id="8549a-414">O <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> propriedade retorna a instância atual.</span><span class="sxs-lookup"><span data-stu-id="8549a-414">The <xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType> property returns the current instance.</span></span>  
  
    -   <span data-ttu-id="8549a-415">O <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> propriedade é o mesmo que a posição do <xref:System.Type> objeto na matriz.</span><span class="sxs-lookup"><span data-stu-id="8549a-415">The <xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="8549a-416">Não há suporte para genéricos por padrão. Essa propriedade retorna `false` se não for substituída em uma classe derivada.</span><span class="sxs-lookup"><span data-stu-id="8549a-416">Generics are not supported by default; this property returns `false` if not overridden in a derived class.</span></span> <span data-ttu-id="8549a-417">Construtores genéricos não têm suporte no .NET Framework versão 2.0, para que essa propriedade retorna `false` se a instância atual é do tipo <xref:System.Reflection.ConstructorInfo>.</span><span class="sxs-lookup"><span data-stu-id="8549a-417">Generic constructors are not supported in the .NET Framework version 2.0, so this property returns `false` if the current instance is of type <xref:System.Reflection.ConstructorInfo>.</span></span>  
  
 <span data-ttu-id="8549a-418">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-418">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="8549a-419">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="8549a-419">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsHideBySig">
      <MemberSignature Language="C#" Value="public bool IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsHideBySig" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHideBySig As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-420">Obtém um valor que indica se apenas um membro do mesmo tipo, com exatamente a mesma assinatura, está oculto na classe derivada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-420">Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-421">
            <see langword="true" /> se o membro estiver ocultado por assinatura. Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-421">
              <see langword="true" /> if the member is hidden by signature; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-422">Quando um membro em uma classe derivada é declarado com o c# `new` modificador ou o Visual Basic `Shadows` modificador, ele pode ocultar um membro de mesmo nome na classe base.</span><span class="sxs-lookup"><span data-stu-id="8549a-422">When a member in a derived class is declared with the C# `new` modifier or the Visual Basic `Shadows` modifier, it can hide a member of the same name in the base class.</span></span> <span data-ttu-id="8549a-423">C# oculta os membros da classe base por assinatura.</span><span class="sxs-lookup"><span data-stu-id="8549a-423">C# hides base class members by signature.</span></span> <span data-ttu-id="8549a-424">Ou seja, se o membro de classe base tem várias sobrecargas, a única pessoa que está oculto é aquele que tem a assinatura idêntica.</span><span class="sxs-lookup"><span data-stu-id="8549a-424">That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</span></span> <span data-ttu-id="8549a-425">Por outro lado, o Visual Basic oculta todas as sobrecargas de classe base.</span><span class="sxs-lookup"><span data-stu-id="8549a-425">By contrast, Visual Basic hides all the base class overloads.</span></span> <span data-ttu-id="8549a-426">Portanto, <xref:System.Reflection.MethodBase.IsHideBySig%2A> retorna `false` em um membro declarado com o Visual Basic `Shadows` modificador, e `true` em um membro declarado com o c# `new` modificador.</span><span class="sxs-lookup"><span data-stu-id="8549a-426">Thus, <xref:System.Reflection.MethodBase.IsHideBySig%2A> returns `false` on a member declared with the Visual Basic `Shadows` modifier, and `true` on a member declared with the C# `new` modifier.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="8549a-427">Essa propriedade não determina se um método tem a <xref:System.Reflection.MethodAttributes.NewSlot> atributo.</span><span class="sxs-lookup"><span data-stu-id="8549a-427">This property does not determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute.</span></span> <span data-ttu-id="8549a-428">Um método que é declarado com o o `new` ou `Shadows` modificador terá o <xref:System.Reflection.MethodAttributes.NewSlot> atributo, mas somente os métodos declarados com `new` (ou seja, somente métodos c#) terá o <xref:System.Reflection.MethodBase.IsHideBySig%2A> propriedade definida como `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-428">A method that is declared with either the `new` or the `Shadows` modifier will have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, but only methods declared with `new` (that is, only C# methods) will have the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property set to `true`.</span></span>  <span data-ttu-id="8549a-429">Para determinar se um método tem a <xref:System.Reflection.MethodAttributes.NewSlot> de atributo, use o código semelhante ao seguinte: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` em c# ou `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` no Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="8549a-429">To determine whether a method has the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, use code similar to the following: `if ((myMethodInfo.Attributes & MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)` in C# or `If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot` in Visual Basic.</span></span> <span data-ttu-id="8549a-430">Observe, no entanto, que embora todos os métodos declarados com `new` ou `Shadows` tem o <xref:System.Reflection.MethodAttributes.NewSlot> de atributo, nem todos os métodos que têm o <xref:System.Reflection.MethodAttributes.NewSlot> atributo são declarados com `new` ou `Shadows`.</span><span class="sxs-lookup"><span data-stu-id="8549a-430">Note, however, that although all methods declared with `new` or `Shadows` have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute, not all methods that have the <xref:System.Reflection.MethodAttributes.NewSlot> attribute are declared with `new` or `Shadows`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-431">O exemplo de código a seguir contém uma classe base com um método sobrecarregado e uma classe derivada que oculta uma das sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="8549a-431">The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</span></span> <span data-ttu-id="8549a-432">Na versão Visual Basic do exemplo de código, o <xref:System.Reflection.MethodBase.IsHideBySig%2A> propriedade retorna `false` para o membro na classe derivada.</span><span class="sxs-lookup"><span data-stu-id="8549a-432">In the Visual Basic version of the code example, the <xref:System.Reflection.MethodBase.IsHideBySig%2A> property returns `false` for the member in the derived class.</span></span> <span data-ttu-id="8549a-433">A versão c# do código de exemplo, a propriedade retorna `true` para o membro na classe derivada.</span><span class="sxs-lookup"><span data-stu-id="8549a-433">In the C# version of the code sample, the property returns `true` for the member in the derived class.</span></span>  
  
 [!code-cpp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/cpp/hide.cpp#1)]
 [!code-csharp[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/CS/hide.cs#1)]
 [!code-vb[System.Reflection.MethodBase.IsHideBySig#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.MethodBase.IsHideBySig/VB/hide.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPrivate">
      <MemberSignature Language="C#" Value="public bool IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-434">Obtém um valor que indica se este membro é privado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-434">Gets a value indicating whether this member is private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-435">
            <see langword="true" /> Se o acesso a este método é restrito a outros membros da classe em si; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-435">
              <see langword="true" /> if access to this method is restricted to other members of the class itself; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-436">Se um membro de tipo tem `Private` visibilidade de nível, ele pode ser chamado de qualquer membro na mesma classe e nenhum outro.</span><span class="sxs-lookup"><span data-stu-id="8549a-436">If a type member has `Private` level visibility, it can be called from any member in the same class and no others.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-437">Obtém um valor que indica se este é um método público.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-437">Gets a value indicating whether this is a public method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-438">
            <see langword="true" /> Se esse método é público; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-438">
              <see langword="true" /> if this method is public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-439">Para obter o <xref:System.Reflection.MethodBase>, primeiro obtenha o tipo.</span><span class="sxs-lookup"><span data-stu-id="8549a-439">To get the <xref:System.Reflection.MethodBase>, first get the type.</span></span> <span data-ttu-id="8549a-440">Do tipo, o método get.</span><span class="sxs-lookup"><span data-stu-id="8549a-440">From the type, get the method.</span></span> <span data-ttu-id="8549a-441">O método de obter o `MethodBase`.</span><span class="sxs-lookup"><span data-stu-id="8549a-441">From the method, get the `MethodBase`.</span></span> <span data-ttu-id="8549a-442">Se o `MethodBase` ou construtor for diferente de público, ele é protegido e não pode ser acessado prontamente.</span><span class="sxs-lookup"><span data-stu-id="8549a-442">If the `MethodBase` or constructor is other than public, it is protected and cannot be readily accessed.</span></span> <span data-ttu-id="8549a-443">Para acessar um método não público, defina o <xref:System.Reflection.BindingFlags> máscara para `NonPublic` em `GetMethod`.</span><span class="sxs-lookup"><span data-stu-id="8549a-443">To access a non-public method, set the <xref:System.Reflection.BindingFlags> mask to `NonPublic` in `GetMethod`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-444">O exemplo a seguir usa o <xref:System.Reflection.MethodBase.IsPublic%2A> propriedade para exibir uma mensagem que indica se o método especificado é público.</span><span class="sxs-lookup"><span data-stu-id="8549a-444">The following example uses the <xref:System.Reflection.MethodBase.IsPublic%2A> property to display a message that indicates whether the specified method is public.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsPublic Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.BindingFlags" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-445">Obtém um valor que indica se o método ou o construtor atual é crítico para segurança ou crítico para segurança e disponível no código transparente no nível de confiança atual e, portanto, pode realizar operações críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-445">Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-446">
            <see langword="true" /> Se o método atual ou o construtor for crítico de segurança ou segurança-crítico para segurança no nível de confiança atual; <see langword="false" /> se é transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-446">
              <see langword="true" /> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-447">O <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</span><span class="sxs-lookup"><span data-stu-id="8549a-447">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="8549a-448">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="8549a-448">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="8549a-449">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="8549a-449">Security level</span></span>|<span data-ttu-id="8549a-450">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="8549a-450">IsSecurityCritical</span></span>|<span data-ttu-id="8549a-451">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="8549a-451">IsSecuritySafeCritical</span></span>|<span data-ttu-id="8549a-452">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="8549a-452">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="8549a-453">Crítico</span><span class="sxs-lookup"><span data-stu-id="8549a-453">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="8549a-454">Segurança crítica</span><span class="sxs-lookup"><span data-stu-id="8549a-454">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="8549a-455">Transparente</span><span class="sxs-lookup"><span data-stu-id="8549a-455">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="8549a-456">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</span><span class="sxs-lookup"><span data-stu-id="8549a-456">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8549a-457">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-457">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="8549a-458">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-458">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="8549a-459">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="8549a-459">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="8549a-460">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="8549a-460">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="8549a-461">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="8549a-461">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="8549a-462">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8549a-462">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="8549a-463">Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-463">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="8549a-464">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-464">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-465">Obtém um valor que indica se o método ou o construtor atual é crítico para segurança e disponível no código transparente no nível de confiança atual; ou seja, se ele pode realizar operações críticas e ser acessado pelo código transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-465">Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-466">
            <see langword="true" /> Se o método ou construtor é safe-crítico de segurança no nível de confiança atual; <see langword="false" /> se ele é crítico de segurança ou transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-466">
              <see langword="true" /> if the method or constructor is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-467">O <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</span><span class="sxs-lookup"><span data-stu-id="8549a-467">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="8549a-468">As combinações destas propriedades são mostradas na seguinte tabela:</span><span class="sxs-lookup"><span data-stu-id="8549a-468">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="8549a-469">Nível de segurança</span><span class="sxs-lookup"><span data-stu-id="8549a-469">Security level</span></span>|<span data-ttu-id="8549a-470">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="8549a-470">IsSecurityCritical</span></span>|<span data-ttu-id="8549a-471">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="8549a-471">IsSecuritySafeCritical</span></span>|<span data-ttu-id="8549a-472">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="8549a-472">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="8549a-473">Crítico</span><span class="sxs-lookup"><span data-stu-id="8549a-473">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="8549a-474">Segurança crítica</span><span class="sxs-lookup"><span data-stu-id="8549a-474">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="8549a-475">Transparente</span><span class="sxs-lookup"><span data-stu-id="8549a-475">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="8549a-476">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</span><span class="sxs-lookup"><span data-stu-id="8549a-476">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8549a-477">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-477">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="8549a-478">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-478">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="8549a-479">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="8549a-479">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="8549a-480">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="8549a-480">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="8549a-481">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="8549a-481">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="8549a-482">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8549a-482">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="8549a-483">Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-483">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="8549a-484">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-484">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-485">Obtém um valor que indica que se o método ou o construtor atual é transparente no nível de confiança atual e, portanto, não é pode realizar operações críticas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-485">Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-486">
            <see langword="true" /> Se o método ou construtor é transparente de segurança no nível de confiança atual; Caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-486">
              <see langword="true" /> if the method or constructor is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-487">Se essa propriedade retorna `true`, o <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> e <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> propriedades retorno `false`.</span><span class="sxs-lookup"><span data-stu-id="8549a-487">If this property returns `true`, the <xref:System.Reflection.MethodBase.IsSecurityCritical%2A> and <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="8549a-488">O <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, e <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</span><span class="sxs-lookup"><span data-stu-id="8549a-488">The <xref:System.Reflection.MethodBase.IsSecurityCritical%2A>, <xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A>, and <xref:System.Reflection.MethodBase.IsSecurityTransparent%2A> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="8549a-489">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</span><span class="sxs-lookup"><span data-stu-id="8549a-489">Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="8549a-490">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-490">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="8549a-491">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</span><span class="sxs-lookup"><span data-stu-id="8549a-491">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="8549a-492">O assembly e todos os tipos são tratados como transparentes.</span><span class="sxs-lookup"><span data-stu-id="8549a-492">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="8549a-493">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</span><span class="sxs-lookup"><span data-stu-id="8549a-493">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="8549a-494">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</span><span class="sxs-lookup"><span data-stu-id="8549a-494">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="8549a-495">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> e <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="8549a-495">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="8549a-496">Para obter mais informações sobre reflexão e transparência, consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-496">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="8549a-497">Para obter informações sobre a transparência, consulte [alterações de segurança](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="8549a-497">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Reflection.MethodBase.IsSecurityCritical" />
        <altmember cref="P:System.Reflection.MethodBase.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-498">Obtém um valor que indica se esse método tem um nome especial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-498">Gets a value indicating whether this method has a special name.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-499">
            <see langword="true" /> se esse método tiver um nome especial; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-499">
              <see langword="true" /> if this method has a special name; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-500">O <xref:System.Reflection.MethodAttributes.SpecialName> bit é definido como sinalizador membros que são tratados de forma especial por alguns compiladores (como acessadores de propriedade e métodos de sobrecarga de operador).</span><span class="sxs-lookup"><span data-stu-id="8549a-500">The <xref:System.Reflection.MethodAttributes.SpecialName> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="8549a-501">Este exemplo mostra um uso de <xref:System.Reflection.MethodBase.IsSpecialName%2A> filtro interno ou membros particulares fora de uma lista.</span><span class="sxs-lookup"><span data-stu-id="8549a-501">This example shows a use of <xref:System.Reflection.MethodBase.IsSpecialName%2A> to filter internal or private members out of a list.</span></span>  
  
 [!code-cpp[Classic Type.IsSpecialName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsSpecialName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsSpecialName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsSpecialName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsStatic">
      <MemberSignature Language="C#" Value="public bool IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsStatic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStatic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-502">Obtém um valor que indica se o método é <see langword="static" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-502">Gets a value indicating whether the method is <see langword="static" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-503">
            <see langword="true" /> se esse método for <see langword="static" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-503">
              <see langword="true" /> if this method is <see langword="static" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-504">Um membro estático implicitamente não pode fazer referência a dados da instância em uma classe.</span><span class="sxs-lookup"><span data-stu-id="8549a-504">A static member cannot implicitly reference instance data in a class.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Reflection.MethodAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsVirtual">
      <MemberSignature Language="C#" Value="public bool IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.IsVirtual" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVirtual As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-505">Obtém um valor que indica se o método é <see langword="virtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-505">Gets a value indicating whether the method is <see langword="virtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-506">
            <see langword="true" /> se esse método for <see langword="virtual" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-506">
              <see langword="true" /> if this method is <see langword="virtual" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-507">Um membro virtual pode fazer referência a dados da instância em uma classe e deve ser referenciado através de uma instância da classe.</span><span class="sxs-lookup"><span data-stu-id="8549a-507">A virtual member may reference instance data in a class and must be referenced through an instance of the class.</span></span>  
  
 <span data-ttu-id="8549a-508">Para determinar se um método substituível, não é suficiente verificar se `IsVirtual` é `true`.</span><span class="sxs-lookup"><span data-stu-id="8549a-508">To determine if a method is overridable, it is not sufficient to check that `IsVirtual` is `true`.</span></span> <span data-ttu-id="8549a-509">Para um método substituível, `IsVirtual` devem ser `true` e <xref:System.Reflection.MethodBase.IsFinal%2A> devem ser `false`.</span><span class="sxs-lookup"><span data-stu-id="8549a-509">For a method to be overridable, `IsVirtual` must be `true` and <xref:System.Reflection.MethodBase.IsFinal%2A> must be `false`.</span></span> <span data-ttu-id="8549a-510">Por exemplo, um método pode ser não-virtual, mas ele implementa um método de interface.</span><span class="sxs-lookup"><span data-stu-id="8549a-510">For example, a method might be non-virtual, but it implements an interface method.</span></span> <span data-ttu-id="8549a-511">O common language runtime requer que todos os métodos que implementam membros de interface devem ser marcados como `virtual`; portanto, o compilador marca o método `virtual final`.</span><span class="sxs-lookup"><span data-stu-id="8549a-511">The common language runtime requires that all methods that implement interface members must be marked as `virtual`; therefore, the compiler marks the method `virtual final`.</span></span> <span data-ttu-id="8549a-512">Portanto, há casos em que um método é marcado como `virtual` , mas ainda não substituível.</span><span class="sxs-lookup"><span data-stu-id="8549a-512">So there are cases where a method is marked as `virtual` but is still not overridable.</span></span>  
  
 <span data-ttu-id="8549a-513">Para estabelecer com certeza se um método é substituível, use um código como este:</span><span class="sxs-lookup"><span data-stu-id="8549a-513">To establish with certainty whether a method is overridable, use code such as this:</span></span>  
  
```csharp  
if (MethodInfo.IsVirtual && !MethodInfo.IsFinal)  
```  
  
```vb  
If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  
```  
  
 <span data-ttu-id="8549a-514">Se `IsVirtual` é `false` ou `IsFinal` é `true`, em seguida, o método não pode ser substituído.</span><span class="sxs-lookup"><span data-stu-id="8549a-514">If `IsVirtual` is `false` or `IsFinal` is `true`, then the method cannot be overridden.</span></span>  
  
 <span data-ttu-id="8549a-515">Você pode determinar se o método atual substitui um método em uma classe base chamando o <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="8549a-515">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="8549a-516">O exemplo a seguir implementa um `IsOverride` método que faz isso.</span><span class="sxs-lookup"><span data-stu-id="8549a-516">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="8549a-517">O exemplo a seguir exibe `false` para `IsFinal`, que pode levar a pensar `MyMethod` é substituível.</span><span class="sxs-lookup"><span data-stu-id="8549a-517">The following example displays `false` for `IsFinal`, which might lead you to think that `MyMethod` is overridable.</span></span> <span data-ttu-id="8549a-518">Imprime o código `false` , embora `MyMethod` não está marcado como `virtual` e, portanto, não pode ser substituído.</span><span class="sxs-lookup"><span data-stu-id="8549a-518">The code prints `false` even though `MyMethod` is not marked `virtual` and thus cannot be overridden.</span></span>  
  
 [!code-cpp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.IsVirtual Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.IsVirtual Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodHandle">
      <MemberSignature Language="C#" Value="public abstract RuntimeMethodHandle MethodHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeMethodHandle MethodHandle" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodHandle" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property MethodHandle As RuntimeMethodHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeMethodHandle MethodHandle { RuntimeMethodHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.MethodHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeMethodHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-519">Obtém um identificador para a representação interna de metadados de um método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-519">Gets a handle to the internal metadata representation of a method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-520">Um objeto <see cref="T:System.RuntimeMethodHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-520">A <see cref="T:System.RuntimeMethodHandle" /> object.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-521">Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</span><span class="sxs-lookup"><span data-stu-id="8549a-521">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MethodImplementationFlags">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MethodImplAttributes MethodImplementationFlags" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.MethodImplementationFlags" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MethodImplementationFlags As MethodImplAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodImplAttributes MethodImplementationFlags { System::Reflection::MethodImplAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodImplAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-522">Obtém os sinalizadores <see cref="T:System.Reflection.MethodImplAttributes" /> que especificam os atributos de uma implementação de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-522">Gets the <see cref="T:System.Reflection.MethodImplAttributes" /> flags that specify the attributes of a method implementation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-523">Os sinalizadores de implementação de método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-523">The method implementation flags.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-524">Consulte o método <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> para obter mais informações.</span><span class="sxs-lookup"><span data-stu-id="8549a-524">See the <xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A> method for more information.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="8549a-525">O primeiro objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-525">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="8549a-526">O segundo objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-526">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-527">Indica se dois objetos <see cref="T:System.Reflection.MethodBase" /> são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-527">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-528">
            <see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-528">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodBase left, System.Reflection.MethodBase right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodBase left, class System.Reflection.MethodBase right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodBase, right As MethodBase) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodBase ^ left, System::Reflection::MethodBase ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodBase" />
        <Parameter Name="right" Type="System.Reflection.MethodBase" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="8549a-529">O primeiro objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-529">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="8549a-530">O segundo objeto a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-530">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-531">Indica se dois objetos <see cref="T:System.Reflection.MethodBase" /> não são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-531">Indicates whether two <see cref="T:System.Reflection.MethodBase" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-532">
            <see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-532">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodBase.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodBase::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="8549a-533">Reservado para uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-533">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8549a-534">Deve ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-534">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="8549a-535">Matriz passada de nomes a serem mapeados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-535">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="8549a-536">Contagem dos nomes a serem mapeados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-536">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8549a-537">O contexto de localidade no qual interpretar os nomes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-537">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="8549a-538">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-538">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-539">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-539">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-540">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="8549a-540">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8549a-541">Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="8549a-541">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8549a-542">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-542">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetType">
      <MemberSignature Language="C#" Value="Type _MethodBase.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodBase.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodBase.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodBase.GetType() = System::Runtime::InteropServices::_MethodBase::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="8549a-543">Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-543">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="8549a-544">Para obter uma descrição desse membro, consulte <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-544">For a description of this member, see <see cref="M:System.Runtime.InteropServices._MethodBase.GetType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-545">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-545">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-546">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-546">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodBase.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="8549a-547">As informações de tipo a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-547">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8549a-548">O identificador de localidade das informações do tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-548">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="8549a-549">Recebe um ponteiro para o objeto de informações de tipo solicitado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-549">Receives a pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-550">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-550">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-551">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="8549a-551">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8549a-552">Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="8549a-552">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8549a-553">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-553">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodBase.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodBase.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodBase::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="8549a-554">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-554">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-555">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-555">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-556">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="8549a-556">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8549a-557">Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="8549a-557">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8549a-558">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-558">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.Invoke">
      <MemberSignature Language="C#" Value="void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodBase.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodBase.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodBase.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodBase::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodBase.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="8549a-559">Identifica o membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-559">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="8549a-560">Reservado para uso futuro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-560">Reserved for future use.</span>
          </span>
          <span data-ttu-id="8549a-561">Deve ser IID_NULL.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-561">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="8549a-562">O contexto de localidade no qual interpretar argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-562">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="8549a-563">Sinalizadores que descrevem o contexto da chamada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-563">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="8549a-564">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-564">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="8549a-565">Ponteiro para o local onde o resultado deve ser armazenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-565">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="8549a-566">Ponteiro para uma estrutura que contém informações de exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-566">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="8549a-567">O índice do primeiro argumento que tem um erro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-567">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="8549a-568">Fornece acesso a propriedades e métodos expostos por um objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-568">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-569">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="8549a-569">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="8549a-570">Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.</span><span class="sxs-lookup"><span data-stu-id="8549a-570">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="8549a-571">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-571">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAbstract">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAbstract As Boolean Implements _MethodBase.IsAbstract" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-572">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-572">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-573">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-573">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-574">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-574">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-575">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-575">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsAssembly As Boolean Implements _MethodBase.IsAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-576">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-576">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-577">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-577">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-578">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-578">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-579">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-579">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsConstructor">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsConstructor" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsConstructor As Boolean Implements _MethodBase.IsConstructor" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsConstructor { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsConstructor</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-580">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-580">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-581">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-581">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-582">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-582">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-583">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-583">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamily">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamily" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamily As Boolean Implements _MethodBase.IsFamily" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-584">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-584">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-585">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-585">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-586">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-586">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-587">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-587">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyAndAssembly As Boolean Implements _MethodBase.IsFamilyAndAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-588">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-588">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-589">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-589">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-590">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-590">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-591">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-591">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFamilyOrAssembly As Boolean Implements _MethodBase.IsFamilyOrAssembly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-592">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-592">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-593">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-593">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-594">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-594">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-595">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-595">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsFinal">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsFinal" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFinal As Boolean Implements _MethodBase.IsFinal" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsFinal { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsFinal</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-596">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-596">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-597">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-597">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-598">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-598">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-599">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-599">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsHideBySig">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsHideBySig" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsHideBySig As Boolean Implements _MethodBase.IsHideBySig" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsHideBySig { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsHideBySig</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-600">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-600">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-601">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-601">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-602">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-602">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-603">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-603">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPrivate">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPrivate As Boolean Implements _MethodBase.IsPrivate" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-604">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-604">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-605">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-605">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-606">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-606">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-607">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-607">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsPublic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsPublic As Boolean Implements _MethodBase.IsPublic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-608">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-608">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-609">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-609">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-610">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-610">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-611">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-611">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsSpecialName">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSpecialName As Boolean Implements _MethodBase.IsSpecialName" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-612">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-612">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-613">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-613">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-614">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-614">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-615">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-615">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsStatic">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsStatic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsStatic As Boolean Implements _MethodBase.IsStatic" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsStatic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsStatic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-616">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-616">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-617">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-617">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-618">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-618">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-619">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-619">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodBase.IsVirtual">
      <MemberSignature Language="C#" Value="bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Runtime.InteropServices._MethodBase.IsVirtual" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsVirtual As Boolean Implements _MethodBase.IsVirtual" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Runtime.InteropServices._MethodBase.IsVirtual { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodBase.IsVirtual</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="8549a-620">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-620">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="8549a-621">Para obter uma descrição desse membro, consulte <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="8549a-621">For a description of this member, see <see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="8549a-622">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="8549a-622">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="8549a-623">Ele só pode ser usado quando a instância de <xref:System.Reflection.MethodBase> é convertida em uma interface de <xref:System.Runtime.InteropServices._MethodBase>.</span><span class="sxs-lookup"><span data-stu-id="8549a-623">It can be used only when the <xref:System.Reflection.MethodBase> instance is cast to an <xref:System.Runtime.InteropServices._MethodBase> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>