<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodBase.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac55a27c711459e7ed675df80d23d28b658e1d7b113.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5a27c711459e7ed675df80d23d28b658e1d7b113</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Provides information about methods and constructors.</source>
          <target state="translated">Fornece informações sobre os métodos e construtores.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">`MethodBase`</ph> é a classe base de <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>for full trust for inheritors.</source>
          <target state="translated">para confiança total de herdeiros.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta classe não pode ser herdada pelo código parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo é thread-safe.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodBase">
          <source>When you inherit from <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, you must override the following members: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Ao herdar de <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph>, você deve substituir os seguintes membros: <ph id="ph2">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph5">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph6">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph9">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph11">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph> , <ph id="ph12">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, e <ph id="ph13">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.#ctor">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Gets the attributes associated with this method.</source>
          <target state="translated">Obtém os atributos associados a esse método.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph> values.</source>
          <target state="translated">Um dos valores de <ph id="ph1">&lt;see cref="T:System.Reflection.MethodAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
          <target state="translated">Todos os membros têm um conjunto de atributos que são definidos em relação do tipo específico de membro.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
          <target state="translated">Para obter o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, primeiro obtenha o tipo.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the type, get the method.</source>
          <target state="translated">Do tipo, o método get.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
          <target state="translated">O método de obter o <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>The following code example displays the attributes of the user-defined method Mymethod.</source>
          <target state="translated">O exemplo de código a seguir exibe os atributos do método definido pelo usuário Meumetodo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>This code produces the following output:</source>
          <target state="translated">Esse código gera a seguinte saída:</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Reflection.MethodBase.Attributes Sample</source>
          <target state="translated">Exemplo de Reflection.MethodBase.Attributes</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)</source>
          <target state="translated">Mymethodbase = Meumetodo Void (Int32, ByRef de System. String, System. String ByRef)</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>PrivateScope</source>
          <target state="translated">PrivateScope</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>FamANDAssem</source>
          <target state="translated">FamANDAssem</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Family</source>
          <target state="translated">Família</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Public</source>
          <target state="translated">Público</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>HideBySig</source>
          <target state="translated">HideBySig</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>ReuseSlot</source>
          <target state="translated">ReuseSlot</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.Attributes">
          <source>Use the <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> property to determine whether a method is <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>, and so on.</source>
          <target state="translated">Use o <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph> propriedade para determinar se um método é <ph id="ph2">&lt;see langword="public" /&gt;</ph>, <ph id="ph3">&lt;see langword="private" /&gt;</ph>, <ph id="ph4">&lt;see langword="final" /&gt;</ph>, <ph id="ph5">&lt;see langword="virtual" /&gt;</ph>e assim por diante.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>Gets a value indicating the calling conventions for this method.</source>
          <target state="translated">Obtém um valor que indica as convenções de chamada deste método.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.CallingConvention">
          <source>The <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> for this method.</source>
          <target state="translated">As <ph id="ph1">&lt;see cref="T:System.Reflection.CallingConventions" /&gt;</ph> deste método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
          <target state="translated">Obtém um valor que indica se o método genérico contém parâmetros de tipo genérico não atribuídos.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objeto representa um método genérico que contém parâmetros de tipo genérico não atribuídos; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
          <target state="translated">Um método genérico pode ser chamado somente se não houver nenhuma definição de tipo genérico ou tipos construídos abertos em argumentos de tipo do método próprio ou em qualquer tipo de delimitador.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
          <target state="translated">Como tipos podem ser arbitrariamente complexos, é difícil fazer essa determinação recursiva.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
          <target state="translated">Para sua conveniência e para reduzir a chance de erro, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade fornece uma maneira padrão para distinguir entre os métodos construídos fechados, que podem ser chamados, e abrir construída métodos, que não é possível.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`true`</ph>, o método não pode ser invocado.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade pesquisa recursivamente para parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
          <target state="translated">Por exemplo, ele retorna <ph id="ph1">`true`</ph> para qualquer método em um tipo aberto <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> no Visual Basic), mesmo que o próprio método não é genérico.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
          <target state="translated">Compare isso com o comportamento do <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade, que retorna <ph id="ph2">`false`</ph> para tal método.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
          <target state="translated">Da mesma forma, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> retorna o parâmetro de propriedade <ph id="ph2">`true`</ph> para nenhum construtor em um tipo aberto, mesmo que construtores não podem ter parâmetros de tipo de seus próprios.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.ContainsGenericParameters">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto a ser comparado com essa instância ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Retorna um valor que indica se essa instância é igual a um objeto especificado.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> for igual ao tipo e ao valor dessa instância, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Returns a <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que representa o método em execução no momento.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Reflection.MethodBase.GetCurrentMethod" /&gt;</ph> é um método estático que é chamado de um método em execução e que retorna informações sobre esse método.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> object representing the currently executing method.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que representa o método em execução no momento.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
          <target state="translated">Se o método atualmente em execução é definido em um tipo genérico, o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que é retornado por <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> é obtido da definição de tipo genérico (ou seja, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A?displayProperty=nameWithType&gt;</ph> retorna <ph id="ph4">`true`</ph>).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
          <target state="translated">Portanto, não reflete os argumentos de tipo que foram usados quando o método foi chamado.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
          <target state="translated">Por exemplo, se um método <ph id="ph1">`M()`</ph> é definido em um tipo genérico <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> no Visual Basic), e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> é chamado de <ph id="ph5">`C&lt;string&gt;.M()`</ph>, em seguida, <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> retorna <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> no Visual Basic).</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
          <target state="translated">Se o método de execução no momento é um método genérico, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> retorna a definição de método genérico.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
          <target state="translated">Se o método genérico está definido em um tipo genérico, o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> é obtido da definição de tipo genérico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The following example defines two types.</source>
          <target state="translated">O exemplo a seguir define dois tipos.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The first is a non-generic class, <ph id="ph1">`TestClass`</ph>, includes a constructor, a method named <ph id="ph2">`GetValue`</ph>, and a read-write property named <ph id="ph3">`GetValue`</ph>.</source>
          <target state="translated">A primeira é uma classe não-genérica, <ph id="ph1">`TestClass`</ph>, inclui um construtor, um método chamado <ph id="ph2">`GetValue`</ph>e uma propriedade de leitura-gravação chamada <ph id="ph3">`GetValue`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>The second is a generic class named <ph id="ph1">`TestClass&lt;T&gt;`</ph> that includes a constructor, a <ph id="ph2">`GetValue`</ph> method, and a generic method, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</source>
          <target state="translated">O segundo é uma classe genérica denominada <ph id="ph1">`TestClass&lt;T&gt;`</ph> que inclui um construtor, um <ph id="ph2">`GetValue`</ph> método e um método genérico, <ph id="ph3">`ConvertValue&lt;Y&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Each constructor, method, and property accessor includes a call to the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> method.</source>
          <target state="translated">Cada construtor, um método e um acessador de propriedade incluem uma chamada para o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>This member was invoked with a late-binding mechanism.</source>
          <target state="translated">Este membro foi invocado com um mecanismo de associação tardia.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetCurrentMethod">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Retorna uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Retornará uma matriz vazia se o método atual não for um método genérico.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Os elementos da matriz retornada estão na ordem em que aparecem na lista de parâmetros de tipo para o método genérico.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Se o método atual é um método de construído fechado (ou seja, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`false`</ph>), a matriz retornada pelo <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> método contém os tipos que foram atribuídos a parâmetros de tipo genérico de definição de método genérico.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Se o método atual é uma definição de método genérico, a matriz contém os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Se o método atual é um método construído open (ou seja, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`true`</ph>) em que tipos específicos foram atribuídos a alguns parâmetros de tipo e parâmetros de tipo de delimitador tipos genéricos foram atribuídos a outros parâmetros de tipo, a matriz contém tipos e tipo de parâmetros.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propriedade distingui-los.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Para ver uma demonstração desse cenário, consulte o exemplo de código fornecido para o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Não há suporte para construtores genéricos no .NET Framework versão 2.0.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Essa propriedade gerará <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> se não for substituída em uma classe derivada, então uma exceção será lançada se a instância atual é do tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>The current object is a <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</source>
          <target state="translated">O objeto atual é um <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
          <target state="translated">Não há suporte para construtores genéricos no .NET Framework versão 2.0.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetGenericArguments">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
          <target state="translated">Essa exceção será o comportamento padrão se esse método não for substituído em uma classe derivada.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> que fornece acesso ao fluxo MSIL, variáveis locais e exceções para o método atual.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBody" /&gt;</ph> que fornece acesso ao fluxo MSIL, variáveis locais e exceções para o método atual.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
          <target state="translated">Você não precisa substituir o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> para usá-lo.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
          <target state="translated">Você pode chamar o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> método <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objetos, porque o método é substituído nas versões em tempo de execução dessas classes.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
          <target state="translated">Por exemplo, a versão de tempo de execução do <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> classe deriva o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> classe, que por sua vez deriva o <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The following code example defines a test method named <ph id="ph1">`MethodBodyExample`</ph> and displays its local variable information and exception-handling clauses.</source>
          <target state="translated">O exemplo de código a seguir define um método de teste chamado <ph id="ph1">`MethodBodyExample`</ph> e exibe suas informações de variáveis locais e cláusulas de tratamento de exceção.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> method is used to obtain a <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> object for the test method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A?displayProperty=nameWithType&gt;</ph> método é usado para obter um <ph id="ph2">&lt;xref:System.Reflection.MethodBody&gt;</ph> objeto para o método de teste.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> property is used to obtain a list of <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objects and display their types and index order.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBody.LocalVariables%2A&gt;</ph> propriedade é usada para obter uma lista de <ph id="ph2">&lt;xref:System.Reflection.LocalVariableInfo&gt;</ph> objetos e exibir seus tipos e ordem de índice.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> property is used to obtain a list of exception-handling clauses.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBody.ExceptionHandlingClauses%2A&gt;</ph> propriedade é usada para obter uma lista de cláusulas de tratamento de exceção.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Not all computer languages can generate <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> clauses.</source>
          <target state="translated">Nem todos os idiomas do computador podem gerar <ph id="ph1">&lt;xref:System.Reflection.ExceptionHandlingClauseOptions.Filter?displayProperty=nameWithType&gt;</ph> cláusulas.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>The Visual Basic example shows a filter clause, using a Visual Basic <ph id="ph1">`When`</ph> expression, which is omitted from the examples for other languages.</source>
          <target state="translated">O exemplo do Visual Basic mostra uma cláusula de filtro, usando um Visual Basic <ph id="ph1">`When`</ph> expressão, que é omitido dos exemplos para outros idiomas.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>This method is invalid unless overridden in a derived class.</source>
          <target state="translated">Esse método é inválido, a menos que seja substituído em uma classe derivada.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>for the access to metadata for members.</source>
          <target state="translated">para o acesso aos metadados para membros.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodBody">
          <source>Permission value: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Valor de permissão: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Gets method information using the specified handle.</source>
          <target state="translated">Obtém informações sobre o método usando o identificador especificado.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>The method's handle.</source>
          <target state="translated">O identificador do método.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
          <target state="translated">Obtém informações de método usando a representação de metadados internos do método (identificador).</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>A <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> containing information about the method.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="MethodBase" /&gt;</ph> que contém informações sobre o método.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> é inválido.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
          <target state="translated">Um identificador para a representação de metadados internos de um construtor ou método.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A handle to the generic type that defines the constructor or method.</source>
          <target state="translated">Um identificador para o tipo genérico que define o construtor ou método.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> para o construtor ou método representado pelo identificador especificado, para o tipo genérico especificado.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object representing the method or constructor specified by <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, in the generic type specified by <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> que representa o método ou o construtor especificado por <ph id="ph2">&lt;paramref name="handle" /&gt;</ph>, no tipo genérico especificado por <ph id="ph3">&lt;paramref name="declaringType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
          <target state="translated">Um <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> estrutura para um construtor ou método de um tipo genérico pode representar diferentes <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objetos, dependendo dos tipos especificados para os parâmetros de tipo do tipo genérico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
          <target state="translated">Por exemplo, se <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> no Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> em C++) tem um método que retorna tipo <ph id="ph4">`T`</ph>, o <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto para o método em uma classe construído como <ph id="ph6">`G&lt;int&gt;`</ph> é diferente do <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto para esse método de definição de tipo genérico.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="handle" /&gt;</ph> é inválido.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodFromHandle(System.RuntimeMethodHandle,System.RuntimeTypeHandle)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Quando substituído em uma classe derivada, retorna os sinalizadores <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph> flags.</source>
          <target state="translated">Os sinalizadores <ph id="ph1">&lt;see langword="MethodImplAttributes" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>The following example defines a constructor in a dynamic assembly and then uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method to display the method implementation flags that are set by default.</source>
          <target state="translated">O exemplo a seguir define um construtor em um assembly dinâmico e, em seguida, usa o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> método para exibir os sinalizadores de implementação de método são definidos por padrão.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetMethodImplementationFlags">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém os parâmetros do método ou do construtor especificado.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>An array of type <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph> instance.</source>
          <target state="translated">Uma matriz do tipo <ph id="ph1">&lt;see langword="ParameterInfo" /&gt;</ph> que contém informações que correspondem à assinatura do método (ou do construtor) refletido por essa instância <ph id="ph2">&lt;see langword="MethodBase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method to retrieve the parameters of the <ph id="ph2">`Invoke`</ph> method of a delegate.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> método para recuperar os parâmetros do <ph id="ph2">`Invoke`</ph> método de um representante.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The example defines a delegate named <ph id="ph1">`MyDelegate`</ph> and an event named <ph id="ph2">`ev`</ph> of type <ph id="ph3">`MyDelegate`</ph>.</source>
          <target state="translated">O exemplo define um delegado chamado <ph id="ph1">`MyDelegate`</ph> e um evento chamado <ph id="ph2">`ev`</ph> do tipo <ph id="ph3">`MyDelegate`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>The code in the <ph id="ph1">`Main`</ph> method discovers the event signature by getting the delegate type of the event, getting the <ph id="ph2">`Invoke`</ph> method of the delegate type, and then retrieving and displaying the parameters.</source>
          <target state="translated">O código de <ph id="ph1">`Main`</ph> método descobre a assinatura de evento, fazendo com que o tipo delegado do evento, obtendo o <ph id="ph2">`Invoke`</ph> método do tipo delegado e, em seguida, recuperar e exibir os parâmetros.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.GetParameters">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodBase">
          <source>Invokes the method or constructor reflected by this <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph> instance.</source>
          <target state="translated">Invoca o método ou construtor refletido por esta instância <ph id="ph1">&lt;see langword="MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">O objeto no qual o método ou o construtor será invocado.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Se um método for estático, esse argumento será ignorado.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Se um construtor for estático, esse argumento deverá ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou uma instância da classe que define o construtor.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Uma lista de argumentos para o construtor ou método invocado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Esta é uma matriz de objetos com o mesmo número, ordem e tipo que os parâmetros do método ou do construtor a ser invocado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If there are no parameters, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se não houver nenhum parâmetro, <bpt id="p1">&lt;c&gt;</bpt>parameters<ept id="p1">&lt;/c&gt;</ept> deverá ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Se o método ou construtor representado por esta instância usar um parâmetro <ph id="ph1">&lt;see langword="ref" /&gt;</ph> (<ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> no Visual Basic), nenhum atributo especial será necessário para esse parâmetro, a fim de invocar o método ou construtor com o uso dessa função.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Qualquer objeto nesta matriz que não for inicializado explicitamente com um valor conterá o valor padrão desse tipo de objeto.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Para elementos de tipo de referência, esse valor é <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Para elementos de tipo de valor, esse valor é 0, 0,0, ou <ph id="ph1">&lt;see langword="false" /&gt;</ph>, dependendo do tipo de elemento específico.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
          <target state="translated">Invoca o método ou o construtor representado pela instância atual, usando os parâmetros especificados.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> in the case of a constructor.</source>
          <target state="translated">Um objeto que contém o valor retornado do método invocado, ou <ph id="ph1">&lt;see langword="null" /&gt;</ph> no caso de um construtor.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
          <target state="translated">Este é um método prático que chama o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> sobrecarga do método, passando <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> para <ph id="ph3">`invokeAttr`</ph> e <ph id="ph4">`null`</ph> para <ph id="ph5">`binder`</ph> e <ph id="ph6">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> method returns the exception.</source>
          <target state="translated">Se o método invocado lança uma exceção, o <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=nameWithType&gt;</ph> método retorna a exceção.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">Para invocar um método estático usando seu <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> de objeto, passe <ph id="ph2">`null`</ph> para <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Se essa sobrecarga de método é usada para chamar um construtor de instância, o objeto fornecido para <ph id="ph1">`obj`</ph> é reinicializada; ou seja, todos os inicializadores de instância são executados.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor retornado é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Se um construtor de classe é chamado, a classe é reiniciada; ou seja, todos os inicializadores de classe são executados.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor retornado é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Começando por <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o sinalizador <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>considerações de segurança para reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Se um parâmetro do método atual é um tipo de valor e o argumento correspondente em <ph id="ph1">`parameters`</ph> é <ph id="ph2">`null`</ph>, o tempo de execução passa uma instância inicializada do zero, o tipo de valor.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The following code example demonstrates dynamic method lookup using reflection.</source>
          <target state="translated">O exemplo de código a seguir demonstra a pesquisa de método dinâmico usando a reflexão.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Note that you cannot use the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.</source>
          <target state="translated">Observe que você não pode usar o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto da classe base para invocar o método substituído na classe derivada, porque a associação tardia não é possível resolver as substituições.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> instead.</source>
          <target state="translated">No <bpt id="p1">[</bpt>.NET para aplicativos da Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou na <bpt id="p2">[</bpt>Biblioteca de Classes Portátil<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture <ph id="ph1">&lt;see cref="T:System.Exception" /&gt;</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e o método não é estático.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">O método não está declarado nem é herdado pela classe de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Um construtor estático é invocado, e <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> não é <ph id="ph2">&lt;see langword="null" /&gt;</ph> nem uma instância da classe que declarou o construtor.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The elements of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array do not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">Os elementos da matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> não correspondem à assinatura do método ou do construtor refletida por essa instância.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">O método ou o construtor invocado gera uma exceção.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> that contains unverifiable code.</source>
          <target state="translated">A instância atual é um <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph> que contém um código não verificável.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</source>
          <target state="translated">Consulte a seção “Verificação” em Comentários de <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.DynamicMethod" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">A matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> não tem o número correto de argumentos.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>, instead.</source>
          <target state="translated">Em vez disso, no <bpt id="p1">[</bpt>.NET para aplicativos da Windows Store<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> ou na <bpt id="p2">[</bpt>Biblioteca de Classes Portátil<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, capture a exceção de classe base, <ph id="ph1">&lt;see cref="T:System.MemberAccessException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">O chamador não tem permissão para executar o método ou um construtor representado pela instância atual.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">O tipo que declara o método é um tipo genérico aberto.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> retorna <ph id="ph2">&lt;see langword="true" /&gt;</ph> para o tipo declarativo.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>The current instance is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</source>
          <target state="translated">A instância atual é um <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.MethodBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the method or constructor.</source>
          <target state="translated">O objeto no qual o método ou o construtor será invocado.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a method is static, this argument is ignored.</source>
          <target state="translated">Se um método for estático, esse argumento será ignorado.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a constructor is static, this argument must be <ph id="ph1">&lt;see langword="null" /&gt;</ph> or an instance of the class that defines the constructor.</source>
          <target state="translated">Se um construtor for estático, esse argumento deverá ser <ph id="ph1">&lt;see langword="null" /&gt;</ph> ou uma instância da classe que define o construtor.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Um bitmask que é uma combinação de 0 ou mais sinalizadores de bit de <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this parameter is assigned the value <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; thus, whatever you pass in is ignored.</source>
          <target state="translated">Se <bpt id="p1">&lt;c&gt;</bpt>associador<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, este parâmetro receberá o valor <ph id="ph2">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>; portanto, tudo o que você passar será ignorado.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects via reflection.</source>
          <target state="translated">Um objeto que permite a associação, a coerção de tipos de argumentos, invocação de membros e a recuperação de objetos <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> por meio de reflexão.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>binder<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the default binder is used.</source>
          <target state="translated">Se o <bpt id="p1">&lt;c&gt;</bpt>associador<ept id="p1">&lt;/c&gt;</ept> for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, o associador padrão será usado.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An argument list for the invoked method or constructor.</source>
          <target state="translated">Uma lista de argumentos para o construtor ou método invocado.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
          <target state="translated">Esta é uma matriz de objetos com o mesmo número, ordem e tipo que os parâmetros do método ou do construtor a ser invocado.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If there are no parameters, this should be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Se não houver nenhum parâmetro, isso deverá ser <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
          <target state="translated">Se o método ou construtor representado por esta instância usar um parâmetro ByRef, não será necessário nenhum atributo especial para esse parâmetro a fim de invocar o método ou o construtor que usa essa função.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
          <target state="translated">Qualquer objeto nesta matriz que não for inicializado explicitamente com um valor conterá o valor padrão desse tipo de objeto.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For reference-type elements, this value is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Para elementos de tipo de referência, esse valor é <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">&lt;see langword="false" /&gt;</ph>, depending on the specific element type.</source>
          <target state="translated">Para elementos de tipo de valor, esse valor é 0, 0,0, ou <ph id="ph1">&lt;see langword="false" /&gt;</ph>, dependendo do tipo de elemento específico.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An instance of <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> used to govern the coercion of types.</source>
          <target state="translated">Uma instância de <ph id="ph1">&lt;see langword="CultureInfo" /&gt;</ph> usada para determinar a coerção de tipos.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, the <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> for the current thread is used.</source>
          <target state="translated">Se isso for <ph id="ph1">&lt;see langword="null" /&gt;</ph>, será usado o <ph id="ph2">&lt;see langword="CultureInfo" /&gt;</ph> para o thread atual.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(This is necessary to convert a <ph id="ph1">&lt;see langword="String" /&gt;</ph> that represents 1000 to a <ph id="ph2">&lt;see langword="Double" /&gt;</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
          <target state="translated">(Isso é necessário para converter um <ph id="ph1">&lt;see langword="String" /&gt;</ph> que representa 1000 para um valor <ph id="ph2">&lt;see langword="Double" /&gt;</ph>, por exemplo, uma vez que 1000 é representado de forma diferente por diferentes culturas.)</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
          <target state="translated">Quando substituído em uma classe derivada, invoca o método ou o construtor refletido com parâmetros especificados.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>An <ph id="ph1">&lt;see langword="Object" /&gt;</ph> containing the return value of the invoked method, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> in the case of a constructor, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the method's return type is <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="Object" /&gt;</ph> que contém o valor retornado do método invocado, ou <ph id="ph2">&lt;see langword="null" /&gt;</ph>, no caso de um construtor, ou <ph id="ph3">&lt;see langword="null" /&gt;</ph>, se o tipo de retorno do método for <ph id="ph4">&lt;see langword="void" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Before calling the method or constructor, <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
          <target state="translated">Antes de chamar o método ou o construtor, o <ph id="ph1">&lt;see langword="Invoke" /&gt;</ph> verifica se o usuário tem permissão de acesso e verifica se os parâmetros são válidos.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
          <target state="translated">Dinamicamente invoca o método refletido por esta instância <ph id="ph1">`obj`</ph>e passa os parâmetros especificados.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
          <target state="translated">Se o método é estático, o <ph id="ph1">`obj`</ph> parâmetro é ignorado.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
          <target state="translated">Para métodos de não-estático, <ph id="ph1">`obj`</ph> deve ser uma instância de uma classe que herda ou declara o método e deve ser o mesmo tipo que essa classe.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Se o método não tem parâmetros, o valor de <ph id="ph1">`parameters`</ph> devem ser <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
          <target state="translated">Caso contrário, o número, tipo e ordem dos elementos no <ph id="ph1">`parameters`</ph> devem ser idênticos para o número, tipo e ordem de parâmetros para o método refletido por esta instância.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
          <target state="translated">Você não pode omitir os parâmetros opcionais em chamadas para <ph id="ph1">`Invoke`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
          <target state="translated">Para invocar um método de omissão de parâmetros opcionais, você deve chamar <ph id="ph1">`Type.InvokeMember`</ph> em vez disso.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
          <target state="translated">Se essa sobrecarga de método é usada para chamar um construtor de instância, o objeto fornecido para <ph id="ph1">`obj`</ph> é reinicializada; ou seja, todos os inicializadores de instância são executados.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor retornado é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
          <target state="translated">Se um construtor de classe é chamado, a classe é reiniciada; ou seja, todos os inicializadores de classe são executados.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
          <target state="translated">O valor retornado é <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
          <target state="translated">Para parâmetros de passagem-por-valor primitivo, widening normal é executada (Int16 -&gt; Int32, por exemplo).</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
          <target state="translated">Para parâmetros de referência de passagem-por-valor, a referência normal de ampliação é permitida (classe derivada para a classe base e a classe base para o tipo de interface).</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
          <target state="translated">No entanto, para parâmetros de primitivos de passagem-por-referência, os tipos devem corresponder exatamente.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
          <target state="translated">Para parâmetros de referência de passagem-por-referência, a ampliação normal ainda se aplica.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
          <target state="translated">Por exemplo, se o método refletido por esta instância é declarada como <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, em seguida, <ph id="ph2">`parameters`</ph> devem ser uma matriz de <ph id="ph3">`Objects`</ph> com comprimento 2, de modo que <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
          <target state="translated">Se um parâmetro do método atual é um tipo de valor e o argumento correspondente em <ph id="ph1">`parameters`</ph> é <ph id="ph2">`null`</ph>, o tempo de execução passa uma instância inicializada do zero, o tipo de valor.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
          <target state="translated">Reflexão usa a pesquisa de método dinâmico ao chamar métodos virtuais.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
          <target state="translated">Por exemplo, suponha que a classe B herda da classe A, e ambos implementam um método virtual denominado M. Agora suponha que você tenha um <ph id="ph1">`MethodInfo`</ph> objeto que representa o M na classe A. Se você usar o <ph id="ph2">`Invoke`</ph> método a ser invocado M em um objeto do tipo B, em seguida, reflexão usarão a implementação fornecida pela classe B. Mesmo se o objeto do tipo B é convertido para um, a implementação fornecida pela classe B é usada (veja o exemplo de código abaixo).</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
          <target state="translated">Por outro lado, se o método é não virtual, em seguida, reflexão usarão a implementação fornecida pelo tipo do qual o <ph id="ph1">`MethodInfo`</ph> foi obtido, independentemente do tipo de objeto passado como o destino.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code.</source>
          <target state="translated">Restrições de acesso são ignoradas por código totalmente confiável.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
          <target state="translated">Ou seja, propriedades, métodos, campos e construtores privados podem ser acessadas e por meio de reflexão são invocadas sempre que o código é totalmente confiável.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
          <target state="translated">Se o método invocado lança uma exceção, <ph id="ph1">`TargetInvocationException.GetException`</ph> retorna a exceção.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
          <target state="translated">Esta implementação lança um <ph id="ph1">`NotSupportedException`</ph>.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Começando por <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, este método pode ser usado para acessar membros não públicos caso o chamador tenha recebido <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> com o sinalizador <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> e caso o conjunto de concessões dos membros não públicos esteja restrito ao conjunto de concessões do chamador ou um subconjunto dele.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Consulte <bpt id="p1">[</bpt>considerações de segurança para reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> ou posterior.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The following example demonstrates all members of the <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class using an overload of <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir demonstra todos os membros de <ph id="ph1">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> classe usando uma sobrecarga de <ph id="ph2">&lt;xref:System.Type.InvokeMember%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The private method <ph id="ph1">`CanConvertFrom`</ph> finds compatible types for a given type.</source>
          <target state="translated">O método particular <ph id="ph1">`CanConvertFrom`</ph> localiza tipos compatíveis para um determinado tipo.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>For another example of invoking members in a custom binding scenario, see <bpt id="p1">[</bpt>Dynamically Loading and Using Types<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</source>
          <target state="translated">Outro exemplo de invocação de membros em um cenário de associação personalizada, consulte <bpt id="p1">[</bpt>Carregando dinamicamente e usando tipos<ept id="p1">](~/docs/framework/reflection-and-codedom/dynamically-loading-and-using-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and the method is not static.</source>
          <target state="translated">O parâmetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e o método não é estático.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The method is not declared or inherited by the class of <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</source>
          <target state="translated">O método não está declarado nem é herdado pela classe de <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>A static constructor is invoked, and <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is neither <ph id="ph2">&lt;see langword="null" /&gt;</ph> nor an instance of the class that declared the constructor.</source>
          <target state="translated">Um construtor estático é invocado, e <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> não é <ph id="ph2">&lt;see langword="null" /&gt;</ph> nem uma instância da classe que declarou o construtor.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of the <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> parameter does not match the signature of the method or constructor reflected by this instance.</source>
          <target state="translated">O tipo do parâmetro <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> não corresponde à assinatura do método ou do construtor refletida por essa instância.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> array does not have the correct number of arguments.</source>
          <target state="translated">A matriz <ph id="ph1">&lt;paramref name="parameters" /&gt;</ph> não tem o número correto de argumentos.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The invoked method or constructor throws an exception.</source>
          <target state="translated">O método ou o construtor invocado gera uma exceção.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
          <target state="translated">O chamador não tem permissão para executar o método ou um construtor representado pela instância atual.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>The type that declares the method is an open generic type.</source>
          <target state="translated">O tipo que declara o método é um tipo genérico aberto.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph> for the declaring type.</source>
          <target state="translated">Ou seja, a propriedade <ph id="ph1">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> retorna <ph id="ph2">&lt;see langword="true" /&gt;</ph> para o tipo declarativo.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>when invoked late-bound through mechanisms such as <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">quando invocado com associação tardia por meio de mecanismos como <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</source>
          <target state="translated">Enumeração associada: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>Gets a value indicating whether the method is abstract.</source>
          <target state="translated">Obtém um valor que indica se o método é abstrato.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method is abstract; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o método é abstract; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
          <target state="translated">Um membro abstrato é declarado em uma classe base e não forneceu nenhuma implementação.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Para obter o <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, primeiro obtenha o tipo.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the type, get the method.</source>
          <target state="translated">Do tipo, o método get.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">O método de obter o <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Se o <ph id="ph1">`MethodBase`</ph> ou construtor for diferente de público, ele é protegido e não pode ser acessado prontamente.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Para acessar um método não público, defina o <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> máscara para <ph id="ph2">`NonPublic`</ph> em <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAbstract">
          <source>The following example determines whether specified the method is abstract and displays the result.</source>
          <target state="translated">O exemplo a seguir determina se especificado, o método é abstract e exibe o resultado.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
          <target state="translated">Obtém um valor que indica se a visibilidade potencial deste método ou construtor é descrita por <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; ou seja, o construtor ou método é visível no máximo para outros tipos no mesmo assembly e não é visível a tipos derivados fora do assembly.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se a visibilidade deste método ou construtor exatamente é descrita por <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Assembly" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">A visibilidade real de um método é limitada pela visibilidade de seu tipo.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> propriedade pode ser <ph id="ph2">`true`</ph> para um método, mas se ele é um método de um tipo aninhado particular e em seguida, o método não é visível fora do tipo recipiente.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
          <target state="translated">A visibilidade de um método ou construtor exatamente é descrita por <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Assembly?displayProperty=nameWithType&gt;</ph> se o modificador de visibilidade só é <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> no Visual Basic).</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Esta propriedade é <ph id="ph1">`false`</ph> para métodos que são <ph id="ph2">`protected internal`</ph> em c# (<ph id="ph3">`Protected Friend`</ph> no Visual Basic, <ph id="ph4">`protected public`</ph> em C++); use o <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propriedade para identificar esses métodos.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">As linguagens Visual Basic e c#, não é possível definir métodos com <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidade; que o nível de acesso aparece somente no exemplo C++.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Gets a value indicating whether the method is a constructor.</source>
          <target state="translated">Obtém um valor que indica se o método é um construtor.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is a constructor represented by a <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objects); otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se esse método é um construtor representado por um <ph id="ph2">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objeto (consulte a observação em comentários <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.ConstructorBuilder" /&gt;</ph> objetos); caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> propriedade retorna <ph id="ph2">`false`</ph> para um <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> do objeto em um tipo dinâmico, a menos que o <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName?displayProperty=nameWithType&gt;</ph> sinalizador foi incluído no <ph id="ph5">`attributes`</ph> parâmetro quando o construtor foi definido.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsConstructor">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
          <target state="translated">A omissão de <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> sinalizador não afeta a exatidão do construtor emitido.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
          <target state="translated">Obtém um valor que indica se a visibilidade deste método ou construtor é descrita por <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; ou seja, o método ou o construtor é visível somente dentro de sua classe e de classes derivadas.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o acesso a este método ou construtor exatamente é descrito por <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.Family" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
          <target state="translated">A visibilidade de um método ou construtor exatamente é descrita por <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.Family?displayProperty=nameWithType&gt;</ph> se o modificador de visibilidade só é <ph id="ph2">`protected`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
          <target state="translated">Esta propriedade é <ph id="ph1">`false`</ph> para métodos que são <ph id="ph2">`protected internal`</ph> em c# (<ph id="ph3">`Protected Friend`</ph> no Visual Basic, <ph id="ph4">`protected public`</ph> em C++); use o <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propriedade para identificar esses métodos.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamily">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">As linguagens Visual Basic e c#, não é possível definir métodos com <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidade; que o nível de acesso aparece somente no exemplo C++.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
          <target state="translated">Obtém um valor que indica se a visibilidade deste método ou construtor é descrita por <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; ou seja, o método ou o construtor pode ser chamado por classes derivadas, mas apenas se estiverem no mesmo assembly.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o acesso a este método ou construtor exatamente é descrito por <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamANDAssem" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
          <target state="translated">A visibilidade de um método ou construtor exatamente é descrita por <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> se o modificador de visibilidade é <ph id="ph2">`protected private`</ph> em C++.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
          <target state="translated">Métodos com essa visibilidade não podem ser definidos no Visual Basic ou c#.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyAndAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">As linguagens Visual Basic e c#, não é possível definir métodos com <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidade; que o nível de acesso aparece somente no exemplo C++.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
          <target state="translated">Obtém um valor que indica se a visibilidade potencial deste método ou construtor é descrita por <ph id="ph1">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; ou seja, o método ou o construtor pode ser chamado por classes derivadas, não importa em que lugar elas estejam e por classes no mesmo assembly.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o acesso a este método ou construtor exatamente é descrito por <ph id="ph2">&lt;see cref="F:System.Reflection.MethodAttributes.FamORAssem" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
          <target state="translated">Se um membro de tipo tem <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> visibilidade, ele pode ser chamado de qualquer membro em uma classe derivada ou qualquer membro no mesmo assembly, mas não a partir de qualquer outro tipo.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
          <target state="translated">A visibilidade real de um método é limitada pela visibilidade de seu tipo.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> propriedade pode ser <ph id="ph2">`true`</ph> para um método, mas se ele é um método de um tipo aninhado particular e em seguida, o método não é visível fora do tipo recipiente.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
          <target state="translated">A visibilidade de um método ou construtor exatamente é descrita por <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamORAssem?displayProperty=nameWithType&gt;</ph> se o modificador de visibilidade é <ph id="ph2">`protected internal`</ph> em c# (<ph id="ph3">`Protected Friend`</ph> no Visual Basic, <ph id="ph4">`protected public`</ph> em C++).</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The following code example defines methods with varying levels of visibility, and displays the values of their <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> properties.</source>
          <target state="translated">O exemplo de código a seguir define os métodos com vários níveis de visibilidade e exibe os valores de suas <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFamilyOrAssembly">
          <source>The Visual Basic and C# languages cannot define methods with <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibility; that access level appears only in the C++ example.</source>
          <target state="translated">As linguagens Visual Basic e c#, não é possível definir métodos com <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.FamANDAssem?displayProperty=nameWithType&gt;</ph> visibilidade; que o nível de acesso aparece somente no exemplo C++.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>Gets a value indicating whether this method is <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</source>
          <target state="translated">Obtém um valor que indica se esse método é <ph id="ph1">&lt;see langword="final" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="final" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse método for <ph id="ph2">&lt;see langword="final" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para determinar se um método substituível, não é suficiente verificar se <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Para um método substituível, <ph id="ph1">`IsVirtual`</ph> devem ser <ph id="ph2">`true`</ph> e <ph id="ph3">`IsFinal`</ph> devem ser <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Por exemplo, um método pode ser não-virtual, mas ele implementa um método de interface.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">O common language runtime requer que todos os métodos que implementam membros de interface devem ser marcados como <ph id="ph1">`virtual`</ph>; portanto, o compilador marca o método <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Portanto, há casos em que um método é marcado como <ph id="ph1">`virtual`</ph> , mas ainda não substituível.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Para estabelecer com certeza se um método é substituível, use um código como este:</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Se <ph id="ph1">`IsVirtual`</ph> é <ph id="ph2">`false`</ph> ou <ph id="ph3">`IsFinal`</ph> é <ph id="ph4">`true`</ph>, em seguida, o método não pode ser substituído.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that MyMethod is overridable.</source>
          <target state="translated">O exemplo a seguir exibe <ph id="ph1">`false`</ph> para <ph id="ph2">`IsFinal`</ph>, que pode levar você acha que Meumetodo é substituível.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsFinal">
          <source>The code prints <ph id="ph1">`false`</ph> even though MyMethod is not marked <ph id="ph2">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Imprime o código <ph id="ph1">`false`</ph> mesmo que não está marcado como Meumetodo <ph id="ph2">`virtual`</ph> e, portanto, não pode ser substituído.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Gets a value indicating whether the method is generic.</source>
          <target state="translated">Obtém um valor que indica se o método é genérico.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> represents a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> representa um método genérico; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade para determinar se o atual <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto representa um método genérico.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade para determinar se o atual <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objeto representa um método construído aberto ou um método construído fechado.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Não há suporte para genéricos por padrão. Essa propriedade retorna <ph id="ph1">`false`</ph> se não for substituída em uma classe derivada.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Construtores genéricos não têm suporte no .NET Framework versão 2.0, para que essa propriedade retorna <ph id="ph1">`false`</ph> se a instância atual é do tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The following table summarizes the invariant conditions for terms specific to generic methods.</source>
          <target state="translated">A tabela a seguir resume as condições invariáveis para termos específicos para os métodos genéricos.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>For other terms used in generic reflection, such as <bpt id="p1">*</bpt>generic type parameter<ept id="p1">*</ept> and <bpt id="p2">*</bpt>generic type<ept id="p2">*</ept>, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para outros termos usados em reflexão genérico, como <bpt id="p1">*</bpt>parâmetro de tipo genérico<ept id="p1">*</ept> e <bpt id="p2">*</bpt>tipo genérico<ept id="p2">*</ept>, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Term</source>
          <target state="translated">Termo</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Invariant condition</source>
          <target state="translated">Condição invariável</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method definition</source>
          <target state="translated">definição de método genérico</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition&gt;</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Defines a generic method.</source>
          <target state="translated">Define um método genérico.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>A constructed method is created by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition, and specifying an array of type arguments.</source>
          <target state="translated">Um método construído é criado chamando o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> método em um <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> do objeto que representa uma definição de método genérico e especificando uma matriz de argumentos de tipo.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be called only on generic method definitions.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método pode ser chamado apenas em definições de método genérico.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Any generic method definition is a generic method, but the converse is not true.</source>
          <target state="translated">Qualquer definição de método genérico é um método genérico, mas o contrário não é válido.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>generic method</source>
          <target state="translated">método genérico</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">`IsGenericMethod`</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">`IsGenericMethod`</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>Can be a generic method definition, an open constructed method, or a closed constructed method.</source>
          <target state="translated">Pode ser uma definição de método genérico, um método construído aberto ou um método construído fechado.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>open constructed method</source>
          <target state="translated">método construído Open</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>It is not possible to invoke an open constructed method.</source>
          <target state="translated">Não é possível chamar um método construído aberto.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>closed constructed method</source>
          <target state="translated">método construído fechado</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters&gt;</ph> é <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>When examined recursively, the method has no unassigned generic parameters.</source>
          <target state="translated">Quando examinada recursivamente, o método não tem nenhum parâmetro genérico não atribuído.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The containing type has no generic type parameters, and none of the type arguments have generic type parameters.</source>
          <target state="translated">O tipo de conteúdo não tem nenhum parâmetro de tipo genérico e nenhum dos argumentos de tipo tem parâmetros de tipo genérico.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethod">
          <source>The method can be invoked.</source>
          <target state="translated">O método pode ser chamado.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
          <target state="translated">Obtém um valor que indica se o método é uma definição de método genérica.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o atual <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objeto representa a definição de um método genérico; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> representa uma definição de método genérico, então:</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
          <target state="translated">Para cada <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto na matriz retornada pelo <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> método:</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">A propriedade <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=nameWithType&gt;</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> property returns the current instance.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=nameWithType&gt;</ph> propriedade retorna a instância atual.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=nameWithType&gt;</ph> propriedade é o mesmo que a posição do <ph id="ph2">&lt;xref:System.Type&gt;</ph> objeto na matriz.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
          <target state="translated">Não há suporte para genéricos por padrão. Essa propriedade retorna <ph id="ph1">`false`</ph> se não for substituída em uma classe derivada.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
          <target state="translated">Construtores genéricos não têm suporte no .NET Framework versão 2.0, para que essa propriedade retorna <ph id="ph1">`false`</ph> se a instância atual é do tipo <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
          <target state="translated">Obtém um valor que indica se apenas um membro do mesmo tipo, com exatamente a mesma assinatura, está oculto na classe derivada.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member is hidden by signature; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se o membro estiver ocultado por assinatura. Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
          <target state="translated">Quando um membro em uma classe derivada é declarado com o c# <ph id="ph1">`new`</ph> modificador ou o Visual Basic <ph id="ph2">`Shadows`</ph> modificador, ele pode ocultar um membro de mesmo nome na classe base.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>C# hides base class members by signature.</source>
          <target state="translated">C# oculta os membros da classe base por assinatura.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
          <target state="translated">Ou seja, se o membro de classe base tem várias sobrecargas, a única pessoa que está oculto é aquele que tem a assinatura idêntica.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
          <target state="translated">Por outro lado, o Visual Basic oculta todas as sobrecargas de classe base.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
          <target state="translated">Portanto, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> retorna <ph id="ph2">`false`</ph> em um membro declarado com o Visual Basic <ph id="ph3">`Shadows`</ph> modificador, e <ph id="ph4">`true`</ph> em um membro declarado com o c# <ph id="ph5">`new`</ph> modificador.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
          <target state="translated">Essa propriedade não determina se um método tem a <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
          <target state="translated">Um método que é declarado com o o <ph id="ph1">`new`</ph> ou <ph id="ph2">`Shadows`</ph> modificador terá o <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo, mas somente os métodos declarados com <ph id="ph4">`new`</ph> (ou seja, somente métodos c#) terá o <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> propriedade definida como <ph id="ph6">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
          <target state="translated">Para determinar se um método tem a <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> de atributo, use o código semelhante ao seguinte: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> em c# ou <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> no Visual Basic.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
          <target state="translated">Observe, no entanto, que embora todos os métodos declarados com <ph id="ph1">`new`</ph> ou <ph id="ph2">`Shadows`</ph> tem o <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> de atributo, nem todos os métodos que têm o <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> atributo são declarados com <ph id="ph5">`new`</ph> ou <ph id="ph6">`Shadows`</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads.</source>
          <target state="translated">O exemplo de código a seguir contém uma classe base com um método sobrecarregado e uma classe derivada que oculta uma das sobrecargas.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the Visual Basic version of the code example, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the member in the derived class.</source>
          <target state="translated">Na versão Visual Basic do exemplo de código, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> propriedade retorna <ph id="ph2">`false`</ph> para o membro na classe derivada.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsHideBySig">
          <source>In the C# version of the code sample, the property returns <ph id="ph1">`true`</ph> for the member in the derived class.</source>
          <target state="translated">A versão c# do código de exemplo, a propriedade retorna <ph id="ph1">`true`</ph> para o membro na classe derivada.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>Gets a value indicating whether this member is private.</source>
          <target state="translated">Obtém um valor que indica se este membro é privado.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o acesso a este método é restrito a outros membros da classe em si; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPrivate">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
          <target state="translated">Se um membro de tipo tem <ph id="ph1">`Private`</ph> visibilidade de nível, ele pode ser chamado de qualquer membro na mesma classe e nenhum outro.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>Gets a value indicating whether this is a public method.</source>
          <target state="translated">Obtém um valor que indica se este é um método público.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se esse método é público; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
          <target state="translated">Para obter o <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, primeiro obtenha o tipo.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the type, get the method.</source>
          <target state="translated">Do tipo, o método get.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
          <target state="translated">O método de obter o <ph id="ph1">`MethodBase`</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
          <target state="translated">Se o <ph id="ph1">`MethodBase`</ph> ou construtor for diferente de público, ele é protegido e não pode ser acessado prontamente.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
          <target state="translated">Para acessar um método não público, defina o <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> máscara para <ph id="ph2">`NonPublic`</ph> em <ph id="ph3">`GetMethod`</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsPublic">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> property to display a message that indicates whether the specified method is public.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> propriedade para exibir uma mensagem que indica se o método especificado é público.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Obtém um valor que indica se o método ou o construtor atual é crítico para segurança ou crítico para segurança e disponível no código transparente no nível de confiança atual e, portanto, pode realizar operações críticas.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o método atual ou o construtor for crítico de segurança ou segurança-crítico para segurança no nível de confiança atual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se é transparente.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">As combinações destas propriedades são mostradas na seguinte tabela:</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Nível de segurança</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Segurança crítica</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">O assembly e todos os tipos são tratados como transparentes.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre reflexão e transparência, consulte <bpt id="p1">[</bpt>considerações de segurança para reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obter informações sobre a transparência, consulte <bpt id="p1">[</bpt>alterações de segurança<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Obtém um valor que indica se o método ou o construtor atual é crítico para segurança e disponível no código transparente no nível de confiança atual; ou seja, se ele pode realizar operações críticas e ser acessado pelo código transparente.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o método ou construtor é safe-crítico de segurança no nível de confiança atual; <ph id="ph2">&lt;see langword="false" /&gt;</ph> se ele é crítico de segurança ou transparente.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">As combinações destas propriedades são mostradas na seguinte tabela:</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Nível de segurança</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Crítico</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Segurança crítica</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparente</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">O assembly e todos os tipos são tratados como transparentes.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre reflexão e transparência, consulte <bpt id="p1">[</bpt>considerações de segurança para reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obter informações sobre a transparência, consulte <bpt id="p1">[</bpt>alterações de segurança<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Obtém um valor que indica que se o método ou o construtor atual é transparente no nível de confiança atual e, portanto, não é pode realizar operações críticas.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Se o método ou construtor é transparente de segurança no nível de confiança atual; Caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Se essa propriedade retorna <ph id="ph1">`true`</ph>, o <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> propriedades retorno <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> o nível de transparência de método ou construtor em seu nível de confiança atual, conforme determinado pelo common language runtime (CLR) de propriedades do relatam.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">O uso dessas propriedades é muito mais simples do que examinando as anotações de segurança de um assembly e seus tipos e membros, verificando o nível de confiança atual e a tentativa de duplicar as regras do runtime.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Para assemblies de confiança parcial, o valor desta propriedade depende do nível de confiança atual do assembly.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Se o assembly está carregado em um domínio de aplicativo parcialmente confiável (por exemplo, para um domínio de aplicativo na área restrita), o tempo de execução ignora as anotações de segurança do assembly.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">O assembly e todos os tipos são tratados como transparentes.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">O tempo de execução só presta atenção nas anotações de segurança de um assembly de confiança parcial quando o assembly é carregado em um domínio de aplicativo totalmente confiável (por exemplo, no domínio de aplicativo padrão de um aplicativo da área de trabalho).</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Por outro lado, um assembly confiável (ou seja, um assembly de nome forte que está instalado no cache de assembly global) é sempre carregado com confiança total, independentemente do nível de confiança do domínio do aplicativo, logo, o nível de confiança atual sempre é totalmente confiável.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">É possível determinar os níveis de confiança atuais de assemblies e de domínios de aplicativo usando-se as propriedades <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre reflexão e transparência, consulte <bpt id="p1">[</bpt>considerações de segurança para reflexão<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Para obter informações sobre a transparência, consulte <bpt id="p1">[</bpt>alterações de segurança<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>Gets a value indicating whether this method has a special name.</source>
          <target state="translated">Obtém um valor que indica se esse método tem um nome especial.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method has a special name; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse método tiver um nome especial; caso contrário, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit é definido como sinalizador membros que são tratados de forma especial por alguns compiladores (como acessadores de propriedade e métodos de sobrecarga de operador).</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsSpecialName">
          <source>This example shows a use of <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> to filter internal or private members out of a list.</source>
          <target state="translated">Este exemplo mostra um uso de <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSpecialName%2A&gt;</ph> filtro interno ou membros particulares fora de uma lista.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</source>
          <target state="translated">Obtém um valor que indica se o método é <ph id="ph1">&lt;see langword="static" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="static" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse método for <ph id="ph2">&lt;see langword="static" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsStatic">
          <source>A static member cannot implicitly reference instance data in a class.</source>
          <target state="translated">Um membro estático implicitamente não pode fazer referência a dados da instância em uma classe.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>Gets a value indicating whether the method is <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</source>
          <target state="translated">Obtém um valor que indica se o método é <ph id="ph1">&lt;see langword="virtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this method is <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se esse método for <ph id="ph2">&lt;see langword="virtual" /&gt;</ph>; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
          <target state="translated">Um membro virtual pode fazer referência a dados da instância em uma classe e deve ser referenciado através de uma instância da classe.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Para determinar se um método substituível, não é suficiente verificar se <ph id="ph1">`IsVirtual`</ph> é <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Para um método substituível, <ph id="ph1">`IsVirtual`</ph> devem ser <ph id="ph2">`true`</ph> e <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> devem ser <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
          <target state="translated">Por exemplo, um método pode ser não-virtual, mas ele implementa um método de interface.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
          <target state="translated">O common language runtime requer que todos os métodos que implementam membros de interface devem ser marcados como <ph id="ph1">`virtual`</ph>; portanto, o compilador marca o método <ph id="ph2">`virtual final`</ph>.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
          <target state="translated">Portanto, há casos em que um método é marcado como <ph id="ph1">`virtual`</ph> , mas ainda não substituível.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
          <target state="translated">Para estabelecer com certeza se um método é substituível, use um código como este:</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
          <target state="translated">Se <ph id="ph1">`IsVirtual`</ph> é <ph id="ph2">`false`</ph> ou <ph id="ph3">`IsFinal`</ph> é <ph id="ph4">`true`</ph>, em seguida, o método não pode ser substituído.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Você pode determinar se o método atual substitui um método em uma classe base chamando o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">O exemplo a seguir implementa um <ph id="ph1">`IsOverride`</ph> método que faz isso.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The following example displays <ph id="ph1">`false`</ph> for <ph id="ph2">`IsFinal`</ph>, which might lead you to think that <ph id="ph3">`MyMethod`</ph> is overridable.</source>
          <target state="translated">O exemplo a seguir exibe <ph id="ph1">`false`</ph> para <ph id="ph2">`IsFinal`</ph>, que pode levar a pensar <ph id="ph3">`MyMethod`</ph> é substituível.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.IsVirtual">
          <source>The code prints <ph id="ph1">`false`</ph> even though <ph id="ph2">`MyMethod`</ph> is not marked <ph id="ph3">`virtual`</ph> and thus cannot be overridden.</source>
          <target state="translated">Imprime o código <ph id="ph1">`false`</ph> , embora <ph id="ph2">`MyMethod`</ph> não está marcado como <ph id="ph3">`virtual`</ph> e, portanto, não pode ser substituído.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>Gets a handle to the internal metadata representation of a method.</source>
          <target state="translated">Obtém um identificador para a representação interna de metadados de um método.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>A <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.RuntimeMethodHandle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodHandle">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Os identificadores são válidos somente no domínio do aplicativo no qual eles foram obtidos.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> flags that specify the attributes of a method implementation.</source>
          <target state="translated">Obtém os sinalizadores <ph id="ph1">&lt;see cref="T:System.Reflection.MethodImplAttributes" /&gt;</ph> que especificam os atributos de uma implementação de método.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>The method implementation flags.</source>
          <target state="translated">Os sinalizadores de implementação de método.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.MethodImplementationFlags">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
          <target state="translated">Consulte o método <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> para obter mais informações.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Equality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> não são iguais.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.op_Inequality(System.Reflection.MethodBase,System.Reflection.MethodBase)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> não for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="M:System.Runtime.InteropServices._MethodBase.GetType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso a propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAbstract" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsConstructor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamily" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsFinal" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsHideBySig" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPrivate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsPublic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsSpecialName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsStatic" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>For a description of this member, see <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</source>
          <target state="translated">Para obter uma descrição desse membro, consulte <ph id="ph1">&lt;see cref="P:System.Runtime.InteropServices._MethodBase.IsVirtual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Este membro é uma implementação do membro de interface explícita.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
          <target state="translated">Ele só pode ser usado quando a instância de <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> é convertida em uma interface de <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>