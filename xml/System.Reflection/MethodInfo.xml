<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="MethodInfo.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd4ae293dba419bbcd758325322617d8b6cce4b7.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd4ae293dba419bbcd758325322617d8b6cce4b7</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Discovers the attributes of a method and provides access to method metadata.</source>
          <target state="translated">Descobre os atributos de um método e fornece acesso aos metadados de método.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class represents a method of a type.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> classe representa um método de um tipo.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can use a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object to obtain information about the method that the object represents and to invoke the method.</source>
          <target state="translated">Você pode usar um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para obter informações sobre o método que representa o objeto e invocar o método de objeto.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For example:</source>
          <target state="translated">Por exemplo:</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine the method's visibility by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> properties.</source>
          <target state="translated">Você pode determinar a visibilidade do método recuperando os valores de <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsPrivate%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodBase.IsPublic%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can discover what attributes are applied to the method by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> property or calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated">Você pode descobrir quais atributos são aplicados ao método por recuperar o valor da <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Attributes%2A&gt;</ph> propriedade ou chamar o <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetCustomAttributes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> properties.</source>
          <target state="translated">Você pode determinar se o método é um método genérico, um aberto construído método genérico ou construído um método genérico, recuperando os valores da <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> e <ph id="ph2">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can get information about the method's parameters and return type from the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> method and the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> properties.</source>
          <target state="translated">Você pode obter informações sobre os parâmetros do método e tipo de retorno de <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetParameters%2A&gt;</ph> método e o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.ReturnParameter%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ReturnType%2A&gt;</ph>, e <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A&gt;</ph> propriedades.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can execute a method on a class instance by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> method.</source>
          <target state="translated">Você pode executar um método em uma instância da classe chamando o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a constructed generic method from one that represents a generic method definition by calling the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa um método genérico construído de um que representa uma definição de método genérico ao chamar o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>You can instantiate a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instances by calling the <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> method, or by calling the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated">Você pode instanciar uma <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> instâncias chamando o <ph id="ph2">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> ou <ph id="ph3">&lt;xref:System.Type.GetMethod%2A?displayProperty=nameWithType&gt;</ph> método, ou chamando o <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType&gt;</ph> método de um <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>for full trust for inheritors.</source>
          <target state="translated">para confiança total de herdeiros.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This class cannot be inherited by partially trusted code.</source>
          <target state="translated">Esta classe não pode ser herdada pelo código parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>This type is thread safe.</source>
          <target state="translated">Este tipo é thread-safe.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Reflection.MethodInfo">
          <source>When you inherit from <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, you must override <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, and <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</source>
          <target state="translated">Ao herdar de <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, você deve substituir <ph id="ph2">&lt;see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" /&gt;</ph>, <ph id="ph3">&lt;see cref="P:System.Reflection.MethodInfo.ReturnType" /&gt;</ph>, <ph id="ph4">&lt;see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" /&gt;</ph>, <ph id="ph5">&lt;see cref="M:System.Reflection.MethodBase.GetParameters" /&gt;</ph>, <ph id="ph6">&lt;see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" /&gt;</ph>, <ph id="ph7">&lt;see cref="P:System.Reflection.MethodBase.MethodHandle" /&gt;</ph>, <ph id="ph8">&lt;see cref="P:System.Reflection.MethodBase.Attributes" /&gt;</ph>, <ph id="ph9">&lt;see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" /&gt;</ph>, <ph id="ph10">&lt;see cref="P:System.Reflection.MemberInfo.Name" /&gt;</ph>, <ph id="ph11">&lt;see cref="P:System.Reflection.MemberInfo.MemberType" /&gt;</ph>, <ph id="ph12">&lt;see cref="P:System.Reflection.MemberInfo.DeclaringType" /&gt;</ph>, <ph id="ph13">&lt;see cref="P:System.Reflection.MemberInfo.ReflectedType" /&gt;</ph>, <ph id="ph14">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" /&gt;</ph>, <ph id="ph15">&lt;see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" /&gt;</ph>, e <ph id="ph16">&lt;see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="T:System.Reflection.MethodInfo">
          <source>Creates a delegate from this method.</source>
          <target state="translated">Cria um delegado desse método.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The type of the delegate to create.</source>
          <target state="translated">O tipo do delegado a criar.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>Creates a delegate of the specified type from this method.</source>
          <target state="translated">Cria um delegado do tipo especificado desse método.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)">
          <source>The delegate for this method.</source>
          <target state="translated">O delegado para esse método.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The type of the delegate to create.</source>
          <target state="translated">O tipo do delegado a criar.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The object targeted by the delegate.</source>
          <target state="translated">O objeto almejado pelo delegado.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>Creates a delegate of the specified type with the specified target from this method.</source>
          <target state="translated">Cria um delegado do tipo especificado com o destino especificado deste método.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)">
          <source>The delegate for this method.</source>
          <target state="translated">O delegado para esse método.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>An object to compare with this instance, or <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Um objeto a ser comparado com essa instância ou <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
          <target state="translated">Retorna um valor que indica se essa instância é igual a um objeto especificado.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> equals the type and value of this instance; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> for igual ao tipo e ao valor dessa instância, caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</source>
          <target state="translated">Quando substituído em uma classe derivada, retorna o objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> para o método sobre a classe base direta ou indireta em que o método representado por esta instância foi declarado.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object for the first implementation of this method.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> para a primeira implementação deste método.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the first definition of the specified method in the class hierarchy.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna a primeira definição do método especificado na hierarquia de classe.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine the type on which the first definition of the method is found by retrieving the value of the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Você pode determinar o tipo no qual a primeira definição do método foi encontrada ao recuperar o valor da <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.DeclaringType%2A&gt;</ph> propriedade retornado <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method behaves as follows:</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método se comporta da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an interface implementation, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto representa uma implementação de interface, o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna atual <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that overrides a virtual definition in a base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the virtual definition.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto representa um método que substitui uma definição virtual em uma classe base, o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna um <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa a definição de virtual.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is specified with the <ph id="ph2">`new`</ph> keyword in C# or the <ph id="ph3">`Shadows`</ph> keyword in Visual Basic (as in <ph id="ph4">`newslot`</ph>, as described in <bpt id="p1">[</bpt>Common Type System<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se atual <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto representa um método que é especificado com o <ph id="ph2">`new`</ph> palavra-chave em c# ou o <ph id="ph3">`Shadows`</ph> palavra-chave no Visual Basic (como em <ph id="ph4">`newslot`</ph>, conforme descrito em <bpt id="p1">[</bpt>CTS<ept id="p1">](~/docs/standard/base-types/common-type-system.md)</ept>), o <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna atual <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents an inherited method (that is, the current method does not provide its own implementation), the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the lowest method in the class hierarchy.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto representa um método herdado (ou seja, o método atual não fornece sua própria implementação), o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna um <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa o método mais baixo na hierarquia de classe.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>For example, if <ph id="ph1">`Base.ToString`</ph> overrides <ph id="ph2">`Object.ToString`</ph>, and <ph id="ph3">`Derived.ToString`</ph> overrides <ph id="ph4">`Base.ToString`</ph>, calling the <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method on a <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph7">`Derived.ToString`</ph> returns a <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents <ph id="ph9">`Object.ToString`</ph>.</source>
          <target state="translated">Por exemplo, se <ph id="ph1">`Base.ToString`</ph> substitui <ph id="ph2">`Object.ToString`</ph>, e <ph id="ph3">`Derived.ToString`</ph> substitui <ph id="ph4">`Base.ToString`</ph>, chamar o <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método em um <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa <ph id="ph7">`Derived.ToString`</ph> retorna um <ph id="ph8">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa <ph id="ph9">`Object.ToString`</ph>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object represents a method that is not present in any base class, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Se o atual <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto representa um método que não está presente em nenhuma classe base, o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método retorna atual <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">Você pode determinar se o método atual substitui um método em uma classe base chamando o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
          <target state="translated">O exemplo a seguir implementa um <ph id="ph1">`IsOverride`</ph> método que faz isso.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>To call the <ph id="ph1">`GetBaseDefinition`</ph> method:</source>
          <target state="translated">Para chamar o <ph id="ph1">`GetBaseDefinition`</ph> método:</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type (the class or structure) that contains the property.</source>
          <target state="translated">Obter um <ph id="ph1">&lt;xref:System.Type&gt;</ph> objeto que representa o tipo (a classe ou estrutura) que contém a propriedade.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>If you are working with an object (an instance of a type), you can call its <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Se você estiver trabalhando com um objeto (uma instância de um tipo), você pode chamar seu <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</source>
          <target state="translated">Caso contrário, você pode usar o operador c# ou o operador do Visual Basic, como mostra o exemplo.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Get a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method in which you're interested.</source>
          <target state="translated">Obter um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa o método no qual você está interessado.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>You can do this by getting an array of all methods from the <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> method and then iterating the elements in the array, or you can retrieve the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the method directly by calling the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> method and specifying the method name.</source>
          <target state="translated">Você pode fazer isso obtendo uma matriz de todos os métodos do <ph id="ph1">&lt;xref:System.Type.GetMethods%2A?displayProperty=nameWithType&gt;</ph> método e, em seguida, iterar os elementos na matriz, ou você podem recuperar o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa o método diretamente ao chamar o <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType&gt;</ph> método e especificando o nome do método.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>Call the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method to get the value of the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents the base method definition.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método para obter o valor da <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa a definição de método de base.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetBaseDefinition">
          <source>The following example demonstrates the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir demonstra o comportamento de <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Retorna uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
          <target state="translated">Uma matriz de objetos <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representam os argumentos de tipo de um método genérico ou os parâmetros de tipo de uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Returns an empty array if the current method is not a generic method.</source>
          <target state="translated">Retornará uma matriz vazia se o método atual não for um método genérico.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
          <target state="translated">Os elementos da matriz retornada estão na ordem em que aparecem na lista de parâmetros de tipo para o método genérico.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
          <target state="translated">Se o método atual é um método de construído fechado (ou seja, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`false`</ph>), a matriz retornada pelo <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> método contém os tipos que foram atribuídos a parâmetros de tipo genérico de definição de método genérico.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
          <target state="translated">Se o método atual é uma definição de método genérico, a matriz contém os parâmetros de tipo.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
          <target state="translated">Se o método atual é um método construído open (ou seja, o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`true`</ph>) em que tipos específicos foram atribuídos a alguns parâmetros de tipo e parâmetros de tipo de delimitador tipos genéricos foram atribuídos a outros parâmetros de tipo, a matriz contém tipos e tipo de parâmetros.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Use o <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> propriedade distingui-los.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Para ver uma demonstração desse cenário, consulte o exemplo de código para o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=nameWithType&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>The following code example shows how to get the type arguments of a generic method and display them.</source>
          <target state="translated">O exemplo de código a seguir mostra como obter os argumentos de tipo de um método genérico e exibi-los.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericArguments">
          <source>This method is not supported.</source>
          <target state="translated">Não há suporte para o método.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Retorna um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa uma definição de método genérico da qual o método atual pode ser criado.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing a generic method definition from which the current method can be constructed.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa uma definição de método genérico da qual o método atual pode ser criado.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>A generic method definition is a template from which methods can be constructed.</source>
          <target state="translated">Uma definição de método genérico é um modelo do qual os métodos podem ser construídos.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, from the generic method definition <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expressed in C# syntax; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> in Visual Basic) you can construct and invoke the method <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Por exemplo, da definição de método genérico <ph id="ph1">`T M&lt;T&gt;(T t)`</ph> (expresso na sintaxe do c#; <ph id="ph2">`Function M(Of T)(ByVal tVal As T) As T`</ph> no Visual Basic) você pode criar e invocar o método <ph id="ph3">`int M&lt;int&gt;(int t)`</ph> (<ph id="ph4">`Function M(Of Integer)(ByVal tVal As Integer) As Integer`</ph> no Visual Basic).</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object representing this constructed method, the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the generic method definition.</source>
          <target state="translated">Dado um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> construída de objeto que representa esse método, o <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> método retorna a definição de método genérico.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If two constructed methods are created from the same generic method definition, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object for both methods.</source>
          <target state="translated">Se os dois métodos construídos são criados da definição do método genérico, o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> método retorna o mesmo <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto para ambos os métodos.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If you call <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> on a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that already represents a generic method definition, it returns the current <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A&gt;</ph> em uma <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que já representa uma definição de método genérico, ele retorna atual <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</source>
          <target state="translated">Se uma definição de método genérico inclui parâmetros genéricos do tipo declarativo, haverá uma definição de método genérico específicos para cada tipo construído.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For example, consider the following C#, Visual Basic, and C++ code:</source>
          <target state="translated">Por exemplo, considere o seguinte código c#, Visual Basic e C++:</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the generic method <ph id="ph3">`M`</ph> returns <ph id="ph4">`B&lt;int, S&gt;`</ph>.</source>
          <target state="translated">O tipo construído <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> no Visual Basic), o método genérico <ph id="ph3">`M`</ph> retorna <ph id="ph4">`B&lt;int, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the open type <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> returns <ph id="ph3">`B&lt;T, S&gt;`</ph>.</source>
          <target state="translated">No tipo aberto <ph id="ph1">`C&lt;T&gt;`</ph>, <ph id="ph2">`M`</ph> retorna <ph id="ph3">`B&lt;T, S&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In both cases, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for the <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents <ph id="ph4">`M`</ph>, so <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> can be called on both <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects.</source>
          <target state="translated">Em ambos os casos, o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A&gt;</ph> propriedade retorna <ph id="ph2">`true`</ph> para o <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa <ph id="ph4">`M`</ph>, portanto <ph id="ph5">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> pode ser chamado em ambos <ph id="ph6">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the constructed type, the result of calling <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> is a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that can be invoked.</source>
          <target state="translated">No caso do tipo construído, o resultado da chamada <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> é um <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que pode ser invocado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>In the case of the open type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> returned by <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> cannot be invoked.</source>
          <target state="translated">No caso do tipo aberto, o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> retornado por <ph id="ph2">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> não pode ser invocado.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The following code example shows a class with a generic method and the code required to obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</source>
          <target state="translated">O exemplo de código a seguir mostra uma classe com um método genérico e o código necessário para obter um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> para o método, vincular o método argumentos de tipo e voltar a definição de tipo genérico original do método associado.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method.</source>
          <target state="translated">Este exemplo é parte de um exemplo maior fornecido para o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>The current method is not a generic method.</source>
          <target state="translated">O método atual não é um método genérico.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.IsGenericMethod" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.IsGenericMethod" /&gt;</ph> retorna <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetGenericMethodDefinition">
          <source>This method is not supported.</source>
          <target state="translated">Não há suporte para o método.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.GetHashCode">
          <source>A 32-bit signed integer hash code.</source>
          <target state="translated">Um código de hash do inteiro assinado de 32 bits.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic method definition.</source>
          <target state="translated">Uma matriz de tipos a serem substituídos para os parâmetros de tipo da definição de método genérico atual.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object representing the resulting constructed method.</source>
          <target state="translated">Substitui os elementos de uma matriz de tipos pelos parâmetros de tipo da definição de método genérico atual e retorna um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa o método construído resultante.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> object that represents the constructed method formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic method definition.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> que representa o método construído formado pela substituição dos elementos de <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> pelos parâmetros de tipo da definição de método genérico atual.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a particular constructed method.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método permite que você escreva código que atribui tipos específicos para os parâmetros de tipo de uma definição de método genérico, criando assim uma <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto que representa um método específico de construído.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property of this <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object returns <ph id="ph3">`true`</ph>, you can use it to invoke the method or to create a delegate to invoke the method.</source>
          <target state="translated">Se o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade deste <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objeto retorna <ph id="ph3">`true`</ph>, você pode usá-lo para chamar o método ou para criar um delegado para invocar o método.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Methods constructed with the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</source>
          <target state="translated">Métodos construído com o <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.MakeGenericMethod%2A&gt;</ph> método pode ser aberto, ou seja, alguns de seus argumentos de tipo podem ser parâmetros de tipo de tipos genéricos de circunscrição.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>You might use such open constructed methods when you generate dynamic assemblies.</source>
          <target state="translated">Você pode usar esses métodos construídos abertos quando você gerar assemblies dinâmicos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For example, consider the following C#, Visual Basic, and C++ code.</source>
          <target state="translated">Por exemplo, considere o seguinte código c#, Visual Basic e C++.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The method body of <ph id="ph1">`M`</ph> contains a call to method <ph id="ph2">`N`</ph>, specifying the type parameter of <ph id="ph3">`M`</ph> and the type <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">O corpo do método de <ph id="ph1">`M`</ph> contém uma chamada ao método <ph id="ph2">`N`</ph>, especificando o parâmetro de tipo de <ph id="ph3">`M`</ph> e o tipo <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for method <ph id="ph3">`N&lt;V,int&gt;`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> propriedade retorna <ph id="ph2">`false`</ph> método <ph id="ph3">`N&lt;V,int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, so method <ph id="ph3">`N&lt;V,int&gt;`</ph> cannot be invoked.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> propriedade retorna <ph id="ph2">`true`</ph>, portanto método <ph id="ph3">`N&lt;V,int&gt;`</ph> não pode ser invocado.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para termos específicos para os métodos genéricos, consulte o <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Para obter uma lista das condições invariáveis para outros termos usados na reflexão genérico, consulte o <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The following code example demonstrates the properties and methods of <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that support the examination of generic methods.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e métodos de <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que dão suporte a exame de métodos genéricos.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The example does the following:</source>
          <target state="translated">O exemplo faz o seguinte:</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Defines a class that has a generic method.</source>
          <target state="translated">Define uma classe que tem um método genérico.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Creates a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that represents the generic method.</source>
          <target state="translated">Cria um <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> que representa o método genérico.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the generic method definition.</source>
          <target state="translated">Exibe as propriedades da definição de método genérico.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Assigns type arguments to the type parameters of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, and invokes the resulting constructed generic method.</source>
          <target state="translated">Atribui digite argumentos para os parâmetros de tipo de <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph>e invoca o método genérico construído resultante.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Displays properties of the constructed generic method.</source>
          <target state="translated">Exibe as propriedades do método genérico construído.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Retrieves the generic method definition from the constructed method and compares it to the original definition.</source>
          <target state="translated">Recupera a definição de método genérico do método construído e a compara à definição original.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> does not represent a generic method definition.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> atual não representa uma definição de método genérico.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Ou seja, <ph id="ph1">&lt;see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /&gt;</ph> retorna <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Qualquer elemento de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters of the current generic method definition.</source>
          <target state="translated">O número de elementos em <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> não é igual ao número de parâmetros de tipo da definição de método genérico atual.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</source>
          <target state="translated">Um elemento de <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> não satisfaz as restrições especificadas para o parâmetro de tipo correspondente da definição de método genérico atual.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])">
          <source>This method is not supported.</source>
          <target state="translated">Não há suporte para o método.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Obtém um valor <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica que esse membro é um método.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a method.</source>
          <target state="translated">Um valor <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> que indica que esse membro é um método.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Esta propriedade substitui <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects — for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> only when a given member is a method.</source>
          <target state="translated">Portanto, quando você examinar um conjunto de <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objetos — por exemplo, a matriz retornada por <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph> — o <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> propriedade retorna <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType&gt;</ph> somente quando um determinado membro é um método.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>To get the <ph id="ph1">`MemberType`</ph> property, first get the class <ph id="ph2">`Type`</ph>.</source>
          <target state="translated">Para obter o <ph id="ph1">`MemberType`</ph> propriedade, primeiro obtenha a classe <ph id="ph2">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Do <ph id="ph1">`Type`</ph>, obter o <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`MemberType`</ph>.</source>
          <target state="translated">Do <ph id="ph1">`MethodInfo`</ph>, obter o <ph id="ph2">`MemberType`</ph>.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.MemberType">
          <source>The following example displays the type of the specified member.</source>
          <target state="translated">O exemplo a seguir exibe o tipo do membro especificado.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> são iguais.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The first object to compare.</source>
          <target state="translated">O primeiro objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>The second object to compare.</source>
          <target state="translated">O segundo objeto a ser comparado.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Indica se dois objetos <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> não são iguais.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="left" /&gt;</ph> não for igual a <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; caso contrário, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> que contém informações sobre o tipo de retorno do método, como se o tipo de retorno tem modificadores personalizados.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> object that contains information about the return type.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterInfo" /&gt;</ph> que contém informações sobre o tipo de retorno.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>Compiler designers can use the <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> object returned by this property to discover whether custom modifiers, such as <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, have been applied to the return type.</source>
          <target state="translated">Designers de compilador podem usar o <ph id="ph1">&lt;xref:System.Reflection.ParameterInfo&gt;</ph> objeto retornado por essa propriedade para descobrir se personalizado modificadores, como <ph id="ph2">&lt;xref:Microsoft.VisualC.IsConstModifier&gt;</ph>, foram aplicadas ao tipo de retorno.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnParameter">
          <source>This method is not implemented.</source>
          <target state="translated">Este método não está implementado.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>Gets the return type of this method.</source>
          <target state="translated">Obtém o tipo de retorno desse método.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The return type of this method.</source>
          <target state="translated">O tipo de retorno desse método.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>To get the return type property, first get the class <ph id="ph1">`Type`</ph>.</source>
          <target state="translated">Para obter a propriedade de tipo de retorno, primeiro obtenha a classe <ph id="ph1">`Type`</ph>.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`Type`</ph>, get the <ph id="ph2">`MethodInfo`</ph>.</source>
          <target state="translated">Do <ph id="ph1">`Type`</ph>, obter o <ph id="ph2">`MethodInfo`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>From the <ph id="ph1">`MethodInfo`</ph>, get the <ph id="ph2">`ReturnType`</ph>.</source>
          <target state="translated">Do <ph id="ph1">`MethodInfo`</ph>, obter o <ph id="ph2">`ReturnType`</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnType">
          <source>The following example displays the return type of the specified method.</source>
          <target state="translated">O exemplo a seguir exibe o tipo de retorno do método especificado.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>Gets the custom attributes for the return type.</source>
          <target state="translated">Obtém os atributos personalizados para o tipo de retorno.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes">
          <source>An <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> object representing the custom attributes for the return type.</source>
          <target state="translated">Um <ph id="ph1">&lt;see langword="ICustomAttributeProvider" /&gt;</ph> objeto que representa os atributos personalizados para o tipo de retorno.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Matriz passada de nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Contagem dos nomes a serem mapeados.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">O contexto de localidade no qual interpretar os nomes.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array that receives the IDs corresponding to the names.</source>
          <target state="translated">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>Provides access to the <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> method from COM.</source>
          <target state="translated">Dá acesso ao <ph id="ph1">&lt;see cref="M:System.Object.GetType" /&gt;</ph> método do COM.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> type.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> que representa o tipo <ph id="ph2">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">As informações de tipo a serem retornadas.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">O identificador de localidade das informações do tipo.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Receives a pointer to the requested type information object.</source>
          <target state="translated">Recebe um ponteiro para o objeto de informações de tipo solicitado.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can be used to get the type information for an interface.</source>
          <target state="translated">Recupera as informações de tipo para um objeto, que pode ser usado para obter as informações de tipo para uma interface.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Identifica o membro.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Reservado para uso futuro.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Deve ser IID_NULL.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">O contexto de localidade no qual interpretar argumentos.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Sinalizadores que descrevem o contexto da chamada.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ponteiro para o local onde o resultado deve ser armazenado.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ponteiro para uma estrutura que contém informações de exceção.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">O índice do primeiro argumento que tem um erro.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Fornece acesso a propriedades e métodos expostos por um objeto.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Para obter mais informações sobre <ph id="ph1">`IDispatch::Invoke`</ph>, consulte a Biblioteca MSDN.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Não há suporte para acesso com associação tardia usando a interface <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> COM.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>