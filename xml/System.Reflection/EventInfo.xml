<Type Name="EventInfo" FullName="System.Reflection.EventInfo">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e3a24d2627f509047bc37a4173ff4b025100dcff" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37473422" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class EventInfo : System.Reflection.MemberInfo, System.Runtime.InteropServices._EventInfo" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit EventInfo extends System.Reflection.MemberInfo implements class System.Runtime.InteropServices._EventInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.EventInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class EventInfo&#xA;Inherits MemberInfo&#xA;Implements _EventInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventInfo abstract : System::Reflection::MemberInfo, System::Runtime::InteropServices::_EventInfo" />
  <TypeSignature Language="F#" Value="type EventInfo = class&#xA;    inherit MemberInfo&#xA;    interface _EventInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._EventInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._EventInfo))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Descobre os atributos de um evento e fornece acesso aos metadados de evento.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Reflection.EventInfo> classe para inspecionar eventos e ligar manipuladores de eventos, conforme mostrado no código de exemplo para o <xref:System.Reflection.EventInfo.AddEventHandler%2A> método.  
  
> [!NOTE]
>  <xref:System.Reflection.EventInfo> não se destina a ser usado para gerar eventos. Um objeto gera eventos conforme determinado pelo seu estado interno.  
  
 Eventos são usados com delegados. Um ouvinte de eventos cria uma instância de um delegado de manipulador de eventos é invocado sempre que o evento é gerado por uma origem do evento. Para se conectar à origem do evento, o ouvinte de eventos adiciona esse delegado à lista de invocação na origem. Quando o evento é gerado, o método invoke do delegado de manipulador de eventos é chamado. Há suporte para ambas as notificações de eventos multicast e conversão de único. O `Add` e `Remove` métodos, bem como a classe de delegado do manipulador de eventos associado com um evento deve ser marcada nos metadados.  
  
 Os delegados são ponteiros de função orientada a objeto. Em C ou C++, um ponteiro de função é uma referência a um método. Em contraste com o ponteiro de função C ou C++, um delegado contém duas referências: uma referência a um método e uma referência a um objeto que suporta o método. Delegados podem invocar um método sem saber o tipo de classe que declara ou herda o método. Delegados só precisam saber a lista de tipo e o parâmetro de retorno do método.  
  
 O modelo de evento funciona igualmente bem para delegados multicast único e multicast. Quando o delegado de invocação do método é chamado, somente um único objeto terão um método chamado nela. Um modificador de multicast pode ser aplicado a uma declaração delegate, que permite que vários métodos ser chamado quando o método invoke do delegado é chamado.  
  
 Chamando <xref:System.Reflection.ICustomAttributeProvider.GetCustomAttributes%2A?displayProperty=nameWithType> na `EventInfo` quando o `inherit` parâmetro do `GetCustomAttributes` é `true` não percorrer a hierarquia de tipo. Use <xref:System.Attribute?displayProperty=nameWithType> herdar os atributos personalizados.  
  
   
  
## Examples  
 O código a seguir obtém um <xref:System.Reflection.EventInfo> do objeto para o <xref:System.Windows.Forms.Control.Click> evento do <xref:System.Windows.Forms.Button> classe.  
  
 [!code-cpp[type_getevent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[type_getevent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[type_getevent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser herdada pelo código parcialmente confiável.</permission>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <block subset="none" type="overrides">
      <para>Quando você herda <see langword="EventInfo" />, você deve substituir os seguintes membros: <see cref="M:System.Reflection.EventInfo.GetAddMethod(System.Boolean)" />, <see cref="M:System.Reflection.EventInfo.GetRemoveMethod(System.Boolean)" />, e <see cref="M:System.Reflection.EventInfo.GetRaiseMethod(System.Boolean)" />.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected EventInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; EventInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see langword="EventInfo" />.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="AddEventHandler">
      <MemberSignature Language="C#" Value="public virtual void AddEventHandler (object target, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddEventHandler(object target, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub AddEventHandler (target As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddEventHandler(System::Object ^ target, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddEventHandler : obj * Delegate -&gt; unit&#xA;override this.AddEventHandler : obj * Delegate -&gt; unit" Usage="eventInfo.AddEventHandler (target, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.AddEventHandler(System.Object,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="target">A fonte do evento.</param>
        <param name="handler">Encapsula um ou mais métodos a serem invocados quando o evento é gerado pelo destino.</param>
        <summary>Adiciona um manipulador de eventos à origem de um evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método tenta adicionar um delegado para sincronizar o evento no objeto de destino.  
  
 Cada vez que o evento é gerado pelo parâmetro de destino, o método ou métodos encapsulados pelo manipulador são invocados.  
  
Você pode usar o `AddEventHander` método quando você carrega um tipo depois que o programa já é compilado quando não é possível usar a sintaxe de + = em C# ou Visual Basic `WithEvents` e `Handles` palavras-chave para conectar o evento.   
  
## Examples  
 O exemplo a seguir cria uma instância da <xref:System.Timers.Timer?displayProperty=nameWithType> classe, cria um manipulador de eventos usando um assembly dinâmico e conecta-se o manipulador de eventos dinâmicos. Todas as ações são executadas usando a associação tardia.  
  
 O <xref:System.Timers.Timer> instância é armazenada em uma variável do tipo <xref:System.Object>e todo o código que acessa o <xref:System.Timers.Timer> faz então associação tardia. O exemplo usa o <xref:System.Type.GetEvent%2A?displayProperty=nameWithType> método para obter o <xref:System.Timers.Timer.Elapsed> evento e o <xref:System.Reflection.EventInfo.EventHandlerType%2A> propriedade para obter o tipo de delegado para o evento.  
  
 O exemplo obtém uma <xref:System.Reflection.MethodInfo> para o `Invoke` método do tipo de delegado e obtém a assinatura do delegado da <xref:System.Reflection.MethodInfo> instância. O exemplo cria um assembly dinâmico com um módulo que contém um único tipo denominado `Handler` e fornece o tipo de um `static` método (`Shared` método no Visual Basic) denominada `DynamicHandler` que manipula o evento.  
  
 Depois que o tipo dinâmico é criado, o exemplo obtém uma <xref:System.Reflection.MethodInfo> para o método concluído e o utiliza para criar uma instância de delegado. Esta instância é passada para o <xref:System.Reflection.EventInfo.AddEventHandler%2A> método para ligar o evento. O programa faz uma pausa, em seguida, para permitir que o evento a ser gerado.  
  
 [!code-csharp[AddEventHandler#1](~/samples/snippets/csharp/VS_Snippets_CLR/AddEventHandler/cs/source.cs)]
 [!code-vb[AddEventHandler#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AddEventHandler/vb/source.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O evento não tem um acessador <see langword="add" /> público.</exception>
        <exception cref="T:System.ArgumentException">O manipulador passado não pode ser usado.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> No <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicativos da Windows Store</see> ou na <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MemberAccessException" />.  </para>
          </block> O chamador não tem permissão de acesso ao membro.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para> No <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicativos da Windows Store</see> ou na <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de Classes Portátil</see>, capture <see cref="T:System.Exception" />.  </para>
          </block> O parâmetro <paramref name="target" /> é <see langword="null" /> e o evento não é estático.  -ou- A <see cref="T:System.Reflection.EventInfo" /> não está declarada no destino.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Delegate" />
        <altmember cref="T:System.EventHandler" />
      </Docs>
    </Member>
    <Member MemberName="AddMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo AddMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo AddMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.AddMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property AddMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ AddMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AddMethod : System.Reflection.MethodInfo" Usage="System.Reflection.EventInfo.AddMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see cref="T:System.Reflection.MethodInfo" /> para o método <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)" /> do evento, incluindo métodos não públicos.</summary>
        <value>Um objeto <see cref="T:System.Reflection.MethodInfo" /> para o método <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é equivalente a chamar o <xref:System.Reflection.EventInfo.GetAddMethod%2A> com um valor de `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.EventAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Attributes As EventAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::EventAttributes Attributes { System::Reflection::EventAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.EventAttributes" Usage="System.Reflection.EventInfo.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._EventInfo.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os atributos desse evento.</summary>
        <value>Os atributos somente leitura para este evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os atributos são retornados em um inteiro de 4 bytes que representa um bitmap dos atributos definidos para o evento refletido por esta instância.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="eventInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Um objeto a ser comparado com essa instância ou <see langword="null" />.</param>
        <summary>Retorna um valor que indica se essa instância é igual a um objeto especificado.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> for igual ao tipo e ao valor dessa instância, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EventHandlerType">
      <MemberSignature Language="C#" Value="public virtual Type EventHandlerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type EventHandlerType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.EventHandlerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventHandlerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ EventHandlerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventHandlerType : Type" Usage="System.Reflection.EventInfo.EventHandlerType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._EventInfo.EventHandlerType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see langword="Type" /> do delegado do manipulador de eventos subjacente associado a esse evento.</summary>
        <value>Um objeto <see langword="Type" /> somente leitura que representa o manipulador de eventos do delegado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa o <xref:System.Reflection.EventInfo.EventHandlerType%2A> para descobrir o tipo de delegado de um evento e exibir seus tipos de parâmetro de propriedade.  
  
 O exemplo define um delegado chamado `MyDelegate` e um evento denominado `ev` do tipo `MyDelegate`. O código a `Main` método descobre a assinatura de evento, fazendo com que o tipo de delegado do evento, obtendo o `Invoke` método do tipo de delegado e, em seguida, recuperando e exibindo os parâmetros.  
  
 [!code-cpp[eventarg#1](~/samples/snippets/cpp/VS_Snippets_CLR/EventArg/CPP/eventarg.cpp#1)]
 [!code-csharp[eventarg#1](~/samples/snippets/csharp/VS_Snippets_CLR/EventArg/CS/eventarg.cs#1)]
 [!code-vb[eventarg#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/EventArg/VB/eventarg.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.Delegate" />
        <altmember cref="T:System.EventHandler" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAddMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o método usado para adicionar um delegado de manipulador de eventos para a origem do evento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAddMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetAddMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetAddMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetAddMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAddMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetAddMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetAddMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetAddMethod : unit -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetAddMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetAddMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o método usado para adicionar um delegado de manipulador de eventos para a origem do evento.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.MethodInfo" /> representando o método usado para adicionar um delegado de manipulador de eventos para a origem do evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAddMethod` inicializa e adiciona o evento método subscribe. O `AddEventHandler` método é usado para adicionar um delegado de manipulador de eventos para a lista de invocação de uma origem do evento.  
  
   
  
## Examples  
 Normalmente, o método tem a seguinte assinatura:  
  
```  
add_<EventName>(<EventHandlerType> handler)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetAddMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetAddMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetAddMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetAddMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetAddMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetAddMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetAddMethod : bool -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetAddMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetAddMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" /> se métodos não públicos podem ser retornados; caso contrário, <see langword="false" />.</param>
        <summary>Quando substituído em uma classe derivada, recupera o objeto <see langword="MethodInfo" /> para o método <see cref="M:System.Reflection.EventInfo.AddEventHandler(System.Object,System.Delegate)" /> do evento, especificando se métodos não públicos devem ou não ser retornados.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.MethodInfo" /> representando o método usado para adicionar um delegado de manipulador de eventos para a origem do evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `GetAddMethod` inicializa e adiciona o evento inscrever-se o método como um valor booliano. O `AddEventHandler` método é usado para adicionar um delegado de manipulador de eventos para a lista de invocação de uma origem do evento.  
  
   
  
## Examples  
 Normalmente, o método tem a seguinte assinatura:  
  
```  
add_<EventName>(<EventHandlerType> handler)  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> é <see langword="true" />, o método usado para adicionar um delegado de manipulador de eventos é não público e o chamador não tem permissão para refletir nos métodos não públicos.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="eventInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash para essa instância.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetOtherMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna os métodos associados a um evento em MSIL usando a diretiva <see langword=".other" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetOtherMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetOtherMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetOtherMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetOtherMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOtherMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetOtherMethods();" />
      <MemberSignature Language="F#" Value="member this.GetOtherMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="eventInfo.GetOtherMethods " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna os métodos públicos que foram associados um evento em metadados usando a diretiva <see langword=".other" />.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> representando os métodos públicos que foram associados um evento em metadados usando a diretiva <see langword=".other" />. Se não há nenhum desses métodos públicos, uma matriz vazia é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os metadados para um evento podem associar a quatro tipos de métodos com o evento:  
  
-   O `.addon` diretiva especifica o método usado para adicionar manipuladores de eventos. Use o <xref:System.Reflection.EventInfo.GetAddMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.removeon` diretiva especifica o método usado para desanexar manipuladores de eventos. Use o <xref:System.Reflection.EventInfo.GetRemoveMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.fire` diretiva especifica o método usado para gerar o evento. Use o <xref:System.Reflection.EventInfo.GetRaiseMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.other` diretiva especifica quaisquer outros métodos associados ao evento. Use o <xref:System.Reflection.EventInfo.GetOtherMethods%2A> método para recuperar uma matriz de <xref:System.Reflection.EventInfo> objetos para esses métodos.  
  
 Os métodos associados a um evento usando o `.other` diretiva não ter nenhum significado especial para o tempo de execução. Os compiladores c# e Visual Basic não usam o `.other` diretiva.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetOtherMethods">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo[] GetOtherMethods (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetOtherMethods(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetOtherMethods(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetOtherMethods (nonPublic As Boolean) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetOtherMethods(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetOtherMethods : bool -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetOtherMethods : bool -&gt; System.Reflection.MethodInfo[]" Usage="eventInfo.GetOtherMethods nonPublic" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" /> para incluir os métodos não públicos; caso contrário, <see langword="false" />.</param>
        <summary>Retorna os métodos que foram associados ao evento nos metadados usando a diretiva <see langword=".other" />, especificando se métodos não públicos devem ou não ser incluídos.</summary>
        <returns>Uma matriz de objetos <see cref="T:System.Reflection.EventInfo" /> representando os métodos que foram associados um evento em metadados usando a diretiva <see langword=".other" />. Se não houver nenhum método que corresponda à especificação, uma matriz vazia será retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os metadados para um evento podem associar a quatro tipos de métodos com o evento:  
  
-   O `.addon` diretiva especifica o método usado para adicionar manipuladores de eventos. Use o <xref:System.Reflection.EventInfo.GetAddMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.removeon` diretiva especifica o método usado para desanexar manipuladores de eventos. Use o <xref:System.Reflection.EventInfo.GetRemoveMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.fire` diretiva especifica o método usado para gerar o evento. Use o <xref:System.Reflection.EventInfo.GetRaiseMethod%2A> método para recuperar um <xref:System.Reflection.EventInfo> para esse método.  
  
-   O `.other` diretiva especifica quaisquer outros métodos associados ao evento. Use o <xref:System.Reflection.EventInfo.GetOtherMethods%2A> método para recuperar uma matriz de <xref:System.Reflection.EventInfo> objetos para esses métodos.  
  
 Os métodos associados a um evento usando o `.other` diretiva não ter nenhum significado especial para o tempo de execução. Os compiladores c# e Visual Basic não usam o `.other` diretiva.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Este método não está implementado.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRaiseMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o método que é chamado quando o evento é acionado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRaiseMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetRaiseMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetRaiseMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetRaiseMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRaiseMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetRaiseMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetRaiseMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetRaiseMethod : unit -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetRaiseMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetRaiseMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o método que é chamado quando o evento é acionado.</summary>
        <returns>O método que é chamado quando o evento é acionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método normalmente retorna `null` eventos declarados com o c# `event` palavra-chave ou o Visual Basic `Event` palavra-chave. Isso ocorre porque os compiladores c# e Visual Basic não geram um método desse tipo por padrão.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetRaiseMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetRaiseMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetRaiseMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetRaiseMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetRaiseMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetRaiseMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetRaiseMethod : bool -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetRaiseMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetRaiseMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" /> se métodos não públicos podem ser retornados; caso contrário, <see langword="false" />.</param>
        <summary>Quando substituído em uma classe derivada, recupera o método chamado quando o evento é acionado, especificando se métodos não públicos devem ou não ser retornados.</summary>
        <returns>Um objeto <see langword="MethodInfo" /> foi chamado quando o evento foi acionado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método normalmente retorna `null` eventos declarados com o c# `event` palavra-chave ou o Visual Basic `Event` palavra-chave. Isso ocorre porque os compiladores c# e Visual Basic não geram um método desse tipo por padrão.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> é <see langword="true" />, o método usado para adicionar um delegado de manipulador de eventos é não público e o chamador não tem permissão para refletir nos métodos não públicos.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetRemoveMethod">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o método usado para remover um delegado de manipulador de eventos da origem do evento.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetRemoveMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetRemoveMethod ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetRemoveMethod() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetRemoveMethod" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemoveMethod () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetRemoveMethod();" />
      <MemberSignature Language="F#" Value="abstract member GetRemoveMethod : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetRemoveMethod : unit -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetRemoveMethod " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetRemoveMethod</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o método usado para remover um delegado de manipulador de eventos da origem do evento.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.MethodInfo" /> representando o método usado para remover um delegado de manipulador de eventos da origem do evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Normalmente, o método tem a seguinte assinatura:  
  
```  
remove_<EventName>(<EventHandlerType> handler)  
```  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetRemoveMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetRemoveMethod (bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetRemoveMethod(bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetRemoveMethod(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetRemoveMethod (nonPublic As Boolean) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetRemoveMethod(bool nonPublic);" />
      <MemberSignature Language="F#" Value="abstract member GetRemoveMethod : bool -&gt; System.Reflection.MethodInfo" Usage="eventInfo.GetRemoveMethod nonPublic" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetRemoveMethod(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="nonPublic">
          <see langword="true" /> se métodos não públicos podem ser retornados; caso contrário, <see langword="false" />.</param>
        <summary>Quando substituído em uma classe derivada, recupera o objeto <see langword="MethodInfo" /> para remover um método do evento, especificando se métodos não públicos devem ou não ser retornados.</summary>
        <returns>Um objeto <see cref="T:System.Reflection.MethodInfo" /> representando o método usado para remover um delegado de manipulador de eventos da origem do evento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Normalmente, o método tem a seguinte assinatura:  
  
```  
remove_<EventName>(<EventHandlerType> handler)  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MethodAccessException">
          <paramref name="nonPublic" /> é <see langword="true" />, o método usado para adicionar um delegado de manipulador de eventos é não público e o chamador não tem permissão para refletir nos métodos não públicos.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="eventInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMulticast">
      <MemberSignature Language="C#" Value="public virtual bool IsMulticast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMulticast" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.IsMulticast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsMulticast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsMulticast { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMulticast : bool" Usage="System.Reflection.EventInfo.IsMulticast" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._EventInfo.IsMulticast</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o evento é multicast.</summary>
        <value>
          <see langword="true" /> Se o delegado é uma instância de um delegado multicast; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException">O chamador não tem a permissão necessária.</exception>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.EventHandler" />
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Reflection.EventInfo.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._EventInfo.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see langword="EventInfo" /> tem um nome com um significado especial.</summary>
        <value>
          <see langword="true" /> Se esse evento possui um nome especial; Caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade determina se o nome do evento tem um significado especial. Os nomes que começam com ou contenham um caractere de sublinhado (_), os acessadores de propriedade e métodos de sobrecarga de operador são exemplos de nomes que podem exigir tratamento especial por alguns compiladores.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventAttributes" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.EventInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._EventInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor <see cref="T:System.Reflection.MemberTypes" /> que indica que esse membro é um evento.</summary>
        <value>Um <see cref="T:System.Reflection.MemberTypes" /> valor que indica que esse membro é um evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade substitui <xref:System.Reflection.MemberInfo.MemberType%2A>. Portanto, quando você examinar um conjunto de <xref:System.Reflection.MemberInfo> objetos — por exemplo, a matriz retornada por <xref:System.Type.GetMembers%2A> — a <xref:System.Reflection.MemberInfo.MemberType%2A> propriedade retorna <xref:System.Reflection.MemberTypes.Event?displayProperty=nameWithType> somente quando um determinado membro é um evento.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.EventInfo left, System.Reflection.EventInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.EventInfo left, class System.Reflection.EventInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.op_Equality(System.Reflection.EventInfo,System.Reflection.EventInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As EventInfo, right As EventInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::EventInfo ^ left, System::Reflection::EventInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.EventInfo * System.Reflection.EventInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.EventInfo" />
        <Parameter Name="right" Type="System.Reflection.EventInfo" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois objetos <see cref="T:System.Reflection.EventInfo" /> são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.EventInfo left, System.Reflection.EventInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.EventInfo left, class System.Reflection.EventInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.op_Inequality(System.Reflection.EventInfo,System.Reflection.EventInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As EventInfo, right As EventInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::EventInfo ^ left, System::Reflection::EventInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.EventInfo * System.Reflection.EventInfo -&gt; bool" Usage="System.Reflection.EventInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.EventInfo" />
        <Parameter Name="right" Type="System.Reflection.EventInfo" />
      </Parameters>
      <Docs>
        <param name="left">O primeiro objeto a ser comparado.</param>
        <param name="right">O segundo objeto a ser comparado.</param>
        <summary>Indica se dois objetos <see cref="T:System.Reflection.EventInfo" /> não são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="left" /> não for igual a <paramref name="right" />; caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo RaiseMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo RaiseMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.RaiseMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RaiseMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ RaiseMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RaiseMethod : System.Reflection.MethodInfo" Usage="System.Reflection.EventInfo.RaiseMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o método que é chamado quando o evento é acionado, incluindo métodos não públicos.</summary>
        <value>O método que é chamado quando o evento é acionado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é equivalente a chamar o <xref:System.Reflection.EventInfo.GetRaiseMethod%2A> com um valor de `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveEventHandler">
      <MemberSignature Language="C#" Value="public virtual void RemoveEventHandler (object target, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveEventHandler(object target, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.RemoveEventHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub RemoveEventHandler (target As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveEventHandler(System::Object ^ target, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveEventHandler : obj * Delegate -&gt; unit&#xA;override this.RemoveEventHandler : obj * Delegate -&gt; unit" Usage="eventInfo.RemoveEventHandler (target, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.RemoveEventHandler(System.Object,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="target">A fonte do evento.</param>
        <param name="handler">O delegado a ser desassociado dos eventos gerados pelo destino.</param>
        <summary>Remove um manipulador de eventos de uma origem de evento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método tenta remover o delegado que pode sincronizar esse evento no objeto de destino.  
  
 Quando um evento é acionado pelo destino, método ou métodos encapsulados por `handler` não será invocado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O evento não tem um acessador <see langword="remove" /> público.</exception>
        <exception cref="T:System.ArgumentException">O manipulador passado não pode ser usado.</exception>
        <exception cref="T:System.Reflection.TargetException">
          <block subset="none" type="note">
            <para> No <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicativos da Windows Store</see> ou na <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de Classes Portátil</see>, capture <see cref="T:System.Exception" />.  </para>
          </block> O parâmetro <paramref name="target" /> é <see langword="null" /> e o evento não é estático.  -ou- A <see cref="T:System.Reflection.EventInfo" /> não está declarada no destino.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para> No <see href="https://msdn.microsoft.com/library/windows/apps/br230232(v=vs.110).aspx">.NET para aplicativos da Windows Store</see> ou na <see href="~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md">Biblioteca de Classes Portátil</see>, capture a exceção de classe base, <see cref="T:System.MemberAccessException" />.  </para>
          </block> O chamador não tem permissão de acesso ao membro.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.Delegate" />
        <altmember cref="T:System.EventHandler" />
      </Docs>
    </Member>
    <Member MemberName="RemoveMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo RemoveMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo RemoveMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.EventInfo.RemoveMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property RemoveMethod As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ RemoveMethod { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoveMethod : System.Reflection.MethodInfo" Usage="System.Reflection.EventInfo.RemoveMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o objeto <see langword="MethodInfo" /> para remover um método do evento, incluindo métodos não públicos.</summary>
        <value>O <see langword="MethodInfo" /> objeto para remover um método do evento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é equivalente a chamar o <xref:System.Reflection.EventInfo.GetRemoveMethod%2A> com um valor de `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._EventInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _EventInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._EventInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.System#Runtime#InteropServices#_EventInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _EventInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._EventInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_EventInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="rgszNames">Matriz passada de nomes a serem mapeados.</param>
        <param name="cNames">Contagem dos nomes a serem mapeados.</param>
        <param name="lcid">O contexto de localidade no qual interpretar os nomes.</param>
        <param name="rgDispId">Matriz alocada pelo chamador que recebe os IDs correspondentes aos nomes.</param>
        <summary>Mapeia um conjunto de nomes para um conjunto correspondente de identificadores de expedição.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetIDsOfNames`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._EventInfo.GetType">
      <MemberSignature Language="C#" Value="Type _EventInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._EventInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.System#Runtime#InteropServices#_EventInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _EventInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._EventInfo.GetType() = System::Runtime::InteropServices::_EventInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um objeto <c>T:System.Type</c> representando o tipo <see cref="T:System.Reflection.EventInfo" />.</summary>
        <returns>Um objeto <c>T:System.Type</c> representando o tipo <see cref="T:System.Reflection.EventInfo" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._EventInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _EventInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._EventInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.System#Runtime#InteropServices#_EventInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _EventInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._EventInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_EventInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">As informações de tipo a serem retornadas.</param>
        <param name="lcid">O identificador de localidade das informações do tipo.</param>
        <param name="ppTInfo">Recebe um ponteiro para o objeto de informações de tipo solicitado.</param>
        <summary>Recupera as informações do tipo de um objeto, que podem ser usadas para obter informações de tipo para uma interface.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfo`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._EventInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _EventInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.System#Runtime#InteropServices#_EventInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _EventInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._EventInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_EventInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Aponta para um local que recebe o número de interfaces de informações de tipo fornecido pelo objeto.</param>
        <summary>Retorna o número de interfaces de informações do tipo que um objeto fornece (0 ou 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::GetTypeInfoCount`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._EventInfo.Invoke">
      <MemberSignature Language="C#" Value="void _EventInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._EventInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.EventInfo.System#Runtime#InteropServices#_EventInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _EventInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._EventInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_EventInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._EventInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Identifica o membro.</param>
        <param name="riid">Reservado para uso futuro. Deve ser IID_NULL.</param>
        <param name="lcid">O contexto de localidade no qual interpretar argumentos.</param>
        <param name="wFlags">Sinalizadores que descrevem o contexto da chamada.</param>
        <param name="pDispParams">Ponteiro para uma estrutura contendo uma matriz de argumentos, uma matriz de DISPIDs de argumento para argumentos nomeados e contagens para o número de elementos nas matrizes.</param>
        <param name="pVarResult">Ponteiro para o local onde o resultado deve ser armazenado.</param>
        <param name="pExcepInfo">Ponteiro para uma estrutura que contém informações de exceção.</param>
        <param name="puArgErr">O índice do primeiro argumento que tem um erro.</param>
        <summary>Fornece acesso a propriedades e métodos expostos por um objeto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método é para acesso a classes gerenciadas de código não gerenciado e não deve ser chamado em código gerenciado. Para obter mais informações sobre `IDispatch::Invoke`, consulte a Biblioteca MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Não há suporte para acesso com associação tardia usando a interface <c>IDispatch</c> COM.</exception>
      </Docs>
    </Member>
  </Members>
</Type>