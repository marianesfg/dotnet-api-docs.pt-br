<Type Name="WorkflowPersistenceService" FullName="System.Workflow.Runtime.Hosting.WorkflowPersistenceService">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6cbc9cd683f0346f1532afdb1709c1ce11dec398" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51935411" /></Metadata><TypeSignature Language="C#" Value="public abstract class WorkflowPersistenceService : System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit WorkflowPersistenceService extends System.Workflow.Runtime.Hosting.WorkflowRuntimeService" />
  <TypeSignature Language="DocId" Value="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WorkflowPersistenceService&#xA;Inherits WorkflowRuntimeService" />
  <TypeSignature Language="C++ CLI" Value="public ref class WorkflowPersistenceService abstract : System::Workflow::Runtime::Hosting::WorkflowRuntimeService" />
  <TypeSignature Language="F#" Value="type WorkflowPersistenceService = class&#xA;    inherit WorkflowRuntimeService" />
  <AssemblyInfo>
    <AssemblyName>System.Workflow.Runtime</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Workflow.Runtime.Hosting.WorkflowRuntimeService</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Obsolete("The System.Workflow.* types are deprecated.  Instead, please use the new types from System.Activities.*")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>A classe base abstrata da qual todos os serviços de persistência são derivados.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  [!INCLUDE[DeprecatedContent](~/includes/deprecatedcontent-md.md)]  
  
 Quando determinadas condições ocorrem enquanto o fluxo de trabalho está em execução, o mecanismo de tempo de execução do fluxo de trabalho persiste informações de estado sobre a instância de fluxo de trabalho. Persistência pode ocorrer, por exemplo, quando uma conclusão de transação atômica, quando a instância de fluxo de trabalho fica ociosa, quando o host chama <xref:System.Workflow.Runtime.WorkflowInstance.Unload%2A?displayProperty=nameWithType> na instância do fluxo de trabalho, ou quando uma instância de fluxo de trabalho seja finalizada ou termina. Quando a semântica de mecanismo de tempo de execução de fluxo de trabalho dita que a persistência deve ocorrer, o mecanismo de tempo de execução do fluxo de trabalho chama métodos que são fornecidos por um serviço de persistência para salvar as informações de estado sobre a instância de fluxo de trabalho. Da mesma forma, quando o mecanismo de tempo de execução do fluxo de trabalho precisa restaurar uma instância de fluxo de trabalho persistidas anteriormente, ele chama os métodos que são fornecidos pelo serviço de persistência para carregar essas informações de estado. O mecanismo de tempo de execução do fluxo de trabalho lida com toda a semântica de referentes a quando a persistência será executada. O serviço de persistência trata realmente salvar e carregar as informações de estado de fluxo de trabalho de ou para um armazenamento de dados.  
  
 Você pode criar um serviço de persistência derivando uma classe a partir de <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> classe.  Você pode adicionar o serviço de persistência para o mecanismo de tempo de execução do fluxo de trabalho chamando <xref:System.Workflow.Runtime.WorkflowRuntime.AddService%2A> ou fazendo uma entrada apropriada no arquivo de configuração do aplicativo. O <xref:System.Workflow.Runtime.WorkflowRuntime> deve conter apenas um serviço de persistência. Windows Workflow Foundation fornece o <xref:System.Workflow.Runtime.Hosting.SqlWorkflowPersistenceService> de classe, um serviço de persistência de out-of-box, que pode ser usado como está ou estender.  
  
 O mecanismo de tempo de execução do fluxo de trabalho tem semântica de bloqueio de informações de estado de fluxo de trabalho para uso em ambientes em que os serviços de persistência que são executados em diferentes processos talvez tenha acesso a um único repositório de dados. O <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService> classe fornece a capacidade de dar suporte a essa funcionalidade do mecanismo de tempo de execução do fluxo de trabalho, fornecendo um parâmetro para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> que especifica se as informações de estado de uma instância de fluxo de trabalho devem ser desbloqueadas no repositório de dados, e fornecendo um método <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> desbloquear anteriormente bloqueado informações de estado de fluxo de trabalho. Em um serviço de persistência que implementa o bloqueio, uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> deve bloquear as informações de estado para uma instância de fluxo de trabalho.  
  
 O serviço de persistência deve lançar uma <xref:System.Workflow.Runtime.Hosting.PersistenceException> se ele falhar ao salvar informações de estado em seu armazenamento de dados ou carregar informações de estado do seu repositório de dados. O mecanismo de tempo de execução do fluxo de trabalho espera que esse comportamento.  
  
 Um mecanismo de envio em lote é fornecido para serviços que usam um armazenamento durável para salvar as informações de estado de fluxo de trabalho. É importante para manter a consistência entre o armazenamento durável que é usado pelo serviço de persistência e o estado interno do mecanismo de tempo de execução de fluxo de trabalho nesses casos. Você pode adicionar funcionalidade definida pela <xref:System.Workflow.Runtime.IPendingWork> interface ao seu serviço e, em seguida, participar de lote de transações de fluxo de trabalho fornecida pelo <xref:System.Workflow.Runtime.Hosting.WorkflowCommitWorkBatchService> adicionando as alterações ao seu armazenamento de dados como itens de trabalho para o <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A>. O armazenamento durável propriamente dito deve implementar o <xref:System.Transactions.IEnlistmentNotification> interface, para que as informações de fluxo de trabalho não são persistidas incorretamente no caso de uma reversão de transação. Para obter mais informações, consulte <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity%2A> ou <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WorkflowPersistenceService ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WorkflowPersistenceService();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, inicializa uma nova instância da classe <see cref="T:System.Workflow.Runtime.Hosting.WorkflowPersistenceService" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como criar uma instância das `SqlWorkflowPersistenceService` classe (derivado de `WorkflowPersistenceService`). Este exemplo é do exemplo de SDK de manipuladores de exceção aninhados, da classe Program.cs.  Para obter mais informações, consulte o [exemplo de manipuladores de exceção aninhados](https://msdn.microsoft.com/library/d1da0209-842b-41c8-9b7c-0cbaa1034265).  
  
 [!code-csharp[WF_Samples#161](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets11.cs#161)]
 [!code-vb[WF_Samples#161](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets11.vb#161)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static byte[] GetDefaultSerializedForm (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig unsigned int8[] GetDefaultSerializedForm(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static cli::array &lt;System::Byte&gt; ^ GetDefaultSerializedForm(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="static member GetDefaultSerializedForm : System.Workflow.ComponentModel.Activity -&gt; byte[]" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetDefaultSerializedForm activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">O <see cref="T:System.Workflow.ComponentModel.Activity" /> cujo formato serializado é solicitado.</param>
        <summary>Recupera o formato padrão serializado da <see cref="T:System.Workflow.ComponentModel.Activity" />.</summary>
        <returns>O formato serializado padrão da <see cref="T:System.Workflow.ComponentModel.Activity" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetIsBlocked">
      <MemberSignature Language="C#" Value="protected internal static bool GetIsBlocked (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool GetIsBlocked(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetIsBlocked (rootActivity As Activity) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool GetIsBlocked(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetIsBlocked : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetIsBlocked rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Indica se a atividade fornecida está bloqueada.</summary>
        <returns><see langword="true" /> se a atividade fornecida estiver bloqueada, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetSuspendOrTerminateInfo">
      <MemberSignature Language="C#" Value="protected internal static string GetSuspendOrTerminateInfo (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig string GetSuspendOrTerminateInfo(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetSuspendOrTerminateInfo (rootActivity As Activity) As String" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::String ^ GetSuspendOrTerminateInfo(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetSuspendOrTerminateInfo : System.Workflow.ComponentModel.Activity -&gt; string" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetSuspendOrTerminateInfo rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Recupera as informações de término ou de suspensão da atividade fornecida.</summary>
        <returns>Uma <see cref="T:System.String" /> que contém informações de término ou de suspensão.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetWorkflowStatus">
      <MemberSignature Language="C#" Value="protected internal static System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig valuetype System.Workflow.Runtime.WorkflowStatus GetWorkflowStatus(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared Function GetWorkflowStatus (rootActivity As Activity) As WorkflowStatus" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static System::Workflow::Runtime::WorkflowStatus GetWorkflowStatus(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="static member GetWorkflowStatus : System.Workflow.ComponentModel.Activity -&gt; System.Workflow.Runtime.WorkflowStatus" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.Runtime.WorkflowStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Recupera o status do fluxo de trabalho.</summary>
        <returns>Um valor de enumeração de <see cref="T:System.Workflow.Runtime.WorkflowStatus" /> que indica o status do fluxo de trabalho.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadCompletedContextActivity (Guid scopeId, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadCompletedContextActivity(valuetype System.Guid scopeId, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity(System.Guid,System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadCompletedContextActivity (scopeId As Guid, outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadCompletedContextActivity(Guid scopeId, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="abstract member LoadCompletedContextActivity : Guid * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadCompletedContextActivity (scopeId, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scopeId" Type="System.Guid" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="scopeId">O <see cref="T:System.Guid" /> do escopo concluído.</param>
        <param name="outerActivity">Uma <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa a atividade que inclui o escopo concluído.</param>
        <summary>Quando implementada em uma classe derivada, carrega o escopo concluído especificado novamente na memória.</summary>
        <returns>Uma <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mecanismo de tempo de execução do fluxo de trabalho usa <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> para implementar a compensação. Você deve restaurar uma cópia idêntica do escopo concluído. Para fazer isso, você deve restaurar válido <xref:System.IO.Stream> em sua representação do escopo concluído nos dados de armazenamento. Em seguida, você deve passar isso <xref:System.IO.Stream> a um dos métodos sobrecarregados de <xref:System.Workflow.ComponentModel.Activity.Load%2A> para realizar a desserialização do escopo.  
  
 Se seu serviço de persistência não é possível carregar o escopo concluído de seu armazenamento de dados, ele deve gerar um <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem apropriada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `LoadCompletedContextActivity` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState (Guid instanceId);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Workflow.ComponentModel.Activity LoadWorkflowInstanceState(valuetype System.Guid instanceId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Function LoadWorkflowInstanceState (instanceId As Guid) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract System::Workflow::ComponentModel::Activity ^ LoadWorkflowInstanceState(Guid instanceId);" />
      <MemberSignature Language="F#" Value="abstract member LoadWorkflowInstanceState : Guid -&gt; System.Workflow.ComponentModel.Activity" Usage="workflowPersistenceService.LoadWorkflowInstanceState instanceId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="instanceId" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="instanceId">O <see cref="T:System.Guid" /> da atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Quando implementada em uma classe derivada, carrega o estado especificado da instância de fluxo de trabalho novamente na memória.</summary>
        <returns>Uma <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa a atividade raiz da instância do fluxo de trabalho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve restaurar uma cópia idêntica da atividade. Para fazer isso, você deve restaurar válida <xref:System.IO.Stream> de sua representação da instância do fluxo de trabalho no armazenamento de dados; em seguida, você deve passar isso <xref:System.IO.Stream> dentre sobrecarregado <xref:System.Workflow.ComponentModel.Activity.Load%2A> estado da instância de métodos para desserializar o fluxo de trabalho. Se seu serviço de persistência não é possível carregar o estado da instância de fluxo de trabalho de seu armazenamento de dados, ele deve gerar um <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem apropriada.  
  
 O mecanismo de tempo de execução do fluxo de trabalho implementa a semântica de bloqueio para restringir o acesso a um estado de instância de fluxo de trabalho é salvo em um armazenamento de dados. Isso pode ser acessado por serviços de persistência que são executados em vários processos. A semântica de bloqueio é projetada para impedir que os serviços de persistência que são executados em dois processos diferentes de carregar a mesma instância de fluxo de trabalho na memória ao mesmo tempo. Dependendo do tipo de ambiente que seu serviço de persistência foi projetado para dar suporte, você pode optar por dar suporte a essa funcionalidade. Se você optar por oferecer suporte a semântica de bloqueio de tempo de execução, e se esse fluxo de trabalho instância estado foi bloqueada anteriormente por outro processo, você deve lançar uma <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Caso contrário, você deve bloquear o acesso para o estado da instância de fluxo de trabalho no seu armazenamento de dados. O estado da instância de fluxo de trabalho pode ser desbloqueado por uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState%2A> ou uma chamada para <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> com o parâmetro de desbloqueio definido como `true`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `LoadWorkflowInstanceState` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#266](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#266)]
 [!code-vb[WF_Samples#266](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#266)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreFromDefaultSerializedForm">
      <MemberSignature Language="C#" Value="protected static System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm (byte[] activityBytes, System.Workflow.ComponentModel.Activity outerActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Workflow.ComponentModel.Activity RestoreFromDefaultSerializedForm(unsigned int8[] activityBytes, class System.Workflow.ComponentModel.Activity outerActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm(System.Byte[],System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function RestoreFromDefaultSerializedForm (activityBytes As Byte(), outerActivity As Activity) As Activity" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Workflow::ComponentModel::Activity ^ RestoreFromDefaultSerializedForm(cli::array &lt;System::Byte&gt; ^ activityBytes, System::Workflow::ComponentModel::Activity ^ outerActivity);" />
      <MemberSignature Language="F#" Value="static member RestoreFromDefaultSerializedForm : byte[] * System.Workflow.ComponentModel.Activity -&gt; System.Workflow.ComponentModel.Activity" Usage="System.Workflow.Runtime.Hosting.WorkflowPersistenceService.RestoreFromDefaultSerializedForm (activityBytes, outerActivity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Workflow.ComponentModel.Activity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activityBytes" Type="System.Byte[]" />
        <Parameter Name="outerActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activityBytes">O formato serializado da <see cref="T:System.Workflow.ComponentModel.Activity" />.</param>
        <param name="outerActivity">A <see cref="T:System.Workflow.ComponentModel.Activity" /> externa, que contém a <see cref="T:System.Workflow.ComponentModel.Activity" /> a ser restaurada.</param>
        <summary>Restaura a atividade <see cref="T:System.Workflow.ComponentModel.Activity" /> de sua forma serializada.</summary>
        <returns>A <see cref="T:System.Workflow.ComponentModel.Activity" /> restaurada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `RestoreFromDefaultSerializedForm` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#269](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#269)]
 [!code-vb[WF_Samples#269](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#269)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveCompletedContextActivity">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveCompletedContextActivity (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveCompletedContextActivity(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveCompletedContextActivity(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveCompletedContextActivity(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member SaveCompletedContextActivity : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.SaveCompletedContextActivity activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Uma <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</param>
        <summary>Quando implementada em uma classe derivada, salva o escopo concluído especificado em um armazenamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O mecanismo de tempo de execução do fluxo de trabalho salva o estado de atividades do escopo concluído para implementar a compensação. Você deve chamar uma das sobrecarregado <xref:System.Workflow.ComponentModel.Activity.Save%2A> métodos para serializar `activity` em um <xref:System.IO.Stream>; você pode optar por processar além do <xref:System.IO.Stream> antes de gravá-los no seu armazenamento de dados. No entanto, quando o mecanismo de tempo de execução do fluxo de trabalho chama <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A>, você deve restaurar uma cópia idêntica da atividade.  
  
 Você deve ser capaz de associar o escopo concluído com a instância de fluxo de trabalho delimitador para marcar o escopo como desnecessários no seu armazenamento de dados quando a instância de fluxo de trabalho é concluída ou é encerrado. Portanto, você também deve salvar o <xref:System.Guid> da instância do fluxo de trabalho que está associada com o escopo concluído; isso pode ser obtido a <xref:System.Workflow.Runtime.WorkflowInstance.InstanceId%2A> propriedade do <xref:System.Workflow.Runtime.WorkflowInstance> associado `activity`.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadCompletedContextActivity%2A> leva o <xref:System.Guid> do escopo concluído como um parâmetro. Portanto, você também deve salvar o <xref:System.Workflow.ComponentModel.ActivityExecutionContext.ContextGuid%2A> propriedade associada `activity`. Essa propriedade pode ser referenciada por meio de <xref:System.Workflow.ComponentModel.Activity.ActivityContextGuidProperty> campo de `activity`.  
  
 Se você estiver implementando um serviço de persistência que usa um armazenamento durável, para manter a consistência com o estado interno do mecanismo de tempo de execução de fluxo de trabalho, você deve participar de transações de fluxo de trabalho em lotes para adiar a gravação real no seu repositório durável até um ponto de confirmação de fluxo de trabalho. Para participar de envio em lote, adicione um item de trabalho para o <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> propriedade que representa as alterações pendentes no banco de dados e implementar o <xref:System.Workflow.Runtime.IPendingWork> interface em seu serviço de persistência.  
  
 Se você não pode salvar o escopo concluído para o armazenamento de dados, você deve lançar uma <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem de erro apropriada.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `SaveCompletedContextActivity` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#268](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#268)]
 [!code-vb[WF_Samples#268](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#268)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SaveWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void SaveWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity, bool unlock);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void SaveWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity, bool unlock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState(System.Workflow.ComponentModel.Activity,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub SaveWorkflowInstanceState (rootActivity As Activity, unlock As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void SaveWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity, bool unlock);" />
      <MemberSignature Language="F#" Value="abstract member SaveWorkflowInstanceState : System.Workflow.ComponentModel.Activity * bool -&gt; unit" Usage="workflowPersistenceService.SaveWorkflowInstanceState (rootActivity, unlock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
        <Parameter Name="unlock" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <param name="unlock"><see langword="true" /> se a instância de fluxo de trabalho não deve ser bloqueada; <see langword="false" /> se a instância de fluxo de trabalho deve ser bloqueada.</param>
        <summary>Quando implementado em uma classe derivada, salva o estado da instância de fluxo de trabalho em um armazenamento de dados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve chamar uma das sobrecarregado <xref:System.Workflow.ComponentModel.Activity.Save%2A> métodos para serializar `rootActivity` em um <xref:System.IO.Stream>. Você pode optar por processar adicionalmente o <xref:System.IO.Stream> antes de gravá-los no seu armazenamento de dados. No entanto, quando o mecanismo de tempo de execução do fluxo de trabalho chama <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A>, você deve restaurar uma cópia idêntica da atividade raiz. Se você não pode salvar o estado da instância de fluxo de trabalho em seu armazenamento de dados, você deve lançar uma <xref:System.Workflow.Runtime.Hosting.PersistenceException> com uma mensagem de erro apropriada.  
  
 O mecanismo de tempo de execução do fluxo de trabalho fornece a semântica de bloqueio para restringir o acesso a um estado de instância de fluxo de trabalho é salvo no repositório de dados. Isso pode ser acessado pelos serviços em execução em vários hosts e apontando para o mesmo armazenamento de dados de persistência. A semântica de bloqueio é projetada para impedir que os serviços de persistência que são executados em dois tempos de execução do fluxo de trabalho diferente de carregar a mesma instância de fluxo de trabalho na memória ao mesmo tempo. Dependendo do tipo de ambiente que seu serviço de persistência é projetado para dar suporte, você pode optar por dar suporte a essa funcionalidade. Se você optar por oferecer suporte a semântica de bloqueio de tempo de execução, então, se um serviço de persistência tenta salvar um estado de instância de fluxo de trabalho que foi bloqueado anteriormente por outro serviço de persistência, você deve lançar uma <xref:System.Workflow.Runtime.WorkflowOwnershipException>. Se `unlock` é `true`, você deve desbloquear o acesso para o estado da instância de fluxo de trabalho depois que você salvá-lo.  
  
 <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.LoadWorkflowInstanceState%2A> leva o <xref:System.Guid> da instância do fluxo de trabalho como um parâmetro. Portanto, você deve salvar isso <xref:System.Guid>. Você também pode usar isso <xref:System.Guid> para associar a instância de fluxo de trabalho com os estados salvos de seus escopos concluídos. Você deve fazer isso porque você deve poder marcar esses escopos concluídos como desnecessários quando a instância de fluxo de trabalho é concluída.  
  
 A mecanismo de tempo de execução de fluxo de trabalho chama <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> uma última vez em que a instância de fluxo de trabalho é concluída ou terminada. Portanto, se <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.GetWorkflowStatus%2A> é igual a <xref:System.Workflow.Runtime.WorkflowStatus.Completed> ou <xref:System.Workflow.Runtime.WorkflowStatus.Terminated>, você pode excluir com segurança a instância de fluxo de trabalho e todos os seus escopos concluídos associados de seu armazenamento de dados. Como alternativa, você pode se inscrever para o <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowCompleted> ou <xref:System.Workflow.Runtime.WorkflowRuntime.WorkflowTerminated> eventos para determinar quando é seguro excluir os registros associados com a instância de fluxo de trabalho. Se você realmente excluir os registros de seu armazenamento de dados depende de sua implementação.  
  
 Se você implementar um serviço de persistência que usa um armazenamento durável, então, para manter a consistência com o estado interno do mecanismo de tempo de execução de fluxo de trabalho, você deve participar de transações de fluxo de trabalho em lotes para adiar a gravação real no seu repositório durável até um ponto de confirmação de fluxo de trabalho. Para participar de envio em lote, adicione um item de trabalho que representa as alterações pendentes para o armazenamento durável para a <xref:System.Workflow.Runtime.WorkflowEnvironment.WorkBatch%2A> propriedade e implementar o <xref:System.Workflow.Runtime.IPendingWork> interface em seu serviço de persistência.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `SaveWorkflowInstanceState` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#264](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#264)]
 [!code-vb[WF_Samples#264](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#264)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnloadOnIdle">
      <MemberSignature Language="C#" Value="protected internal abstract bool UnloadOnIdle (System.Workflow.ComponentModel.Activity activity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool UnloadOnIdle(class System.Workflow.ComponentModel.Activity activity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnloadOnIdle(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract bool UnloadOnIdle(System::Workflow::ComponentModel::Activity ^ activity);" />
      <MemberSignature Language="F#" Value="abstract member UnloadOnIdle : System.Workflow.ComponentModel.Activity -&gt; bool" Usage="workflowPersistenceService.UnloadOnIdle activity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="activity">Uma <see cref="T:System.Workflow.ComponentModel.Activity" /> que representa o escopo concluído.</param>
        <summary>Determina se um fluxo de trabalho deve ser descarregado quando ocioso.</summary>
        <returns>Se <see langword="true" />, o mecanismo de tempo de execução de fluxo de trabalho descarrega o fluxo de trabalho especificado quando ele se torna ocioso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `UnloadOnIdle` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#270](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#270)]
 [!code-vb[WF_Samples#270](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#270)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnlockWorkflowInstanceState">
      <MemberSignature Language="C#" Value="protected internal abstract void UnlockWorkflowInstanceState (System.Workflow.ComponentModel.Activity rootActivity);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void UnlockWorkflowInstanceState(class System.Workflow.ComponentModel.Activity rootActivity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.UnlockWorkflowInstanceState(System.Workflow.ComponentModel.Activity)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend MustOverride Sub UnlockWorkflowInstanceState (rootActivity As Activity)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void UnlockWorkflowInstanceState(System::Workflow::ComponentModel::Activity ^ rootActivity);" />
      <MemberSignature Language="F#" Value="abstract member UnlockWorkflowInstanceState : System.Workflow.ComponentModel.Activity -&gt; unit" Usage="workflowPersistenceService.UnlockWorkflowInstanceState rootActivity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Workflow.Runtime</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rootActivity" Type="System.Workflow.ComponentModel.Activity" />
      </Parameters>
      <Docs>
        <param name="rootActivity">A atividade raiz da instância do fluxo de trabalho.</param>
        <summary>Quando substituído em uma classe derivada, desbloqueia o estado da instância de fluxo de trabalho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método é abstrato, portanto, ele não contém uma implementação padrão no bloqueio e desbloqueio.  
  
 Ao implementar um serviço de persistência personalizado, se você quiser implementar um esquema de bloqueio você precisará substituir esse método e fornecem um mecanismo de bloqueio de desbloqueio no <xref:System.Workflow.Runtime.Hosting.WorkflowPersistenceService.SaveWorkflowInstanceState%2A> método com base no valor do parâmetro unlock.  
  
   
  
## Examples  
 O exemplo a seguir demonstra uma implementação do `UnlockWorkflowInstanceState` método. Este exemplo é do exemplo de serviço de persistência personalizado, do arquivo FilePersistenceService.cs. Para obter mais informações, consulte [exemplo de serviço de persistência personalizado](https://msdn.microsoft.com/library/869dfadf-5298-4551-bc80-f4cf7918729d).  
  
 [!code-csharp[WF_Samples#267](~/samples/snippets/csharp/VS_Snippets_CFX/wf_samples/cs/snippets24.cs#267)]
 [!code-vb[WF_Samples#267](~/samples/snippets/visualbasic/VS_Snippets_CFX/wf_samples/vb/snippets24.vb#267)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>