<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb3cbdf16c699365dc1a2fa7cf6e6eb4d128a87b" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51891458" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>O módulo <see langword="FileSystem" /> contém os procedimentos usados para executar operações de arquivo, diretório ou pasta e sistema. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo do que usando o módulo <see langword="FileSystem" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este módulo oferece suporte a palavras-chave de linguagem Visual Basic e membros da biblioteca em tempo de execução que acessam arquivos e pastas.  
  
   
  
## Examples  
 Este exemplo usa o `GetAttr` função para determinar os atributos de um arquivo e diretório ou pasta.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">Resumo de diretórios e arquivos</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">Resumo de entrada e saída</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Palavras-chave (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Necessário. Uma expressão <see langword="String" /> que identifica qual diretório ou pasta se torna o novo diretório ou pasta padrão. <c>Path</c> pode incluir a unidade. Se nenhuma unidade for especificada, o <see langword="ChDir" /> alterará o diretório ou pasta padrão na unidade atual.</param>
        <summary>Altera o diretório ou pasta atual. O recurso <see langword="My" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="ChDir" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ChDir` função altera o diretório padrão, mas não a unidade padrão. Por exemplo, se a unidade padrão é C, a instrução a seguir altera o diretório padrão na unidade D, mas C permanece a unidade padrão:  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 Você pode tornar relativo alterações de diretório é, digitando dois pontos, da seguinte maneira:  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  O `ChDir` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e.  
  
   
  
## Examples  
 Este exemplo usa o `ChDir` função para alterar o diretório atual ou a pasta.  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> está vazio.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Uma unidade inválida foi especificada ou a unidade está indisponível.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">Como analisar demarcadores de arquivo no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">Criando, excluindo e movendo arquivos e diretórios no Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Altera a unidade atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Necessário. Expressão de cadeia de caracteres que especifica uma unidade existente. Se você fornecer uma cadeia de caracteres de tamanho zero (""), a unidade atual não será alterada. Se o argumento <c>Unidade</c> for uma cadeia de vários caracteres, <see langword="ChDrive" /> usará somente a primeira letra.</param>
        <summary>Altera a unidade atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ChDrive` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este exemplo usa o `ChDrive` função para alterar a unidade atual. A função gera uma exceção se a unidade não existe.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Uma unidade inválida foi especificada ou a unidade está indisponível.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">Necessário. Expressão de cadeia de caracteres que especifica uma unidade existente. Se você fornecer uma cadeia de caracteres de tamanho zero (""), a unidade atual não será alterada. Se o argumento <c>Unidade</c> for uma cadeia de vários caracteres, <see langword="ChDrive" /> usará somente a primeira letra.</param>
        <summary>Altera a unidade atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `ChDrive` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este exemplo usa o `ChDrive` função para alterar a unidade atual. A função gera uma exceção se a unidade não existe.  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Uma unidade inválida foi especificada ou a unidade está indisponível.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o caminho atual. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o caminho atual. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Uma cadeia de caracteres que representa o caminho atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo usa o `CurDir` função para retornar o caminho atual.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">Opcional. A expressão <see langword="Char" /> que especifica uma unidade existente. Se nenhuma unidade for especificada ou, se <c>Unidade</c> for uma cadeia de caracteres de tamanho zero (""), <see langword="CurDir" /> retornará o caminho da unidade atual.</param>
        <summary>Retorna uma cadeia de caracteres que representa o caminho atual. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</summary>
        <returns>Uma cadeia de caracteres que representa o caminho atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo usa o `CurDir` função para retornar o caminho atual.  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />. Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />. Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</summary>
        <returns>Uma cadeia de caracteres representando o nome de um arquivo, diretório ou pasta correspondente a um padrão especificado ou atributo de arquivo ou o rótulo de volume de uma unidade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Dir` função suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.  
  
 `VbVolume` Retorna o rótulo de volume para a unidade em vez de um nome de arquivo específico.  
  
 Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função. Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.  
  
> [!IMPORTANT]
>  Para ser executado corretamente, o `Dir` função requer que o <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 O `Attributes` valores de enumeração de argumento são da seguinte maneira:  
  
|Valor|Constante|Descrição|  
|-|-|-|  
|`Normal`|`vbnormal`|Padrão. Especifica os arquivos sem atributos.|  
|`ReadOnly`|`vbReadOnly`|Especifica arquivos somente leitura e também arquivos sem atributos.|  
|`Hidden`|`vbHidden`|Especifica arquivos ocultos e também arquivos sem atributos.|  
|`System`|`vbSystem`|Especifica os arquivos do sistema e arquivos sem atributos.|  
|`Volume`|`vbVolume`|Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado.|  
|`Directory`|`vbDirectory`|Especifica diretórios ou pastas e arquivos sem atributos.|  
|`Archive`|`vbArchive`|O arquivo foi alterado desde o último backup.|  
|`Alias`|`vbAlias`|O arquivo tem um nome diferente.|  
  
> [!NOTE]
>  Essas enumerações são especificadas pela linguagem Visual Basic e podem ser usadas em qualquer lugar em seu código em vez dos valores reais.  
  
   
  
## Examples  
 Este exemplo usa o `Dir` função para verificar se existem determinados arquivos e diretórios.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcional. Expressão de <see langword="String" /> que especifica um nome de arquivo, diretório ou pasta ou um rótulo de volume de unidade. Uma cadeia de caracteres de tamanho zero (<see langword="&quot;&quot;" />) será retornada se <c>PathName</c> não for encontrado.</param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">Opcional. Enumeração ou expressão numérica cujo valor especifica atributos de arquivo. Se omitido, <see langword="Dir" /> retorna arquivos que correspondem a <c>PathName</c>, mas não têm atributos.</param>
        <summary>Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />. Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</summary>
        <returns>Uma cadeia de caracteres representando o nome de um arquivo, diretório ou pasta correspondente a um padrão especificado ou atributo de arquivo ou o rótulo de volume de uma unidade.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Dir` função suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.  
  
 `VbVolume` Retorna o rótulo de volume para a unidade em vez de um nome de arquivo específico.  
  
 Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função. Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.  
  
> [!IMPORTANT]
>  Para ser executado corretamente, o `Dir` função requer que o <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
 O `Attributes` valores de enumeração de argumento são da seguinte maneira:  
  
|Valor|Constante|Descrição|  
|-|-|-|  
|`Normal`|`vbnormal`|Padrão. Especifica os arquivos que não têm atributos.|  
|`ReadOnly`|`vbReadOnly`|Especifica arquivos somente leitura, além dos arquivos que não têm atributos.|  
|`Hidden`|`vbHidden`|Especifica arquivos ocultos, além dos arquivos que não têm atributos.|  
|`System`|`vbSystem`|Especifica os arquivos do sistema, além dos arquivos que não têm atributos.|  
|`Volume`|`vbVolume`|Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado.|  
|`Directory`|`vbDirectory`|Especifica diretórios ou pastas, além dos arquivos que não têm atributos.|  
|`Archive`|`vbArchive`|O arquivo foi alterado desde o último backup.|  
|`Alias`|`vbAlias`|O arquivo tem um nome diferente.|  
  
> [!NOTE]
>  Essas enumerações são especificadas pela linguagem Visual Basic e podem ser usadas em qualquer lugar em seu código no lugar dos valores reais.  
  
   
  
## Examples  
 Este exemplo usa o `Dir` função para verificar se existem determinados arquivos e diretórios.  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Um <see langword="Integer" /> que contém qualquer número de arquivo válido.</param>
        <summary>Retorna um valor booliano <see langword="True" /> quando o final de um arquivo aberto para <see langword="Random" /> ou <see langword="Input" /> sequencial foi atingido.</summary>
        <returns>Retorna um valor booliano <see langword="True" /> quando o final de um arquivo aberto para <see langword="Random" /> ou <see langword="Input" /> sequencial foi atingido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `EOF` para evitar o erro gerado pela tentativa de obter entrada passou do final de um arquivo.  
  
 O `EOF` retornos de função `False` até o final do arquivo foi atingido. Com arquivos abertos para `Random` ou `Binary` acesso `EOF` retorna `False` até o último executado `FileGet` função não é possível ler um registro inteiro.  
  
 Com arquivos abertos para `Binary` acessar, uma tentativa de ler o arquivo usando o `Input` funcionando até `EOF` retorna `True` gera um erro. Use o `LOF` e `Loc` funções em vez de `EOF` ao ler arquivos binários com `Input`, ou use `Get` ao usar o `EOF` função. Com arquivos abertos para `Output`, `EOF` sempre retorna `True`.  
  
   
  
## Examples  
 Este exemplo usa o `EOF` função para detectar o final de um arquivo. Este exemplo supõe que `Testfile` é um arquivo de texto que contém várias linhas de texto.  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. <see langword="Integer" />. Qualquer número de arquivo válido.</param>
        <summary>Retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando a função <see langword="FileOpen" />. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="FileAttr" />. Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> para obter mais informações.</summary>
        <returns>Os seguintes valores de enumeração indicam o modo de acesso do arquivo: 
 <list type="table"><item><term> Valor 
 </term><description> Modo 
 </description></item><item><term> 1 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> 2 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> 4 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> 8 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> 32 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa função retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando o `FileOpen` função.  
  
   
  
## Examples  
 Este exemplo usa o `FileAttr` função para retornar o modo de arquivo de um arquivo aberto.  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">Opcional. Matriz de parâmetros de 0 ou mais canais que serão fechados.</param>
        <summary>Conclui a E/S (Entrada/Saída) para um arquivo aberto usando a função <see langword="FileOpen" />. <see langword="My" /> oferece maior produtividade e desempenho em operações de E/S de arquivo. Consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> para obter mais informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileClose` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [como: ler texto de arquivos com um StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [como: gravar texto em arquivos com um StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), e [passo a passo: Manipulando arquivos e diretórios em Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).  
  
 Se você omitir `FileNumbers`, todos os arquivos ativos abertos pelo `FileOpen` função são fechados.  
  
 Quando você fecha arquivos abertos para `Output` ou `Append`, o buffer final da saída é gravado no buffer de sistema operacional para esse arquivo. Todos os buffers espaço associado fechado arquivo seja liberado.  
  
 Quando o `FileClose` função é executada, a associação de um arquivo com seu arquivo número termina.  
  
   
  
## Examples  
 Este exemplo usa o `FileClose` função para fechar um arquivo aberto para `Input`.  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> não existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Instrução End</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">Instrução Stop (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">Necessário. A expressão <see langword="String" /> que especifica o nome do arquivo a ser copiado. <c>Source</c> pode incluir o diretório ou a pasta, e a unidade do arquivo de origem.</param>
        <param name="Destination">Necessário. A expressão <see langword="String" /> que especifica o nome do arquivo de destino. <c>Destination</c> pode incluir o diretório ou a pasta e a unidade do arquivo de destino.</param>
        <summary>Copia um arquivo. O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="FileCopy" />. Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> para obter mais informações.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você tentar usar o `FileCopy` de função em um arquivo aberto, ocorrerá um erro.  
  
 `FileCopy` requer confiança total para trabalhar na unidade local.  
  
   
  
## Examples  
 Este exemplo usa o `FileCopy` função para copiar um arquivo para outro. Para fins deste exemplo, suponha que `SrcFile` é um arquivo que contém dados.  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Source" /> ou <paramref name="Destination" /> é inválido ou não foi especificado.</exception>
        <exception cref="T:System.IO.IOException">O arquivo já está aberto.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Arquivo inexistente.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">Como criar uma cópia de um arquivo em um diretório diferente no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">Como criar uma cópia de um arquivo no mesmo diretório no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">Como copiar um diretório para outro diretório no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Necessário. Expressão <see langword="String" /> que especifica um nome de arquivo. <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</param>
        <summary>Retorna um valor <see langword="Date" /> que indica a data e hora em que ocorreu a gravação em um arquivo. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileDateTime" />. Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Retorna um valor <see langword="Date" /> que indica a data e hora em que um arquivo foi criado ou modificado pela última vez.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo usa o `FileDateTime` função para determinar a data e hora em que um arquivo foi criada ou modificado pela última vez. O formato de data e hora exibido se baseia nas configurações de localidade do sistema.  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="PathName" /> é inválido ou contém caracteres curinga.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de destino não existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o`FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado. Em seguida, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função,`FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o`FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <param name="StringIsFixedLength">Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o tamanho. O padrão é <see langword="False" />.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <param name="ArrayIsDynamic">Opcional. Aplica-se somente ao gravar uma matriz. Especifica se a matriz deve ser tratada como dinâmica e se é necessário um descritor de matriz que descreve o tamanho e limites da matriz.</param>
        <param name="StringIsFixedLength">Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o tamanho. O padrão é <see langword="False" />.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FileGet` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita. Se ele foi gravado com o descritor, você precisará ler o descritor. Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.  
  
     O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     218 bytes são distribuídos da seguinte maneira:  
  
    -   18 bytes para o descritor: (2 + 8 * 2)  
  
    -   200 bytes para os dados: (5 * 10 * 4).  
  
-   Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.  
  
-   `FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais. Isso inclui qualquer matrizes e seus descritores. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados. Nenhum descritor é lido.  
  
-   `FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
    > [!IMPORTANT]
    >  Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido no qual os dados são lidos.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</param>
        <summary>Lê dados de um arquivo aberto de disco em uma variável.  O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGetObject" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileGetObject` função é usada em vez de `FileGet` para evitar ambiguidades em tempo de compilação se tipo `Object` é retornado em vez de outro tipo, como `Integer`, `Long`, `Short`e assim por diante.  
  
 Se você pretende gravar o `Variant` tipo, `FileGetObject` é necessária. Em caso de dúvida, se você estiver usando um objeto para o segundo parâmetro, é sempre aconselhável que você use `FilePutObject` e `FileGetObject`.  
  
 `FileGetObject` só é válido em `Random` e `Binary` modo.  
  
 Dados lidos com `FileGetObject` geralmente são gravados com `FilePutObject`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, `FileGetObject` lê o registro ou byte após a última `FileGetObject` ou `FilePutObject` função (ou apontada pela última `Seek` função).  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGetObject` lê registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada precisamente, é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.  
  
-   Se a variável que está sendo lida é uma cadeia de caracteres, por padrão `FileGetObject` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres. Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo e ao ler um arquivo, o descritor de comprimento não é gravado. Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo lida é uma matriz e, em seguida, o comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: 2 + 8 * NumberOfDimensions.  
  
     Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco:  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     218 bytes são distribuídos da seguinte maneira: 18 bytes para o descritor (2 + 8 * 2) e 100 bytes para os dados (5 * 10 * 4).  
  
-   `FileGetObject` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos. No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePutObject`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: 2 + 8 * NumberOfDimensions. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais, incluindo qualquer matrizes e seus descritores. O <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe pode ser aplicada a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, todos os `Random` regras se aplicam, com as seguintes exceções:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FileGetObject` lê todas as variáveis do disco de forma contígua, ou seja, sem nenhum preenchimento entre registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGetObject` lê apenas os dados. Nenhum descritor é lido.  
  
 `FileGetObject` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento. O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
   
  
## Examples  
 O exemplo a seguir lê um registro em um arquivo de teste e, em seguida, irá recuperá-lo.  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Necessário. Expressão <see langword="String" /> que especifica um arquivo. <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</param>
        <summary>Retorna um valor <see langword="Long" /> que especifica o tamanho de um arquivo em bytes. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileLen" />. Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</summary>
        <returns>Valor <see langword="Long" /> que especifica o tamanho de um arquivo em bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o arquivo especificado estiver aberto quando o `FileLen` função é chamada, o valor retornado representa o tamanho do arquivo no momento em que ele foi aberto.  
  
> [!NOTE]
>  Para obter o tamanho atual de um arquivo aberto, use o `LOF` função.  
  
   
  
## Examples  
 Este exemplo usa o `FileLen` função para retornar o comprimento de um arquivo em bytes. Para fins deste exemplo, suponha que `TestFile` é um arquivo que contém alguns dados.  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Arquivo inexistente.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido. Use a função de <see langword="FreeFile" /> para obter o próximo número disponível de arquivo.</param>
        <param name="FileName">Necessário. Expressão <see langword="String" /> que especifica um nome de arquivo — pode incluir o diretório ou pasta, e unidade.</param>
        <param name="Mode">Necessário. Enumeração especificando o modo de arquivo: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> ou <see langword="Random" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenMode" />.</param>
        <param name="Access">Opcional. Enumeração especificando as operações permitidas no arquivo aberto: <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />. Assume o padrão de <see langword="ReadWrite" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</param>
        <param name="Share">Opcional. Enumeração especificando as operações não permitidas no arquivo aberto: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> ou <see langword="Lock Read Write" />. Assume o padrão de <see langword="Lock Read Write" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenShare" />.</param>
        <param name="RecordLength">Opcional. Número menor que ou igual a 32.767 (bytes). Para arquivos abertos para acesso aleatório, esse valor é o tamanho do registro. Para arquivos sequenciais, esse valor é o número de caracteres armazenados em buffer.</param>
        <summary>Abre um arquivo para entrada ou saída. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileOpen" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FileOpen` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Você deve abrir um arquivo antes de qualquer operação de e/s pode ser executada nele. `FileOpen` aloca um buffer de e/s para o arquivo e determina o modo de acesso para usar com o buffer.  
  
> [!IMPORTANT]
>  Ao gravar em um arquivo, um aplicativo pode ter que criar um arquivo, se não existir o arquivo ao qual ele está tentando gravar. Para fazer isso, ele precisa de permissão para o diretório no qual o arquivo deve ser criado. No entanto, se o arquivo especificado por `FileName` existir, o aplicativo precisa `Write` permissão somente para o arquivo propriamente dito. Sempre que possível, para ajudar a melhorar a segurança, criar o arquivo durante a implantação e grant `Write` permissão a esse arquivo único, em vez de para todo o diretório. Para ajudar a aprimorar a segurança, gravar dados em diretórios de usuário em vez de para o diretório raiz ou o diretório de arquivos de programas.  
  
 Para abrir o canal pode ser encontrado usando o `FreeFile()` função.  
  
> [!IMPORTANT]
>  O `FileOpen` função requer `Read` acessar a partir de `FileIOPermissionAccess` enumeração, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
   
  
## Examples  
 Este exemplo ilustra vários usos do `FileOpen` função para habilitar a entrada e saída para um arquivo.  
  
 O código a seguir abre o arquivo `TestFile` em `Input` modo.  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 Este exemplo abre o arquivo no `Binary` modo para gravar somente operações.  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 O exemplo a seguir abre o arquivo no `Random` modo. O arquivo contiver registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 Este exemplo de código abre o arquivo no `Output` modo; qualquer possível de processo de leitura ou gravação em um arquivo.  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 Este exemplo de código abre o arquivo no `Binary` modo para leitura; outros processos não é possível ler o arquivo.  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">tamanho do registro é negativo (e não é igual a -1).</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileName" /> já está aberto ou <paramref name="FileName" /> é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o`VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na`RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <param name="StringIsFixedLength">Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se um descritor de comprimento de cadeia de caracteres de dois bytes da cadeia de caracteres deve ou não ser gravado no arquivo. O padrão é <see langword="False" />.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <param name="ArrayIsDynamic">Opcional. Aplica-se somente ao gravar uma matriz. Especifica se a matriz deve ou não ser tratada como dinâmica e se um descritor de matriz deve ou não ser gravado na cadeia de caracteres que descreve o comprimento.</param>
        <param name="StringIsFixedLength">Opcional. Aplica-se somente ao gravar uma cadeia de caracteres. Especifica se um descritor de comprimento de cadeia de caracteres de dois bytes da cadeia de caracteres deve ou não ser gravado no arquivo. O padrão é <see langword="False" />.</param>
        <summary>Grava dados de uma variável em um arquivo de disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `FilePut` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePut` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.  
  
-   Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável. Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz. O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores. O padrão do Visual Basic 2005 é não gravar o descritor. Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`. Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions). O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável. O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.  
  
-   `FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos. O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.  
  
    > [!NOTE]
    >  Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções. As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
-   Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados. Nenhum descritor é escrito.  
  
-   `FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento. O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres. Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `FilePut` função para gravar dados em um arquivo. Cinco registros da estrutura `Person` são gravados no arquivo.  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</exception>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. Nome de variável válido que contém dados gravados em disco.</param>
        <param name="RecordNumber">Opcional. Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</param>
        <summary>Grava dados de uma variável em um arquivo de disco.  O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePutObject" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `FilePutObject` função é usada em vez de `FilePut` para evitar ambiguidades em tempo de compilação se tipo `Object` é passado em vez de outro tipo, como `Integer`, `Long`, `Short`e assim por diante.  
  
 `FilePutObject` gravações e leituras de descritores que descrevem o objeto. Se você pretende gravar o `Variant` tipo, `FilePutObject` é necessária. Em caso de dúvida, se você estiver usando um objeto para o segundo parâmetro, é recomendável que você sempre use `FilePutObject` e `FileGetObject`.  
  
 `FilePutObject` só é válido em `Random` e `Binary` modo.  
  
 Dados gravados com `FilePutObject` costumam ser lidos a partir de um arquivo usando `FileGetObject`.  
  
 O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante. Se você omitir `RecordNumber`, `FilePutObject` grava o próximo registro ou byte após a última `FileGetObject` ou `FilePutObject` função (ou o registro ou byte apontado pela última `Seek` função).  
  
 O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo. `FilePutObject` não grava o descritor do tamanho quando o argumento é `True`. Se você usar `StringIsFixedLength`  =  `True` com `FilePutObject`, você precisa fazer o mesmo com `FileGetObject`, e você deve também Certifique-se de que a cadeia de caracteres é inicializada com o tamanho esperado.  
  
## <a name="random-mode"></a>Modo aleatório  
 Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:  
  
-   Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePutObject` grava registros subsequentes em limites de comprimento de registro. O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo. Como a quantidade de dados de preenchimento não pode ser determinada precisamente, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados. Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.  
  
-   Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePutObject` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável. Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePutObject` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.  
  
-   Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePutObject` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres. O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes. Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.  
  
-   Se a variável que está sendo gravada seja uma matriz e, em seguida, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz. O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação. Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 * NumberOfDimensions).  
  
## <a name="binary-mode"></a>Modo binário  
 Para arquivos abertos no `Binary` modo, todos os o `Random` aplicarem regras de modo, exceto:  
  
-   A cláusula `RecordLength` na função de `FileOpen` não está em vigor. `FilePutObject` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.  
  
   
  
## Examples  
 Este exemplo usa o `FilePutObject` função para gravar uma cadeia de caracteres em um arquivo.  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="RecordWidth">Necessário. Expressão numérica no intervalo 0 a 255, inclusive, que indica quantos caracteres são exibidos em uma linha antes de uma nova linha ser iniciada. Se <c>RecordWidth</c> for igual a 0, não haverá nenhum limite para o tamanho de uma linha. O valor padrão de <c>RecordWidth</c> é 0.</param>
        <summary>Atribui uma largura de linha de saída a um arquivo aberto usando a função <see langword="FileOpen" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Este exemplo usa o `FileWidth` função para definir a largura da linha de saída para um arquivo.  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um valor <see langword="Integer" /> que representa o próximo número de arquivo disponível para uso pela função <see langword="FileOpen" />.</summary>
        <returns>Retorna um valor <see langword="Integer" /> que representa o próximo número de arquivo disponível para uso pela função <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use `FreeFile` para fornecer um número de arquivo que já não está sendo usado.  
  
   
  
## Examples  
 Este exemplo usa o `FreeFile` função para retornar o próximo número de arquivos disponíveis. Cinco arquivos são abertos para saída dentro do loop, e alguns dados de exemplo são gravados para cada um.  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Mais de 255 arquivos estão em uso.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Necessário. A expressão <see langword="String" /> que especifica um nome de arquivo, diretório ou pasta. <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</param>
        <summary>Retorna um valor <see langword="FileAttribute" /> que representa os atributos de um arquivo, diretório ou pasta. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileAttribute" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>O valor retornado por <see langword="GetAttr" /> é a soma dos seguintes valores de enumeração: 
 <list type="table"><item><term> Valor 
 </term><description> Constante 
 </description><description> Descrição 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> Normal.  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> Somente leitura.  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> Oculto.  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> Arquivo do sistema.  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> Diretório ou pasta.  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> O arquivo foi alterado desde o último backup.  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> O arquivo tem um nome diferente.  
  
 </description></item></list><block subset="none" type="note"><para>  
 Essas enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser usados em qualquer lugar no seu código em vez dos valores reais.  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para determinar quais atributos estão definidos, use o `And` operador para executar uma comparação bit a bit do valor retornado pelo `GetAttr` função e o valor do atributo de arquivo individual desejado. Se o resultado não for zero, esse atributo é definido para o arquivo nomeado. Por exemplo, o valor de retorno dos seguintes `And` expressão for zero, se o `Archive` atributo não for definido:  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 Um valor diferente de zero será retornado se o `Archive` atributo é definido.  
  
   
  
## Examples  
 Este exemplo usa o `GetAttr` função para determinar os atributos de um arquivo e diretório ou pasta.  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="Pathname" /> é inválido ou contém caracteres curinga.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo de destino não existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">Operador And (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo supõe que `TestFile` é um arquivo que tem algumas linhas de dados gravados nele usando o `Write` funcionar, cada linha que contém uma cadeia de caracteres entre aspas e um número separado por uma vírgula, por exemplo: ("Olá", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo supõe que `TestFile` é um arquivo que tem algumas linhas de dados gravados nele usando o `Write` funcionar, cada linha que contém uma cadeia de caracteres entre aspas e um número separado por uma vírgula, por exemplo: ("Olá", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, como a vírgula é tratada como um separador variável, em vez de como um ponto decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Value">Necessário. A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</param>
        <summary>Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.  
  
 Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação. A tabela a seguir ilustra como outros dados de entrada são tratados.  
  
|Dados|Valor atribuído à variável|  
|-|-|  
|Delimitador de vírgula ou linha em branco|Vazio|  
|NULL # #|`DBNull`|  
|# TRUE ou FALSE de # #|`True` ou `False`|  
|#`yyyy-mm-dd hh:mm:ss`#|A data e/ou hora representada pela expressão|  
|#ERROR `errornumber`#|`errornumber` (a variável é um objeto marcado como um erro)|  
  
 Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.  
  
> [!NOTE]
>  O `Input` função não está localizada. Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis. Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="CharCount">Necessário. Qualquer expressão numérica válida que especifica o número de caracteres a serem lidos.</param>
        <summary>Retorna o valor <see langword="String" /> que contém caracteres de um arquivo aberto no modo <see langword="Input" /> ou <see langword="Binary" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="InputString" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Retorna o valor <see langword="String" /> que contém caracteres de um arquivo aberto no modo <see langword="Input" /> ou <see langword="Binary" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="InputString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `InputString` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com o `InputString` função geralmente é gravada em um arquivo usando `Print` ou `FilePut`. Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.  
  
 Ao contrário do `Input` função, o `InputString` função retorna todos os caracteres que ele lê. Isso inclui vírgulas, retornos de carro, alimentação de linha, as aspas e espaços à esquerda.  
  
 Com arquivos abertos para `Binary` acessar, uma tentativa de ler o arquivo usando o `InputString` funcionando até `EOF` retorna `True` gera um erro. Use o `LOF` e `Loc` funções em vez de `EOF` quando você ler arquivos binários usando `InputString`, ou use `FileGet` quando você usa o `EOF` função.  
  
> [!NOTE]
>  Ao ler de arquivos, não tome decisões de segurança sobre o conteúdo do arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
   
  
## Examples  
 Este exemplo usa o `InputString` função para ler um caractere por vez de um arquivo e imprimi-lo para o `Output` janela. Este exemplo supõe que `MyFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> não existe.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="CharCount" /> &lt; 0 ou &gt; 214.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Necessário. Expressão <see langword="String" /> que especifica um ou mais nomes de arquivo a serem excluídos. <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</param>
        <summary>Exclui arquivos de um disco. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Kill" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Kill` suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.  
  
 **Observação de segurança** para executar, o `Kill` função requer `Read` e `PathDiscovery` sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução. Para obter mais informações, consulte <xref:System.Security.SecurityException> [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)  
  
   
  
## Examples  
 Este exemplo usa o `Kill` função para excluir um arquivo de um disco.  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Arquivos de destino abertos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Arquivos de destino não encontrados.</exception>
        <exception cref="T:System.Security.SecurityException">Permissão negada.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <summary>Lê uma única linha de um arquivo sequencial aberto e a atribui a uma variável <see langword="String" />.</summary>
        <returns>Lê uma única linha de um arquivo sequencial aberto e a atribui a uma variável <see langword="String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `LineInput` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Dados lidos com `LineInput` costumam ser gravados em um arquivo usando-se `Print`.  
  
> [!IMPORTANT]
>  Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo. Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.  
  
 O `LineInput` função lê a partir de um caractere de um arquivo por vez até encontrar um retorno de carro (`Chr(13)`) ou retorno/alimentação de linha de carro (`Chr(13) + Chr(10)`) sequência. Sequências de feed de linha/retorno de carro são ignoradas em vez de acrescentado à cadeia de caracteres.  
  
> [!IMPORTANT]
>  Leitura de um arquivo usando o `LineInput` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.  
  
   
  
## Examples  
 Este exemplo usa o `LineInput` função ler uma linha de um arquivo sequencial e atribuí-lo a uma variável. Este exemplo supõe que `TestFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">Fim do arquivo atingido.</exception>
        <exception cref="T:System.IO.IOException">
          <paramref name="FileNumber" /> não existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo <see langword="Integer" /> válido.</param>
        <summary>Retorna um <see langword="Long" /> valor que especifica a posição de leitura/gravação atual em um arquivo aberto.</summary>
        <returns>Retorna um <see langword="Long" /> valor que especifica a posição de leitura/gravação atual em um arquivo aberto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Loc` função é baseado em zero; usá-lo para recuperar o primeiro byte em um arquivo, retornará 0.  
  
 O `Loc` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 O exemplo a seguir descreve o valor de retorno para cada modo de acesso do arquivo:  
  
|Modo|Valor retornado|  
|-|-|  
|`Random`|Número do último registro lido ou gravado no arquivo.|  
|`Sequential`|Posição atual do byte no arquivo dividida por 128. No entanto, a informações retornadas pelo `Loc` para arquivos sequenciais não é usada nem necessário.|  
|`Binary`|Posição do último byte lido ou gravado.|  
  
   
  
## Examples  
 Este exemplo usa o `Loc` função para retornar a posição de leitura/gravação atual em um arquivo aberto. Este exemplo supõe que `MyFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Record">Opcional. Número do único registro ou byte a ser bloqueado ou desbloqueado</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="FromRecord">Opcional. Número do primeiro registro ou byte a ser bloqueado ou desbloqueado.</param>
        <param name="ToRecord">Opcional. Número do último registro ou byte a ser bloqueado ou desbloqueado.</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Um <see langword="Integer" /> que contém um número de arquivo válido.</param>
        <summary>Retorna um <see langword="Long" /> que representa o tamanho, em bytes, de um arquivo aberto usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="LOF" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Retorna um <see langword="Long" /> que representa o tamanho, em bytes, de um arquivo aberto usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="LOF" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o `FileLen` função para obter o comprimento de um arquivo que não está aberto.  
  
   
  
## Examples  
 Este exemplo usa o `LOF` função para determinar o tamanho de um arquivo aberto. Este exemplo supõe que `TestFile` é um arquivo de texto que contém dados de exemplo.  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Necessário. Expressão <see langword="String" /> que identifica o diretório a ser criado. O <c>Caminho</c> pode incluir a unidade. Se nenhuma unidade for especificada, <see langword="MkDir" /> criará um novo diretório na unidade atual.</param>
        <summary>Cria um novo diretório. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="MkDir" />. Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa função cria um novo diretório.  
  
   
  
## Examples  
 Este exemplo usa o `MkDir` função para criar um diretório. Se a unidade não for especificada, o novo diretório é criado na unidade atual.  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> não foi especificado ou está vazio.</exception>
        <exception cref="T:System.Security.SecurityException">Permissão negada.</exception>
        <exception cref="T:System.IO.IOException">O diretório já existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">Como criar um diretório no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Output">Opcional. Zero ou mais expressões delimitadas por vírgula a serem gravadas em um arquivo.  
  
As configurações do argumento <c>Saída</c> são: 
 <see langword="T:System.IO.IOException" />: o modo de arquivo é inválido.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> não existe.</param>
        <summary>Grava dados formatados para exibição em um arquivo sequencial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` não inclui uma alimentação de linha no final de uma linha; No entanto, `PrintLine` incluem uma alimentação de linha.  
  
 Dados gravados com `Print` costumam ser lidos de um arquivo usando `LineInput` ou `Input`.  
  
 Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída. Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.  
  
 Para `Boolean` dados, seja `True` ou `False` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.  
  
 Dados de data são gravados no arquivo usando o formato de data abreviada padrão reconhecido pelo seu sistema. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.  
  
 Nada será gravado no arquivo se `Output` dados estão vazios. No entanto, se `Output` dados de lista estão `DBNull`, `Null` é gravada no arquivo.  
  
 Para `Error` dados, a saída é exibida como `Error errorcode`. O `Error` palavra-chave não será convertido, independentemente da localidade.  
  
 Todos os dados gravados no arquivo usando `Print` internacionalmente reconhece; ou seja, os dados são formatados corretamente usando o separador decimal apropriado. Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.  
  
 Gravando em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Print` e `PrintLine` funções para gravar dados em um arquivo.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Output">Opcional. Zero ou mais expressões delimitadas por vírgula a serem gravadas em um arquivo.  
  
As configurações do argumento <c>Saída</c> são: 
 <see langword="T:System.IO.IOException" />: o modo de arquivo é inválido.  
  
 <see langword="T:System.IO.IOException" />: <c>FileNumber</c> não existe.</param>
        <summary>Grava dados formatados para exibição em um arquivo sequencial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 `Print` não inclui uma alimentação de linha no final de uma linha; No entanto,`PrintLine` incluem uma alimentação de linha.  
  
 Dados gravados com `Print` costumam ser lidos de um arquivo usando `LineInput` ou `Input`.  
  
 Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída. Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.  
  
 Para `Boolean` dados, seja `True` ou `False` é impresso. O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.  
  
 Dados de data são gravados no arquivo usando o formato de data abreviada padrão reconhecido pelo sistema. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.  
  
 Nada será gravado no arquivo se `Output` dados estão vazios. No entanto, se `Output` dados de lista estão `DBNull`, `Null` é gravada no arquivo.  
  
 Para `Error` dados, a saída é exibida como `Error errorcode`. O `Error` palavra-chave não será convertido, independentemente da localidade.  
  
 Todos os dados gravados no arquivo usando `Print` internacionalmente reconhece; ou seja, os dados são formatados corretamente usando o separador decimal apropriado. Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.  
  
 Gravando em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Print` e `PrintLine` funções para gravar dados em um arquivo.  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">Necessário. <see langword="String" /> expressão que especifica o local e o nome do arquivo existente. <c>OldPath</c> pode incluir o diretório e a unidade do arquivo.</param>
        <param name="NewPath">Necessário. <see langword="String" /> expressão que especifica o local e o nome do novo arquivo. <c>NewPath</c> pode incluir o diretório e a unidade do local de destino. O nome do arquivo especificado por <c>NewPath</c> não pode já existir.</param>
        <summary>Renomeia um arquivo de disco ou um diretório. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Rename" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O`Rename` função renomeia um arquivo e a move para um diretório diferente, se necessário. O `Rename` função pode mover um arquivo em unidades, mas ele só pode renomear um diretório existente quando ambos `NewPath` e `OldPath` estão localizados na mesma unidade. `Rename` não é possível criar um novo arquivo ou diretório.  
  
 Usando o `Rename` função em um arquivo aberto produz um erro. Você deve fechar um arquivo aberto antes de renomeá-lo. `Rename` argumentos não podem incluir caracteres curinga de caractere único (?) e de vários caracteres (*).  
  
> [!IMPORTANT]
>  Ao usar `Rename` para copiar um arquivo de um local desprotegido para um local protegido, o arquivo manterá os direitos menos restritos. Verifique se você não está apresentando um possível risco à segurança.  
  
   
  
## Examples  
 Este exemplo usa o `Rename` função para renomear um arquivo. Para fins deste exemplo, suponha que os diretórios que são especificados já existem.  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Caminho inválido.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo <paramref name="OldPath" /> não existe.</exception>
        <exception cref="T:System.IO.IOException">Não é possível renomear com outro dispositivo.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">Como renomear um arquivo no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha todos os arquivos de disco abertos usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Reset" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Reset` função fecha todos os arquivos ativos abertos pela `FileOpen` de função e tem a mesma função que `FileClose()` sem parâmetros.  
  
   
  
## Examples  
 Este exemplo usa o `Reset` função para fechar todos os arquivos abertos e gravar o conteúdo de todos os buffers de arquivo em disco. Observe o uso do `Object` variável `FileNumber` como uma cadeia de caracteres e um número.  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">Instrução End</related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">Necessário. <see langword="String" /> expressão que identifica o diretório ou a pasta a ser removida. <c>Path</c> pode incluir a unidade. Se nenhuma unidade for especificada, <see langword="RmDir" /> removerá o diretório na unidade atual.</param>
        <summary>Remove um diretório existente. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="RmDir" />. Para obter mais informações, consulte <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ocorrerá um erro se você tentar usar `RmDir` em um diretório que contém os arquivos. Use o `Kill` função para excluir todos os arquivos antes de tentar remover um diretório.  
  
   
  
## Examples  
 Este exemplo usa o `RmDir` function para remover um diretório existente.  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="Path" /> não foi especificado ou está vazio.</exception>
        <exception cref="T:System.IO.IOException">O diretório de destino contém arquivos.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O diretório não existe.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Um <see langword="Integer" /> que contém um número de arquivo válido.</param>
        <summary>Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <returns>Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.  
  
 O exemplo a seguir descreve os valores retornados para cada modo de acesso do arquivo:  
  
|Modo|Valor de Retorno|  
|-|-|  
|`Random`|Número do próximo registro lido ou gravado|  
|`Binary`, `Input`, `Output`, `Append`|Posição do byte em que a próxima operação ocorre. O primeiro byte em um arquivo está na posição 1, o segundo byte estiver na posição 2 e assim por diante.|  
  
   
  
## Examples  
 Este exemplo usa o `Seek` função para retornar a posição atual do arquivo. O exemplo supõe `TestFile` é um arquivo que contém registros de uma estrutura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Para arquivos abertos no `Random` modo, `Seek` retorna o número do próximo registro.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Para arquivos abertos em modos diferentes de `Random` modo, `Seek` retorna a posição do byte em que a próxima operação ocorre. Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Este exemplo usa o `Seek` função para definir a posição para a próxima leitura ou gravação em um arquivo.  
  
 Para arquivos abertos em modos diferentes de `Random` modo, `Seek` define a posição do byte em que a próxima operação ocorre. Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Um <see langword="Integer" /> que contém um número de arquivo válido.</param>
        <param name="Position">Necessário. Número no intervalo de 1 a 2.147.483.647, inclusive, que indica onde a próxima operação de leitura/gravação deve ocorrer.</param>
        <summary>Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Seek` Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.  
  
 O exemplo a seguir descreve os valores retornados para cada modo de acesso do arquivo:  
  
|Modo|Valor de Retorno|  
|-|-|  
|`Random`|Número do próximo registro lido ou gravado|  
|`Binary`, `Input`, `Output`, `Append`|Posição do byte em que a próxima operação ocorre. O primeiro byte em um arquivo está na posição 1, o segundo byte estiver na posição 2 e assim por diante.|  
  
   
  
## Examples  
 Este exemplo usa o `Seek` função para retornar a posição atual do arquivo. O exemplo supõe `TestFile` é um arquivo que contém registros de uma estrutura `Record`.  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 Para arquivos abertos no `Random` modo, `Seek` retorna o número do próximo registro.  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 Para arquivos abertos em modos diferentes de `Random` modo, `Seek` retorna a posição do byte em que a próxima operação ocorre. Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 Este exemplo usa o `Seek` função para definir a posição para a próxima leitura ou gravação em um arquivo.  
  
 Para arquivos abertos em modos diferentes de `Random` modo, `Seek` define a posição do byte em que a próxima operação ocorre. Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">Lendo a partir de arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">Gravando em arquivos no Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">Necessário. Expressão <see langword="String" /> que especifica um nome de arquivo. <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</param>
        <param name="Attributes">Necessário. Expressão constante ou numérica, cuja soma especifica atributos de arquivo.</param>
        <summary>Define as informações de atributo de um arquivo. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="SetAttr" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um erro de tempo de execução ocorrerá se você tentar definir os atributos de um arquivo aberto.  
  
 O `Attributes` valores de enumeração de argumento são da seguinte maneira:  
  
|Valor|Constante|Descrição|  
|-|-|-|  
|`Normal`|`vbNormal`|Normal (padrão).|  
|`ReadOnly`|`vbReadOnly`|Somente leitura.|  
|`Hidden`|`vbHidden`|Oculto.|  
|`System`|`vbSystem`|Arquivo do sistema.|  
|`Volume`|`vbVolume`|Rótulo do volume|  
|`Directory`|`vbDirectory`|Diretório ou pasta.|  
|`Archive`|`vbArchive`|O arquivo foi alterado desde o último backup.|  
|`Alias`|`vbAlias`|O arquivo tem um nome diferente.|  
  
> [!NOTE]
>  Essas enumerações são especificadas pela linguagem Visual Basic. Os nomes podem ser usados em qualquer lugar no seu código em vez dos valores reais.  
  
   
  
## Examples  
 Este exemplo usa o `SetAttr` função para definir atributos para um arquivo.  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tipo <paramref name="Attribute" /> é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">Necessário. O número de espaços a serem inseridos antes de exibir ou imprimir a próxima expressão em uma lista.</param>
        <summary>Usado com a função <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</summary>
        <returns>Usado com a função <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Count` é menor do que a largura da linha de saída, a próxima posição de impressão imediatamente após o número de espaços impressos. Se`Count` é maior que a largura da linha de saída, `SPC` calculará a próxima posição de impressa usando a fórmula:  
  
 `currentprintposition`(+(`Count``Mod``width`))  
  
 Por exemplo, se a posição de impressão atual for 24, a largura de linha de saída for 80, e você especificar `SPC(90)`, a próxima impressão começará na posição 34 (posição de impressão atual + o resto de 90/80). Se a diferença entre a posição atual de impressão e a largura da linha de saída for menor que `Count` (ou `Count` `Mod` *largura*), o `SPC` função pula para o início da próxima linha e gera espaços iguais a `Count` – (*largura* – *currentprintposition*).  
  
> [!NOTE]
>  Verifique se que as colunas da tabela são suficientes permitir a amplas letras.  
  
   
  
## Examples  
 Este exemplo usa o `SPC` função para posicionar a saída em um arquivo e em de **saída** janela.  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operador Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</summary>
        <returns>Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a posição de impressão atual na linha atual é maior que `Column`, `TAB` pulará para a coluna de valor igual a `Column` na próxima linha de saída. Se `Column` é menor que 1, `TAB` move a posição de impressão para a coluna 1. Se `Column` é maior do que a largura da linha de saída, `TAB` calculará a próxima posição de impressa usando a fórmula:  
  
 Largura da coluna Mod  
  
 Por exemplo, se *largura* é 80 e você especificar `TAB(90)`, a próxima impressão começará na coluna 10 (o resto de 90/80). Se `Column` é menor que a posição atual de impressão, impressão é iniciado na próxima linha na posição de impressão calculada. Se a posição de impressão calculada for maior que a posição atual de impressão, impressão começa no calculada imprimir a posição na mesma linha.  
  
 A posição mais à esquerda de impressão em uma linha de saída é sempre 1. Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.  
  
 O `TAB` função também pode ser usada com o `WriteLine` função. Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verifique se que as colunas da tabela são grande o suficiente para conter letras amplas.  
  
   
  
## Examples  
 Este exemplo usa o `TAB` função para posicionar a saída em um arquivo e em de **saída** janela.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operador Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">Opcional. O número de coluna movido antes de exibir ou imprimir a próxima expressão em uma lista. Se omitido, <see langword="TAB" /> move o ponto de inserção para o início da próxima zona de impressão.</param>
        <summary>Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</summary>
        <returns>Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a posição de impressão atual na linha atual for maior que `Column`, `TAB` pulará para a coluna de valor igual a `Column` na próxima linha de saída. Se `Column` é menor que 1, `TAB` move a posição de impressão para a coluna 1. Se `Column` é maior que a largura da linha de saída, `TAB` calculará a próxima posição de impressa usando a fórmula:  
  
 Largura da coluna Mod  
  
 Por exemplo, se *largura* é 80 e você especificar `TAB(90)`, a próxima impressão começará na coluna 10 (o resto de 90/80). Se `Column` é menor que a posição atual de impressão, impressão é iniciado na próxima linha na posição de impressão calculada. Se a posição de impressão calculada for maior que a posição atual de impressão, impressão começa no calculada imprimir a posição na mesma linha.  
  
 A posição mais à esquerda de impressão em uma linha de saída é sempre 1. Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.  
  
 O `TAB` função também pode ser usada com o `WriteLine` função. Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Verifique se que as colunas da tabela são grande o suficiente para conter letras amplas.  
  
   
  
## Examples  
 Este exemplo usa o `TAB` função para posicionar a saída em um arquivo e em de **saída** janela.  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">Operador Mod (Visual Basic)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="Record">Opcional. Número do único registro ou byte a ser bloqueado ou desbloqueado</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Qualquer número de arquivo válido.</param>
        <param name="FromRecord">Opcional. Número do primeiro registro ou byte a ser bloqueado ou desbloqueado.</param>
        <param name="ToRecord">Opcional. Número do último registro ou byte a ser bloqueado ou desbloqueado.</param>
        <summary>Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />. Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.  
  
 `Lock` e `Unlock` funções sempre são usadas em pares. Os argumentos para `Lock` e `Unlock` devem ser idênticos.  
  
 Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo. Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.  
  
 Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.  
  
   
  
## Examples  
 Este exemplo ilustra o uso do `Lock` e `Unlock` funções. Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Uma expressão <see langword="Integer" /> que contém qualquer número de arquivo válido.</param>
        <param name="Output">Opcional. Uma ou mais expressões delimitadas por vírgula para gravar em um arquivo.</param>
        <summary>Grava dados em um arquivo sequencial. Dados gravados com <see langword="Write" /> costumam ser lidos a partir de um arquivo usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se você omitir `Output`, uma linha em branco é impresso para o arquivo. Várias expressões podem ser separadas por vírgula.  
  
 Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas conforme elas são gravadas no arquivo. Você não precisa colocar delimitadores explícitas na lista. Quando `Write` é usado para gravar dados em um arquivo, numérico somente `Boolean`, data, null, e `Error` há suporte para formatos de dados. As seguintes suposições universais são seguidas para que os dados sempre podem ser lido e interpretado corretamente usando `Input`, independentemente da localidade:  
  
-   Dados numéricos são sempre gravados usando o ponto como separador decimal.  
  
-   Para `Boolean` dados, seja `#TRUE#` ou `#FALSE#` é impresso. O `True` e `False` palavras-chave não são traduzidas, independente da localidade.  
  
-   Dados de data são gravados no arquivo usando o formato de data universal. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.  
  
-   Nada será gravado no arquivo se `Output` dados estão vazios. No entanto, para dados nulos, `#NULL#` é gravado.  
  
-   Para `Error` dados, a saída é exibida como `#ERROR errorcode#`. O `Error` palavra-chave não será convertido, independente da localidade.  
  
 `WriteLine` Insere um caractere de nova linha (ou seja, um retorno de carro/linha de alimentação, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.  
  
 Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou "". Por exemplo,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retorna uma cadeia de caracteres com o valor de `Double quotation marks aren't "difficult" to handle`.  
  
 Gravando em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Write` função para gravar dados brutos em um arquivo sequencial.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">O modo de arquivo é inválido.</exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">Necessário. Uma expressão <see langword="Integer" /> que contém qualquer número de arquivo válido.</param>
        <param name="Output">Opcional. Uma ou mais expressões delimitadas por vírgula para gravar em um arquivo.</param>
        <summary>Grava dados em um arquivo sequencial. Dados gravados com <see langword="Write" /> costumam ser lidos a partir de um arquivo usando <see langword="Input" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho. Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho. Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).  
  
 Se você omitir `Output`, uma linha em branco é impresso para o arquivo. Várias expressões podem ser separadas por vírgula.  
  
 Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas conforme elas são gravadas no arquivo. Você não precisa colocar delimitadores explícitas na lista. Quando `Write` é usado para gravar dados em um arquivo, numérico somente `Boolean`, data, null, e `Error` há suporte para formatos de dados. As seguintes suposições universais são seguidas para que os dados sempre podem ser lido e interpretado corretamente usando `Input`, independentemente da localidade:  
  
-   Dados numéricos são sempre gravados usando o ponto como separador decimal.  
  
-   Para `Boolean` dados, seja `#TRUE#` ou `#FALSE#` é impresso. O `True` e `False` palavras-chave não são traduzidas, independente da localidade.  
  
-   Dados de data são gravados no arquivo usando o formato de data universal. Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.  
  
-   Nada será gravado no arquivo se `Output` dados estão vazios. No entanto, para dados nulos, `#NULL#` é gravado.  
  
-   Para `Error` dados, a saída é exibida como `#ERROR errorcode#`. O `Error` palavra-chave não será convertido, independente da localidade.  
  
 `WriteLine` Insere um caractere de nova linha (ou seja, um retorno de carro/linha de alimentação, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.  
  
 Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou "". Por exemplo,  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 Retorna uma cadeia de caracteres com o valor de `Double quotation marks aren't "difficult" to handle`.  
  
 Gravando em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar do `FileIOPermissionAccess` enumeração. Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.  
  
   
  
## Examples  
 Este exemplo usa o `Write` função para gravar dados brutos em um arquivo sequencial.  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">Access de arquivo com o Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">Como gravar texto em arquivos no Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</related>
      </Docs>
    </Member>
  </Members>
</Type>