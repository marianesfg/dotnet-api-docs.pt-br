<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eb3cbdf16c699365dc1a2fa7cf6e6eb4d128a87b" />
    <Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/17/2018" />
    <Meta Name="ms.locfileid" Value="51891458" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="79fe2-101">O módulo <see langword="FileSystem" /> contém os procedimentos usados para executar operações de arquivo, diretório ou pasta e sistema.</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span>
      </span>
      <span data-ttu-id="79fe2-102">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo do que usando o módulo <see langword="FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span>
      </span>
      <span data-ttu-id="79fe2-103">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-104">Este módulo oferece suporte a palavras-chave de linguagem Visual Basic e membros da biblioteca em tempo de execução que acessam arquivos e pastas.</span><span class="sxs-lookup"><span data-stu-id="79fe2-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-105">Este exemplo usa o `GetAttr` função para determinar os atributos de um arquivo e diretório ou pasta.</span><span class="sxs-lookup"><span data-stu-id="79fe2-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md">
      <span data-ttu-id="79fe2-106">Resumo de diretórios e arquivos</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-106">Directories and Files Summary</span>
      </span>
    </related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md">
      <span data-ttu-id="79fe2-107">Resumo de entrada e saída</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-107">Input and Output Summary</span>
      </span>
    </related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">
      <span data-ttu-id="79fe2-108">Palavras-chave (Visual Basic)</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-108">Keywords (Visual Basic)</span>
      </span>
    </related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">
      <span data-ttu-id="79fe2-109">Membros de biblioteca de tempo de execução do Visual Basic</span>
      <span class="sxs-lookup">
        <span data-stu-id="79fe2-109">Visual Basic Run-Time Library Members</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="79fe2-110">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-110">Required.</span>
          </span>
          <span data-ttu-id="79fe2-111">Uma expressão <see langword="String" /> que identifica qual diretório ou pasta se torna o novo diretório ou pasta padrão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-111">A <see langword="String" /> expression that identifies which directory or folder becomes the new default directory or folder.</span>
          </span>
          <span data-ttu-id="79fe2-112">
            <c>Path</c> pode incluir a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-112">
              <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="79fe2-113">Se nenhuma unidade for especificada, o <see langword="ChDir" /> alterará o diretório ou pasta padrão na unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-113">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-114">Altera o diretório ou pasta atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-114">Changes the current directory or folder.</span>
          </span>
          <span data-ttu-id="79fe2-115">O recurso <see langword="My" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="ChDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-115">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-116">Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-116">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-117">O `ChDir` função altera o diretório padrão, mas não a unidade padrão.</span><span class="sxs-lookup"><span data-stu-id="79fe2-117">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="79fe2-118">Por exemplo, se a unidade padrão é C, a instrução a seguir altera o diretório padrão na unidade D, mas C permanece a unidade padrão:</span><span class="sxs-lookup"><span data-stu-id="79fe2-118">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="79fe2-119">Você pode tornar relativo alterações de diretório é, digitando dois pontos, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-119">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-120">O `ChDir` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-120">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="79fe2-121">Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e.</span><span class="sxs-lookup"><span data-stu-id="79fe2-121">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-122">Este exemplo usa o `ChDir` função para alterar o diretório atual ou a pasta.</span><span class="sxs-lookup"><span data-stu-id="79fe2-122">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-123">
            <paramref name="Path" /> está vazio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-123">
              <paramref name="Path" /> is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-124">Uma unidade inválida foi especificada ou a unidade está indisponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-124">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md">
          <span data-ttu-id="79fe2-125">Como analisar demarcadores de arquivo no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-125">How to: Parse File Paths in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md">
          <span data-ttu-id="79fe2-126">Criando, excluindo e movendo arquivos e diretórios no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-126">Creating, Deleting, and Moving Files and Directories in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-127">Altera a unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-127">Changes the current drive.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="79fe2-128">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-128">Required.</span>
          </span>
          <span data-ttu-id="79fe2-129">Expressão de cadeia de caracteres que especifica uma unidade existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-129">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="79fe2-130">Se você fornecer uma cadeia de caracteres de tamanho zero (""), a unidade atual não será alterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-130">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="79fe2-131">Se o argumento <c>Unidade</c> for uma cadeia de vários caracteres, <see langword="ChDrive" /> usará somente a primeira letra.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-131">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-132">Altera a unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-132">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-133">O `ChDrive` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-133">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="79fe2-134">Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="79fe2-134">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-135">Este exemplo usa o `ChDrive` função para alterar a unidade atual.</span><span class="sxs-lookup"><span data-stu-id="79fe2-135">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="79fe2-136">A função gera uma exceção se a unidade não existe.</span><span class="sxs-lookup"><span data-stu-id="79fe2-136">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-137">Uma unidade inválida foi especificada ou a unidade está indisponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-137">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-138">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-138">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="79fe2-139">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-139">Required.</span>
          </span>
          <span data-ttu-id="79fe2-140">Expressão de cadeia de caracteres que especifica uma unidade existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-140">String expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="79fe2-141">Se você fornecer uma cadeia de caracteres de tamanho zero (""), a unidade atual não será alterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-141">If you supply a zero-length string (""), the current drive does not change.</span>
          </span>
          <span data-ttu-id="79fe2-142">Se o argumento <c>Unidade</c> for uma cadeia de vários caracteres, <see langword="ChDrive" /> usará somente a primeira letra.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-142">If the <c>Drive</c> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-143">Altera a unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-143">Changes the current drive.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-144">O `ChDrive` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-144">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="79fe2-145">Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="79fe2-145">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-146">Este exemplo usa o `ChDrive` função para alterar a unidade atual.</span><span class="sxs-lookup"><span data-stu-id="79fe2-146">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="79fe2-147">A função gera uma exceção se a unidade não existe.</span><span class="sxs-lookup"><span data-stu-id="79fe2-147">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-148">Uma unidade inválida foi especificada ou a unidade está indisponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-148">Invalid drive is specified, or drive is unavailable.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-149">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-149">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-150">Retorna uma cadeia de caracteres que representa o caminho atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-150">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="79fe2-151">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-151">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="79fe2-152">Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-152">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-153">Retorna uma cadeia de caracteres que representa o caminho atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-153">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="79fe2-154">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="79fe2-155">Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-156">Uma cadeia de caracteres que representa o caminho atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-156">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="79fe2-157">Este exemplo usa o `CurDir` função para retornar o caminho atual.</span><span class="sxs-lookup"><span data-stu-id="79fe2-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive">
          <span data-ttu-id="79fe2-158">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-158">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-159">A expressão <see langword="Char" /> que especifica uma unidade existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-159">
              <see langword="Char" /> expression that specifies an existing drive.</span>
          </span>
          <span data-ttu-id="79fe2-160">Se nenhuma unidade for especificada ou, se <c>Unidade</c> for uma cadeia de caracteres de tamanho zero (""), <see langword="CurDir" /> retornará o caminho da unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-160">If no drive is specified, or if <c>Drive</c> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-161">Retorna uma cadeia de caracteres que representa o caminho atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-161">Returns a string representing the current path.</span>
          </span>
          <span data-ttu-id="79fe2-162">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="CurDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span>
          </span>
          <span data-ttu-id="79fe2-163">Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-163">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-164">Uma cadeia de caracteres que representa o caminho atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-164">A string representing the current path.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="79fe2-165">Este exemplo usa o `CurDir` função para retornar o caminho atual.</span><span class="sxs-lookup"><span data-stu-id="79fe2-165">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-166">Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-166">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="79fe2-167">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-167">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-168">Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-168">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-169">Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-169">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="79fe2-170">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-170">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-171">Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-171">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-172">Uma cadeia de caracteres representando o nome de um arquivo, diretório ou pasta correspondente a um padrão especificado ou atributo de arquivo ou o rótulo de volume de uma unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-172">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-173">O `Dir` função suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-173">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="79fe2-174">`VbVolume` Retorna o rótulo de volume para a unidade em vez de um nome de arquivo específico.</span><span class="sxs-lookup"><span data-stu-id="79fe2-174">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="79fe2-175">Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-175">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="79fe2-176">Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-176">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-177">Para ser executado corretamente, o `Dir` função requer que o <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução.</span><span class="sxs-lookup"><span data-stu-id="79fe2-177">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="79fe2-178">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="79fe2-178">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="79fe2-179">O `Attributes` valores de enumeração de argumento são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-179">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="79fe2-180">Valor</span><span class="sxs-lookup"><span data-stu-id="79fe2-180">Value</span></span>|<span data-ttu-id="79fe2-181">Constante</span><span class="sxs-lookup"><span data-stu-id="79fe2-181">Constant</span></span>|<span data-ttu-id="79fe2-182">Descrição</span><span class="sxs-lookup"><span data-stu-id="79fe2-182">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="79fe2-183">Padrão.</span><span class="sxs-lookup"><span data-stu-id="79fe2-183">Default.</span></span> <span data-ttu-id="79fe2-184">Especifica os arquivos sem atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-184">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="79fe2-185">Especifica arquivos somente leitura e também arquivos sem atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-185">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="79fe2-186">Especifica arquivos ocultos e também arquivos sem atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-186">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="79fe2-187">Especifica os arquivos do sistema e arquivos sem atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-187">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="79fe2-188">Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-188">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="79fe2-189">Especifica diretórios ou pastas e arquivos sem atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-189">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="79fe2-190">O arquivo foi alterado desde o último backup.</span><span class="sxs-lookup"><span data-stu-id="79fe2-190">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="79fe2-191">O arquivo tem um nome diferente.</span><span class="sxs-lookup"><span data-stu-id="79fe2-191">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-192">Essas enumerações são especificadas pela linguagem Visual Basic e podem ser usadas em qualquer lugar em seu código em vez dos valores reais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-192">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-193">Este exemplo usa o `Dir` função para verificar se existem determinados arquivos e diretórios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-193">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (Pathname, Attributes)" FrameworkAlternate="netframework-1.1;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-194">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-194">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-195">Expressão de <see langword="String" /> que especifica um nome de arquivo, diretório ou pasta ou um rótulo de volume de unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-195">
              <see langword="String" /> expression that specifies a file name, directory or folder name, or drive volume label.</span>
          </span>
          <span data-ttu-id="79fe2-196">Uma cadeia de caracteres de tamanho zero (<see langword="&quot;&quot;" />) será retornada se <c>PathName</c> não for encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-196">A zero-length string (<see langword="&quot;&quot;" />) is returned if <c>PathName</c> is not found.</span>
          </span>
        </param>
        <param name="Pathname">To be added.</param>
        <param name="Attributes">
          <span data-ttu-id="79fe2-197">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-197">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-198">Enumeração ou expressão numérica cujo valor especifica atributos de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-198">Enumeration or numeric expression whose value specifies file attributes.</span>
          </span>
          <span data-ttu-id="79fe2-199">Se omitido, <see langword="Dir" /> retorna arquivos que correspondem a <c>PathName</c>, mas não têm atributos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-199">If omitted, <see langword="Dir" /> returns files that match <c>PathName</c> but have no attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-200">Retorna uma cadeia de caracteres que representa o nome de um arquivo, diretório ou pasta que corresponde a um padrão ou atributo de arquivo especificado ou o rótulo de volume de uma unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-200">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
          <span data-ttu-id="79fe2-201">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="Dir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-201">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-202">Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-202">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-203">Uma cadeia de caracteres representando o nome de um arquivo, diretório ou pasta correspondente a um padrão especificado ou atributo de arquivo ou o rótulo de volume de uma unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-203">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-204">O `Dir` função suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-204">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="79fe2-205">`VbVolume` Retorna o rótulo de volume para a unidade em vez de um nome de arquivo específico.</span><span class="sxs-lookup"><span data-stu-id="79fe2-205">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="79fe2-206">Você deve fornecer um `PathName` na primeira vez que você chamar o `Dir` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-206">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="79fe2-207">Para recuperar o próximo item, você pode fazer chamadas subsequentes para o `Dir` função sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-207">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-208">Para ser executado corretamente, o `Dir` função requer que o <xref:System.Security.Permissions.FileIOPermissionAccess.Read> e <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução.</span><span class="sxs-lookup"><span data-stu-id="79fe2-208">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="79fe2-209">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="79fe2-209">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="79fe2-210">O `Attributes` valores de enumeração de argumento são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-210">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="79fe2-211">Valor</span><span class="sxs-lookup"><span data-stu-id="79fe2-211">Value</span></span>|<span data-ttu-id="79fe2-212">Constante</span><span class="sxs-lookup"><span data-stu-id="79fe2-212">Constant</span></span>|<span data-ttu-id="79fe2-213">Descrição</span><span class="sxs-lookup"><span data-stu-id="79fe2-213">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="79fe2-214">Padrão.</span><span class="sxs-lookup"><span data-stu-id="79fe2-214">Default.</span></span> <span data-ttu-id="79fe2-215">Especifica os arquivos que não têm atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-215">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="79fe2-216">Especifica arquivos somente leitura, além dos arquivos que não têm atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-216">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="79fe2-217">Especifica arquivos ocultos, além dos arquivos que não têm atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-217">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="79fe2-218">Especifica os arquivos do sistema, além dos arquivos que não têm atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-218">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="79fe2-219">Especifica o rótulo do volume; Se qualquer outro atributo for especificado, `vbVolume` será ignorado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-219">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="79fe2-220">Especifica diretórios ou pastas, além dos arquivos que não têm atributos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-220">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="79fe2-221">O arquivo foi alterado desde o último backup.</span><span class="sxs-lookup"><span data-stu-id="79fe2-221">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="79fe2-222">O arquivo tem um nome diferente.</span><span class="sxs-lookup"><span data-stu-id="79fe2-222">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-223">Essas enumerações são especificadas pela linguagem Visual Basic e podem ser usadas em qualquer lugar em seu código no lugar dos valores reais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-223">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-224">Este exemplo usa o `Dir` função para verificar se existem determinados arquivos e diretórios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-224">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-225">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-225">Required.</span>
          </span>
          <span data-ttu-id="79fe2-226">Um <see langword="Integer" /> que contém qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-226">An <see langword="Integer" /> that contains any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-227">Retorna um valor booliano <see langword="True" /> quando o final de um arquivo aberto para <see langword="Random" /> ou <see langword="Input" /> sequencial foi atingido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-227">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-228">Retorna um valor booliano <see langword="True" /> quando o final de um arquivo aberto para <see langword="Random" /> ou <see langword="Input" /> sequencial foi atingido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-228">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-229">Use `EOF` para evitar o erro gerado pela tentativa de obter entrada passou do final de um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-229">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="79fe2-230">O `EOF` retornos de função `False` até o final do arquivo foi atingido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-230">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="79fe2-231">Com arquivos abertos para `Random` ou `Binary` acesso `EOF` retorna `False` até o último executado `FileGet` função não é possível ler um registro inteiro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-231">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="79fe2-232">Com arquivos abertos para `Binary` acessar, uma tentativa de ler o arquivo usando o `Input` funcionando até `EOF` retorna `True` gera um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-232">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="79fe2-233">Use o `LOF` e `Loc` funções em vez de `EOF` ao ler arquivos binários com `Input`, ou use `Get` ao usar o `EOF` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-233">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="79fe2-234">Com arquivos abertos para `Output`, `EOF` sempre retorna `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-234">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-235">Este exemplo usa o `EOF` função para detectar o final de um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-235">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="79fe2-236">Este exemplo supõe que `Testfile` é um arquivo de texto que contém várias linhas de texto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-236">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-237">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-237">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-238">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-238">Required.</span>
          </span>
          <span data-ttu-id="79fe2-239">
            <see langword="Integer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-239">
              <see langword="Integer" />.</span>
          </span>
          <span data-ttu-id="79fe2-240">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-240">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-241">Retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-241">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-242">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo do que a função <see langword="FileAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-242">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-243">Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-243">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-244">Os seguintes valores de enumeração indicam o modo de acesso do arquivo:</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-244">The following enumeration values indicate the file access mode:</span>
          </span>
          <list type="table">
            <item>
              <term>
                <span data-ttu-id="79fe2-245">Valor</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-245">Value</span>
                </span>
              </term>
              <description>
                <span data-ttu-id="79fe2-246">Modo</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-246">Mode</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="79fe2-247">1</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-247">1</span>
                </span>
              </term>
              <description>
                <see langword="OpenMode.Input" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="79fe2-248">2</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-248">2</span>
                </span>
              </term>
              <description>
                <see langword="OpenMode.Output" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="79fe2-249">4</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-249">4</span>
                </span>
              </term>
              <description>
                <see langword="OpenMode.Random" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="79fe2-250">8</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-250">8</span>
                </span>
              </term>
              <description>
                <see langword="OpenMode.Append" />
              </description>
            </item>
            <item>
              <term>
                <span data-ttu-id="79fe2-251">32</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-251">32</span>
                </span>
              </term>
              <description>
                <see langword="OpenMode.Binary" />
              </description>
            </item>
          </list>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-252">Essa função retorna uma enumeração que representa o modo de arquivo para arquivos abertos usando o `FileOpen` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-252">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-253">Este exemplo usa o `FileAttr` função para retornar o modo de arquivo de um arquivo aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-253">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-254">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-254">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers">
          <span data-ttu-id="79fe2-255">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-255">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-256">Matriz de parâmetros de 0 ou mais canais que serão fechados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-256">Parameter array of 0 or more channels to be closed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-257">Conclui a E/S (Entrada/Saída) para um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-257">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-258">
            <see langword="My" /> oferece maior produtividade e desempenho em operações de E/S de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-258">
              <see langword="My" /> gives you better productivity and performance in file I/O operations.</span>
          </span>
          <span data-ttu-id="79fe2-259">Consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-259">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-260">O `FileClose` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-260">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-261">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-261">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-262">Para obter mais informações, consulte [como: ler texto de arquivos com um StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [como: gravar texto em arquivos com um StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), e [passo a passo: Manipulando arquivos e diretórios em Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-262">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="79fe2-263">Se você omitir `FileNumbers`, todos os arquivos ativos abertos pelo `FileOpen` função são fechados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-263">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="79fe2-264">Quando você fecha arquivos abertos para `Output` ou `Append`, o buffer final da saída é gravado no buffer de sistema operacional para esse arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-264">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="79fe2-265">Todos os buffers espaço associado fechado arquivo seja liberado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-265">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="79fe2-266">Quando o `FileClose` função é executada, a associação de um arquivo com seu arquivo número termina.</span><span class="sxs-lookup"><span data-stu-id="79fe2-266">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-267">Este exemplo usa o `FileClose` função para fechar um arquivo aberto para `Input`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-267">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-268">
            <paramref name="FileNumber" /> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-268">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">
          <span data-ttu-id="79fe2-269">Instrução End</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-269">End Statement</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md">
          <span data-ttu-id="79fe2-270">Instrução Stop (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-270">Stop Statement (Visual Basic)</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-271">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-271">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source">
          <span data-ttu-id="79fe2-272">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-272">Required.</span>
          </span>
          <span data-ttu-id="79fe2-273">A expressão <see langword="String" /> que especifica o nome do arquivo a ser copiado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-273">
              <see langword="String" /> expression that specifies the name of the file to be copied.</span>
          </span>
          <span data-ttu-id="79fe2-274">
            <c>Source</c> pode incluir o diretório ou a pasta, e a unidade do arquivo de origem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-274">
              <c>Source</c> may include the directory or folder, and drive, of the source file.</span>
          </span>
        </param>
        <param name="Destination">
          <span data-ttu-id="79fe2-275">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-275">Required.</span>
          </span>
          <span data-ttu-id="79fe2-276">A expressão <see langword="String" /> que especifica o nome do arquivo de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-276">
              <see langword="String" /> expression that specifies the destination file name.</span>
          </span>
          <span data-ttu-id="79fe2-277">
            <c>Destination</c> pode incluir o diretório ou a pasta e a unidade do arquivo de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-277">
              <c>Destination</c> may include the directory or folder, and drive, of the destination file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-278">Copia um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-278">Copies a file.</span>
          </span>
          <span data-ttu-id="79fe2-279">O <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> oferece maior produtividade e desempenho em operações de E/S de arquivo que <see langword="FileCopy" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-279">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span>
          </span>
          <span data-ttu-id="79fe2-280">Consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> para obter mais informações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-280">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-281">Se você tentar usar o `FileCopy` de função em um arquivo aberto, ocorrerá um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-281">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="79fe2-282">`FileCopy` requer confiança total para trabalhar na unidade local.</span><span class="sxs-lookup"><span data-stu-id="79fe2-282">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-283">Este exemplo usa o `FileCopy` função para copiar um arquivo para outro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-283">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="79fe2-284">Para fins deste exemplo, suponha que `SrcFile` é um arquivo que contém dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-284">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-285">
            <paramref name="Source" /> ou <paramref name="Destination" /> é inválido ou não foi especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-285">
              <paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-286">O arquivo já está aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-286">File is already open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-287">Arquivo inexistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-287">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md">
          <span data-ttu-id="79fe2-288">Como criar uma cópia de um arquivo em um diretório diferente no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-288">How to: Create a Copy of a File in a Different Directory in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md">
          <span data-ttu-id="79fe2-289">Como criar uma cópia de um arquivo no mesmo diretório no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-289">How to: Create a Copy of a File in the Same Directory in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md">
          <span data-ttu-id="79fe2-290">Como copiar um diretório para outro diretório no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-290">How to: Copy a Directory to Another Directory in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-291">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-291">Required.</span>
          </span>
          <span data-ttu-id="79fe2-292">Expressão <see langword="String" /> que especifica um nome de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-292">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="79fe2-293">
            <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-293">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-294">Retorna um valor <see langword="Date" /> que indica a data e hora em que ocorreu a gravação em um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-294">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span>
          </span>
          <span data-ttu-id="79fe2-295">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileDateTime" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-295">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span>
          </span>
          <span data-ttu-id="79fe2-296">Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-296">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-297">Retorna um valor <see langword="Date" /> que indica a data e hora em que um arquivo foi criado ou modificado pela última vez.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-297">
              <see langword="Date" /> value that indicates the date and time a file was created or last modified.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="79fe2-298">Este exemplo usa o `FileDateTime` função para determinar a data e hora em que um arquivo foi criada ou modificado pela última vez.</span><span class="sxs-lookup"><span data-stu-id="79fe2-298">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="79fe2-299">O formato de data e hora exibido se baseia nas configurações de localidade do sistema.</span><span class="sxs-lookup"><span data-stu-id="79fe2-299">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-300">
            <paramref name="PathName" /> é inválido ou contém caracteres curinga.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-300">
              <paramref name="PathName" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-301">O arquivo de destino não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-301">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-302">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-302">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-303">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-303">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-304">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-304">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-305">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-305">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-306">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-306">Required.</span>
          </span>
          <span data-ttu-id="79fe2-307">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-307">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-308">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-308">Required.</span>
          </span>
          <span data-ttu-id="79fe2-309">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-309">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-310">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-310">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-311">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-311">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-312">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-312">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-313">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-313">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-314">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-314">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-315">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-315">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-316">Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-316">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-317">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-317">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-318">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-318">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-319">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-319">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-320">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-320">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-321">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-321">Random Mode</span></span>  
 <span data-ttu-id="79fe2-322">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-322">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-323">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-323">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-324">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-324">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-325">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-325">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-326">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-326">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-327">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-327">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-328">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-328">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-329">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-329">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-330">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-330">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-331">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-331">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-332">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-332">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-333">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-333">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-334">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-334">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-335">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-335">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-336">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-336">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-337">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-337">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-338">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-338">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-339">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-339">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-340">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-340">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-341">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-341">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-342">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-342">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-343">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-343">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-344">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-344">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-345">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-345">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-346">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-346">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-347">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-347">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-348">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-348">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-349">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-349">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-350">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-350">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-351">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-351">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-352">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-352">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-353">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-353">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-354">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-354">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-355">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-355">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-356">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-356">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-357">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-357">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-358">Leitura de um arquivo usando o`FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-358">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-359">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-359">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-360">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-360">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-361">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-361">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-362">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-362">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-363">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-363">Required.</span>
          </span>
          <span data-ttu-id="79fe2-364">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-364">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-365">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-365">Required.</span>
          </span>
          <span data-ttu-id="79fe2-366">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-366">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-367">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-367">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-368">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-368">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-369">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-369">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-370">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-370">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-371">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-371">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-372">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-372">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-373">Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-373">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-374">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-374">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-375">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-375">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-376">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-376">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-377">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-377">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-378">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-378">Random Mode</span></span>  
 <span data-ttu-id="79fe2-379">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-379">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-380">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-380">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-381">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-381">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-382">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-382">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-383">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-383">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-384">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-384">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-385">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-385">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-386">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-386">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-387">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-387">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-388">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-388">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-389">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-389">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-390">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-390">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-391">Se o descritor não for usado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-391">If the descriptor is not used.</span></span> <span data-ttu-id="79fe2-392">Em seguida, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-392">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-393">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-393">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-394">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-394">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-395">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-395">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-396">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-396">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-397">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-397">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-398">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-398">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-399">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-399">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-400">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-400">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-401">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-401">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-402">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-402">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-403">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-403">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-404">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-404">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-405">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-405">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-406">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-406">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-407">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-407">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-408">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-408">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-409">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-409">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-410">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-410">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-411">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-411">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-412">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-412">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-413">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-413">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-414">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-414">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-415">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-415">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-416">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-416">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-417">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-417">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-418">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-418">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-419">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-419">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-420">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-420">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-421">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-421">Required.</span>
          </span>
          <span data-ttu-id="79fe2-422">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-422">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-423">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-423">Required.</span>
          </span>
          <span data-ttu-id="79fe2-424">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-424">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-425">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-425">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-426">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-426">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-427">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-427">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-428">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-428">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-429">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-429">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-430">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-430">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-431">Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-431">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-432">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-432">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-433">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-433">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-434">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-434">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-435">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-435">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-436">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-436">Random Mode</span></span>  
 <span data-ttu-id="79fe2-437">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-437">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-438">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-438">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-439">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-439">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-440">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-440">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-441">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-441">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-442">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-442">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-443">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-443">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-444">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-444">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-445">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-445">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-446">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-446">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-447">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-447">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-448">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-448">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-449">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-449">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-450">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-450">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-451">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-451">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-452">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-452">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-453">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-453">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-454">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-454">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-455">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-455">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-456">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-456">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-457">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-457">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-458">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-458">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-459">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-459">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-460">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-460">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-461">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-461">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-462">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-462">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-463">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-463">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-464">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-464">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-465">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-465">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-466">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-466">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-467">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-467">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-468">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-468">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-469">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-469">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-470">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-470">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-471">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-471">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-472">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-472">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-473">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-473">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-474">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-474">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-475">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-475">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-476">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-476">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-477">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-477">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-478">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-478">Required.</span>
          </span>
          <span data-ttu-id="79fe2-479">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-479">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-480">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-480">Required.</span>
          </span>
          <span data-ttu-id="79fe2-481">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-481">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-482">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-482">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-483">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-483">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-484">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-484">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-485">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-485">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-486">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-486">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-487">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-487">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-488">Dados lidos com `FileGet` geralmente são gravados em um arquivo com `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-488">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-489">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-489">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-490">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-490">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-491">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-491">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-492">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-492">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-493">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-493">Random Mode</span></span>  
 <span data-ttu-id="79fe2-494">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-494">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-495">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função,`FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-495">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-496">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-496">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-497">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-497">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-498">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-498">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-499">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-499">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-500">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-500">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-501">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-501">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-502">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-502">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-503">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-503">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-504">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-504">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-505">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-505">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-506">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-506">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-507">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-507">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-508">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-508">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-509">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-509">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-510">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-510">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-511">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-511">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-512">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-512">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-513">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-513">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-514">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-514">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-515">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-515">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-516">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-516">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-517">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-517">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-518">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-518">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-519">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-519">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-520">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-520">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-521">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-521">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-522">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-522">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-523">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-523">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-524">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-524">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-525">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-525">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-526">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-526">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-527">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-527">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-528">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-528">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-529">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-529">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-530">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-530">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-531">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-531">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-532">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-532">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-533">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-533">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-534">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-534">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-535">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-535">Required.</span>
          </span>
          <span data-ttu-id="79fe2-536">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-536">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-537">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-537">Required.</span>
          </span>
          <span data-ttu-id="79fe2-538">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-538">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-539">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-539">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-540">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-540">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-541">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-541">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-542">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-542">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-543">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-543">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-544">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-544">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-545">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-545">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-546">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-546">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-547">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-547">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-548">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-548">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-549">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-549">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-550">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-550">Random Mode</span></span>  
 <span data-ttu-id="79fe2-551">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-551">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-552">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-552">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-553">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-553">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-554">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-554">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-555">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-555">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-556">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-556">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-557">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-557">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-558">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-558">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-559">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-559">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-560">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-560">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-561">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-561">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-562">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-562">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-563">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-563">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-564">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-564">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-565">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-565">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-566">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-566">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-567">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-567">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-568">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-568">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-569">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-569">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-570">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-570">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-571">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-571">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-572">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-573">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-573">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-574">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-574">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-575">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-576">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-576">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-577">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-577">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-578">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-578">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-579">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-579">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-580">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-580">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-581">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-581">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-582">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-582">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-583">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-583">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-584">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-584">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-585">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-585">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-586">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-586">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-587">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-587">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-588">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-588">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-589">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-589">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-590">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-590">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-591">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-591">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-592">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-592">Required.</span>
          </span>
          <span data-ttu-id="79fe2-593">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-593">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-594">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-594">Required.</span>
          </span>
          <span data-ttu-id="79fe2-595">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-595">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-596">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-596">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-597">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-597">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-598">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-598">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-599">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-599">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-600">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-600">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-601">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-601">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-602">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-602">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-603">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-603">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-604">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-604">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-605">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-605">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-606">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-606">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-607">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-607">Random Mode</span></span>  
 <span data-ttu-id="79fe2-608">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-608">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-609">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-609">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-610">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-610">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-611">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-611">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-612">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-612">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-613">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-613">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-614">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-614">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-615">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-615">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-616">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-616">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-617">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-617">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-618">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-618">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-619">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-619">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-620">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-620">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-621">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-621">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-622">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-622">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-623">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-623">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-624">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-624">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-625">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-625">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-626">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-626">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-627">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-627">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-628">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-628">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-629">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-629">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-630">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-630">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-631">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-631">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-632">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-632">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-633">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-633">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-634">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-634">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-635">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-635">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-636">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-636">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-637">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-637">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-638">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-638">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-639">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-639">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-640">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-640">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-641">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-641">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-642">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-642">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-643">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-643">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-644">Leitura de um arquivo usando o`FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-644">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-645">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-645">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-646">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-646">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-647">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-647">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-648">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-648">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-649">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-649">Required.</span>
          </span>
          <span data-ttu-id="79fe2-650">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-650">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-651">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-651">Required.</span>
          </span>
          <span data-ttu-id="79fe2-652">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-652">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-653">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-653">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-654">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-654">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-655">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-655">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-656">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-656">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-657">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-657">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-658">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-658">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-659">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-659">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-660">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-660">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-661">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-661">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-662">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-662">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-663">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-663">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-664">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-664">Random Mode</span></span>  
 <span data-ttu-id="79fe2-665">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-665">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-666">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-666">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-667">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-667">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-668">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-668">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-669">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-669">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-670">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-670">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-671">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-671">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-672">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-672">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-673">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-673">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-674">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-674">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-675">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-675">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-676">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-676">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-677">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-677">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-678">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-678">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-679">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-679">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-680">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-680">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-681">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-681">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-682">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-682">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-683">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-683">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-684">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-684">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-685">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-685">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-686">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-686">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-687">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-687">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-688">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-688">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-689">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-690">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-690">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-691">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-691">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-692">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-692">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-693">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-693">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-694">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-694">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-695">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-695">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-696">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-696">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-697">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-697">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-698">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-698">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-699">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-699">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-700">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-700">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-701">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-701">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-702">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-702">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-703">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-703">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-704">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-704">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-705">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-705">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-706">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-706">Required.</span>
          </span>
          <span data-ttu-id="79fe2-707">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-707">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-708">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-708">Required.</span>
          </span>
          <span data-ttu-id="79fe2-709">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-709">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-710">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-710">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-711">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-711">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-712">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-712">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-713">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-713">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-714">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-714">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-715">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-715">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-716">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-716">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-717">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-717">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-718">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-718">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-719">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-719">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-720">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-720">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-721">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-721">Random Mode</span></span>  
 <span data-ttu-id="79fe2-722">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-722">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-723">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-723">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-724">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-724">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-725">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-725">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-726">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-726">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-727">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-727">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-728">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-728">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-729">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-729">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-730">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-730">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-731">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-731">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-732">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-732">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-733">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-733">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-734">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-734">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-735">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-735">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-736">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-736">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-737">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-737">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-738">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-738">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-739">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-739">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-740">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-740">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-741">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-741">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-742">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-742">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-743">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-743">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-744">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-744">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-745">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-745">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-746">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-747">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-747">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-748">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-748">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-749">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-749">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-750">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-750">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-751">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-751">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-752">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-752">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-753">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-753">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-754">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-754">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-755">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-755">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-756">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-756">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-757">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-757">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-758">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-758">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-759">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-759">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-760">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-760">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-761">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-761">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-762">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-762">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-763">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-763">Required.</span>
          </span>
          <span data-ttu-id="79fe2-764">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-764">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-765">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-765">Required.</span>
          </span>
          <span data-ttu-id="79fe2-766">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-766">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-767">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-767">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-768">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-768">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-769">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-769">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-770">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-770">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-771">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-771">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-772">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-772">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-773">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-773">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-774">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-774">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-775">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-775">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-776">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-776">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-777">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-777">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-778">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-778">Random Mode</span></span>  
 <span data-ttu-id="79fe2-779">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-779">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-780">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-780">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-781">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-781">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-782">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-782">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-783">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-783">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-784">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-784">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-785">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-785">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-786">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-786">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-787">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-787">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-788">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-788">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-789">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-789">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-790">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-790">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-791">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-791">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-792">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-792">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-793">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-793">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-794">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-794">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-795">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-795">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-796">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-796">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-797">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-797">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-798">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-798">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-799">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-799">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-800">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-800">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-801">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-801">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-802">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-802">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-803">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-803">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-804">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-804">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-805">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-805">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-806">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-806">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-807">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-807">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-808">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-808">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-809">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-809">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-810">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-810">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-811">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-811">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-812">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-812">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-813">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-813">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-814">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-814">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-815">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-815">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-816">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-816">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-817">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-817">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-818">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-818">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-819">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-819">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-820">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-820">Required.</span>
          </span>
          <span data-ttu-id="79fe2-821">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-821">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-822">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-822">Required.</span>
          </span>
          <span data-ttu-id="79fe2-823">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-823">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-824">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-824">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-825">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-825">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-826">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-826">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-827">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-827">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-828">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-828">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-829">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-829">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-830">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-830">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-831">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-831">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-832">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-832">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-833">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-833">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-834">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-834">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-835">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-835">Random Mode</span></span>  
 <span data-ttu-id="79fe2-836">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-836">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-837">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-837">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-838">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-838">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-839">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-839">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-840">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-840">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-841">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-841">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-842">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-842">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-843">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-843">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-844">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-844">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-845">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-845">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-846">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-846">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-847">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-847">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-848">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-848">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-849">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-849">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-850">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-850">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-851">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-851">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-852">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-852">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-853">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-853">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-854">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-854">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-855">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-855">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-856">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-856">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-857">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-857">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-858">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-858">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-859">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-859">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-860">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-860">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-861">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-861">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-862">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-862">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-863">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-863">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-864">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-864">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-865">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-865">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-866">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-866">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-867">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-867">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-868">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-868">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-869">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-869">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-870">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-870">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-871">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-871">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-872">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-872">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-873">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-873">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-874">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-874">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-875">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-875">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-876">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-876">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-877">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-877">Required.</span>
          </span>
          <span data-ttu-id="79fe2-878">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-878">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-879">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-879">Required.</span>
          </span>
          <span data-ttu-id="79fe2-880">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-880">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-881">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-881">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-882">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-882">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-883">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-883">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-884">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-884">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-885">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-885">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-886">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-886">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-887">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-887">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-888">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-888">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-889">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-889">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-890">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-890">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-891">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-891">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-892">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-892">Random Mode</span></span>  
 <span data-ttu-id="79fe2-893">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-893">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-894">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-894">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-895">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-895">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-896">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-896">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-897">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-897">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-898">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-898">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-899">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-899">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-900">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-900">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-901">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-901">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-902">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-902">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-903">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-903">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-904">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-904">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-905">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-905">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-906">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-906">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-907">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-907">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-908">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-908">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-909">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-909">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-910">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-910">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-911">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-911">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-912">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-912">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-913">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-913">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-914">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-914">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-915">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-915">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-916">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-916">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-917">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-917">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-918">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-918">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-919">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-919">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-920">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-920">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-921">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-921">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-922">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-922">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-923">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-923">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-924">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-924">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-925">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-925">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-926">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-926">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-927">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-927">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-928">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-928">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-929">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-929">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-930">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-930">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-931">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-931">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-932">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-932">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-933">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-933">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-934">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-934">Required.</span>
          </span>
          <span data-ttu-id="79fe2-935">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-935">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-936">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-936">Required.</span>
          </span>
          <span data-ttu-id="79fe2-937">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-937">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-938">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-938">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-939">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-939">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="79fe2-940">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-940">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-941">Aplica-se somente ao gravar uma cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-941">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="79fe2-942">Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o tamanho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-942">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="79fe2-943">O padrão é <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-943">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-944">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-944">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-945">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-945">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-946">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-946">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-947">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-947">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-948">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-948">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-949">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-949">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-950">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-950">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-951">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-951">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-952">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-952">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-953">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-953">Random Mode</span></span>  
 <span data-ttu-id="79fe2-954">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-954">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-955">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-955">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-956">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-956">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-957">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-957">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-958">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-958">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-959">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-959">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-960">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-960">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-961">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-961">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-962">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-962">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-963">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-963">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-964">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-964">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-965">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-965">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-966">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-966">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-967">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-967">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-968">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-968">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-969">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-969">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-970">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-970">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-971">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-971">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-972">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-972">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-973">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-973">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-974">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-974">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-975">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-975">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-976">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-976">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-977">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-977">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-978">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-978">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-979">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-979">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-980">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-980">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-981">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-981">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-982">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-982">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-983">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-983">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-984">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-984">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-985">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-985">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-986">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-986">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-987">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-987">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-988">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-988">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-989">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-989">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-990">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-990">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-991">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-991">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-992">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-992">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-993">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-993">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-994">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-994">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-995">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-995">Required.</span>
          </span>
          <span data-ttu-id="79fe2-996">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-996">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-997">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-997">Required.</span>
          </span>
          <span data-ttu-id="79fe2-998">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-998">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-999">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-999">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1000">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1000">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="79fe2-1001">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1001">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1002">Aplica-se somente ao gravar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1002">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="79fe2-1003">Especifica se a matriz deve ser tratada como dinâmica e se é necessário um descritor de matriz que descreve o tamanho e limites da matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1003">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="79fe2-1004">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1004">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1005">Aplica-se somente ao gravar uma cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1005">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="79fe2-1006">Especifica se deve gravar um descritor de dois bytes para a cadeia de caracteres que descreve o tamanho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1006">Specifies whether to write a two-byte descriptor for the string that describes the length.</span>
          </span>
          <span data-ttu-id="79fe2-1007">O padrão é <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1007">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1008">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1008">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-1009">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGet" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1009">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span>
          </span>
          <span data-ttu-id="79fe2-1010">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1010">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1011">`FileGet` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1011">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1012">Dados lidos com `FileGet` costumam ser gravados em um arquivo usando-se `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1012">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="79fe2-1013">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1013">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1014">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` função (ou apontada pela última `Seek` função) é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1014">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-1015">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1015">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-1016">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1016">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1017">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1017">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1018">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1018">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1019">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGet` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1019">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1020">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1020">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1021">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1021">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-1022">Por padrão, se a variável que está sendo lida é uma cadeia de caracteres, `FileGet` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1022">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1023">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1023">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1024">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo; Quando colocado em um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1024">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-1025">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1025">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1026">Se a variável que está sendo lida é uma matriz, você pode optar por ler um descritor para o tamanho e a dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1026">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="79fe2-1027">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1027">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1028">Ao ler a matriz, você precisa coincidir com a forma que de matriz foi escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1028">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="79fe2-1029">Se ele foi gravado com o descritor, você precisará ler o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1029">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="79fe2-1030">Se o descritor não for usado, o tamanho e limites da matriz passaram para `FileGet` determinar o que ler.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1030">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="79fe2-1031">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1031">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1032">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1032">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1033">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1033">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1034">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1034">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="79fe2-1035">218 bytes são distribuídos da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1035">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="79fe2-1036">18 bytes para o descritor: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="79fe2-1036">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="79fe2-1037">200 bytes para os dados: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1037">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-1038">Se a variável que está sendo lida for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FileGet` lê apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1038">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="79fe2-1039">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1039">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-1040">`FileGet` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1040">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1041">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePut`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1041">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1042">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1042">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="79fe2-1043">Isso inclui qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1043">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-1044">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho de uma cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1044">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1045">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1045">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1046">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1046">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1047">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1047">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1048">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1048">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1049">`FileGet` lê todas as variáveis do disco de maneira contígua; ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1049">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1050">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGet` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1050">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="79fe2-1051">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1051">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="79fe2-1052">`FileGet` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1052">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1053">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1053">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="79fe2-1054">Leitura de um arquivo usando o `FileGet` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1054">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1055">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1055">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1056">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1056">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-1057">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1057">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1058">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1058">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1059">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1059">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1060">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1060">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1061">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1061">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1062">Nome de variável válido no qual os dados são lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1062">Valid variable name into which data is read.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1063">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1063">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1064">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a leitura começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1064">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1065">Lê dados de um arquivo aberto de disco em uma variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1065">Reads data from an open disk file into a variable.</span>
          </span>
          <span data-ttu-id="79fe2-1066">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileGetObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1066">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span>
          </span>
          <span data-ttu-id="79fe2-1067">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1067">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1068">O `FileGetObject` função é usada em vez de `FileGet` para evitar ambiguidades em tempo de compilação se tipo `Object` é retornado em vez de outro tipo, como `Integer`, `Long`, `Short`e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1068">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="79fe2-1069">Se você pretende gravar o `Variant` tipo, `FileGetObject` é necessária.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1069">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="79fe2-1070">Em caso de dúvida, se você estiver usando um objeto para o segundo parâmetro, é sempre aconselhável que você use `FilePutObject` e `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1070">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="79fe2-1071">`FileGetObject` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1071">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1072">Dados lidos com `FileGetObject` geralmente são gravados com `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1072">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="79fe2-1073">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1073">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1074">Se você omitir `RecordNumber`, `FileGetObject` lê o registro ou byte após a última `FileGetObject` ou `FilePutObject` função (ou apontada pela última `Seek` função).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1074">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1075">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1075">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1076">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1076">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1077">Se o comprimento dos dados que está sendo lidos for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FileGetObject` lê registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1077">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1078">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1078">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1079">Como a quantidade de dados de preenchimento não pode ser determinada precisamente, é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que está sendo lidos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1079">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="79fe2-1080">Se a variável que está sendo lida é uma cadeia de caracteres, por padrão `FileGetObject` lê um descritor de dois bytes que contém o comprimento da cadeia de caracteres e, em seguida, lê os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1080">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1081">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula do `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1081">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1082">Visual Basic 6.0 e versões anteriores dão suporte a cadeias de caracteres de comprimento fixo e ao ler um arquivo, o descritor de comprimento não é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1082">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="79fe2-1083">Se você deseja ler uma cadeia de caracteres sem o descritor, você deve passar `True` para o `StringIsFixedLength` parâmetro e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1083">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1084">Se a variável que está sendo lida é uma matriz e, em seguida, o comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1084">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1085">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1085">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1086">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1086">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="79fe2-1087">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1087">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="79fe2-1088">218 bytes são distribuídos da seguinte maneira: 18 bytes para o descritor (2 + 8 \* 2) e 100 bytes para os dados (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1088">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="79fe2-1089">`FileGetObject` lê os elementos de estruturas como se cada um estava sendo lido individualmente, exceto que não há nenhum preenchimento entre elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1089">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1090">No disco, uma matriz dinâmica em um tipo definido pelo usuário (escritos com `FilePutObject`) é prefixado por um descritor cujo comprimento é igual a 2 mais 8 vezes o número de dimensões: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1090">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="79fe2-1091">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessários para ler os elementos individuais, incluindo qualquer matrizes e seus descritores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1091">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="79fe2-1092">O <xref:Microsoft.VisualBasic.VBFixedStringAttribute> classe pode ser aplicada a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1092">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1093">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1093">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1094">Para arquivos abertos no `Binary` modo, todos os `Random` regras se aplicam, com as seguintes exceções:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1094">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="79fe2-1095">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1095">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1096">`FileGetObject` lê todas as variáveis do disco de forma contígua, ou seja, sem nenhum preenchimento entre registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1096">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1097">Para qualquer matriz que não seja uma matriz em uma estrutura, `FileGetObject` lê apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1097">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="79fe2-1098">Nenhum descritor é lido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1098">No descriptor is read.</span></span>  
  
 <span data-ttu-id="79fe2-1099">`FileGetObject` lê cadeias de caracteres de comprimento variável que não são elementos das estruturas sem esperar o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1099">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1100">O número de bytes lidos é igual ao número de caracteres já na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1100">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-1101">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1101">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-1102">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1102">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1103">O exemplo a seguir lê um registro em um arquivo de teste e, em seguida, irá recuperá-lo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1103">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-1104">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1104">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1105">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1105">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-1106">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1106">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1107">Expressão <see langword="String" /> que especifica um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1107">
              <see langword="String" /> expression that specifies a file.</span>
          </span>
          <span data-ttu-id="79fe2-1108">
            <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1108">
              <c>PathName</c> may include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1109">Retorna um valor <see langword="Long" /> que especifica o tamanho de um arquivo em bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1109">Returns a <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
          <span data-ttu-id="79fe2-1110">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileLen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1110">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span>
          </span>
          <span data-ttu-id="79fe2-1111">Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1111">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-1112">Valor <see langword="Long" /> que especifica o tamanho de um arquivo em bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1112">
              <see langword="Long" /> value that specifies the length of a file in bytes.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1113">Se o arquivo especificado estiver aberto quando o `FileLen` função é chamada, o valor retornado representa o tamanho do arquivo no momento em que ele foi aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1113">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-1114">Para obter o tamanho atual de um arquivo aberto, use o `LOF` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1114">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1115">Este exemplo usa o `FileLen` função para retornar o comprimento de um arquivo em bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1115">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="79fe2-1116">Para fins deste exemplo, suponha que `TestFile` é um arquivo que contém alguns dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1116">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-1117">Arquivo inexistente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1117">File does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-1118">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1118">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1119">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1119">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1120">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1120">Any valid file number.</span>
          </span>
          <span data-ttu-id="79fe2-1121">Use a função de <see langword="FreeFile" /> para obter o próximo número disponível de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1121">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span>
          </span>
        </param>
        <param name="FileName">
          <span data-ttu-id="79fe2-1122">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1122">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1123">Expressão <see langword="String" /> que especifica um nome de arquivo — pode incluir o diretório ou pasta, e unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1123">
              <see langword="String" /> expression that specifies a file name—may include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Mode">
          <span data-ttu-id="79fe2-1124">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1124">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1125">Enumeração especificando o modo de arquivo: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> ou <see langword="Random" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1125">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span>
          </span>
          <span data-ttu-id="79fe2-1126">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1126">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span>
          </span>
        </param>
        <param name="Access">
          <span data-ttu-id="79fe2-1127">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1127">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1128">Enumeração especificando as operações permitidas no arquivo aberto: <see langword="Read" />, <see langword="Write" /> ou <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1128">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="79fe2-1129">Assume o padrão de <see langword="ReadWrite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1129">Defaults to <see langword="ReadWrite" />.</span>
          </span>
          <span data-ttu-id="79fe2-1130">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1130">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span>
          </span>
        </param>
        <param name="Share">
          <span data-ttu-id="79fe2-1131">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1131">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1132">Enumeração especificando as operações não permitidas no arquivo aberto: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> ou <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1132">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="79fe2-1133">Assume o padrão de <see langword="Lock Read Write" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1133">Defaults to <see langword="Lock Read Write" />.</span>
          </span>
          <span data-ttu-id="79fe2-1134">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1134">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span>
          </span>
        </param>
        <param name="RecordLength">
          <span data-ttu-id="79fe2-1135">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1135">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1136">Número menor que ou igual a 32.767 (bytes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1136">Number less than or equal to 32,767 (bytes).</span>
          </span>
          <span data-ttu-id="79fe2-1137">Para arquivos abertos para acesso aleatório, esse valor é o tamanho do registro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1137">For files opened for random access, this value is the record length.</span>
          </span>
          <span data-ttu-id="79fe2-1138">Para arquivos sequenciais, esse valor é o número de caracteres armazenados em buffer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1138">For sequential files, this value is the number of characters buffered.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1139">Abre um arquivo para entrada ou saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1139">Opens a file for input or output.</span>
          </span>
          <span data-ttu-id="79fe2-1140">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1140">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span>
          </span>
          <span data-ttu-id="79fe2-1141">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1141">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1142">O `FileOpen` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1142">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-1143">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1143">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-1144">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1144">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-1145">Você deve abrir um arquivo antes de qualquer operação de e/s pode ser executada nele.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1145">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="79fe2-1146">`FileOpen` aloca um buffer de e/s para o arquivo e determina o modo de acesso para usar com o buffer.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1146">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-1147">Ao gravar em um arquivo, um aplicativo pode ter que criar um arquivo, se não existir o arquivo ao qual ele está tentando gravar.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1147">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="79fe2-1148">Para fazer isso, ele precisa de permissão para o diretório no qual o arquivo deve ser criado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1148">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="79fe2-1149">No entanto, se o arquivo especificado por `FileName` existir, o aplicativo precisa `Write` permissão somente para o arquivo propriamente dito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1149">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="79fe2-1150">Sempre que possível, para ajudar a melhorar a segurança, criar o arquivo durante a implantação e grant `Write` permissão a esse arquivo único, em vez de para todo o diretório.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1150">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="79fe2-1151">Para ajudar a aprimorar a segurança, gravar dados em diretórios de usuário em vez de para o diretório raiz ou o diretório de arquivos de programas.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1151">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="79fe2-1152">Para abrir o canal pode ser encontrado usando o `FreeFile()` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1152">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-1153">O `FileOpen` função requer `Read` acessar a partir de `FileIOPermissionAccess` enumeração, que pode afetar sua execução em situações de confiança parcial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1153">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="79fe2-1154">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1154">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1155">Este exemplo ilustra vários usos do `FileOpen` função para habilitar a entrada e saída para um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1155">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="79fe2-1156">O código a seguir abre o arquivo `TestFile` em `Input` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1156">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="79fe2-1157">Este exemplo abre o arquivo no `Binary` modo para gravar somente operações.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1157">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="79fe2-1158">O exemplo a seguir abre o arquivo no `Random` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1158">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="79fe2-1159">O arquivo contiver registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1159">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="79fe2-1160">Este exemplo de código abre o arquivo no `Output` modo; qualquer possível de processo de leitura ou gravação em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1160">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="79fe2-1161">Este exemplo de código abre o arquivo no `Binary` modo para leitura; outros processos não é possível ler o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1161">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1162">tamanho do registro é negativo (e não é igual a -1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1162">Record length is negative (and not equal to -1).</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1163">
            <paramref name="FileName" /> já está aberto ou <paramref name="FileName" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1163">
              <paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-1164">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1164">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1165">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1165">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-1166">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1166">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1167">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1167">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1168">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1168">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1169">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1169">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1170">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1170">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1171">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1171">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1172">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1172">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1173">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1173">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1174">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1174">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1175">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1175">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1176">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1176">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1177">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1177">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1178">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1178">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1179">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1179">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1180">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1180">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1181">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1181">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1182">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1182">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1183">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1183">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1184">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1184">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1185">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1185">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1186">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1186">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1187">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1187">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1188">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1188">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1189">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1189">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1190">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1190">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1191">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1191">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1192">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1192">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1193">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1193">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1194">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1194">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1195">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1195">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1196">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1196">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1197">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1197">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1198">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1198">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1199">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1199">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1200">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1200">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1201">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1201">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1202">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1202">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1203">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1203">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1204">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1204">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1205">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1205">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1206">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1206">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1207">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1207">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1208">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1208">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1209">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1209">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1210">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1210">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1211">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1211">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1212">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1212">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1213">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1213">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1214">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1214">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1215">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1215">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1216">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1216">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1217">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1217">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1218">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1218">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1219">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1219">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1220">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1220">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1221">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1221">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1222">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1222">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1223">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1223">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1224">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1224">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1225">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1225">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1226">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1226">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1227">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1227">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1228">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1228">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1229">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1229">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1230">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1230">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1231">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1231">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1232">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1232">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1233">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1233">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1234">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1234">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1235">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1235">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1236">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1236">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1237">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1237">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1238">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1238">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1239">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1239">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1240">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1240">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1241">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1241">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1242">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1242">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1243">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1243">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1244">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1244">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1245">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1245">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1246">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1246">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1247">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1247">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1248">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1248">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1249">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1249">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1250">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1250">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1251">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1251">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1252">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1252">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1253">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1253">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1254">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1254">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1255">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1255">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1256">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1256">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1257">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1257">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1258">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1258">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1259">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1259">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1260">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1260">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1261">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1261">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1262">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1262">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1263">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1263">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1264">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1264">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1265">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1265">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1266">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1266">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1267">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1267">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1268">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1268">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1269">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1269">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1270">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1270">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1271">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1271">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1272">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1272">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1273">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1273">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1274">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1274">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1275">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1275">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1276">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1276">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1277">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1277">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1278">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1278">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1279">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1279">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1280">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1280">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1281">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1281">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1282">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1282">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1283">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1283">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1284">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1284">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1285">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1285">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1286">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1286">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1287">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1287">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1288">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1288">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1289">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1289">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1290">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1290">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1291">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1291">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1292">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1292">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1293">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1293">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1294">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1294">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1295">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1295">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1296">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1296">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1297">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1297">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1298">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1298">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1299">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1299">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1300">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1300">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1301">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1301">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1302">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1302">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1303">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1303">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1304">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1304">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1305">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1305">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1306">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1306">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1307">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1307">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1308">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1308">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1309">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1309">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1310">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1310">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1311">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1311">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1312">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1312">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1313">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1313">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1314">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1314">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1315">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1315">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1316">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1316">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1317">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1317">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1318">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1318">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1319">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1319">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1320">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1320">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1321">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1321">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1322">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1322">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1323">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1323">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1324">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1324">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1325">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1325">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1326">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1326">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1327">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1327">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1328">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1328">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1329">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1329">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1330">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1330">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1331">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1331">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1332">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1332">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1333">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1333">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1334">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1334">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1335">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1335">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1336">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1336">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1337">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1337">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1338">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1338">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1339">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1339">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1340">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1340">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1341">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1341">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1342">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1342">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1343">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1343">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1344">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1344">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1345">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1345">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1346">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1346">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1347">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1347">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1348">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1348">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1349">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1349">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1350">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1350">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1351">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1351">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1352">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1352">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1353">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1353">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1354">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1354">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1355">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1355">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1356">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1356">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1357">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1357">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1358">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1358">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1359">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1359">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1360">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1360">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1361">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1361">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1362">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1362">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1363">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1363">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1364">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1364">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1365">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1365">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1366">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1366">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1367">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1367">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1368">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1368">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1369">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1369">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1370">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1370">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1371">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1371">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1372">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1372">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1373">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1373">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1374">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1374">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1375">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1375">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1376">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1376">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1377">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1377">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1378">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1378">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1379">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1379">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1380">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1380">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1381">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1381">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1382">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1382">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1383">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1383">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1384">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1384">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1385">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1385">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1386">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1386">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1387">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1387">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1388">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1388">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1389">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1389">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1390">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1390">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1391">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1391">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1392">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1392">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1393">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1393">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1394">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1394">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1395">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1395">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1396">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1396">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1397">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1397">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1398">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1398">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1399">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1399">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1400">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1400">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1401">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1401">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1402">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1402">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1403">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1403">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1404">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1404">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1405">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1405">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1406">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1406">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1407">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1407">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1408">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1408">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1409">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1409">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1410">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1410">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1411">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1411">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1412">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1412">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1413">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1413">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1414">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1414">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1415">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1415">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1416">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1416">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1417">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1417">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1418">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1418">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1419">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1419">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1420">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1420">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1421">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1421">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1422">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1422">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1423">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1423">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1424">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1424">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1425">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1425">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1426">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1426">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1427">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1427">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1428">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1428">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1429">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1429">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1430">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1430">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1431">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1431">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1432">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1432">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1433">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1433">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1434">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1434">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1435">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1435">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1436">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1436">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1437">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1437">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1438">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1438">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1439">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1439">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1440">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1440">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1441">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1441">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1442">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1442">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1443">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1443">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1444">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1444">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1445">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1445">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1446">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1446">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1447">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1447">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1448">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1448">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1449">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1449">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1450">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1450">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1451">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1451">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1452">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1452">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1453">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1453">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1454">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1454">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1455">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1455">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1456">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1456">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1457">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1457">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1458">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1458">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1459">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1459">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1460">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1460">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1461">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1461">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1462">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1462">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1463">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1463">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1464">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1464">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1465">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1465">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1466">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1466">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1467">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1467">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1468">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1468">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1469">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1469">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1470">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1470">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1471">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1471">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1472">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1472">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1473">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1473">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1474">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1474">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1475">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1475">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1476">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1476">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1477">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1477">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1478">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1478">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1479">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1479">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1480">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1480">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1481">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1481">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1482">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1482">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1483">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1483">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1484">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1484">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1485">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1485">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1486">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1486">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1487">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1487">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1488">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1488">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1489">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1489">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1490">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1490">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1491">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1491">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1492">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1492">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1493">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1493">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1494">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1494">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1495">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1495">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1496">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1496">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1497">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1497">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1498">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1498">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1499">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1499">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1500">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1500">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1501">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1501">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1502">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1502">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1503">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1503">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1504">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1504">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1505">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1505">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1506">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1506">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1507">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1507">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1508">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1508">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1509">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1509">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1510">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1510">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1511">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1511">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1512">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1512">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1513">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1513">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1514">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1514">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1515">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1515">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1516">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1516">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1517">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1517">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1518">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1518">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1519">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1519">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1520">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1520">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1521">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1521">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1522">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1522">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1523">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1523">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1524">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1524">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1525">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1525">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1526">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1526">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1527">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1527">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1528">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1528">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1529">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1529">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1530">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1530">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1531">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1531">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1532">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1532">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1533">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1533">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1534">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1534">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1535">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1535">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1536">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1536">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1537">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1537">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1538">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1538">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1539">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1539">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1540">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1540">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1541">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1541">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1542">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1542">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1543">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1543">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1544">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1544">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1545">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1545">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1546">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1546">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1547">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1547">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1548">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1548">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1549">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1549">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1550">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1550">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1551">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1551">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1552">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1552">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1553">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1553">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1554">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1554">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1555">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1555">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1556">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o`VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1556">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1557">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1557">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1558">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1558">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1559">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1559">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1560">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1560">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1561">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1561">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1562">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1562">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1563">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1563">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1564">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1564">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1565">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1565">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1566">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1566">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1567">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1567">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1568">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1568">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1569">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1569">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1570">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1570">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1571">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1571">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1572">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1572">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1573">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1573">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1574">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1574">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1575">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1575">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1576">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1576">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1577">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1577">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1578">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1578">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1579">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1579">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1580">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1580">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1581">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1581">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1582">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1582">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1583">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1583">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1584">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1584">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1585">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1585">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1586">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1586">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1587">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1587">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1588">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1588">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1589">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1589">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1590">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1590">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1591">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1591">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1592">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1592">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1593">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1593">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1594">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1594">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1595">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1595">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1596">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1596">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1597">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1597">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1598">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1598">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1599">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1599">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1600">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1600">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1601">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1601">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1602">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1602">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1603">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1603">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1604">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1604">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1605">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1605">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1606">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1606">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1607">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1607">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1608">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1608">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1609">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1609">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1610">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1610">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1611">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1611">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1612">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1612">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1613">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1613">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1614">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1614">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1615">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1615">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1616">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1616">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1617">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1617">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1618">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1618">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1619">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1619">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1620">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1620">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1621">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1621">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1622">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1622">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1623">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1623">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1624">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1624">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1625">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1625">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1626">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1626">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1627">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1627">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1628">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1628">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1629">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1629">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1630">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1630">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1631">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1631">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1632">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1632">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1633">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1633">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1634">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1634">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1635">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1635">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1636">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1636">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1637">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1637">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1638">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1638">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1639">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1639">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1640">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1640">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1641">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1641">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1642">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1642">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1643">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1643">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1644">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1644">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1645">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1645">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1646">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1646">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1647">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1647">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1648">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1648">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1649">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1649">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1650">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1650">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1651">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1651">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1652">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1652">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1653">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1653">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1654">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1654">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1655">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1655">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1656">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1656">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1657">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1657">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1658">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1658">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1659">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1659">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1660">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1660">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1661">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1661">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1662">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1662">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1663">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1663">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1664">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1664">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1665">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1665">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1666">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1666">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1667">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1667">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1668">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1668">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1669">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1669">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1670">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1670">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1671">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1671">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1672">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1672">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1673">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1673">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1674">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1674">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1675">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1675">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1676">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1676">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1677">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1677">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1678">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1678">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1679">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1679">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1680">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1680">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1681">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1681">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1682">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1682">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1683">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1683">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1684">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1684">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1685">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1685">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1686">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1686">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1687">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1687">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1688">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1688">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1689">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1690">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1690">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1691">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1691">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1692">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1692">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1693">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1693">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1694">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1694">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1695">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1695">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1696">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1696">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1697">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1697">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1698">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1698">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1699">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1699">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1700">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1700">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1701">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1701">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1702">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1702">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1703">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1703">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1704">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1704">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1705">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1705">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1706">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1706">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1707">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1707">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1708">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1708">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1709">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1709">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1710">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1710">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1711">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1711">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1712">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1712">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1713">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1713">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1714">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1714">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1715">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1715">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1716">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1716">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1717">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1717">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1718">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1718">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1719">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1719">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1720">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1720">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1721">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1721">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1722">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1722">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1723">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1723">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1724">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1724">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1725">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1725">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1726">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1726">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1727">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1727">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1728">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1728">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1729">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1729">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1730">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1730">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1731">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1731">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1732">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1732">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1733">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1733">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1734">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1734">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1735">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1735">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1736">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1736">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1737">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1737">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1738">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1738">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1739">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1739">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1740">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1740">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1741">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1741">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1742">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1742">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1743">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1743">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1744">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1744">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1745">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1745">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1746">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1747">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1747">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1748">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1748">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1749">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1750">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1750">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1751">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1751">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1752">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1752">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1753">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1753">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1754">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1754">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1755">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1755">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1756">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1756">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1757">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1757">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1758">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1758">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1759">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1759">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1760">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1760">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1761">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1761">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1762">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1762">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1763">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1763">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1764">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1764">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1765">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1765">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1766">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1766">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1767">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1767">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1768">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1768">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1769">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1769">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1770">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1770">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1771">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1771">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1772">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1772">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1773">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1773">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1774">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1774">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1775">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1775">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1776">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1776">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1777">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1777">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1778">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1778">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1779">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1779">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1780">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1780">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1781">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1781">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1782">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1782">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1783">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1783">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1784">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1784">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1785">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1785">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1786">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1786">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1787">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na`RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1787">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1788">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1788">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1789">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1789">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1790">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1790">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1791">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1791">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1792">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1792">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1793">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1793">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1794">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1794">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1795">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1795">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1796">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1796">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1797">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1798">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1798">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1799">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1799">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1800">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1800">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1801">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1801">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1802">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1802">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1803">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1803">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1804">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1804">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1805">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1805">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1806">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1806">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1807">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1807">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1808">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1808">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1809">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1809">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1810">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1810">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1811">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1811">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1812">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1812">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1813">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1813">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1814">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1814">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1815">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1815">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1816">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1816">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1817">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1817">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1818">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1818">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1819">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1819">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1820">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1820">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1821">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1821">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1822">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1822">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1823">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1823">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1824">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1824">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1825">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1825">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1826">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1826">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1827">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1827">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1828">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1828">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1829">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1829">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1830">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1830">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1831">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1831">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1832">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1832">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1833">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1833">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1834">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1834">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1835">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1835">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1836">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1836">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1837">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1837">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1838">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1838">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1839">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1839">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1840">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1840">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1841">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1841">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1842">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1842">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1843">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1843">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1844">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1844">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1845">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1845">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1846">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1846">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1847">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1847">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1848">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1848">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1849">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1849">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1850">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1850">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1851">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1851">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1852">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1852">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1853">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1853">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1854">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1854">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1855">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1855">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1856">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1856">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1857">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1857">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1858">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1858">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1859">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1859">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1860">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1860">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1861">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1861">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1862">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1862">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1863">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1863">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1864">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1864">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1865">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1865">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1866">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1866">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1867">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1867">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1868">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1868">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1869">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1869">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1870">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1870">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1871">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1871">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1872">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1872">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1873">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1873">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1874">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1874">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1875">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1875">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1876">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1876">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1877">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1877">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1878">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1878">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1879">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1879">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1880">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1880">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1881">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1881">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1882">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1882">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1883">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1883">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1884">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1884">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1885">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1885">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1886">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1886">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1887">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1887">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1888">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1888">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1889">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1889">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1890">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1890">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1891">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1891">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1892">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1892">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1893">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1893">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1894">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1894">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="79fe2-1895">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1895">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1896">Aplica-se somente ao gravar uma cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1896">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="79fe2-1897">Especifica se um descritor de comprimento de cadeia de caracteres de dois bytes da cadeia de caracteres deve ou não ser gravado no arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1897">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="79fe2-1898">O padrão é <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1898">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1899">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1899">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1900">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1900">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1901">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1901">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />..</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1902">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1902">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1903">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1903">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1904">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1904">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1905">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1905">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1906">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1906">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1907">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1907">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1908">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1908">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1909">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1909">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1910">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1910">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1911">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1911">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1912">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1912">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1913">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1913">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1914">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1914">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1915">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1915">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1916">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1916">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1917">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1917">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1918">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1918">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1919">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1919">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1920">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1920">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1921">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1921">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1922">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1922">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1923">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1923">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1924">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1924">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1925">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1925">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1926">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1926">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1927">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1927">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1928">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1928">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1929">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1929">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1930">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1930">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1931">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1931">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1932">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1932">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-1933">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1933">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-1934">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1934">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-1935">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1935">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-1936">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-1936">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-1937">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-1937">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-1938">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1938">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-1939">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1939">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-1940">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1940">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-1941">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1941">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-1942">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1942">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-1943">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1943">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-1944">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1944">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-1945">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1945">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-1946">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1946">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-1947">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1947">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-1948">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1948">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-1949">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1949">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-1950">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1950">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-1951">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1951">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-1952">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1952">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-1953">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1953">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1954">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1954">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-1955">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1955">Required.</span>
          </span>
          <span data-ttu-id="79fe2-1956">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1956">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-1957">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1957">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1958">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1958">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <param name="ArrayIsDynamic">
          <span data-ttu-id="79fe2-1959">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1959">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1960">Aplica-se somente ao gravar uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1960">Applies only when writing an array.</span>
          </span>
          <span data-ttu-id="79fe2-1961">Especifica se a matriz deve ou não ser tratada como dinâmica e se um descritor de matriz deve ou não ser gravado na cadeia de caracteres que descreve o comprimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1961">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span>
          </span>
        </param>
        <param name="StringIsFixedLength">
          <span data-ttu-id="79fe2-1962">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1962">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-1963">Aplica-se somente ao gravar uma cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1963">Applies only when writing a string.</span>
          </span>
          <span data-ttu-id="79fe2-1964">Especifica se um descritor de comprimento de cadeia de caracteres de dois bytes da cadeia de caracteres deve ou não ser gravado no arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1964">Specifies whether to write a two-byte string length descriptor for the string to the file.</span>
          </span>
          <span data-ttu-id="79fe2-1965">O padrão é <see langword="False" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1965">The default is <see langword="False" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-1966">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1966">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-1967">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePut" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1967">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span>
          </span>
          <span data-ttu-id="79fe2-1968">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-1968">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-1969">`FilePut` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1969">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-1970">Dados gravados com `FilePut` costumam ser lidos a partir de um arquivo usando `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1970">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="79fe2-1971">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1971">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-1972">Se você omitir `RecordNumber`, o próximo registro ou byte após a última `FileGet` ou `FilePut` funcionar ou apontado pela última `Seek` função é escrita.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1972">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="79fe2-1973">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1973">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-1974">`FilePut` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1974">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-1975">Se você usar `StringIsFixedLength`  =  `True` com `FilePut`, você precisa fazer o mesmo com `FileGet`, e você precisa certificar-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1975">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-1976">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-1976">Random Mode</span></span>  
 <span data-ttu-id="79fe2-1977">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-1977">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-1978">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePut` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1978">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-1979">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1979">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-1980">Como a quantidade de dados de preenchimento não pode ser determinada com certeza, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1980">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-1981">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será gerada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1981">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-1982">Caso a variável que está sendo gravada seja uma cadeia de caracteres, `FilePut` grava um descritor de dois bytes que contém o tamanho da cadeia de caracteres e, em seguida, grava os dados que vão para a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1982">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="79fe2-1983">Portanto, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser pelo menos dois bytes maior do que o comprimento real da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1983">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="79fe2-1984">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePut` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1984">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-1985">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePut` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1985">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-1986">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1986">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-1987">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePut` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1987">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-1988">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1988">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-1989">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1989">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-1990">Caso a variável gravada seja uma matriz, você tem a opção de gravar ou não um descritor para o tamanho e as dimensões da matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1990">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="79fe2-1991">O descritor de arquivo para uma matriz dinâmica, mas não para uma matriz de tamanho fixo de gravação do Visual Basic 6.0 e versões anteriores.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1991">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="79fe2-1992">O padrão do Visual Basic 2005 é não gravar o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1992">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="79fe2-1993">Para gravar o descritor, defina as `ArrayIsDynamic` parâmetro para `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1993">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="79fe2-1994">Ao escrever a matriz, você precisa comparar a forma com que a matriz será lida; se ela for lida com o descritor, você precisará escrever o descritor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1994">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="79fe2-1995">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1995">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-1996">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-1996">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="79fe2-1997">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1997">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-1998">Por exemplo, a seguinte declaração de matriz requer 218 bytes quando a matriz é gravada no disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1998">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="79fe2-1999">Se a variável que está sendo gravada for qualquer outro tipo de variável (não uma cadeia de caracteres de comprimento variável ou um objeto), `FilePut` grava apenas os dados da variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-1999">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="79fe2-2000">O comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual ao comprimento dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2000">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="79fe2-2001">`FilePut` grava os elementos de estruturas como se cada um fosse escrito individualmente, exceto que não há nenhum preenchimento entre os elementos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2001">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="79fe2-2002">O `VBFixedString` atributo pode ser aplicado a campos de cadeia de caracteres em estruturas para indicar o tamanho da cadeia de caracteres quando gravados em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2002">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="79fe2-2003">Os campos que têm mais bytes que o especificado pela cadeia de caracteres a `VBFixedString` atributo são truncados quando gravados em disco,</span><span class="sxs-lookup"><span data-stu-id="79fe2-2003">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-2004">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-2004">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-2005">Para arquivos abertos no `Binary` modo, a maioria do `Random` modo regras se aplicam, com algumas exceções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2005">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="79fe2-2006">As seguintes regras para arquivos abertos no `Binary` modo são diferentes das regras para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2006">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="79fe2-2007">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2007">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-2008">`FilePut` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2008">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="79fe2-2009">Para qualquer matriz que não seja uma matriz em uma estrutura, `FilePut` grava apenas os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2009">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="79fe2-2010">Nenhum descritor é escrito.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2010">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="79fe2-2011">`FilePut` Grava cadeias de caracteres de comprimento variável que não são elementos das estruturas sem o descritor de dois bytes de comprimento.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2011">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="79fe2-2012">O número de bytes gravados é igual ao número de caracteres na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2012">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="79fe2-2013">Por exemplo, as instruções a seguir escrever 11 bytes no arquivo número 1:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2013">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="79fe2-2014">A gravação em um arquivo usando a função `FilePut` requer o acesso `Write` da enumeração <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2014">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2015">Este exemplo usa o `FilePut` função para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2015">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="79fe2-2016">Cinco registros da estrutura `Person` são gravados no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2016">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2017">
            <paramref name="RecordNumber" /> &lt; 1 e não é igual a -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2017">
              <paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2018">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2018">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2019">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2019">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2020">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2020">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2021">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2021">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2022">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2022">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2023">Nome de variável válido que contém dados gravados em disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2023">Valid variable name that contains data written to disk.</span>
          </span>
        </param>
        <param name="RecordNumber">
          <span data-ttu-id="79fe2-2024">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2024">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2025">Registre o número (arquivos de modo <see langword="Random" />) ou número de byte (arquivos de modo <see langword="Binary" />) no qual a gravação começa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2025">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2026">Grava dados de uma variável em um arquivo de disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2026">Writes data from a variable to a disk file.</span>
          </span>
          <span data-ttu-id="79fe2-2027">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FilePutObject" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2027">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span>
          </span>
          <span data-ttu-id="79fe2-2028">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2028">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2029">O `FilePutObject` função é usada em vez de `FilePut` para evitar ambiguidades em tempo de compilação se tipo `Object` é passado em vez de outro tipo, como `Integer`, `Long`, `Short`e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2029">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="79fe2-2030">`FilePutObject` gravações e leituras de descritores que descrevem o objeto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2030">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="79fe2-2031">Se você pretende gravar o `Variant` tipo, `FilePutObject` é necessária.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2031">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="79fe2-2032">Em caso de dúvida, se você estiver usando um objeto para o segundo parâmetro, é recomendável que você sempre use `FilePutObject` e `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2032">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="79fe2-2033">`FilePutObject` só é válido em `Random` e `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2033">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-2034">Dados gravados com `FilePutObject` costumam ser lidos a partir de um arquivo usando `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2034">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="79fe2-2035">O primeiro registro ou byte em um arquivo está na posição 1, o segundo registro ou byte está na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2035">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="79fe2-2036">Se você omitir `RecordNumber`, `FilePutObject` grava o próximo registro ou byte após a última `FileGetObject` ou `FilePutObject` função (ou o registro ou byte apontado pela última `Seek` função).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2036">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="79fe2-2037">O argumento `StringIsFixedLength` controla se a função interpreta cadeias de caracteres como sendo de tamanho variável ou fixo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2037">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="79fe2-2038">`FilePutObject` não grava o descritor do tamanho quando o argumento é `True`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2038">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="79fe2-2039">Se você usar `StringIsFixedLength`  =  `True` com `FilePutObject`, você precisa fazer o mesmo com `FileGetObject`, e você deve também Certifique-se de que a cadeia de caracteres é inicializada com o tamanho esperado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2039">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="79fe2-2040">Modo aleatório</span><span class="sxs-lookup"><span data-stu-id="79fe2-2040">Random Mode</span></span>  
 <span data-ttu-id="79fe2-2041">Para arquivos abertos no `Random` modo, as seguintes regras se aplicam:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2041">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="79fe2-2042">Se o comprimento dos dados que estão sendo gravados for menor que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, `FilePutObject` grava registros subsequentes em limites de comprimento de registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2042">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="79fe2-2043">O espaço entre o final de um registro e o início do próximo registro é preenchido com o conteúdo existente no buffer de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2043">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="79fe2-2044">Como a quantidade de dados de preenchimento não pode ser determinada precisamente, geralmente é uma boa ideia ter o comprimento do registro corresponde ao tamanho dos dados que estão sendo gravados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2044">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="79fe2-2045">Se o comprimento dos dados que estão sendo gravados for maior que o comprimento especificado na `RecordLength` cláusula do `FileOpen` função, uma exceção será lançada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2045">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="79fe2-2046">Caso a variável que está sendo gravada seja um objeto que contém um tipo numérico, `FilePutObject` grava dois bytes que identificam o `VarType` do objeto e, em seguida, grava a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2046">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="79fe2-2047">Por exemplo, ao escrever um objeto que contém um número inteiro, `FilePutObject` grava seis bytes: dois bytes que identificam o objeto como `VarType(3)` (`Integer`) e quatro bytes que contêm os dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2047">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="79fe2-2048">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser pelo menos dois bytes maior do que o número real de bytes necessários para armazenar a variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2048">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="79fe2-2049">Se a variável que está sendo gravada for um objeto que contém uma cadeia de caracteres `FilePutObject` grava um descritor de dois bytes que identifica o `VarType(8)` do objeto, um descritor de dois bytes indicando o comprimento da cadeia de caracteres e, em seguida, grava os dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2049">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="79fe2-2050">O comprimento do registro especificado pelo `RecordLength` parâmetro no `FileOpen` função deve ser maior que o comprimento real da cadeia de caracteres de pelo menos quatro bytes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2050">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="79fe2-2051">Caso queira colocar uma cadeia de caracteres sem o descritor, você deve passar `True` para o parâmetro `StringIsFixedLength`, e a cadeia de caracteres lida deve ter o tamanho correto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2051">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="79fe2-2052">Se a variável que está sendo gravada seja uma matriz e, em seguida, o comprimento do registro especificado pelo `RecordLength` cláusula no `FileOpen` função deve ser maior que ou igual à soma de todos os bytes necessário para gravar os dados de matriz e o descritor de matriz.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2052">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="79fe2-2053">O descritor especifica a classificação de matriz, o tamanho e os limites inferiores para cada classificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2053">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="79fe2-2054">Seu comprimento é igual a 2 mais 8 vezes o número de dimensões: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2054">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="79fe2-2055">Modo binário</span><span class="sxs-lookup"><span data-stu-id="79fe2-2055">Binary Mode</span></span>  
 <span data-ttu-id="79fe2-2056">Para arquivos abertos no `Binary` modo, todos os o `Random` aplicarem regras de modo, exceto:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2056">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="79fe2-2057">A cláusula `RecordLength` na função de `FileOpen` não está em vigor.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2057">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="79fe2-2058">`FilePutObject` grava todas as variáveis em disco de maneira contígua, ou seja, sem preenchimento entre os registros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2058">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2059">Este exemplo usa o `FilePutObject` função para gravar uma cadeia de caracteres em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2059">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2060">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2060">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2061">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2061">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2062">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2062">Any valid file number.</span>
          </span>
        </param>
        <param name="RecordWidth">
          <span data-ttu-id="79fe2-2063">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2063">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2064">Expressão numérica no intervalo 0 a 255, inclusive, que indica quantos caracteres são exibidos em uma linha antes de uma nova linha ser iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2064">Numeric expression in the range 0–255, inclusive, which indicates how many characters appear on a line before a new line is started.</span>
          </span>
          <span data-ttu-id="79fe2-2065">Se <c>RecordWidth</c> for igual a 0, não haverá nenhum limite para o tamanho de uma linha.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2065">If <c>RecordWidth</c> equals 0, there is no limit to the length of a line.</span>
          </span>
          <span data-ttu-id="79fe2-2066">O valor padrão de <c>RecordWidth</c> é 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2066">The default value for <c>RecordWidth</c> is 0.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2067">Atribui uma largura de linha de saída a um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2067">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="79fe2-2068">Este exemplo usa o `FileWidth` função para definir a largura da linha de saída para um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2068">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2069">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2069">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2070">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2070">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2071">Retorna um valor <see langword="Integer" /> que representa o próximo número de arquivo disponível para uso pela função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2071">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2072">Retorna um valor <see langword="Integer" /> que representa o próximo número de arquivo disponível para uso pela função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2072">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2073">Use `FreeFile` para fornecer um número de arquivo que já não está sendo usado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2073">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2074">Este exemplo usa o `FreeFile` função para retornar o próximo número de arquivos disponíveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2074">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="79fe2-2075">Cinco arquivos são abertos para saída dentro do loop, e alguns dados de exemplo são gravados para cada um.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2075">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2076">Mais de 255 arquivos estão em uso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2076">More than 255 files are in use.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2077">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2077">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-2078">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2078">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2079">A expressão <see langword="String" /> que especifica um nome de arquivo, diretório ou pasta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2079">
              <see langword="String" /> expression that specifies a file, directory, or folder name.</span>
          </span>
          <span data-ttu-id="79fe2-2080">
            <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2080">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2081">Retorna um valor <see langword="FileAttribute" /> que representa os atributos de um arquivo, diretório ou pasta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2081">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span>
          </span>
          <span data-ttu-id="79fe2-2082">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="FileAttribute" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2082">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span>
          </span>
          <span data-ttu-id="79fe2-2083">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2083">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2084">O valor retornado por <see langword="GetAttr" /> é a soma dos seguintes valores de enumeração:</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2084">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span>
          </span>
          <list type="table">
            <item>
              <term>
                <span data-ttu-id="79fe2-2085">Valor</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2085">Value</span>
                </span>
              </term>
              <description>
                <span data-ttu-id="79fe2-2086">Constante</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2086">Constant</span>
                </span>
              </description>
              <description>
                <span data-ttu-id="79fe2-2087">Descrição</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2087">Description</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="Normal" />
              </term>
              <description>
                <see langword="vbNormal" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2088">Normal.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2088">Normal.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="ReadOnly" />
              </term>
              <description>
                <see langword="vbReadOnly" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2089">Somente leitura.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2089">Read-only.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="Hidden" />
              </term>
              <description>
                <see langword="vbHidden" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2090">Oculto.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2090">Hidden.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="System" />
              </term>
              <description>
                <see langword="vbSystem" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2091">Arquivo do sistema.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2091">System file.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="Directory" />
              </term>
              <description>
                <see langword="vbDirectory" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2092">Diretório ou pasta.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2092">Directory or folder.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="Archive" />
              </term>
              <description>
                <see langword="vbArchive" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2093">O arquivo foi alterado desde o último backup.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2093">File has changed since last backup.</span>
                </span>
              </description>
            </item>
            <item>
              <term>
                <see langword="Alias" />
              </term>
              <description>
                <see langword="vbAlias" />
              </description>
              <description>
                <span data-ttu-id="79fe2-2094">O arquivo tem um nome diferente.</span>
                <span class="sxs-lookup">
                  <span data-stu-id="79fe2-2094">File has a different name.</span>
                </span>
              </description>
            </item>
          </list>
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="79fe2-2095">Essas enumerações são especificadas pela linguagem Visual Basic.</span>
              <span class="sxs-lookup">
                <span data-stu-id="79fe2-2095">These enumerations are specified by the Visual Basic language.</span>
              </span>
              <span data-ttu-id="79fe2-2096">Os nomes podem ser usados em qualquer lugar no seu código em vez dos valores reais.</span>
              <span class="sxs-lookup">
                <span data-stu-id="79fe2-2096">The names can be used anywhere in your code in place of the actual values.</span>
              </span>
            </para>
          </block>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2097">Para determinar quais atributos estão definidos, use o `And` operador para executar uma comparação bit a bit do valor retornado pelo `GetAttr` função e o valor do atributo de arquivo individual desejado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2097">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="79fe2-2098">Se o resultado não for zero, esse atributo é definido para o arquivo nomeado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2098">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="79fe2-2099">Por exemplo, o valor de retorno dos seguintes `And` expressão for zero, se o `Archive` atributo não for definido:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2099">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="79fe2-2100">Um valor diferente de zero será retornado se o `Archive` atributo é definido.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2100">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2101">Este exemplo usa o `GetAttr` função para determinar os atributos de um arquivo e diretório ou pasta.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2101">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2102">
            <paramref name="Pathname" /> é inválido ou contém caracteres curinga.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2102">
              <paramref name="Pathname" /> is invalid or contains wildcards.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-2103">O arquivo de destino não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2103">Target file does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md">
          <span data-ttu-id="79fe2-2104">Operador And (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2104">And Operator (Visual Basic)</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2105">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2105">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2106">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2106">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2107">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2107">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2108">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2108">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2109">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2109">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2110">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2110">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2111">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2111">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2112">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2112">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2113">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2113">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2114">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2114">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2115">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2115">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2116">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2116">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2117">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2117">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2118">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2118">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2119">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2119">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2120">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2120">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2121">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2121">Data</span></span>|<span data-ttu-id="79fe2-2122">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2122">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2123">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2123">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2124">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2124">Empty</span></span>|  
|<span data-ttu-id="79fe2-2125">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2125">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2126"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2126">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2127">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2127">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2128">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2128">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2129">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2129">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2130">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2130">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2131">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2131">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2132">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2132">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2133">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2133">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2134">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2134">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2135">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2135">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2136">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2136">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2137">Este exemplo supõe que `TestFile` é um arquivo que tem algumas linhas de dados gravados nele usando o `Write` funcionar, cada linha que contém uma cadeia de caracteres entre aspas e um número separado por uma vírgula, por exemplo: ("Olá", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2137">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2138">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2138">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2139">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2139">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2140">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2140">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2141">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2141">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2142">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2142">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2143">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2143">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2144">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2144">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2145">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2145">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2146">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2146">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2147">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2147">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2148">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2148">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2149">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2149">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2150">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2150">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2151">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2151">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2152">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2152">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2153">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2153">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2154">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2154">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2155">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2155">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2156">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2156">Data</span></span>|<span data-ttu-id="79fe2-2157">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2157">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2158">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2158">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2159">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2159">Empty</span></span>|  
|<span data-ttu-id="79fe2-2160">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2160">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2161"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2161">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2162">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2162">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2163">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2163">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2164">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2164">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2165">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2165">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2166">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2166">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2167">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2167">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2168">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2168">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2169">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2169">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2170">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2170">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2171">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2171">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2172">Este exemplo supõe que `TestFile` é um arquivo que tem algumas linhas de dados gravados nele usando o `Write` funcionar, cada linha que contém uma cadeia de caracteres entre aspas e um número separado por uma vírgula, por exemplo: ("Olá", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2172">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2173">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2173">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2174">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2174">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2175">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2175">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2176">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2176">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2177">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2177">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2178">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2178">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2179">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2179">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2180">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2180">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2181">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2181">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2182">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2182">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2183">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2183">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2184">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2184">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2185">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2185">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2186">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2186">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2187">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2187">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2188">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2188">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2189">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2189">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2190">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2190">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2191">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2191">Data</span></span>|<span data-ttu-id="79fe2-2192">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2192">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2193">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2193">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2194">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2194">Empty</span></span>|  
|<span data-ttu-id="79fe2-2195">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2195">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2196"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2196">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2197">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2197">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2198">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2198">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2199">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2199">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2200">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2200">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2201">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2201">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2202">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2202">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2203">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2203">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2204">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2204">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2205">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2205">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2206">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2206">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2207">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2207">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2208">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2208">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2209">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2209">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2210">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2210">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2211">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2211">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2212">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2212">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2213">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2213">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2214">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2214">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2215">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2215">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2216">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2216">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2217">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2217">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2218">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2218">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2219">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2219">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2220">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2220">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2221">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2221">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2222">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2222">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2223">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2223">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2224">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2224">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2225">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2225">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2226">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2226">Data</span></span>|<span data-ttu-id="79fe2-2227">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2227">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2228">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2228">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2229">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2229">Empty</span></span>|  
|<span data-ttu-id="79fe2-2230">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2230">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2231"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2231">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2232">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2232">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2233">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2233">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2234">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2234">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2235">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2235">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2236">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2236">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2237">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2237">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2238">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2238">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2239">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2239">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2240">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2240">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2241">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2241">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2242">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2242">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2243">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2243">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2244">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2244">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2245">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2245">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2246">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2246">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2247">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2247">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2248">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2248">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2249">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2249">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2250">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2250">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2251">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2251">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2252">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2252">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2253">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2253">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2254">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2254">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2255">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2255">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2256">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2256">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2257">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2257">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2258">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2258">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2259">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2259">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2260">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2260">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2261">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2261">Data</span></span>|<span data-ttu-id="79fe2-2262">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2262">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2263">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2263">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2264">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2264">Empty</span></span>|  
|<span data-ttu-id="79fe2-2265">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2265">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2266"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2266">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2267">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2267">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2268">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2268">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2269">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2269">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2270">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2270">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2271">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2271">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2272">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2272">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2273">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2273">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2274">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2274">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2275">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2275">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2276">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2276">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2277">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2277">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2278">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2278">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2279">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2279">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2280">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2280">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2281">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2281">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2282">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2282">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2283">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2283">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2284">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2284">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2285">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2285">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2286">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2286">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2287">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2287">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2288">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2288">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2289">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2289">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2290">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2290">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2291">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2291">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2292">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2292">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2293">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2293">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2294">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2294">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2295">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2295">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2296">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2296">Data</span></span>|<span data-ttu-id="79fe2-2297">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2297">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2298">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2298">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2299">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2299">Empty</span></span>|  
|<span data-ttu-id="79fe2-2300">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2300">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2301"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2301">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2302">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2302">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2303">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2303">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2304">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2304">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2305">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2305">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2306">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2306">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2307">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2307">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2308">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2308">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2309">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2309">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2310">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2310">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2311">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2311">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2312">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2312">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2313">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2313">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2314">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2314">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2315">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2315">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2316">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2316">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2317">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2317">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2318">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2318">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2319">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2319">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2320">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2320">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2321">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2321">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2322">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2322">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2323">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2323">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2324">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2324">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2325">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2325">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2326">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2326">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2327">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2327">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2328">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2328">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2329">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2329">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2330">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2330">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2331">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2331">Data</span></span>|<span data-ttu-id="79fe2-2332">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2332">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2333">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2333">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2334">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2334">Empty</span></span>|  
|<span data-ttu-id="79fe2-2335">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2335">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2336"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2336">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2337">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2337">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2338">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2338">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2339">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2339">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2340">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2340">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2341">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2341">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2342">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2342">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2343">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2343">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2344">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2344">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2345">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2345">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2346">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2346">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2347">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2347">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2348">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2348">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2349">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2349">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2350">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2350">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2351">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2351">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2352">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2352">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2353">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2353">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2354">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2354">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2355">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2355">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2356">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2356">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2357">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2357">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2358">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2358">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2359">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2359">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2360">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2360">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2361">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2361">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2362">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2362">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2363">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2363">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2364">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2364">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2365">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2365">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2366">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2366">Data</span></span>|<span data-ttu-id="79fe2-2367">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2367">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2368">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2368">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2369">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2369">Empty</span></span>|  
|<span data-ttu-id="79fe2-2370">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2370">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2371"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2371">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2372">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2372">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2373">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2373">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2374">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2374">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2375">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2375">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2376">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2376">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2377">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2377">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2378">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, como a vírgula é tratada como um separador variável, em vez de como um ponto decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2378">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2379">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2379">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2380">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2380">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2381">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2381">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2382">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2382">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2383">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2383">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2384">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2384">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2385">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2385">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2386">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2386">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2387">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2387">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2388">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2388">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2389">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2389">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2390">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2390">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2391">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2391">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2392">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2392">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2393">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2393">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2394">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2394">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2395">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2395">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2396">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2396">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2397">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2397">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2398">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2398">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2399">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2399">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2400">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2400">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2401">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2401">Data</span></span>|<span data-ttu-id="79fe2-2402">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2402">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2403">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2403">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2404">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2404">Empty</span></span>|  
|<span data-ttu-id="79fe2-2405">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2405">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2406"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2406">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2407">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2407">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2408">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2408">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2409">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2409">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2410">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2410">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2411">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2411">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2412">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2412">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2413">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2413">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2414">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2414">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2415">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2415">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2416">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2416">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2417">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2417">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2418">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2418">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2419">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2419">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2420">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2420">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2421">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2421">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2422">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2422">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2423">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2423">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2424">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2424">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2425">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2425">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2426">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2426">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2427">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2427">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2428">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2428">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2429">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2429">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2430">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2430">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2431">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2431">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2432">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2432">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2433">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2433">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2434">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2434">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2435">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2435">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2436">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2436">Data</span></span>|<span data-ttu-id="79fe2-2437">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2437">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2438">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2438">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2439">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2439">Empty</span></span>|  
|<span data-ttu-id="79fe2-2440">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2440">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2441"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2441">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2442">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2442">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2443">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2443">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2444">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2444">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2445">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2445">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2446">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2446">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2447">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2447">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2448">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2448">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2449">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2449">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2450">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2450">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2451">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2451">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2452">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2452">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2453">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2453">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2454">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2454">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2455">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2455">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2456">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2456">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2457">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2457">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2458">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2458">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2459">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2459">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2460">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2460">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2461">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2461">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2462">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2462">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2463">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2463">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2464">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2464">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2465">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2465">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2466">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2466">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2467">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2467">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2468">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2468">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2469">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2469">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2470">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2470">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2471">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2471">Data</span></span>|<span data-ttu-id="79fe2-2472">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2472">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2473">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2473">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2474">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2474">Empty</span></span>|  
|<span data-ttu-id="79fe2-2475">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2475">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2476"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2476">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2477">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2477">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2478">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2478">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2479">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2479">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2480">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2480">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2481">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2481">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2482">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2482">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2483">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2483">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2484">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2484">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2485">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2485">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2486">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2486">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2487">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2487">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2488">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2488">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2489">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2489">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2490">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2490">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2491">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2491">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2492">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2492">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2493">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2493">Any valid file number.</span>
          </span>
        </param>
        <param name="Value">
          <span data-ttu-id="79fe2-2494">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2494">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2495">A variável à qual os valores lidos do arquivo são atribuídos, não pode ser uma variável de objeto ou matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2495">Variable that is assigned the values read from the file—cannot be an array or object variable.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2496">Lê dados de um arquivo sequencial aberto e atribui os dados a variáveis.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2496">Reads data from an open sequential file and assigns the data to variables.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2497">O `Input` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2497">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2498">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2498">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2499">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2499">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2500">Dados lidos com `Input` costumam ser gravados em um arquivo usando-se `Write`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2500">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="79fe2-2501">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2501">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2502">Ao ler de arquivos, não tome decisões sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2502">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2503">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo fonte do Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2503">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="79fe2-2504">Quando lidos, dados numéricos ou cadeia de caracteres padrão são atribuídos a variáveis sem modificação.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2504">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="79fe2-2505">A tabela a seguir ilustra como outros dados de entrada são tratados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2505">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="79fe2-2506">Dados</span><span class="sxs-lookup"><span data-stu-id="79fe2-2506">Data</span></span>|<span data-ttu-id="79fe2-2507">Valor atribuído à variável</span><span class="sxs-lookup"><span data-stu-id="79fe2-2507">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="79fe2-2508">Delimitador de vírgula ou linha em branco</span><span class="sxs-lookup"><span data-stu-id="79fe2-2508">Delimiting comma or blank line</span></span>|<span data-ttu-id="79fe2-2509">Vazio</span><span class="sxs-lookup"><span data-stu-id="79fe2-2509">Empty</span></span>|  
|<span data-ttu-id="79fe2-2510">NULL # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2510">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="79fe2-2511"># TRUE ou FALSE de # #</span><span class="sxs-lookup"><span data-stu-id="79fe2-2511">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="79fe2-2512">`True` ou `False`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2512">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="79fe2-2513">A data e/ou hora representada pela expressão</span><span class="sxs-lookup"><span data-stu-id="79fe2-2513">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="79fe2-2514">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="79fe2-2514">#ERROR `errornumber`#</span></span>|<span data-ttu-id="79fe2-2515">`errornumber` (a variável é um objeto marcado como um erro)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2515">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="79fe2-2516">Caso você atinja o final do arquivo enquanto insere um item de dados, a entrada é interrompida e ocorre um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2516">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2517">O `Input` função não está localizada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2517">The `Input` function is not localized.</span></span> <span data-ttu-id="79fe2-2518">Por exemplo, na versão em alemão, caso você insira 3,14159, ele retorna apenas 3, porque a vírgula é tratada como um separador variável, em vez de uma vírgula decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2518">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2519">Leitura de um arquivo usando o `Input` função requer `Read` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2519">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2520">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2520">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2521">Este exemplo usa o `Input` função para ler dados de um arquivo em duas variáveis.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2521">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="79fe2-2522">Este exemplo pressupõe que `TestFile` seja um arquivo tendo várias linhas de dados gravadas usando a função `Write`, cada linha contendo uma cadeia de caracteres entre aspas e um número separado por uma vírgula; por exemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2522">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2523">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2523">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2524">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2524">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2525">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2525">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2526">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2526">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2527">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2527">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2528">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2528">Any valid file number.</span>
          </span>
        </param>
        <param name="CharCount">
          <span data-ttu-id="79fe2-2529">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2529">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2530">Qualquer expressão numérica válida que especifica o número de caracteres a serem lidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2530">Any valid numeric expression specifying the number of characters to read.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2531">Retorna o valor <see langword="String" /> que contém caracteres de um arquivo aberto no modo <see langword="Input" /> ou <see langword="Binary" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2531">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="79fe2-2532">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2532">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
          <span data-ttu-id="79fe2-2533">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2533">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2534">Retorna o valor <see langword="String" /> que contém caracteres de um arquivo aberto no modo <see langword="Input" /> ou <see langword="Binary" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2534">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span>
          </span>
          <span data-ttu-id="79fe2-2535">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="InputString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2536">O `InputString` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2536">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2537">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2537">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2538">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2538">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2539">Dados lidos com o `InputString` função geralmente é gravada em um arquivo usando `Print` ou `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2539">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="79fe2-2540">Use essa função somente com arquivos abertos no `Input` ou `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2540">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="79fe2-2541">Ao contrário do `Input` função, o `InputString` função retorna todos os caracteres que ele lê.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2541">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="79fe2-2542">Isso inclui vírgulas, retornos de carro, alimentação de linha, as aspas e espaços à esquerda.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2542">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="79fe2-2543">Com arquivos abertos para `Binary` acessar, uma tentativa de ler o arquivo usando o `InputString` funcionando até `EOF` retorna `True` gera um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2543">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="79fe2-2544">Use o `LOF` e `Loc` funções em vez de `EOF` quando você ler arquivos binários usando `InputString`, ou use `FileGet` quando você usa o `EOF` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2544">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2545">Ao ler de arquivos, não tome decisões de segurança sobre o conteúdo do arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2545">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2546">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2546">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2547">Este exemplo usa o `InputString` função para ler um caractere por vez de um arquivo e imprimi-lo para o `Output` janela.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2547">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="79fe2-2548">Este exemplo supõe que `MyFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2548">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2549">
            <paramref name="FileNumber" /> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2549">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2550">
            <paramref name="CharCount" /> &lt; 0 ou &gt; 214.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2550">
              <paramref name="CharCount" /> &lt; 0 or &gt; 214.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2551">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2551">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2552">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2552">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2553">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2553">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-2554">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2554">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2555">Expressão <see langword="String" /> que especifica um ou mais nomes de arquivo a serem excluídos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2555">
              <see langword="String" /> expression that specifies one or more file names to be deleted.</span>
          </span>
          <span data-ttu-id="79fe2-2556">
            <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2556">
              <c>PathName</c> can include the directory or folder, and the drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2557">Exclui arquivos de um disco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2557">Deletes files from a disk.</span>
          </span>
          <span data-ttu-id="79fe2-2558">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Kill" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2558">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span>
          </span>
          <span data-ttu-id="79fe2-2559">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2559">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2560">`Kill` suporta o uso de vários caracteres (`*`) e de caractere único (`?`) caracteres curinga para especificar vários arquivos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2560">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="79fe2-2561">**Observação de segurança** para executar, o `Kill` função requer `Read` e `PathDiscovery` sinalizadores de <xref:System.Security.Permissions.FileIOPermission> sejam concedidas ao código em execução.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2561">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="79fe2-2562">Para obter mais informações, consulte <xref:System.Security.SecurityException> [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="79fe2-2562">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2563">Este exemplo usa o `Kill` função para excluir um arquivo de um disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2563">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2564">Arquivos de destino abertos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2564">Target file(s) open.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-2565">Arquivos de destino não encontrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2565">Target file(s) not found.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="79fe2-2566">Permissão negada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2566">Permission denied.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2567">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2567">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2568">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2568">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2569">Lê uma única linha de um arquivo sequencial aberto e a atribui a uma variável <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2569">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2570">Lê uma única linha de um arquivo sequencial aberto e a atribui a uma variável <see langword="String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2570">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2571">O `LineInput` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2571">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2572">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2572">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2573">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2573">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2574">Dados lidos com `LineInput` costumam ser gravados em um arquivo usando-se `Print`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2574">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2575">Ao ler de arquivos, não tome decisões sobre o conteúdo de um arquivo com base na extensão de nome de arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2575">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="79fe2-2576">Por exemplo, um arquivo chamado Form1.vb não pode ser um arquivo de origem do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2576">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="79fe2-2577">O `LineInput` função lê a partir de um caractere de um arquivo por vez até encontrar um retorno de carro (`Chr(13)`) ou retorno/alimentação de linha de carro (`Chr(13) + Chr(10)`) sequência.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2577">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="79fe2-2578">Sequências de feed de linha/retorno de carro são ignoradas em vez de acrescentado à cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2578">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2579">Leitura de um arquivo usando o `LineInput` função requer `Read` acessar do <xref:System.Security.Permissions.FileIOPermissionAccess> enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2579">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2580">Este exemplo usa o `LineInput` função ler uma linha de um arquivo sequencial e atribuí-lo a uma variável.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2580">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="79fe2-2581">Este exemplo supõe que `TestFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2581">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException">
          <span data-ttu-id="79fe2-2582">Fim do arquivo atingido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2582">End of file reached.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2583">
            <paramref name="FileNumber" /> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2583">
              <paramref name="FileNumber" /> does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2584">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2584">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2585">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2585">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2586">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2586">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2587">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2587">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2588">Qualquer número de arquivo <see langword="Integer" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2588">Any valid <see langword="Integer" /> file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2589">Retorna um <see langword="Long" /> valor que especifica a posição de leitura/gravação atual em um arquivo aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2589">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2590">Retorna um <see langword="Long" /> valor que especifica a posição de leitura/gravação atual em um arquivo aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2590">Returns a <see langword="Long" /> value that specifies the current read/write position in an open file.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2591">O `Loc` função é baseado em zero; usá-lo para recuperar o primeiro byte em um arquivo, retornará 0.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2591">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="79fe2-2592">O `Loc` função é fornecida para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2592">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2593">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2593">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2594">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2594">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2595">O exemplo a seguir descreve o valor de retorno para cada modo de acesso do arquivo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2595">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="79fe2-2596">Modo</span><span class="sxs-lookup"><span data-stu-id="79fe2-2596">Mode</span></span>|<span data-ttu-id="79fe2-2597">Valor retornado</span><span class="sxs-lookup"><span data-stu-id="79fe2-2597">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="79fe2-2598">Número do último registro lido ou gravado no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2598">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="79fe2-2599">Posição atual do byte no arquivo dividida por 128.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2599">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="79fe2-2600">No entanto, a informações retornadas pelo `Loc` para arquivos sequenciais não é usada nem necessário.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2600">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="79fe2-2601">Posição do último byte lido ou gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2601">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2602">Este exemplo usa o `Loc` função para retornar a posição de leitura/gravação atual em um arquivo aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2602">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="79fe2-2603">Este exemplo supõe que `MyFile` é um arquivo de texto que tenha várias linhas de dados de exemplo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2603">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2604">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2604">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2605">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2605">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2606">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2606">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2607">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2607">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2608">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2608">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2609">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2609">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2610">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2610">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2611">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2611">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2612">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2612">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2613">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2613">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2614">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2614">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2615">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2615">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2616">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2616">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2617">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2617">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2618">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2618">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2619">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2619">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2620">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2620">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2621">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2621">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2622">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2622">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2623">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2623">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2624">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2624">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="79fe2-2625">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2625">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2626">Número do único registro ou byte a ser bloqueado ou desbloqueado</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2626">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2627">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2627">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2628">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2628">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2629">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2629">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2630">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2630">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2631">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2631">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2632">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2632">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2633">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2633">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2634">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2634">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2635">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2635">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2636">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2636">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2637">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2637">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2638">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2638">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2639">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2639">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2640">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2640">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2641">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2641">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="79fe2-2642">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2642">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2643">Número do primeiro registro ou byte a ser bloqueado ou desbloqueado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2643">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="79fe2-2644">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2644">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2645">Número do último registro ou byte a ser bloqueado ou desbloqueado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2645">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2646">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2646">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2647">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2647">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2648">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2648">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2649">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2649">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2650">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2650">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2651">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2651">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2652">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2652">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2653">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2653">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2654">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2654">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2655">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2655">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2656">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2656">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2657">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2657">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2658">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2658">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2659">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2659">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2660">Um <see langword="Integer" /> que contém um número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2660">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2661">Retorna um <see langword="Long" /> que representa o tamanho, em bytes, de um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2661">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2662">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2662">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
          <span data-ttu-id="79fe2-2663">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2663">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2664">Retorna um <see langword="Long" /> que representa o tamanho, em bytes, de um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2664">Returns a <see langword="Long" /> representing the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2665">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="LOF" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2665">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2666">Use o `FileLen` função para obter o comprimento de um arquivo que não está aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2666">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2667">Este exemplo usa o `LOF` função para determinar o tamanho de um arquivo aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2667">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="79fe2-2668">Este exemplo supõe que `TestFile` é um arquivo de texto que contém dados de exemplo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2668">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2669">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2669">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-2670">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2670">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2671">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2671">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="79fe2-2672">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2672">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2673">Expressão <see langword="String" /> que identifica o diretório a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2673">
              <see langword="String" /> expression that identifies the directory to be created.</span>
          </span>
          <span data-ttu-id="79fe2-2674">O <c>Caminho</c> pode incluir a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2674">The <c>Path</c> may include the drive.</span>
          </span>
          <span data-ttu-id="79fe2-2675">Se nenhuma unidade for especificada, <see langword="MkDir" /> criará um novo diretório na unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2675">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2676">Cria um novo diretório.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2676">Creates a new directory.</span>
          </span>
          <span data-ttu-id="79fe2-2677">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="MkDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2677">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span>
          </span>
          <span data-ttu-id="79fe2-2678">Para obter mais informações, consulte <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2678">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2679">Essa função cria um novo diretório.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2679">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2680">Este exemplo usa o `MkDir` função para criar um diretório.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2680">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="79fe2-2681">Se a unidade não for especificada, o novo diretório é criado na unidade atual.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2681">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2682">
            <paramref name="Path" /> não foi especificado ou está vazio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2682">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="79fe2-2683">Permissão negada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2683">Permission denied.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2684">O diretório já existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2684">Directory already exists.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md">
          <span data-ttu-id="79fe2-2685">Como criar um diretório no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2685">How to: Create a Directory in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2686">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2686">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2687">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2687">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="79fe2-2688">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2688">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2689">Zero ou mais expressões delimitadas por vírgula a serem gravadas em um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2689">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="79fe2-2690">As configurações do argumento <c>Saída</c> são:</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2690">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="79fe2-2691">
            <see langword="T:System.IO.IOException" />: o modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2691">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="79fe2-2692">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2692">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2693">Grava dados formatados para exibição em um arquivo sequencial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2693">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2694">O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2694">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2695">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2695">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2696">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2696">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2697">`Print` não inclui uma alimentação de linha no final de uma linha; No entanto, `PrintLine` incluem uma alimentação de linha.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2697">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="79fe2-2698">Dados gravados com `Print` costumam ser lidos de um arquivo usando `LineInput` ou `Input`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2698">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="79fe2-2699">Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2699">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="79fe2-2700">Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2700">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="79fe2-2701">Para `Boolean` dados, seja `True` ou `False` é impresso.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2701">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="79fe2-2702">O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2702">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="79fe2-2703">Dados de data são gravados no arquivo usando o formato de data abreviada padrão reconhecido pelo seu sistema.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2703">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="79fe2-2704">Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2704">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="79fe2-2705">Nada será gravado no arquivo se `Output` dados estão vazios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2705">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="79fe2-2706">No entanto, se `Output` dados de lista estão `DBNull`, `Null` é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2706">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="79fe2-2707">Para `Error` dados, a saída é exibida como `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2707">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="79fe2-2708">O `Error` palavra-chave não será convertido, independentemente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2708">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="79fe2-2709">Todos os dados gravados no arquivo usando `Print` internacionalmente reconhece; ou seja, os dados são formatados corretamente usando o separador decimal apropriado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2709">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="79fe2-2710">Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2710">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="79fe2-2711">Gravando em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2711">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2712">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2712">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2713">Este exemplo usa o `Print` e `PrintLine` funções para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2713">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2714">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2714">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2715">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2715">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2716">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2716">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2717">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2717">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2718">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2718">Any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="79fe2-2719">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2719">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2720">Zero ou mais expressões delimitadas por vírgula a serem gravadas em um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2720">Zero or more comma-delimited expressions to write to a file.</span>
          </span>
          <span data-ttu-id="79fe2-2721">As configurações do argumento <c>Saída</c> são:</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2721">The <c>Output</c> argument settings are:</span>
          </span>
          <span data-ttu-id="79fe2-2722">
            <see langword="T:System.IO.IOException" />: o modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2722">
              <see langword="T:System.IO.IOException" />: File mode is invalid.</span>
          </span>
          <span data-ttu-id="79fe2-2723">
            <see langword="T:System.IO.IOException" />: <c>FileNumber</c> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2723">
              <see langword="T:System.IO.IOException" />: <c>FileNumber</c> does not exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2724">Grava dados formatados para exibição em um arquivo sequencial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2724">Writes display-formatted data to a sequential file.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2725">O `Print` e `PrintLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2725">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2726">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2726">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2727">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2727">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2728">`Print` não inclui uma alimentação de linha no final de uma linha; No entanto,`PrintLine` incluem uma alimentação de linha.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2728">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="79fe2-2729">Dados gravados com `Print` costumam ser lidos de um arquivo usando `LineInput` ou `Input`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2729">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="79fe2-2730">Se você omitir `Output` para `PrintLine`, uma linha em branco é impressa no arquivo; para `Print`, nada é de saída.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2730">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="79fe2-2731">Várias expressões separadas com uma vírgula serão alinhadas nos limites de tabulação, mas a mistura de vírgulas e `TAB` pode causar resultados inconsistentes.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2731">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="79fe2-2732">Para `Boolean` dados, seja `True` ou `False` é impresso.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2732">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="79fe2-2733">O `True` e `False` palavras-chave não são traduzidas, independentemente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2733">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="79fe2-2734">Dados de data são gravados no arquivo usando o formato de data abreviada padrão reconhecido pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2734">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="79fe2-2735">Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2735">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="79fe2-2736">Nada será gravado no arquivo se `Output` dados estão vazios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2736">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="79fe2-2737">No entanto, se `Output` dados de lista estão `DBNull`, `Null` é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2737">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="79fe2-2738">Para `Error` dados, a saída é exibida como `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2738">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="79fe2-2739">O `Error` palavra-chave não será convertido, independentemente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2739">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="79fe2-2740">Todos os dados gravados no arquivo usando `Print` internacionalmente reconhece; ou seja, os dados são formatados corretamente usando o separador decimal apropriado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2740">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="79fe2-2741">Se o usuário deseja gerar a saída de dados para uso em várias localidades, `Write` deve ser usado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2741">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="79fe2-2742">Gravando em um arquivo usando o `Print` ou `PrintLine` funções requer `Write` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2742">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-2743">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2743">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2744">Este exemplo usa o `Print` e `PrintLine` funções para gravar dados em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2744">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2745">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2745">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-2746">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2746">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-2747">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2747">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath">
          <span data-ttu-id="79fe2-2748">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2748">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2749">
            <see langword="String" /> expressão que especifica o local e o nome do arquivo existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2749">
              <see langword="String" /> expression that specifies the existing file name and location.</span>
          </span>
          <span data-ttu-id="79fe2-2750">
            <c>OldPath</c> pode incluir o diretório e a unidade do arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2750">
              <c>OldPath</c> may include the directory, and drive, of the file.</span>
          </span>
        </param>
        <param name="NewPath">
          <span data-ttu-id="79fe2-2751">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2751">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2752">
            <see langword="String" /> expressão que especifica o local e o nome do novo arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2752">
              <see langword="String" /> expression that specifies the new file name and location.</span>
          </span>
          <span data-ttu-id="79fe2-2753">
            <c>NewPath</c> pode incluir o diretório e a unidade do local de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2753">
              <c>NewPath</c> may include directory and drive of the destination location.</span>
          </span>
          <span data-ttu-id="79fe2-2754">O nome do arquivo especificado por <c>NewPath</c> não pode já existir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2754">The file name specified by <c>NewPath</c> cannot already exist.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2755">Renomeia um arquivo de disco ou um diretório.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2755">Renames a disk file or directory.</span>
          </span>
          <span data-ttu-id="79fe2-2756">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Rename" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2756">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span>
          </span>
          <span data-ttu-id="79fe2-2757">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2757">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2758">O`Rename` função renomeia um arquivo e a move para um diretório diferente, se necessário.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2758">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="79fe2-2759">O `Rename` função pode mover um arquivo em unidades, mas ele só pode renomear um diretório existente quando ambos `NewPath` e `OldPath` estão localizados na mesma unidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2759">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="79fe2-2760">`Rename` não é possível criar um novo arquivo ou diretório.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2760">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="79fe2-2761">Usando o `Rename` função em um arquivo aberto produz um erro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2761">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="79fe2-2762">Você deve fechar um arquivo aberto antes de renomeá-lo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2762">You must close an open file before renaming it.</span></span> <span data-ttu-id="79fe2-2763">`Rename` argumentos não podem incluir caracteres curinga de caractere único (?) e de vários caracteres (\*).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2763">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="79fe2-2764">Ao usar `Rename` para copiar um arquivo de um local desprotegido para um local protegido, o arquivo manterá os direitos menos restritos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2764">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="79fe2-2765">Verifique se você não está apresentando um possível risco à segurança.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2765">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2766">Este exemplo usa o `Rename` função para renomear um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2766">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="79fe2-2767">Para fins deste exemplo, suponha que os diretórios que são especificados já existem.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2767">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2768">Caminho inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2768">Path is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-2769">O arquivo <paramref name="OldPath" /> não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2769">
              <paramref name="OldPath" /> file does not exist.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2770">Não é possível renomear com outro dispositivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2770">Cannot rename to different device.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md">
          <span data-ttu-id="79fe2-2771">Como renomear um arquivo no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2771">How to: Rename a File in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2772">Fecha todos os arquivos de disco abertos usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2772">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2773">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Reset" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2773">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span>
          </span>
          <span data-ttu-id="79fe2-2774">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2774">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2775">O `Reset` função fecha todos os arquivos ativos abertos pela `FileOpen` de função e tem a mesma função que `FileClose()` sem parâmetros.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2775">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2776">Este exemplo usa o `Reset` função para fechar todos os arquivos abertos e gravar o conteúdo de todos os buffers de arquivo em disco.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2776">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="79fe2-2777">Observe o uso do `Object` variável `FileNumber` como uma cadeia de caracteres e um número.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2777">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md">
          <span data-ttu-id="79fe2-2778">Instrução End</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2778">End Statement</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path">
          <span data-ttu-id="79fe2-2779">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2779">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2780">
            <see langword="String" /> expressão que identifica o diretório ou a pasta a ser removida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2780">
              <see langword="String" /> expression that identifies the directory or folder to be removed.</span>
          </span>
          <span data-ttu-id="79fe2-2781">
            <c>Path</c> pode incluir a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2781">
              <c>Path</c> can include the drive.</span>
          </span>
          <span data-ttu-id="79fe2-2782">Se nenhuma unidade for especificada, <see langword="RmDir" /> removerá o diretório na unidade atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2782">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2783">Remove um diretório existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2783">Removes an existing directory.</span>
          </span>
          <span data-ttu-id="79fe2-2784">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="RmDir" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2784">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span>
          </span>
          <span data-ttu-id="79fe2-2785">Para obter mais informações, consulte <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2785">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2786">Ocorrerá um erro se você tentar usar `RmDir` em um diretório que contém os arquivos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2786">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="79fe2-2787">Use o `Kill` função para excluir todos os arquivos antes de tentar remover um diretório.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2787">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2788">Este exemplo usa o `RmDir` function para remover um diretório existente.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2788">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2789">
            <paramref name="Path" /> não foi especificado ou está vazio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2789">
              <paramref name="Path" /> is not specified or is empty.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2790">O diretório de destino contém arquivos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2790">Target directory contains files.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="79fe2-2791">O diretório não existe.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2791">Directory does not exist.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2792">Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2792">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2793">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2793">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="79fe2-2794">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2794">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2795">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2795">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2796">Um <see langword="Integer" /> que contém um número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2796">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2797">Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2797">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2798">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2798">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="79fe2-2799">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2799">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2800">Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2800">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2801">`Seek` Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2801">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="79fe2-2802">O exemplo a seguir descreve os valores retornados para cada modo de acesso do arquivo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2802">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="79fe2-2803">Modo</span><span class="sxs-lookup"><span data-stu-id="79fe2-2803">Mode</span></span>|<span data-ttu-id="79fe2-2804">Valor de Retorno</span><span class="sxs-lookup"><span data-stu-id="79fe2-2804">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="79fe2-2805">Número do próximo registro lido ou gravado</span><span class="sxs-lookup"><span data-stu-id="79fe2-2805">Number of the next record read or written</span></span>|  
|<span data-ttu-id="79fe2-2806">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2806">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="79fe2-2807">Posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2807">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2808">O primeiro byte em um arquivo está na posição 1, o segundo byte estiver na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2808">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2809">Este exemplo usa o `Seek` função para retornar a posição atual do arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2809">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="79fe2-2810">O exemplo supõe `TestFile` é um arquivo que contém registros de uma estrutura `Record`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2810">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="79fe2-2811">Para arquivos abertos no `Random` modo, `Seek` retorna o número do próximo registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2811">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="79fe2-2812">Para arquivos abertos em modos diferentes de `Random` modo, `Seek` retorna a posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2812">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2813">Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2813">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="79fe2-2814">Este exemplo usa o `Seek` função para definir a posição para a próxima leitura ou gravação em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2814">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="79fe2-2815">Para arquivos abertos em modos diferentes de `Random` modo, `Seek` define a posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2815">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2816">Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2816">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2817">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2817">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-2818">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2818">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2819">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2819">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2820">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2820">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2821">Um <see langword="Integer" /> que contém um número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2821">An <see langword="Integer" /> that contains a valid file number.</span>
          </span>
        </param>
        <param name="Position">
          <span data-ttu-id="79fe2-2822">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2822">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2823">Número no intervalo de 1 a 2.147.483.647, inclusive, que indica onde a próxima operação de leitura/gravação deve ocorrer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2823">Number in the range 1–2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2824">Retorna um <see langword="Long" /> que especifica a posição de leitura/gravação atual em um arquivo aberto usando a função <see langword="FileOpen" /> ou define a posição para a próxima operação de leitura/gravação em um arquivo aberto usando a função <see langword="FileOpen" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2824">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2825">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="Seek" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2825">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span>
          </span>
          <span data-ttu-id="79fe2-2826">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2826">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2827">`Seek` Retorna um valor entre 1 e 2.147.483.647 (equivalente a 2 ^ 31 – 1), inclusive.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2827">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 – 1), inclusive.</span></span>  
  
 <span data-ttu-id="79fe2-2828">O exemplo a seguir descreve os valores retornados para cada modo de acesso do arquivo:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2828">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="79fe2-2829">Modo</span><span class="sxs-lookup"><span data-stu-id="79fe2-2829">Mode</span></span>|<span data-ttu-id="79fe2-2830">Valor de Retorno</span><span class="sxs-lookup"><span data-stu-id="79fe2-2830">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="79fe2-2831">Número do próximo registro lido ou gravado</span><span class="sxs-lookup"><span data-stu-id="79fe2-2831">Number of the next record read or written</span></span>|  
|<span data-ttu-id="79fe2-2832">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="79fe2-2832">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="79fe2-2833">Posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2833">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2834">O primeiro byte em um arquivo está na posição 1, o segundo byte estiver na posição 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2834">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2835">Este exemplo usa o `Seek` função para retornar a posição atual do arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2835">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="79fe2-2836">O exemplo supõe `TestFile` é um arquivo que contém registros de uma estrutura `Record`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2836">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="79fe2-2837">Para arquivos abertos no `Random` modo, `Seek` retorna o número do próximo registro.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2837">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="79fe2-2838">Para arquivos abertos em modos diferentes de `Random` modo, `Seek` retorna a posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2838">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2839">Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2839">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="79fe2-2840">Este exemplo usa o `Seek` função para definir a posição para a próxima leitura ou gravação em um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2840">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="79fe2-2841">Para arquivos abertos em modos diferentes de `Random` modo, `Seek` define a posição do byte em que a próxima operação ocorre.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2841">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="79fe2-2842">Suponha que `TestFile` seja um arquivo contendo várias linhas de texto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2842">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2843">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2843">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md">
          <span data-ttu-id="79fe2-2844">Lendo a partir de arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2844">Reading from Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md">
          <span data-ttu-id="79fe2-2845">Gravando em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2845">Writing to Files in Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName">
          <span data-ttu-id="79fe2-2846">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2846">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2847">Expressão <see langword="String" /> que especifica um nome de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2847">
              <see langword="String" /> expression that specifies a file name.</span>
          </span>
          <span data-ttu-id="79fe2-2848">
            <c>PathName</c> pode incluir o diretório ou a pasta, bem como a unidade.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2848">
              <c>PathName</c> can include directory or folder, and drive.</span>
          </span>
        </param>
        <param name="Attributes">
          <span data-ttu-id="79fe2-2849">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2849">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2850">Expressão constante ou numérica, cuja soma especifica atributos de arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2850">Constant or numeric expression, whose sum specifies file attributes.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2851">Define as informações de atributo de um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2851">Sets attribute information for a file.</span>
          </span>
          <span data-ttu-id="79fe2-2852">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S do arquivo do que <see langword="SetAttr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2852">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span>
          </span>
          <span data-ttu-id="79fe2-2853">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2853">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2854">Um erro de tempo de execução ocorrerá se você tentar definir os atributos de um arquivo aberto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2854">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="79fe2-2855">O `Attributes` valores de enumeração de argumento são da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2855">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="79fe2-2856">Valor</span><span class="sxs-lookup"><span data-stu-id="79fe2-2856">Value</span></span>|<span data-ttu-id="79fe2-2857">Constante</span><span class="sxs-lookup"><span data-stu-id="79fe2-2857">Constant</span></span>|<span data-ttu-id="79fe2-2858">Descrição</span><span class="sxs-lookup"><span data-stu-id="79fe2-2858">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="79fe2-2859">Normal (padrão).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2859">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="79fe2-2860">Somente leitura.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2860">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="79fe2-2861">Oculto.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2861">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="79fe2-2862">Arquivo do sistema.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2862">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="79fe2-2863">Rótulo do volume</span><span class="sxs-lookup"><span data-stu-id="79fe2-2863">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="79fe2-2864">Diretório ou pasta.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2864">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="79fe2-2865">O arquivo foi alterado desde o último backup.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2865">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="79fe2-2866">O arquivo tem um nome diferente.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2866">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2867">Essas enumerações são especificadas pela linguagem Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2867">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="79fe2-2868">Os nomes podem ser usados em qualquer lugar no seu código em vez dos valores reais.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2868">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2869">Este exemplo usa o `SetAttr` função para definir atributos para um arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2869">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="79fe2-2870">O tipo <paramref name="Attribute" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2870">
              <paramref name="Attribute" /> type is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count">
          <span data-ttu-id="79fe2-2871">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2871">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2872">O número de espaços a serem inseridos antes de exibir ou imprimir a próxima expressão em uma lista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2872">The number of spaces to insert before displaying or printing the next expression in a list.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2873">Usado com a função <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2873">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2874">Usado com a função <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2874">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2875">Se `Count` é menor do que a largura da linha de saída, a próxima posição de impressão imediatamente após o número de espaços impressos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2875">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="79fe2-2876">Se`Count` é maior que a largura da linha de saída, `SPC` calculará a próxima posição de impressa usando a fórmula:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2876">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="79fe2-2877">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="79fe2-2877">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="79fe2-2878">Por exemplo, se a posição de impressão atual for 24, a largura de linha de saída for 80, e você especificar `SPC(90)`, a próxima impressão começará na posição 34 (posição de impressão atual + o resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2878">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="79fe2-2879">Se a diferença entre a posição atual de impressão e a largura da linha de saída for menor que `Count` (ou `Count` `Mod` *largura*), o `SPC` função pula para o início da próxima linha e gera espaços iguais a `Count` – (*largura* – *currentprintposition*).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2879">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` – (*width* – *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2880">Verifique se que as colunas da tabela são suficientes permitir a amplas letras.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2880">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2881">Este exemplo usa o `SPC` função para posicionar a saída em um arquivo e em de **saída** janela.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2881">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">
          <span data-ttu-id="79fe2-2882">Operador Mod (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2882">Mod Operator (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2883">Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2883">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2884">Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2884">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2885">Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2885">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2886">Se a posição de impressão atual na linha atual é maior que `Column`, `TAB` pulará para a coluna de valor igual a `Column` na próxima linha de saída.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2886">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="79fe2-2887">Se `Column` é menor que 1, `TAB` move a posição de impressão para a coluna 1.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2887">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="79fe2-2888">Se `Column` é maior do que a largura da linha de saída, `TAB` calculará a próxima posição de impressa usando a fórmula:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2888">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="79fe2-2889">Largura da coluna Mod</span><span class="sxs-lookup"><span data-stu-id="79fe2-2889">Column Mod width</span></span>  
  
 <span data-ttu-id="79fe2-2890">Por exemplo, se *largura* é 80 e você especificar `TAB(90)`, a próxima impressão começará na coluna 10 (o resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2890">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="79fe2-2891">Se `Column` é menor que a posição atual de impressão, impressão é iniciado na próxima linha na posição de impressão calculada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2891">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="79fe2-2892">Se a posição de impressão calculada for maior que a posição atual de impressão, impressão começa no calculada imprimir a posição na mesma linha.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2892">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="79fe2-2893">A posição mais à esquerda de impressão em uma linha de saída é sempre 1.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2893">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="79fe2-2894">Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2894">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="79fe2-2895">O `TAB` função também pode ser usada com o `WriteLine` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2895">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="79fe2-2896">Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2896">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2897">Verifique se que as colunas da tabela são grande o suficiente para conter letras amplas.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2897">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2898">Este exemplo usa o `TAB` função para posicionar a saída em um arquivo e em de **saída** janela.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2898">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">
          <span data-ttu-id="79fe2-2899">Operador Mod (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2899">Mod Operator (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column">
          <span data-ttu-id="79fe2-2900">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2900">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2901">O número de coluna movido antes de exibir ou imprimir a próxima expressão em uma lista.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2901">The column number moved to before displaying or printing the next expression in a list.</span>
          </span>
          <span data-ttu-id="79fe2-2902">Se omitido, <see langword="TAB" /> move o ponto de inserção para o início da próxima zona de impressão.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2902">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2903">Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2903">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="79fe2-2904">Usado com as funções <see langword="Print" /> ou <see langword="PrintLine" /> para posicionar a saída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2904">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2905">Se a posição de impressão atual na linha atual for maior que `Column`, `TAB` pulará para a coluna de valor igual a `Column` na próxima linha de saída.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2905">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="79fe2-2906">Se `Column` é menor que 1, `TAB` move a posição de impressão para a coluna 1.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2906">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="79fe2-2907">Se `Column` é maior que a largura da linha de saída, `TAB` calculará a próxima posição de impressa usando a fórmula:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2907">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="79fe2-2908">Largura da coluna Mod</span><span class="sxs-lookup"><span data-stu-id="79fe2-2908">Column Mod width</span></span>  
  
 <span data-ttu-id="79fe2-2909">Por exemplo, se *largura* é 80 e você especificar `TAB(90)`, a próxima impressão começará na coluna 10 (o resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2909">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="79fe2-2910">Se `Column` é menor que a posição atual de impressão, impressão é iniciado na próxima linha na posição de impressão calculada.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2910">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="79fe2-2911">Se a posição de impressão calculada for maior que a posição atual de impressão, impressão começa no calculada imprimir a posição na mesma linha.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2911">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="79fe2-2912">A posição mais à esquerda de impressão em uma linha de saída é sempre 1.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2912">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="79fe2-2913">Quando você usa o `Print` ou `PrintLine` funções para imprimir arquivos, a posição de impressão mais à direita é a largura atual do arquivo de saída, você pode definir usando o `FileWidth` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2913">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="79fe2-2914">O `TAB` função também pode ser usada com o `WriteLine` função.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2914">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="79fe2-2915">Ele não pode ser usado com <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2915">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="79fe2-2916">Verifique se que as colunas da tabela são grande o suficiente para conter letras amplas.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2916">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2917">Este exemplo usa o `TAB` função para posicionar a saída em um arquivo e em de **saída** janela.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2917">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md">
          <span data-ttu-id="79fe2-2918">Operador Mod (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2918">Mod Operator (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="79fe2-2919">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2919">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2920">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2920">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2921">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2921">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2922">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2922">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2923">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2923">Any valid file number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2924">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2924">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2925">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2925">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2926">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2926">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2927">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2927">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2928">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2928">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2929">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2929">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2930">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2930">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2931">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2931">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2932">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2932">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2933">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2933">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2934">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2934">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2935">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2935">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2936">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2936">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2937">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2937">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2938">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2938">Any valid file number.</span>
          </span>
        </param>
        <param name="Record">
          <span data-ttu-id="79fe2-2939">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2939">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2940">Número do único registro ou byte a ser bloqueado ou desbloqueado</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2940">Number of the only record or byte to lock or unlock</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2941">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2941">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2942">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2942">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2943">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2943">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2944">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2944">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2945">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2945">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2946">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2946">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2947">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2947">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2948">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2948">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2949">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2949">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2950">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2950">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2951">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2951">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2952">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2952">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2953">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2953">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2954">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2954">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2955">Qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2955">Any valid file number.</span>
          </span>
        </param>
        <param name="FromRecord">
          <span data-ttu-id="79fe2-2956">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2956">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2957">Número do primeiro registro ou byte a ser bloqueado ou desbloqueado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2957">Number of the first record or byte to lock or unlock.</span>
          </span>
        </param>
        <param name="ToRecord">
          <span data-ttu-id="79fe2-2958">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2958">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2959">Número do último registro ou byte a ser bloqueado ou desbloqueado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2959">Number of the last record or byte to lock or unlock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2960">Controla o acesso por outros processos a todo ou à parte de um arquivo aberto usando a função <see langword="Open" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2960">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span>
          </span>
          <span data-ttu-id="79fe2-2961">O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações de E/S de arquivo que <see langword="Lock" /> e <see langword="Unlock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2961">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span>
          </span>
          <span data-ttu-id="79fe2-2962">Para obter mais informações, consulte <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2962">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2963">O `Lock` e `Unlock` funções são usadas em ambientes onde vários processos podem precisam acessar o mesmo arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2963">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="79fe2-2964">`Lock` e `Unlock` funções sempre são usadas em pares.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2964">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="79fe2-2965">Os argumentos para `Lock` e `Unlock` devem ser idênticos.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2965">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="79fe2-2966">Se `Record` ou `FromRecord` e `ToRecord` não for fornecido, o bloqueio será para todo o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2966">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="79fe2-2967">Se `Record` sozinho for especificado o único registro será bloqueada/desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2967">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="79fe2-2968">Se o arquivo foi aberto para entrada ou saída, sequencial `Lock` e `Unlock` afetam todo o arquivo, independentemente do intervalo especificado por `FromRecord` e`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2968">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-2969">Este exemplo ilustra o uso do `Lock` e `Unlock` funções.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2969">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="79fe2-2970">Este exemplo pressupõe que `People.txt` seja um arquivo contendo registros da estrutura `Person`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2970">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-2971">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2971">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-2972">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2972">File Access with Visual Basic</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-2973">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2973">Required.</span>
          </span>
          <span data-ttu-id="79fe2-2974">Uma expressão <see langword="Integer" /> que contém qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2974">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="79fe2-2975">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2975">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-2976">Uma ou mais expressões delimitadas por vírgula para gravar em um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2976">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-2977">Grava dados em um arquivo sequencial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2977">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="79fe2-2978">Dados gravados com <see langword="Write" /> costumam ser lidos a partir de um arquivo usando <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-2978">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-2979">O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2979">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-2980">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2980">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-2981">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-2981">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-2982">Se você omitir `Output`, uma linha em branco é impresso para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2982">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="79fe2-2983">Várias expressões podem ser separadas por vírgula.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2983">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="79fe2-2984">Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas conforme elas são gravadas no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2984">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="79fe2-2985">Você não precisa colocar delimitadores explícitas na lista.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2985">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="79fe2-2986">Quando `Write` é usado para gravar dados em um arquivo, numérico somente `Boolean`, data, null, e `Error` há suporte para formatos de dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2986">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="79fe2-2987">As seguintes suposições universais são seguidas para que os dados sempre podem ser lido e interpretado corretamente usando `Input`, independentemente da localidade:</span><span class="sxs-lookup"><span data-stu-id="79fe2-2987">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="79fe2-2988">Dados numéricos são sempre gravados usando o ponto como separador decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2988">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="79fe2-2989">Para `Boolean` dados, seja `#TRUE#` ou `#FALSE#` é impresso.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2989">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="79fe2-2990">O `True` e `False` palavras-chave não são traduzidas, independente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2990">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="79fe2-2991">Dados de data são gravados no arquivo usando o formato de data universal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2991">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="79fe2-2992">Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2992">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="79fe2-2993">Nada será gravado no arquivo se `Output` dados estão vazios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2993">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="79fe2-2994">No entanto, para dados nulos, `#NULL#` é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2994">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="79fe2-2995">Para `Error` dados, a saída é exibida como `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2995">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="79fe2-2996">O `Error` palavra-chave não será convertido, independente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2996">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="79fe2-2997">`WriteLine` Insere um caractere de nova linha (ou seja, um retorno de carro/linha de alimentação, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-2997">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="79fe2-2998">Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou "".</span><span class="sxs-lookup"><span data-stu-id="79fe2-2998">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="79fe2-2999">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="79fe2-2999">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="79fe2-3000">Retorna uma cadeia de caracteres com o valor de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3000">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="79fe2-3001">Gravando em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3001">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-3002">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3002">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-3003">Este exemplo usa o `Write` função para gravar dados brutos em um arquivo sequencial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3003">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">
          <span data-ttu-id="79fe2-3004">O modo de arquivo é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3004">File mode is invalid.</span>
          </span>
        </exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-3005">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3005">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-3006">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3006">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-3007">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3007">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber">
          <span data-ttu-id="79fe2-3008">Necessário.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3008">Required.</span>
          </span>
          <span data-ttu-id="79fe2-3009">Uma expressão <see langword="Integer" /> que contém qualquer número de arquivo válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3009">An <see langword="Integer" /> expression that contains any valid file number.</span>
          </span>
        </param>
        <param name="Output">
          <span data-ttu-id="79fe2-3010">Opcional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3010">Optional.</span>
          </span>
          <span data-ttu-id="79fe2-3011">Uma ou mais expressões delimitadas por vírgula para gravar em um arquivo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3011">One or more comma-delimited expressions to write to a file.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="79fe2-3012">Grava dados em um arquivo sequencial.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3012">Writes data to a sequential file.</span>
          </span>
          <span data-ttu-id="79fe2-3013">Dados gravados com <see langword="Write" /> costumam ser lidos a partir de um arquivo usando <see langword="Input" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3013">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="79fe2-3014">O `Write` e `WriteLine` funções são fornecidas para compatibilidade com versões anteriores e pode afetar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3014">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="79fe2-3015">Para aplicativos não herdadas, o `My.Computer.FileSystem` objeto fornece um melhor desempenho.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3015">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="79fe2-3016">Para obter mais informações, consulte [acesso a arquivos com o Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="79fe2-3016">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="79fe2-3017">Se você omitir `Output`, uma linha em branco é impresso para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3017">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="79fe2-3018">Várias expressões podem ser separadas por vírgula.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3018">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="79fe2-3019">Ao contrário do `Print` função, o `Write` função insere vírgulas entre os itens e cadeias de caracteres entre aspas conforme elas são gravadas no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3019">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="79fe2-3020">Você não precisa colocar delimitadores explícitas na lista.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3020">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="79fe2-3021">Quando `Write` é usado para gravar dados em um arquivo, numérico somente `Boolean`, data, null, e `Error` há suporte para formatos de dados.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3021">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="79fe2-3022">As seguintes suposições universais são seguidas para que os dados sempre podem ser lido e interpretado corretamente usando `Input`, independentemente da localidade:</span><span class="sxs-lookup"><span data-stu-id="79fe2-3022">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="79fe2-3023">Dados numéricos são sempre gravados usando o ponto como separador decimal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3023">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="79fe2-3024">Para `Boolean` dados, seja `#TRUE#` ou `#FALSE#` é impresso.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3024">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="79fe2-3025">O `True` e `False` palavras-chave não são traduzidas, independente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3025">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="79fe2-3026">Dados de data são gravados no arquivo usando o formato de data universal.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3026">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="79fe2-3027">Quando a data ou o componente de tempo está ausente ou zero, somente a parte fornecida é gravada no arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3027">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="79fe2-3028">Nada será gravado no arquivo se `Output` dados estão vazios.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3028">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="79fe2-3029">No entanto, para dados nulos, `#NULL#` é gravado.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3029">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="79fe2-3030">Para `Error` dados, a saída é exibida como `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3030">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="79fe2-3031">O `Error` palavra-chave não será convertido, independente da localidade.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3031">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="79fe2-3032">`WriteLine` Insere um caractere de nova linha (ou seja, um retorno de carro/linha de alimentação, ou `Chr(13) + Chr(10)`), depois de escrever o caractere final `Output` para o arquivo.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3032">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="79fe2-3033">Você pode inserir aspas em uma cadeia de caracteres usando aspas duplas, ou "".</span><span class="sxs-lookup"><span data-stu-id="79fe2-3033">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="79fe2-3034">Por exemplo,</span><span class="sxs-lookup"><span data-stu-id="79fe2-3034">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="79fe2-3035">Retorna uma cadeia de caracteres com o valor de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3035">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="79fe2-3036">Gravando em um arquivo usando o `Write` ou `WriteLine` funções requer `Append` acessar do `FileIOPermissionAccess` enumeração.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3036">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="79fe2-3037">Para obter mais informações, consulte <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3037">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="79fe2-3038">Este exemplo usa o `Write` função para gravar dados brutos em um arquivo sequencial.</span><span class="sxs-lookup"><span data-stu-id="79fe2-3038">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md">
          <span data-ttu-id="79fe2-3039">Access de arquivo com o Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3039">File Access with Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md">
          <span data-ttu-id="79fe2-3040">Como gravar texto em arquivos no Visual Basic</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3040">How to: Write Text to Files in Visual Basic</span>
          </span>
        </related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md">
          <span data-ttu-id="79fe2-3041">Como: gravar texto em um arquivo com um Streamwriter (Visual Basic)</span>
          <span class="sxs-lookup">
            <span data-stu-id="79fe2-3041">How to: Write Text to a File with a Streamwriter (Visual Basic)</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>