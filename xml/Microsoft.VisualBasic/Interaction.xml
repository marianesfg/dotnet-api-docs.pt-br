<Type Name="Interaction" FullName="Microsoft.VisualBasic.Interaction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="c2148413fcf4cde333c66fabdb5869f474081dc1" /><Meta Name="ms.sourcegitcommit" Value="635a1dbdc9cbcf7f7c258ac9ffa0314ed734da90" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="04/10/2019" /><Meta Name="ms.locfileid" Value="59472203" /></Metadata><TypeSignature Language="C#" Value="public sealed class Interaction" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Interaction extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.Interaction" />
  <TypeSignature Language="VB.NET" Value="Public Module Interaction" />
  <TypeSignature Language="C++ CLI" Value="public ref class Interaction sealed" />
  <TypeSignature Language="F#" Value="type Interaction = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>O módulo <see langword="Interaction" /> contém procedimentos usados para interagir com objetos, aplicativos e sistemas.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este módulo oferece suporte a palavras-chave de linguagem Visual Basic e membros da biblioteca de tempo de execução que executem outros programas, chamam um método ou propriedade, um aviso sonoro do computador, fornecem uma cadeia de caracteres de linha de comando, manipulam objetos COM e controlam caixas de diálogo.  
  
## Examples  
 O exemplo a seguir usa o `Shell` função para executar um aplicativo especificado pelo usuário. Especificando <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> como o segundo argumento abre o aplicativo em tamanho normal e concede a ele o foco.  
  
```vb  
Dim procID As Integer  
' Run calculator.  
procID = Shell("C:\Windows\system32\calc.exe", AppWinStyle.NormalFocus)  
```  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/information-and-interaction-summary.md">Informações e resumo da interação</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md">Palavras-chave (Visual Basic)</related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="AppActivate">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ativa um aplicativo que já está em execução.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (int ProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(int32 ProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (ProcessId As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(int ProcessId);" />
      <MemberSignature Language="F#" Value="static member AppActivate : int -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate ProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="ProcessId"><see langword="Integer" /> especificando o número da ID do processo do Win32 atribuído a este processo. Você pode usar a identificação retornada pelo <see cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />, desde que não seja zero.</param>
        <summary>Ativa um aplicativo que já está em execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa `AppActivate` colocar a janela ativa de um aplicativo em foco. Você não pode ter um identificador ou uma referência para a janela ativa, ou nem sabe qual é a janela está ativa em um determinado momento. Nesse caso, é possível usar o <xref:System.Windows.Forms.Control.Focus%2A> método.  
  
 O `AppActivate` função altera o foco para o aplicativo nomeado ou a janela, mas não afeta se ele está minimizado ou maximizado. Foco é movido para fora da janela do aplicativo ativado quando o usuário executa alguma ação para alterar o foco ou feche a janela. Você pode usar o `Shell` função para iniciar um aplicativo e definir o estilo da janela.  
  
 Se você usar o `Title` parâmetro, `AppActivate` usa uma comparação que diferencia maiusculas de minúsculas, mas caso contrário, requer uma correspondência exata com o conteúdo da barra de título. Ele primeiro procura por meio de janelas de nível superior e, em seguida, as janelas filho. Se ele não é possível localizar uma correspondência, ele gerará um <xref:System.ArgumentException>.  
  
 Você pode usar `AppActivate` somente com os processos que possuem o windows. A maioria dos aplicativos de console não possuem, windows, o que significa que eles não aparecem na lista de processos que `AppActivate` pesquisas. Durante a execução de um aplicativo de console, o sistema cria um processo separado para executar o aplicativo e retorna a saída para o processo de console. Consequentemente, quando você solicita a ID do processo atual, você obtém a ID do processo desse processo separado, em vez de ID de processo. do aplicativo de console  
  
 Em tempo de execução, o `AppActivate` função ativa a qualquer aplicativo em execução com um título correspondente `Title` ou com uma ID de processo que corresponde ao `ProcessId`. Se não houver nenhuma correspondência exata, ele será ativado a qualquer aplicativo cuja cadeia de caracteres de título termina com `Title`. Se houver mais de um aplicativo chamado `Title`, o `AppActivate` função arbitrariamente escolhe um para ativar.  
  
> [!NOTE]
>  O `AppActivate` função requer `UIPermission` no <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nível, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Este exemplo ilustra vários usos do `AppActivate` função para ativar uma janela do aplicativo. Se um processo do bloco de notas não está em execução, o exemplo gera um <xref:System.ArgumentException>. O `Shell` procedimento pressupõe que os aplicativos estão nos caminhos especificados.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="AppActivate">
      <MemberSignature Language="C#" Value="public static void AppActivate (string Title);" />
      <MemberSignature Language="ILAsm" Value=".method public static void AppActivate(string Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.AppActivate(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppActivate (Title As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AppActivate(System::String ^ Title);" />
      <MemberSignature Language="F#" Value="static member AppActivate : string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.AppActivate Title" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Title" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Title"><see langword="String" /> expressão que especifica o título na barra de título do aplicativo que você deseja ativar. Você poderá usar o título atribuído ao aplicativo quando ele foi iniciado.</param>
        <summary>Ativa um aplicativo que já está em execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você usa `AppActivate` colocar a janela ativa de um aplicativo em foco. Você não pode ter um identificador ou uma referência para a janela ativa, ou nem sabe qual é a janela está ativa em um determinado momento. Nesse caso, é possível usar o <xref:System.Windows.Forms.Control.Focus%2A> método.  
  
 O `AppActivate` função altera o foco para o aplicativo nomeado ou a janela, mas não afeta se ele está minimizado ou maximizado. Foco é movido para fora da janela do aplicativo ativado quando o usuário executa alguma ação para alterar o foco ou feche a janela. Você pode usar o `Shell` função para iniciar um aplicativo e definir o estilo da janela.  
  
 Se você usar o `Title` parâmetro, `AppActivate` usa uma comparação que diferencia maiusculas de minúsculas, mas caso contrário, requer uma correspondência exata com o conteúdo da barra de título. Ele primeiro procura por meio de janelas de nível superior e, em seguida, as janelas filho. Se ele não é possível localizar uma correspondência, ele gerará um <xref:System.ArgumentException>.  
  
 Você pode usar `AppActivate` somente com os processos que possuem o windows. A maioria dos aplicativos de console não possuem, windows, o que significa que eles não aparecem na lista de processos que `AppActivate` pesquisas. Durante a execução de um aplicativo de console, o sistema cria um processo separado para executar o aplicativo e retorna a saída para o processo de console. Consequentemente, quando você solicita a ID do processo atual, você obtém a ID do processo desse processo separado, em vez de ID de processo. do aplicativo de console  
  
 Em tempo de execução, o `AppActivate` função ativa a qualquer aplicativo em execução com um título correspondente `Title` ou com uma ID de processo que corresponde ao `ProcessId`. Se não houver nenhuma correspondência exata, ele será ativado a qualquer aplicativo cuja cadeia de caracteres de título termina com `Title`. Se houver mais de um aplicativo chamado `Title`, o `AppActivate` função arbitrariamente escolhe um para ativar.  
  
> [!NOTE]
>  O `AppActivate` função requer `UIPermission` no <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nível, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Este exemplo ilustra vários usos do `AppActivate` função para ativar uma janela do aplicativo. Se um processo do bloco de notas não está em execução, o exemplo gera um <xref:System.ArgumentException>. O `Shell` procedimento pressupõe que os aplicativos estão nos caminhos especificados.  
  
 [!code-vb[VbVbalrCatRef#11](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Control.Focus" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberSignature Language="F#" Value="static member Beep : unit -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.Beep " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Emite um sinal sonoro pelo alto-falante do computador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A densidade e a duração do aviso sonoro dependem de seu hardware e software de sistema e, portanto, variam entre computadores.  
  
> [!NOTE]
>  O `Beep` função requer `UIPermission` no <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nível, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.UIPermission>.  
  
   
  
## Examples  
 Este exemplo usa o `Beep` função um som por meio do alto-falante do computador.  
  
 [!code-vb[VbVbalrCatRef#59](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#59)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/playing-sounds.md">Executando sons</related>
      </Docs>
    </Member>
    <Member MemberName="CallByName">
      <MemberSignature Language="C#" Value="public static object CallByName (object ObjectRef, string ProcName, Microsoft.VisualBasic.CallType UseCallType, params object[] Args);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CallByName(object ObjectRef, string ProcName, valuetype Microsoft.VisualBasic.CallType UseCallType, object[] Args) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CallByName(System.Object,System.String,Microsoft.VisualBasic.CallType,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CallByName (ObjectRef As Object, ProcName As String, UseCallType As CallType, ParamArray Args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CallByName(System::Object ^ ObjectRef, System::String ^ ProcName, Microsoft::VisualBasic::CallType UseCallType, ... cli::array &lt;System::Object ^&gt; ^ Args);" />
      <MemberSignature Language="F#" Value="static member CallByName : obj * string * Microsoft.VisualBasic.CallType * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CallByName (ObjectRef, ProcName, UseCallType, Args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ObjectRef" Type="System.Object" />
        <Parameter Name="ProcName" Type="System.String" />
        <Parameter Name="UseCallType" Type="Microsoft.VisualBasic.CallType" />
        <Parameter Name="Args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="ObjectRef">Necessário. <see langword="Object" />. Um ponteiro para o objeto expondo a propriedade ou método.</param>
        <param name="ProcName">Necessário. <see langword="String" />. Uma expressão de cadeia de caracteres que contém o nome da propriedade ou método no objeto.</param>
        <param name="UseCallType">Necessário. Um membro de enumeração do tipo <see cref="T:Microsoft.VisualBasic.CallType" /> representando o tipo de procedimento sendo chamado. O valor de <see langword="CallType" /> pode ser <see langword="Method" />, <see langword="Get" /> ou <see langword="Set" />.</param>
        <param name="Args">Opcional. <see langword="ParamArray" />. Uma matriz de parâmetros que contém os argumentos a serem passados para a propriedade ou método sendo chamado.</param>
        <summary>Executa um método em um objeto ou define ou retorna uma propriedade em um objeto.</summary>
        <returns>Executa um método em um objeto ou define ou retorna uma propriedade em um objeto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `CallByName` função é usada em tempo de execução para obter uma propriedade, definir uma propriedade ou invocar um método.  
  
   
  
## Examples  
 No exemplo a seguir, a primeira linha usa `CallByName` para definir o `Text` propriedade de uma caixa de texto, a segunda linha recupera o valor da `Text` propriedade e a terceira linha chama o `Move` método para mover a caixa de texto.  
  
 [!code-vb[VbVbalrFunctions#99](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#99)]  
  
 [!code-vb[VbVbalrFunctions#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#20)]  
  
 O próximo exemplo usa o `CallByName` função para invocar o `Add` e `Item` métodos de um objeto de coleção.  
  
 [!code-vb[VbVbalrFunctions#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#21)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Valor <paramref name="UseCallType" /> inválido, deve ser <see langword="Method" />, <see langword="Get" /> ou <see langword="Set" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.CallType" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Matrizes de parâmetros</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/early-late-binding/calling-a-property-or-method-using-a-string-name.md">Chamando uma propriedade ou um método usando o nome de uma cadeia de caracteres</related>
      </Docs>
    </Member>
    <Member MemberName="Choose">
      <MemberSignature Language="C#" Value="public static object Choose (double Index, params object[] Choice);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Choose(float64 Index, object[] Choice) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Choose (Index As Double, ParamArray Choice As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Choose(double Index, ... cli::array &lt;System::Object ^&gt; ^ Choice);" />
      <MemberSignature Language="F#" Value="static member Choose : double * obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Choose (Index, Choice)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Index" Type="System.Double" />
        <Parameter Name="Choice" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="Index">Necessário. <see langword="Double" />. Expressão numérica que resulta em um valor entre 1 e o número de elementos passado no argumento <paramref name="Choice" />.</param>
        <param name="Choice">Necessário. <see langword="Object" /> matriz de parâmetros. Você pode fornecer uma única variável ou uma expressão que é avaliada como o tipo de dados <see langword="Object" />, como uma lista de variáveis ou expressões <see langword="Object" /> separadas por vírgulas ou uma matriz unidimensional de elementos <see langword="Object" />.</param>
        <summary>Seleciona e retorna um valor de uma lista de argumentos.</summary>
        <returns>Seleciona e retorna um valor de uma lista de argumentos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Choose` função retorna um membro da lista passada `Choice()`, com base no valor de `Index`. O primeiro membro da lista é selecionado quando `Index` é 1. O último membro da lista é selecionado quando `Index` está `UBound`(`Choice()`). Se `Index` está fora desses limites `Choose` retorna `Nothing`.  
  
 Se `Index` não é um número inteiro, ele é arredondado para o próximo número inteiro antes de ser avaliado.  
  
 Você pode usar `Choose` para pesquisar um valor em uma lista de possibilidades.  
  
> [!NOTE]
>  As expressões na lista de argumentos podem incluir chamadas de função. Como parte da preparação da lista de argumentos para a chamada para `Choose`, o compilador do Visual Basic chama todas as funções em todas as expressões. Isso significa que você não pode contar com uma função particular não chamada se uma expressão diferente é selecionada por `Index`.  
  
   
  
## Examples  
 Este exemplo usa o `Choose` função para um nome para exibição em resposta a um índice passado para o procedimento a `Ind` parâmetro.  
  
 [!code-vb[VbVbalrFunctions#22](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#22)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Instrução Select...Case (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Command">
      <MemberSignature Language="C#" Value="public static string Command ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Command() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Command" />
      <MemberSignature Language="VB.NET" Value="Public Function Command () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Command();" />
      <MemberSignature Language="F#" Value="static member Command : unit -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Command " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a parte do argumento da linha de comando usada para iniciar o Visual Basic ou um programa executável desenvolvido com o Visual Basic. O recurso <see langword="My" /> fornece melhor produtividade e desempenho do que a função <see langword="Command" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</summary>
        <returns>A parte do argumento da linha de comando usada para iniciar o Visual Basic ou um programa executável desenvolvido com o Visual Basic.  
  
O recurso <see langword="My" /> fornece melhor produtividade e desempenho do que a função <see langword="Command" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois que os argumentos são retornados, você pode procurar por delimitadores comuns, como espaços, barras de frente ou para trás, hifens ou aspas, para dividir ou pesquisar a cadeia de caracteres para parâmetros individuais.  
  
 Para aplicativos desenvolvidos com o Visual Basic e compilado em um arquivo .exe, o `Command` função retorna quaisquer argumentos que aparecem depois do nome do aplicativo na linha de comando, neste formato: `MyApp(cmdlineargs)`.  
  
   
  
## Examples  
 Este exemplo usa o `Command` função para retornar os argumentos de linha de comando em um objeto que contém uma matriz.  
  
 [!code-vb[VbVbalrCatRef#58](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#58)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
        <altmember cref="P:Microsoft.VisualBasic.ApplicationServices.ConsoleApplicationBase.CommandLineArgs" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/reference/command-line-compiler/index.md">Compilador de linha de comando do Visual Basic</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/program-structure/structure-of-a-visual-basic-program.md">Estrutura de um programa Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="CreateObject">
      <MemberSignature Language="C#" Value="public static object CreateObject (string ProgId, string ServerName = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static object CreateObject(string ProgId, string ServerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateObject (ProgId As String, Optional ServerName As String = &quot;&quot;) As Object" />
      <MemberSignature Language="F#" Value="static member CreateObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.CreateObject (ProgId, ServerName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ProgId" Type="System.String" />
        <Parameter Name="ServerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="ProgId">Necessário. <see langword="String" />. A ID do programa do objeto a ser criado.</param>
        <param name="ServerName">Opcional. <see langword="String" />. O nome do servidor de rede no qual o objeto será criado. Se <paramref name="ServerName" /> for uma cadeia de caracteres vazia (""), o computador local será usado.</param>
        <summary>Cria e retorna uma referência a um objeto COM. <see langword="CreateObject" /> não pode ser usado para criar instâncias de classes no Visual Basic, a menos que essas classes sejam expostas explicitamente como componentes COM.</summary>
        <returns>Cria e retorna uma referência a um objeto COM. <see langword="CreateObject" /> não pode ser usado para criar instâncias de classes no Visual Basic, a menos que essas classes sejam expostas explicitamente como componentes COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para criar uma instância de um componente COM, atribua o objeto retornado por `CreateObject` para uma variável de objeto:  
  
```vb  
Sub CreateADODB()  
   Dim adoApp As Object  
   adoApp = CreateObject("ADODB.Connection")  
End Sub  
```  
  
 O tipo da variável de objeto, que você pode usar para armazenar o objeto retornado pode afetar o desempenho do aplicativo. Declarando uma variável de objeto com o `As Object` cláusula cria uma variável que pode conter uma referência a qualquer tipo de objeto. No entanto, o acesso ao objeto por meio dessa variável é *tardia*, ou seja, a associação ocorre quando o programa é executado. Há muitos motivos, que você deve evitar a vinculação tardia, incluindo desempenho mais lento do aplicativo.  
  
 Você pode criar uma variável de objeto que resulta em uma associação antecipada – ou seja, quando o programa é compilado de associação. Para fazer isso, adicione uma referência à biblioteca de tipos para seu objeto do **COM** guia da **adicionar referência** caixa de diálogo na **projeto** menu. Em seguida, declare a variável de objeto do tipo específico de seu objeto. Na maioria dos casos, é mais eficiente usar a `Dim` instrução e um assembly de interoperabilidade primário para criar objetos do que usar o `CreateObject` função.  
  
## <a name="interacting-with-unmanaged-code"></a>Interagindo com código não gerenciado  
 Outro problema é que os objetos COM usam código não gerenciado - código sem o benefício do common language runtime. Há um bom grau de complexidade envolvida na mistura o código gerenciado do Visual Basic com código não gerenciado de COM. Quando você adiciona uma referência a um objeto COM, o Visual Basic procura um assembly de interoperabilidade primário (PIA) para essa biblioteca; Se ele encontrar um, em seguida, ele o utiliza. Se não encontrar um PIA, em seguida, ele cria um assembly de interoperabilidade que contém as classes de interoperabilidade de local para cada classe na biblioteca COM. Para obter mais informações, consulte [interoperabilidade COM em aplicativos do .NET Framework](~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md).  
  
 Geralmente, você deve usar objetos fortemente acoplados e assemblies de interoperabilidade primários, sempre que possível. Os exemplos a seguir usam o `CreateObject` apenas a fins de função com objetos do Microsoft Office para demonstração. No entanto, esses objetos são mais fáceis de usar e mais confiável quando usado com o assembly de interoperabilidade primário apropriado.  
  
## <a name="creating-an-object-on-a-remote-computer"></a>Criando um objeto em um computador remoto  
 Você pode criar um objeto em um computador em rede remoto, passando o nome do computador para o `ServerName` argumento do `CreateObject` função. Esse nome é o mesmo que a parte do nome da máquina de um nome de compartilhamento: para um compartilhamento chamado "\\\MyServer\Public," `ServerName` é "Meuservidor".  
  
> [!NOTE]
>  Consulte a documentação COM (consulte o Microsoft Developer Network) para obter mais informações sobre como tornar um aplicativo acessíveis em um computador em rede remoto. Você talvez precise adicionar uma chave do registro para o seu aplicativo.  
  
 O código a seguir retorna o número de versão de uma instância do Excel em execução em um computador remoto denominado `MyServer`:  
  
```vb  
Sub CreateRemoteExcelObj()  
    Dim xlApp As Object  
    ' Replace string "\\MyServer" with name of the remote computer.  
    xlApp = CreateObject("Excel.Application", "\\MyServer")  
    MsgBox(xlApp.Version)  
End Sub  
```  
  
 Se o nome do servidor remoto está incorreto, ou se ele estiver indisponível, ocorrerá um erro de tempo de execução.  
  
> [!NOTE]
>  Use `CreateObject` quando não há nenhuma instância atual do objeto. Se uma instância do objeto já está em execução, uma nova instância é iniciada e um objeto do tipo especificado é criado. Para usar a instância atual, ou para iniciar o aplicativo e tiver um arquivo de carga, use o `GetObject` função. Se um objeto registrou ele mesmo como um objeto de instância única, apenas uma instância do objeto é criada, não importa como muitas vezes `CreateObject` é executado.  
  
## <a name="creating-framework-objects"></a>Criando objetos de estrutura  
 Você pode usar o `CreateObject` função apenas para criar um objeto COM. Embora não haja nenhum mecanismo equivalente exato para a criação de um objeto do .NET Framework, o <xref:System.Activator> no <xref:System> namespace contém métodos para criar objetos locais ou remotos. Em particular, o <xref:System.Activator.CreateInstance%2A> método ou o <xref:System.Activator.CreateInstanceFrom%2A> método pode ser útil.  
  
> [!IMPORTANT]
>  O `CreateObject` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 O exemplo a seguir usa o `CreateObject` de função para criar uma planilha do Microsoft Excel e salva a planilha em um arquivo. Para usar este exemplo, o Excel deve ser instalado no computador em que este programa é executado. Além disso, você deve adicionar uma referência à biblioteca de tipos dos **COM** guia da **adicionar referência** caixa de diálogo na **projeto** menu. O nome da biblioteca de tipos varia dependendo da versão do Excel instalado em seu computador. Por exemplo, a biblioteca de tipos para o Microsoft Excel 2002 é denominada **biblioteca de objetos do Microsoft Excel 10.0**.  
  
 [!code-vb[VbVbalrExcelObject#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Servidor não disponível</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não existe nenhum objeto do tipo especificado</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.Activator" />
        <altmember cref="Overload:System.Activator.CreateInstance" />
        <altmember cref="Overload:System.Activator.CreateInstanceFrom" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/dim-statement.md">Instrução Dim (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Instrução Declare</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/com-interop/com-interoperability-in-net-framework-applications.md">Interoperabilidade COM em aplicativos .NET Framework</related>
        <related type="Article" href="~/docs/framework/interop/index.md">Interoperação com código não gerenciado</related>
      </Docs>
    </Member>
    <Member MemberName="DeleteSetting">
      <MemberSignature Language="C#" Value="public static void DeleteSetting (string AppName, string Section = null, string Key = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static void DeleteSetting(string AppName, string Section, string Key) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DeleteSetting (AppName As String, Optional Section As String = null, Optional Key As String = null)" />
      <MemberSignature Language="F#" Value="static member DeleteSetting : string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.DeleteSetting (AppName, Section, Key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Necessário. <see langword="String" /> expressão que contém o nome do aplicativo ou do projeto ao qual a seção ou a configuração de chave se aplica.</param>
        <param name="Section">Necessário. <see langword="String" /> expressão que contém o nome da seção da qual a configuração de chave está sendo excluída. Se apenas <paramref name="AppName" /> e <paramref name="Section" /> forem fornecidos, a seção especificada será excluída juntamente com todas as configurações de chave relacionadas.</param>
        <param name="Key">Opcional. <see langword="String" /> expressão que contém o nome da configuração de chave que está sendo excluída.</param>
        <summary>Exclui uma seção ou uma configuração de chave da entrada de um aplicativo no Registro do Windows. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que a função <see langword="DeleteSetting" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se todos os argumentos forem fornecidos, a configuração especificada será excluída. Um erro de tempo de execução ocorrerá se você tentar usar `DeleteSetting` em uma seção inexistente ou configuração de chave.  
  
 `DeleteSetting` requer que um usuário fazer logon, pois ele opera com o `HKEY_LOCAL_USER` chave do registro, que não está ativa até que um usuário faz logon interativamente.  
  
 Configurações do registro que devem ser acessadas a partir de um processo não interativo (por exemplo, Mtx.exe) devem ser armazenadas em do `HKEY_LOCAL_MACHINE\Software\` ou o `HKEY_USER\DEFAULT\Software` chaves do registro.  
  
   
  
## Examples  
 O exemplo a seguir usa primeiro a `SaveSetting` procedimento para fazer as entradas no registro do Windows para o `MyApp` aplicativo e, em seguida, usa o `DeleteSetting` função para removê-los. Porque não há `Key` argumento for especificado, todo o `Startup` seção for excluída, incluindo o nome da seção e todas as suas chaves.  
  
 [!code-vb[VbVbalrCatRef#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O usuário não está conectado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Environ">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna a cadeia de caracteres associada com uma variável de ambiente do sistema operacional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (int Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(int32 Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(int Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Expression">Necessário. Expressão que avalia uma cadeia de caracteres que contém o nome de uma variável de ambiente ou um inteiro correspondente à ordem numérica de uma cadeia de caracteres de ambiente na tabela de cadeia de caracteres de ambiente.</param>
        <summary>Retorna a cadeia de caracteres associada com uma variável de ambiente do sistema operacional.</summary>
        <returns>A cadeia de caracteres associada com uma variável de ambiente do sistema operacional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Expression` contém uma cadeia de caracteres, o <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função retorna o texto atribuído ao ambiente especificado cadeia de caracteres, ou seja, o texto após o sinal de igual (=) na tabela de cadeia de caracteres de ambiente para essa variável de ambiente. Se a cadeia de caracteres em `Expression` não pode ser encontrado na tabela de cadeia de caracteres de ambiente, uma cadeia de caracteres de comprimento zero ("") será retornado.  
  
 Se `Expression` contém um número inteiro, a cadeia de caracteres que ocupam que posição numérica na tabela de cadeia de caracteres de ambiente é retornada. Nesse caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retorna todo o texto, incluindo o nome da variável de ambiente. Se não houver nenhuma cadeia de caracteres de ambiente na posição especificada, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retorna uma cadeia de caracteres de comprimento zero.  
  
> [!IMPORTANT]
>  O <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função requer permissão de ambiente, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este exemplo usa o <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função para fornecer o número de entrada e o comprimento do `PATH` instrução da tabela de cadeia de caracteres de ambiente.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Expression" /> está ausente.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="Environ">
      <MemberSignature Language="C#" Value="public static string Environ (string Expression);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Environ(string Expression) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Environ(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Environ (Expression As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Environ(System::String ^ Expression);" />
      <MemberSignature Language="F#" Value="static member Environ : string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Environ Expression" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Expression">Necessário. Expressão que avalia uma cadeia de caracteres que contém o nome de uma variável de ambiente ou um inteiro correspondente à ordem numérica de uma cadeia de caracteres de ambiente na tabela de cadeia de caracteres de ambiente.</param>
        <summary>Retorna a cadeia de caracteres associada com uma variável de ambiente do sistema operacional.</summary>
        <returns>A cadeia de caracteres associada com uma variável de ambiente do sistema operacional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `Expression` contém uma cadeia de caracteres, o <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função retorna o texto atribuído ao ambiente especificado cadeia de caracteres, ou seja, o texto após o sinal de igual (=) na tabela de cadeia de caracteres de ambiente para essa variável de ambiente. Se a cadeia de caracteres em `Expression` não pode ser encontrado na tabela de cadeia de caracteres de ambiente, uma cadeia de caracteres de comprimento zero ("") será retornado.  
  
 Se `Expression` contém um número inteiro, a cadeia de caracteres que ocupam que posição numérica na tabela de cadeia de caracteres de ambiente é retornada. Nesse caso, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retorna todo o texto, incluindo o nome da variável de ambiente. Se não houver nenhuma cadeia de caracteres de ambiente na posição especificada, <xref:Microsoft.VisualBasic.Interaction.Environ%2A> retorna uma cadeia de caracteres de comprimento zero.  
  
> [!IMPORTANT]
>  O <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função requer permissão de ambiente, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 Este exemplo usa o <xref:Microsoft.VisualBasic.Interaction.Environ%2A> função para fornecer o número de entrada e o comprimento do `PATH` instrução da tabela de cadeia de caracteres de ambiente.  
  
 [!code-vb[VbVbalrCatRef#28](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#28)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Expression" /> está ausente.</exception>
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md">Membros de biblioteca de tempo de execução do Visual Basic</related>
      </Docs>
    </Member>
    <Member MemberName="GetAllSettings">
      <MemberSignature Language="C#" Value="public static string[,] GetAllSettings (string AppName, string Section);" />
      <MemberSignature Language="ILAsm" Value=".method public static string[,] GetAllSettings(string AppName, string Section) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAllSettings (AppName As String, Section As String) As String(,)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^, 2&gt; ^ GetAllSettings(System::String ^ AppName, System::String ^ Section);" />
      <MemberSignature Language="F#" Value="static member GetAllSettings : string * string -&gt; string[,]" Usage="Microsoft.VisualBasic.Interaction.GetAllSettings (AppName, Section)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[,]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Necessário. <see langword="String" /> expressão que contém o nome do aplicativo ou do projeto cujas configurações de chave são solicitadas.</param>
        <param name="Section">Necessário. <see langword="String" /> expressão que contém o nome da seção cujas configurações de chave são solicitadas. <see langword="GetAllSettings" /> retorna um objeto que contém uma matriz bidimensional de cadeias de caracteres. As cadeias de caracteres contêm todas as configurações de chave na seção especificada, além de seus valores correspondentes.</param>
        <summary>Retorna uma lista de configurações de chave e seus respectivos valores (originalmente criados com <see langword="SaveSetting" />) da entrada de um aplicativo no Registro do Windows. O uso do recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que o <see langword="GetAllSettings" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Uma lista de configurações de chave e seus respectivos valores (originalmente criados com <see langword="SaveSetting" />) da entrada de um aplicativo no Registro do Windows.  
  
O uso do recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que o <see langword="GetAllSettings" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetAllSettings` Retorna um não inicializada `Object` se qualquer um dos `AppName` ou `Section` não existe.  
  
 Porque ele opera com o `HKEY_LOCAL_USER` chave do registro, que não está ativa até que um usuário faz logon interativamente, `GetAllSettings` requer que um usuário fazer logon.  
  
 Configurações do registro que devem ser acessadas a partir de um processo não interativo (por exemplo, Mtx.exe) devem ser armazenadas em do `HKEY_LOCAL_MACHINE\Software\` ou o `HKEY_USER\DEFAULT\Software` chaves do registro.  
  
   
  
## Examples  
 Este primeiro exemplo usa o `SaveSetting` função para fazer as entradas no registro do Windows para o aplicativo especificado como `AppName`, em seguida, usa o `GetAllSettings` função para exibir as configurações. Observe que o aplicativo nomes e `Section` nomes não podem ser recuperados com `GetAllSettings`. Por fim, o `DeleteSetting` função remove entradas do aplicativo.  
  
 [!code-vb[VbVbalrCatRef#68](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#68)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O usuário não está conectado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lendo e gravando a partir do Registro (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (string PathName = null, string Class = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static object GetObject(string PathName, string Class) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetObject(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetObject (Optional PathName As String = null, Optional Class As String = null) As Object" />
      <MemberSignature Language="F#" Value="static member GetObject : string * string -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.GetObject (PathName, Class)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Class" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName">Opcional. <see langword="String" />. O nome e caminho completo do arquivo que contém o objeto a ser recuperado. Se <paramref name="PathName" /> for omitido, <paramref name="Class" /> será necessário.</param>
        <param name="Class">Necessário se <paramref name="PathName" /> não for fornecido. <see langword="String" />. Uma cadeia de caracteres que representa a classe do objeto. O argumento <paramref name="Class" /> tem a sintaxe e as partes a seguir: 
 <c>appname</c><c>.</c><c>objecttype</c>  
  
[1|1] Parâmetro 
[1|2] Descrição 
[2|1] <c>appname</c>  
  
[2|2] Necessário. <see langword="String" />. O nome do aplicativo que fornece o objeto.  
  
[3|1] <c>objecttype</c>  
  
[3|2] Necessário. <see langword="String" />. O tipo ou a classe de objeto a ser criado.</param>
        <summary>Retorna uma referência a um objeto fornecido por um componente COM.</summary>
        <returns>Uma referência a um objeto fornecido por um componente COM.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o `GetObject` função para carregar uma instância de um componente COM de um arquivo. O exemplo a seguir ilustra essa situação.  
  
```vb  
Dim CADObject As Object  
CADObject = GetObject("C:\CAD\schema.cad")  
```  
  
 Quando esse código é executado, o aplicativo associado especificado `PathName` é iniciado e o objeto no arquivo especificado é ativado.  
  
## <a name="default-cases"></a>Casos padrão  
 Se `PathName` é uma cadeia de caracteres de comprimento zero (`""`), `GetObject` retorna uma nova instância de objeto do tipo de classe especificado. Se o `PathName` argumento for omitido, `GetObject` retorna um objeto ativo no momento do tipo de classe especificado no `Class`. Se nenhum objeto do tipo especificado existir, ocorrerá um erro.  
  
## <a name="accessing-a-subobject"></a>Acessando um Subobjeto  
 Alguns aplicativos permitem que você ative um Subobjeto associado a um arquivo. Para fazer isso, adicione um ponto de exclamação (`!`) ao final do nome de arquivo e siga-o com uma cadeia de caracteres que identifica a parte do arquivo de você deseja ativar. Para obter informações sobre como criar essa cadeia de caracteres, consulte a documentação para o aplicativo que criou o objeto.  
  
 Por exemplo, em um aplicativo de desenho, você pode ter várias camadas para um desenho armazenado em um arquivo. Você pode usar o código a seguir para ativar uma camada em um desenho chamado `schema.cad`.  
  
```vb  
layerObject = GetObject("C:\CAD\schema.cad!Layer3")  
```  
  
## <a name="specifying-a-class"></a>Especificando uma classe  
 Se você não especificar o objeto `Class`, automação determinará o aplicativo para o início e o objeto para ser ativado, com base no nome do arquivo que você fornecer. Alguns arquivos, no entanto, podem dar suporte a mais de uma classe de objeto. Por exemplo, um desenho pode oferecer suporte a três tipos diferentes de objetos: um `Application` objeto, um `Drawing` objeto e um `Toolbar` objeto, que são parte do mesmo arquivo. Para especificar qual objeto em um arquivo que você deseja ativar, use opcional `Class` argumento. O exemplo a seguir ilustra essa situação.  
  
```vb  
Dim drawObj As Object  
drawObj = GetObject("C:\Drawings\sample.drw", "Figment.Drawing")  
```  
  
 No exemplo anterior, `Figment` é o nome de um aplicativo de desenho e `Drawing` é um dos tipos de objeto, ele dá suporte.  
  
## <a name="using-the-object"></a>Usando o objeto  
 Depois que um objeto é ativado, você consultá-lo no código usando a variável de objeto que você declarou. No exemplo anterior, você acessar propriedades e métodos do novo objeto usando a variável de objeto `drawObj`. O exemplo a seguir ilustra essa situação.  
  
```vb  
drawObj.Line(9, 90)  
drawObj.InsertText(9, 100, "Hello, world.")  
drawObj.SaveAs("C:\Drawings\sample.drw")  
```  
  
> [!NOTE]
>  Use o `GetObject` funcionar quando há uma instância atual do objeto ou se você deseja criar o objeto com um arquivo carregado. Se não há nenhuma instância atual, e você não deseja que o objeto iniciado com um arquivo carregado, use o <xref:Microsoft.VisualBasic.Interaction.CreateObject%2A> função.  
>   
>  Se um objeto registrou ele mesmo como um objeto de instância única do ActiveX, apenas uma instância do objeto é criada, não importa como muitas vezes `CreateObject` é chamado. Com um objeto de instância única `GetObject` sempre retorna a mesma instância quando chamado com a cadeia de caracteres de comprimento zero (`""`) sintaxe e ele causa um erro se o `PathName` argumento for omitido. Não é possível usar `GetObject` para obter uma referência a uma classe criada com o Visual Basic.  
  
> [!IMPORTANT]
>  O `GetObject` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 O exemplo a seguir usa o `GetObject` função para obter uma referência a uma planilha específica do Microsoft Excel (`excelObj`). Ele usa a planilha `Application` propriedade para tornar o Excel visível, para fechá-la e executar outras ações. Usando duas chamadas de API, o `detectExcel` procedimento procura o Excel e, se ele estiver em execução, o insere na tabela de objetos em execução. A primeira chamada para `GetObject` causa um erro se o Excel não estiver sendo executado, que neste exemplo faz com que o `excelWasNotRunning` sinalizador definido como `True`. A segunda chamada para `GetObject` Especifica um arquivo a ser aberto. Se o Excel não estiver sendo executado, a segunda chamada inicia e retorna uma referência à planilha representada pelo arquivo especificado, `test.xls`. O arquivo deve existir no local especificado. Caso contrário, o Visual Basic gera um <xref:System.IO.FileNotFoundException>. Em seguida, o código de exemplo faz o Excel e a janela que contém a planilha especificada visível.  
  
 Este exemplo requer `Option Strict Off` porque ele usa a associação tardia, onde os objetos são atribuídos a variáveis do tipo `Object`. Você pode especificar `Option Strict On` e declarar objetos dos tipos de objeto específico, se você adicionar uma referência para a biblioteca de tipos do Excel a **COM** guia da **Add Reference** caixa de diálogo do  **Projeto** menu do Visual Studio.  
  
 [!code-vb[VbVbalrExcelObject#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#2)]  
  
 [!code-vb[VbVbalrExcelObject#4](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#4)]  
  
 [!code-vb[VbVbalrExcelObject#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrExcelObject/VB/Class1.vb#5)]  
  
 Quando você chama o `getExcel` função, é feita uma verificação para ver se o Excel já está em execução. Se não estiver, uma instância é criada.  
  
> [!IMPORTANT]
>  Para simplificar, o exemplo anterior pressupõe que qualquer janela chamado `XLMAIN` pertence a uma instância do Microsoft Excel. Se outro objeto, possivelmente iniciado por adulteração ilícita, criou uma janela com esse nome, ele receberia todas as mensagens que você pretendia para Excel. Em um aplicativo a ser usado para produção, você deve incluir alguns testes mais rigorosos para verificar se `XLMAIN` realmente pertence ao Excel.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Não existe nenhum objeto do tipo de classe especificado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Não existe nenhum objeto com o caminho e nome de arquivo especificados.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.CreateObject(System.String,System.String)" />
        <altmember cref="T:System.Exception" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/declare-statement.md">Instrução Declare</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Instrução Option Strict</related>
      </Docs>
    </Member>
    <Member MemberName="GetSetting">
      <MemberSignature Language="C#" Value="public static string GetSetting (string AppName, string Section, string Key, string Default = &quot;&quot;);" />
      <MemberSignature Language="ILAsm" Value=".method public static string GetSetting(string AppName, string Section, string Key, string Default) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSetting (AppName As String, Section As String, Key As String, Optional Default As String = &quot;&quot;) As String" />
      <MemberSignature Language="F#" Value="static member GetSetting : string * string * string * string -&gt; string" Usage="Microsoft.VisualBasic.Interaction.GetSetting (AppName, Section, Key, Default)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Default" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Necessário. <see langword="String" /> expressão que contém o nome do aplicativo ou do projeto cuja configuração de chave é solicitada.</param>
        <param name="Section">Necessário. <see langword="String" /> expressão que contém o nome da seção na qual a configuração de chave foi encontrada.</param>
        <param name="Key">Necessário. <see langword="String" /> expressão que contém o nome da configuração de chave a ser retornada.</param>
        <param name="Default">Opcional. A expressão que contém o valor a ser retornado se nenhum valor for definido na configuração <paramref name="Key" />. Se for omitido, <paramref name="Default" /> será considerado uma cadeia de tamanho zero ("").</param>
        <summary>Retorna um valor de configuração de chave da entrada de um aplicativo no Registro do Windows. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que o <see langword="GetAllSettings" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <returns>Um valor de configuração de chave da entrada de um aplicativo no Registro do Windows.  
  
O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que o <see langword="GetAllSettings" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se qualquer um dos itens nomeados na `GetSetting` argumentos não existirem, `GetSetting` retorna um valor de `Default`.  
  
 Porque ele opera com o `HKEY_LOCAL_USER` chave do registro, que não está ativa até que um usuário faz logon interativamente, `GetSetting` requer que um usuário fazer logon.  
  
 Configurações do registro que devem ser acessadas a partir de um processo não interativo (por exemplo, Mtx.exe) devem ser armazenadas em do `HKEY_LOCAL_MACHINE\Software\` ou o `HKEY_USER\DEFAULT\Software` chaves do registro.  
  
 `GetSetting` requer `Read`<xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 Este primeiro exemplo usa o `SaveSetting` função para fazer as entradas no registro do Windows para o aplicativo especificado como `AppName`e, em seguida, usa o `GetSetting` função para exibir uma das configurações. Porque o `Default` argumento for especificado, é garantido algum valor a ser retornado. Observe que `Section` nomes não podem ser recuperados com `GetSetting`. Por fim, o `DeleteSetting` função remove entradas de todas as do aplicativo.  
  
 [!code-vb[VbVbalrCatRef#61](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#61)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Um ou mais argumentos não são expressões <see langword="String" /> ou o usuário não está conectado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lendo e gravando a partir do Registro (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="IIf">
      <MemberSignature Language="C#" Value="public static object IIf (bool Expression, object TruePart, object FalsePart);" />
      <MemberSignature Language="ILAsm" Value=".method public static object IIf(bool Expression, object TruePart, object FalsePart) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IIf (Expression As Boolean, TruePart As Object, FalsePart As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ IIf(bool Expression, System::Object ^ TruePart, System::Object ^ FalsePart);" />
      <MemberSignature Language="F#" Value="static member IIf : bool * obj * obj -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.IIf (Expression, TruePart, FalsePart)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Expression" Type="System.Boolean" />
        <Parameter Name="TruePart" Type="System.Object" />
        <Parameter Name="FalsePart" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Expression">Necessário. <see langword="Boolean" />. A expressão que você deseja avaliar.</param>
        <param name="TruePart">Necessário. <see langword="Object" />. Retornado se <paramref name="Expression" /> for avaliado como <see langword="True" />.</param>
        <param name="FalsePart">Necessário. <see langword="Object" />. Retornado se <paramref name="Expression" /> for avaliado como <see langword="False" />.</param>
        <summary>Retorna um dos dois objetos, dependendo da avaliação de uma expressão.</summary>
        <returns>Retorna um dos dois objetos, dependendo da avaliação de uma expressão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `IIf` função fornece um equivalente para o ternário [operador condicional:?:](https://msdn.microsoft.com/library/88643ee8-7100-4f86-880a-705ec22b6271) no Visual C++.  
  
   
  
## Examples  
 Este exemplo usa o `IIf` função para avaliar a `testMe` parâmetro do `checkIt` procedimento e retorna if "Grande" word a quantidade é maior que 1000; caso contrário, retorna a palavra "Pequeno".  
  
 [!code-vb[VbVbalrFunctions#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#33)]  
  
 Observe que, se `Option Strict` está `On`, você deve usar o `CStr` palavra-chave para converter explicitamente o retorno de `Object` para `String`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/option-strict-statement.md">Instrução Option Strict</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/functions/type-conversion-functions.md">Funções de conversão do tipo</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/if-then-else-statement.md">Instrução If...Then... (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Instrução Select...Case (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="InputBox">
      <MemberSignature Language="C#" Value="public static string InputBox (string Prompt, string Title = &quot;&quot;, string DefaultResponse = &quot;&quot;, int XPos = -1, int YPos = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputBox(string Prompt, string Title, string DefaultResponse, int32 XPos, int32 YPos) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputBox (Prompt As String, Optional Title As String = &quot;&quot;, Optional DefaultResponse As String = &quot;&quot;, Optional XPos As Integer = -1, Optional YPos As Integer = -1) As String" />
      <MemberSignature Language="F#" Value="static member InputBox : string * string * string * int * int -&gt; string" Usage="Microsoft.VisualBasic.Interaction.InputBox (Prompt, Title, DefaultResponse, XPos, YPos)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.String" />
        <Parameter Name="Title" Type="System.String" />
        <Parameter Name="DefaultResponse" Type="System.String" />
        <Parameter Name="XPos" Type="System.Int32" />
        <Parameter Name="YPos" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Prompt">Expressão <see langword="String" /> necessária exibida como a mensagem na caixa de diálogo. O tamanho máximo de <paramref name="Prompt" /> é de aproximadamente 1.024 caracteres, dependendo da largura dos caracteres usados. Se <paramref name="Prompt" /> consistir em mais de uma linha, você poderá separar as linhas usando um caractere de retorno de carro (<see langword="Chr(" />13<see langword=")" />), um caractere de feed de linha (<see langword="Chr(" />10<see langword=")" />) ou uma combinação de retorno de carro/feed de linha (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre cada linha.</param>
        <param name="Title">Opcional. <see langword="String" /> expressão exibida na barra de título da caixa de diálogo. Se você omitir <paramref name="Title" />, o nome do aplicativo será colocado na barra de título.</param>
        <param name="DefaultResponse">Opcional. <see langword="String" /> expressão exibida na caixa de texto como a resposta padrão quando nenhuma outra entrada é fornecida. Se você omitir <paramref name="DefaultResponse" />, a caixa de texto exibida estará vazia.</param>
        <param name="XPos">Opcional. Expressão numérica que especifica, em twips, a distância desde a borda esquerda da caixa de diálogo até a borda esquerda da tela. Se você omitir <paramref name="XPos" />, a caixa de diálogo será centralizada horizontalmente.</param>
        <param name="YPos">Opcional. Expressão numérica que especifica, em twips, a distância desde a borda superior da caixa de diálogo até a parte superior da tela. Se você omitir <paramref name="YPos" />, a caixa de diálogo será posicionada verticalmente, a aproximadamente um terço da parte inferior da tela.</param>
        <summary>Exibe um aviso em uma caixa de diálogo, aguarda até que o usuário insira um texto ou clique em um botão e retorna uma cadeia de caracteres que contém o conteúdo da caixa de texto.</summary>
        <returns>Exibe um aviso em uma caixa de diálogo, aguarda até que o usuário insira um texto ou clique em um botão e retorna uma cadeia de caracteres que contém o conteúdo da caixa de texto.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o usuário clica **Cancelar**, uma cadeia de caracteres de comprimento zero será retornada.  
  
 Para especificar mais do que o primeiro argumento, você deve usar o `InputBox` função em uma expressão. Se você omitir argumentos posicionais, você deve manter o delimitador de vírgula correspondente.  
  
> [!NOTE]
>  O `InputBox` função requer `UIPermission` no <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nível, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte e <xref:System.Security.Permissions.UIPermission> .  
  
   
  
## Examples  
 Este exemplo mostra várias maneiras de usar o `InputBox` função para solicitar que o usuário insira um valor. Se x e y posições forem omitidas, a caixa de diálogo é automaticamente centralizada para os respectivos eixos. A variável `MyValue` contém o valor inserido pelo usuário, se o usuário clica Okey ou pressiona a tecla ENTER.  
  
 [!code-vb[VbVbalrCatRef#67](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#67)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="MsgBox">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.MsgBoxResult MsgBox (object Prompt, Microsoft.VisualBasic.MsgBoxStyle Buttons = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, object Title = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.MsgBoxResult MsgBox(object Prompt, valuetype Microsoft.VisualBasic.MsgBoxStyle Buttons, object Title) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.MsgBox(System.Object,Microsoft.VisualBasic.MsgBoxStyle,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function MsgBox (Prompt As Object, Optional Buttons As MsgBoxStyle = Microsoft.VisualBasic.MsgBoxStyle.ApplicationModal, Optional Title As Object = null) As MsgBoxResult" />
      <MemberSignature Language="F#" Value="static member MsgBox : obj * Microsoft.VisualBasic.MsgBoxStyle * obj -&gt; Microsoft.VisualBasic.MsgBoxResult" Usage="Microsoft.VisualBasic.Interaction.MsgBox (Prompt, Buttons, Title)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.MsgBoxResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Prompt" Type="System.Object" />
        <Parameter Name="Buttons" Type="Microsoft.VisualBasic.MsgBoxStyle" />
        <Parameter Name="Title" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="Prompt">Necessário. <see langword="String" /> expressão exibida como a mensagem na caixa de diálogo. O tamanho máximo de <paramref name="Prompt" /> é de aproximadamente 1.024 caracteres, dependendo da largura dos caracteres usados. Se <paramref name="Prompt" /> consistir em mais de uma linha, você poderá separar as linhas usando um caractere de retorno de carro (<see langword="Chr(" />13<see langword=")" />), um caractere de feed de linha (<see langword="Chr(" />10<see langword=")" />) ou uma combinação de caracteres de retorno de carro/feed de linha (<see langword="Chr(" />13<see langword=")" /> &amp; <see langword="Chr(" />10<see langword=")" />) entre cada linha.</param>
        <param name="Buttons">Opcional. Expressão numérica que é a soma dos valores que especificam o número e o tipo de botões a serem exibidos, o estilo de ícone a ser usado, a identidade do botão padrão e a modalidade da caixa de mensagem. Se você omitir <paramref name="Buttons" />, o valor padrão será zero.</param>
        <param name="Title">Opcional. <see langword="String" /> expressão exibida na barra de título da caixa de diálogo. Se você omitir <paramref name="Title" />, o nome do aplicativo será colocado na barra de título.</param>
        <summary>Exibe uma mensagem em uma caixa de diálogo, aguarda que o usuário clique em um botão e retorna um inteiro que indica em qual botão o usuário clicou.</summary>
        <returns><list type="table">
            <item>
              <term> Constante 
 </term>
              <description> Valor 
 </description>
            </item>
            <item>
              <term>
                <see langword="OK" />
              </term>
              <description> 1 
 </description>
            </item>
            <item>
              <term>
                <see langword="Cancel" />
              </term>
              <description> 2 
 </description>
            </item>
            <item>
              <term>
                <see langword="Abort" />
              </term>
              <description> 3 
 </description>
            </item>
            <item>
              <term>
                <see langword="Retry" />
              </term>
              <description> 4 
 </description>
            </item>
            <item>
              <term>
                <see langword="Ignore" />
              </term>
              <description> 5 
 </description>
            </item>
            <item>
              <term>
                <see langword="Yes" />
              </term>
              <description> 6 
 </description>
            </item>
            <item>
              <term>
                <see langword="No" />
              </term>
              <description> 7 
 </description>
            </item>
          </list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você omitir argumentos posicionais, você deve manter o delimitador de vírgula correspondente.  
  
 Se a caixa de diálogo exibe uma **cancele** botão, pressionando a tecla ESC tem o mesmo efeito que clicar **Cancelar**  
  
 Se a caixa de diálogo contém um **ajudar** botão, ajuda contextual é fornecida para a caixa de diálogo. No entanto, nenhum valor será retornado até que um dos outros botões é escolhido. Em aplicativos de formulário do Windows, escolha o **ajudar** botão executa o <xref:System.Windows.Forms.Control.HelpRequested> evento para o formulário.  
  
> [!NOTE]
>  O `MsgBox` função requer `UIPermission` no <xref:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows> nível, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.UIPermission>.  
  
 O `MsgBoxStyle` valores de enumeração são listados na tabela a seguir.  
  
|Membro|Valor|Descrição|  
|-|-|-|  
|Membro|Valor|Descrição|  
|`OKOnly`|0|Botão de monitores Okey apenas.|  
|`OKCancel`|1|Exibe Okey botões e Cancelar.|  
|`AbortRetryIgnore`|2|Exibe os botões abortar, repetir e ignorar.|  
|`YesNoCancel`|3|Exibe Yes, não e Cancelar botões.|  
|`YesNo`|4|Exibe os botões Sim e não.|  
|`RetryCancel`|5|Exibe os botões Cancelar e tente novamente.|  
|`Critical`|16|Exibe o ícone de mensagem crítica.|  
|`Question`|32|Exibe o ícone de aviso de consulta.|  
|`Exclamation`|48|Exibe o ícone de mensagem de aviso.|  
|`Information`|64|Exibe o ícone de mensagem de informações.|  
|`DefaultButton1`|0|O primeiro botão é padrão.|  
|`DefaultButton2`|256|O segundo botão é padrão.|  
|`DefaultButton3`|512|O terceiro botão é padrão.|  
|`ApplicationModal`|0|Aplicativo é restrito. O usuário deve responder à caixa de mensagem antes de continuar o trabalho no aplicativo atual.|  
|`SystemModal`|4096|O sistema é restrito. Todos os aplicativos são suspensos até que o usuário responda à caixa de mensagem.|  
|`MsgBoxSetForeground`|65536|Especifica a janela da caixa de mensagem como a janela de primeiro plano.|  
|`MsgBoxRight`|524288|Texto é alinhado à direita.|  
|`MsgBoxRtlReading`|1048576|Especifica o texto deve aparecer como direita-leitura para a esquerda nos sistemas hebraico e árabe.|  
  
 O primeiro grupo de valores (0-5) descreve o número e tipo dos botões exibidos na caixa de diálogo. O segundo grupo (16, 32, 48 e 64) descreve o estilo de ícone. O terceiro grupo (0, 256, 512) determina qual botão é o padrão. O quarto grupo (0, 4096) determina a modalidade da caixa de mensagem e o quinto grupo Especifica se a janela da caixa de mensagem é a janela de primeiro plano, juntamente com o alinhamento e a direção do texto. Ao adicionar números para criar um valor final para o `Buttons` argumento, use apenas um número de cada grupo.  
  
   
  
## Examples  
 Este exemplo usa o `MsgBox` função para exibir uma mensagem de erro crítico em uma caixa de diálogo com os botões Sim e não. O botão não é especificado como a resposta padrão. Isso é feito pela combinação de `MsgBox` valores constantes em uma expressão numérica. Nesse caso, adicionando 4 (a combinação botão Sim/não) e 16 (o **mensagem crítica** janela) e 256 (o segundo botão como botão padrão) oferece um total de 276. O valor retornado pelo `MsgBox` função depende do botão escolhido pelo usuário: Sim, retorna um valor de 6; Não retorna um valor de 7.  
  
 [!code-vb[VbVbalrCatRef#20](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#20)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Prompt" /> não é uma expressão <see langword="String" /> ou o <paramref name="Title" /> é inválido.</exception>
        <exception cref="T:System.InvalidOperationException">O processo não está em execução no modo Interativo do Usuário.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Um ou mais parâmetros não são membro da enumeração <see langword="MsgBoxResult" /> ou <see langword="MsgBoxStyle" />.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.InputBox(System.String,System.String,System.String,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.MessageBox.Show(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Partition">
      <MemberSignature Language="C#" Value="public static string Partition (long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="ILAsm" Value=".method public static string Partition(int64 Number, int64 Start, int64 Stop, int64 Interval) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Partition(System.Int64,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Partition (Number As Long, Start As Long, Stop As Long, Interval As Long) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Partition(long Number, long Start, long Stop, long Interval);" />
      <MemberSignature Language="F#" Value="static member Partition : int64 * int64 * int64 * int64 -&gt; string" Usage="Microsoft.VisualBasic.Interaction.Partition (Number, Start, Stop, Interval)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Number" Type="System.Int64" />
        <Parameter Name="Start" Type="System.Int64" />
        <Parameter Name="Stop" Type="System.Int64" />
        <Parameter Name="Interval" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="Number">Necessário. <see langword="Long" />. Número inteiro que você deseja localizar em um dos intervalos calculados.</param>
        <param name="Start">Necessário. <see langword="Long" />. Número inteiro que indica o início do conjunto de intervalos calculados. <paramref name="Start" /> não pode ser menor que 0.</param>
        <param name="Stop">Necessário. <see langword="Long" />. Número inteiro que indica o fim do conjunto de intervalos calculados. <paramref name="Stop" /> não pode ser menor ou igual a <paramref name="Start" />.</param>
        <param name="Interval">Necessário. <see langword="Long" />. Número inteiro que indica o tamanho de cada intervalo calculado entre <paramref name="Start" /> e <paramref name="Stop" />. <paramref name="Interval" /> não pode ser menor que 1.</param>
        <summary>Retorna uma cadeia de caracteres que representa o intervalo calculado que contém um número.</summary>
        <returns>Uma cadeia de caracteres que representa o intervalo calculado que contém um número.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `Partition` função calcula um conjunto de intervalos numéricos, cada um contendo o número de valores especificados pelo `Interval`. O primeiro intervalo começa em `Start`, e o último intervalo termina em `Stop`. O `Partition` função, em seguida, identifica qual intervalo contém `Number` e retorna uma cadeia de caracteres que descreve esse intervalo. O intervalo é representado na cadeia de caracteres como "*valormínimo*:*valormáximo*", em que a extremidade inferior do intervalo (*valormínimo*) é separada da extremidade alta ( *valormáximo*) por dois-pontos (:).  
  
 Se necessário, o `Partition` função insere espaços à esquerda antes *valormínimo* e *valormáximo* para que tenham o mesmo número de caracteres como a representação de cadeia de caracteres de (o valor `Stop` + 1). Isso garante que, se você usar a saída a `Partition` função com vários valores de `Number`, o texto resultante será manipulado apropriadamente durante qualquer tipo de operação subsequente.  
  
 A tabela a seguir mostra algumas cadeias de caracteres para intervalos calculados usando três conjuntos de exemplo `Start`, `Stop`, e `Interval`. O "Primeiro intervalo" e "Último intervalo" colunas mostram a menor e maior possível de intervalos de dados os valores de `Start` e `Stop`. As colunas "antes do primeiro intervalo" e "depois do último intervalo" mostram as cadeias de caracteres retornadas para valores de `Number` menor que `Start` e maior `Stop`, respectivamente.  
  
|`Start`|`Stop`|`Interval`|Antes do primeiro intervalo|Primeiro intervalo|Último intervalo|Depois do último intervalo|  
|-|-|-|-|-|-|-|  
|0|99|5|"   : -1"|"  0:  4"|" 95: 99"|"100:   "|  
|20|199|10|"   : 19"|" 20: 29"|"190:199"|"200:   "|  
|100|1010|20|"    : 99"|" 100: 119"|"1000:1010"|"1011:    "|  
  
 Na tabela anterior, a terceira linha mostra o resultado quando `Start` e `Stop` definem um conjunto de números que não podem ser igualmente divididos por `Interval`. O último intervalo termina em `Stop`, tornando-o somente 11 números, embora `Interval` é 20.  
  
 Se `Interval` for 1, o intervalo é "`Number`:`Number`", independentemente do `Start` e `Stop` argumentos. Por exemplo, se `Number` é 267, `Stop` é 1000, e `Interval` for 1, `Partition` retorna "267: 267".  
  
 `Partition` pode ser útil ao construir consultas de banco de dados. Você pode criar uma consulta SELECT que mostra quantos pedidos ocorrerem em vários intervalos de valor, por exemplo, com valores de nota fiscal de 1 a 1000, 1001 a 2000 e assim por diante.  
  
   
  
## Examples  
 O exemplo a seguir define uma série de intervalos por décadas de 1950 até 2049. Ele localiza o valor de `year` dentro do intervalo apropriado e retorna um `String` mostrando o intervalo de valor. Se `year` tem um valor de 1984, por exemplo, `Partition` retorna "1980: 1989".  
  
 [!code-vb[VbVbalrFunctions#45](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#45)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Start" /> &lt; 0, <paramref name="Stop" /> &lt;= <paramref name="Start" /> ou <paramref name="Interval" /> &lt; 1.</exception>
      </Docs>
    </Member>
    <Member MemberName="SaveSetting">
      <MemberSignature Language="C#" Value="public static void SaveSetting (string AppName, string Section, string Key, string Setting);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SaveSetting(string AppName, string Section, string Key, string Setting) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.SaveSetting(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveSetting (AppName As String, Section As String, Key As String, Setting As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SaveSetting(System::String ^ AppName, System::String ^ Section, System::String ^ Key, System::String ^ Setting);" />
      <MemberSignature Language="F#" Value="static member SaveSetting : string * string * string * string -&gt; unit" Usage="Microsoft.VisualBasic.Interaction.SaveSetting (AppName, Section, Key, Setting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="AppName" Type="System.String" />
        <Parameter Name="Section" Type="System.String" />
        <Parameter Name="Key" Type="System.String" />
        <Parameter Name="Setting" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="AppName">Necessário. <see langword="String" /> expressão que contém o nome do aplicativo ou do projeto ao qual a configuração se aplica.</param>
        <param name="Section">Necessário. <see langword="String" /> expressão que contém o nome da seção na qual a configuração de chave está sendo salva.</param>
        <param name="Key">Necessário. <see langword="String" /> expressão que contém o nome da configuração de chave que está sendo salva.</param>
        <param name="Setting">Necessário. Expressão que contém o valor para o qual <paramref name="Key" /> está sendo definido.</param>
        <summary>Salva ou cria uma entrada de aplicativo no Registro do Windows. O recurso <see langword="My" /> oferece melhor produtividade e desempenho em operações do Registro do que o <see langword="SaveSetting" />. Para obter mais informações, consulte <see cref="P:Microsoft.VisualBasic.Devices.ServerComputer.Registry" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `SaveSetting` função adiciona a chave a ser `HKEY_CURRENT_USER\Software\VB and VBA Program Settings`.  
  
 Se a configuração de chave não pode ser salvo por algum motivo, ocorrerá um erro.  
  
 `SaveSetting` requer que um usuário fazer logon, pois ele opera com o `HKEY_LOCAL_USER` chave do registro, que não está ativa até que um usuário faz logon interativamente.  
  
 Configurações do registro que devem ser acessadas a partir de um processo não interativo (por exemplo, Mtx.exe) devem ser armazenadas em do `HKEY_LOCAL_MACHINE\Software\` ou o `HKEY_USER\DEFAULT\Software` chaves do registro.  
  
 `SaveSetting` requer `Write` e `Create`<xref:System.Security.Permissions.RegistryPermission> .  
  
   
  
## Examples  
 O exemplo a seguir usa primeiro a `SaveSetting` função para fazer as entradas no registro do Windows para o `MyApp` aplicativo e, em seguida, usa o `DeleteSetting` função para removê-los.  
  
 [!code-vb[VbVbalrCatRef#56](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#56)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Não foi possível criar o Registro de chave ou o usuário não está conectado.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.DeleteSetting(System.String,System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetAllSettings(System.String,System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.GetSetting(System.String,System.String,System.String,System.String)" />
        <altmember cref="T:System.Security.Permissions.RegistryPermission" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/computer-resources/reading-from-and-writing-to-the-registry.md">Lendo e gravando a partir do Registro (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Shell">
      <MemberSignature Language="C#" Value="public static int Shell (string Pathname, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string Pathname, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (Pathname As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static int Shell (string PathName, Microsoft.VisualBasic.AppWinStyle Style = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, bool Wait = false, int Timeout = -1);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 Shell(string PathName, valuetype Microsoft.VisualBasic.AppWinStyle Style, bool Wait, int32 Timeout) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Shell (PathName As String, Optional Style As AppWinStyle = Microsoft.VisualBasic.AppWinStyle.MinimizedFocus, Optional Wait As Boolean = false, Optional Timeout As Integer = -1) As Integer" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Shell(System.String,Microsoft.VisualBasic.AppWinStyle,System.Boolean,System.Int32)" FrameworkAlternate="netframework-2.0" />
      <MemberSignature Language="F#" Value="static member Shell : string * Microsoft.VisualBasic.AppWinStyle * bool * int -&gt; int" Usage="Microsoft.VisualBasic.Interaction.Shell (PathName, Style, Wait, Timeout)" FrameworkAlternate="netframework-2.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Style" Type="Microsoft.VisualBasic.AppWinStyle" Index="1" />
        <Parameter Name="Wait" Type="System.Boolean" Index="2" />
        <Parameter Name="Timeout" Type="System.Int32" Index="3" />
      </Parameters>
      <Docs>
        <param name="Pathname">Necessário. <see langword="String" />. Nome do programa a ser executado, junto com argumentos necessários e opções de linha de comando. <paramref name="PathName" /> também pode incluir a unidade e o caminho do diretório ou a pasta.
Se você não souber o caminho para o programa, poderá usar o <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> para localizá-lo. Por exemplo, você pode chamar <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, que retorna o caminho completo de cada arquivo chamado <c>testFile.txt</c> em qualquer lugar da unidade C:\\.</param>
        <param name="PathName">Necessário. <see langword="String" />. Nome do programa a ser executado, junto com argumentos necessários e opções de linha de comando. <paramref name="PathName" /> também pode incluir a unidade e o caminho do diretório ou a pasta.  
 Se você não souber o caminho para o programa, poderá usar o <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" /> para localizá-lo. Por exemplo, você pode chamar <c>My.Computer.FileSystem.GetFiles("C:\", True, "testFile.txt")</c>, que retorna o caminho completo de cada arquivo chamado <c>testFile.txt</c> em qualquer lugar da unidade C:\\.</param>
        <param name="Style">Opcional. <see langword="AppWinStyle" />. Um valor escolhido do <see cref="T:Microsoft.VisualBasic.AppWinStyle" /> que especifica o estilo da janela em que o programa será executado. Se <paramref name="Style" /> for omitido, <see langword="Shell" /> usará <see langword="AppWinStyle.MinimizedFocus" />, que inicia o programa minimizado e com foco.</param>
        <param name="Wait">Opcional. <see langword="Boolean" />. Um valor que indica se a função <see langword="Shell" /> deve aguardar a conclusão do programa. Se <paramref name="Wait" /> for omitido, <see langword="Shell" /> usará <see langword="False" />.</param>
        <param name="Timeout">Opcional. <see langword="Integer" />. O número de milissegundos de espera de uma conclusão se <paramref name="Wait" /> for <see langword="True" />. Se <paramref name="Timeout" /> for omitido, <see langword="Shell" /> usará -1, o que significa que não há nenhum tempo limite e <see langword="Shell" /> não retorna até que o programa seja concluído. Portanto, se você omitir <paramref name="Timeout" /> ou defini-lo como-1, é possível que <see langword="Shell" /> nunca retorne o controle ao seu programa.</param>
        <summary>Executa um programa executável e retorna um inteiro que contém a ID do processo do programa se ele ainda está em execução.</summary>
        <returns>Um inteiro que contém a ID do processo do programa quando ele ainda está em execução. 0 se o programa já tiver terminado sua execução.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno de `Shell` função depende se o programa nomeado na `PathName` ainda está em execução quando `Shell` retorna. Se você definir `Wait` à `True` e o programa seja concluído antes do tempo limite expira, `Shell` retorna zero. Se o tempo limite expirar, ou se você omitir `Wait` ou defina-a como `False`, `Shell` retorna a ID do processo do programa. A ID do processo é um número exclusivo que identifica o programa em execução.  
  
## <a name="failure-to-start"></a>Falha ao iniciar  
 Se o `Shell` função não é possível iniciar o programa nomeado, um <xref:System.IO.FileNotFoundException> erro ocorre. Isso pode acontecer, por exemplo, quando você tenta executar um programa de 16 bits, tais como `command.com`, de um aplicativo usando <xref:System.Windows.Forms?displayProperty=nameWithType>. Para obter uma solução alternativa, você pode executar um programa de 32 bits que chama o programa de 16 bits desejado. No caso de `command.com`, você pode executar `cmd.exe` como uma alternativa.  
  
## <a name="waiting-for-completion"></a>Aguardando a conclusão  
 Por padrão, o `Shell` função executa o programa de forma assíncrona. Isso significa que um programa iniciado com o `Shell` função não pode concluir a execução antes de seguir as instruções de `Shell` função são executadas. Se você quiser esperar para o programa termine antes de continuar, defina `Wait` para `True`.  
  
## <a name="determining-the-exit-code"></a>Determinando o código de saída  
 Um processo pode retornar um *código de saída* quando ele for encerrado. No entanto, você não pode usar `Shell` para recuperar esse código de saída, pois `Shell` retorna zero se ele aguarda o encerramento e também porque o processo é executado em um objeto diferente de `Shell`.  
  
 Para recuperar o código de saída de um processo, você deve escrever seu próprio código para iniciar o processo e aguardar o encerramento. O exemplo a seguir mostra como iniciar um processo, aguardar o encerramento e recuperar seu código de saída.  
  
```vb  
Dim procID As Integer  
Dim newProc As Diagnostics.Process  
newProc = Diagnostics.Process.Start("C:\WINDOWS\NOTEPAD.EXE")  
procID = newProc.Id  
newProc.WaitForExit()  
Dim procEC As Integer = -1  
If newProc.HasExited Then  
    procEC = newProc.ExitCode  
End If  
MsgBox("Process with ID " & CStr(ProcID) & _  
    " terminated with exit code " & CStr(procEC))  
```  
  
## <a name="protecting-the-file-specification"></a>Protegendo a especificação de arquivo  
 Você deve sempre colocar a especificação de arquivo e caminho inteira entre aspas, como mostra o exemplo a seguir.  
  
```vb  
ID = Shell("""C:\Program Files\display.exe"" -a -q", , True, 100000)  
```  
  
 Cada par de aspas duplas adjacentes (`" "`) na cadeia de caracteres literal é interpretado como um caractere aspas duplas na cadeia de caracteres. Portanto, o exemplo anterior apresenta a seguinte cadeia de caracteres para o `Shell` função:  
  
```console  
"C:\Program Files\display.exe" -a -q  
```  
  
 Se você não tem o caminho entre aspas, Windows procurará por um arquivo chamado `Program.exe` no diretório c:\., em vez de `display.exe` no diretório C:\Program Files.  
  
> [!IMPORTANT]
>  Se você não coloque a especificação de arquivo e caminho entre aspas, há um risco à segurança se o nome do arquivo ou um nó de caminho contiver espaços. No exemplo anterior, o nó de caminho `\Program Files` inclui um espaço. Se a especificação não estava dentro das aspas e um programa denominado `Program.exe` tivesse sido instalado em c:\\, por exemplo por adulteração ilícita, Windows seriam executá-lo em vez de `display.exe`.  
  
> [!IMPORTANT]
>  O `Shell` função requer permissão de código não gerenciado, que pode afetar sua execução em situações de confiança parcial. Para obter mais informações, consulte <xref:System.Security.Permissions.SecurityPermission> e [permissões de acesso do código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).  
  
   
  
## Examples  
 O exemplo a seguir usa o `Shell` função para executar um aplicativo especificado pelo usuário. Especificando <xref:Microsoft.VisualBasic.AppWinStyle.NormalFocus?displayProperty=nameWithType> como o segundo argumento abre o aplicativo em tamanho normal e concede a ele o foco.  
  
 [!code-vb[VbVbalrFunctions#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#47)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="Style" /> não está no intervalo de 0 a 9, inclusivo.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><see langword="Shell" /> não pode localizar o arquivo <paramref name="PathName" />.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="PathName" /> é <see langword="Nothing" />.</exception>
        <altmember cref="T:Microsoft.VisualBasic.AppWinStyle" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.NullReferenceException" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.GetFiles" />
        <altmember cref="Overload:Microsoft.VisualBasic.Interaction.AppActivate" />
      </Docs>
    </Member>
    <Member MemberName="Switch">
      <MemberSignature Language="C#" Value="public static object Switch (params object[] VarExpr);" />
      <MemberSignature Language="ILAsm" Value=".method public static object Switch(object[] VarExpr) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.Interaction.Switch(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Switch (ParamArray VarExpr As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ Switch(... cli::array &lt;System::Object ^&gt; ^ VarExpr);" />
      <MemberSignature Language="F#" Value="static member Switch : obj[] -&gt; obj" Usage="Microsoft.VisualBasic.Interaction.Switch VarExpr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="VarExpr" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="VarExpr">Necessário. <see langword="Object" /> matriz de parâmetros. Deve ter um número par de elementos. Você pode fornecer uma lista de variáveis <see langword="Object" /> ou expressões separadas por vírgulas ou uma matriz unidimensional de elementos <see langword="Object" />.</param>
        <summary>Avalia uma lista de expressões e retorna um valor <see langword="Object" /> correspondente à primeira expressão na lista, que é <see langword="True" />.</summary>
        <returns>Avalia uma lista de expressões e retorna um valor <see langword="Object" /> correspondente à primeira expressão na lista, que é <see langword="True" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O argumento fornecido para `VarExpr` consiste em pares de expressões e valores. O `Switch` função avalia as expressões de número ímpar do menor para o maior índice na `VarExpr`e retorna o valor do par associado com a primeira expressão é avaliada como `True`. Por exemplo, se `VarExpr(0)` está `True`, `Switch` retorna `VarExpr(1)`e se `VarExpr(0)` é `False` mas `VarExpr(2)` é `True`, `Switch` retorna `VarExpr(3)`e assim por diante.  
  
 Se você não fornecer a `VarExpr` argumento, `Switch` retorna `Nothing`.  
  
> [!NOTE]
>  As expressões na lista de argumentos podem incluir chamadas de função. Como parte da preparação da lista de argumentos para a chamada para `Switch`, o compilador do Visual Basic chama todas as funções em todas as expressões. Isso significa que você não pode contar com uma função particular não chamada se uma expressão anterior na lista de argumentos for `True`.  
  
   
  
## Examples  
 O exemplo a seguir usa o `Switch` função para retornar o nome de um idioma que corresponde ao nome de uma cidade. Ele requer que `Option Strict` ser `Off`.  
  
 [!code-vb[VbVbalrFunctions#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrFunctions/VB/Class1.vb#48)]  
  
 Porque o <xref:System.Diagnostics> namespace também contém uma classe chamada <xref:System.Diagnostics.Switch>, uma chamada para o `Switch` função deve ser qualificada com o <xref:Microsoft.VisualBasic> namespace.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O número de argumentos é ímpar.</exception>
        <altmember cref="M:Microsoft.VisualBasic.Interaction.Choose(System.Double,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Interaction.IIf(System.Boolean,System.Object,System.Object)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/select-case-statement.md">Instrução Select...Case (Visual Basic)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/parameter-arrays.md">Matrizes de parâmetros</related>
      </Docs>
    </Member>
  </Members>
</Type>
