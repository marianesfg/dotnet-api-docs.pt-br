<Type Name="ServiceBase" FullName="System.ServiceProcess.ServiceBase">
  <Metadata><Meta Name="ms.openlocfilehash" Value="15095204d9fc579de13f7d400c3e24b4339f5ab4" /><Meta Name="ms.sourcegitcommit" Value="d40b35262cbc997b79bf76da3a39ccf59b738efc" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/05/2018" /><Meta Name="ms.locfileid" Value="52906755" /></Metadata><TypeSignature Language="C#" Value="public class ServiceBase : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ServiceBase extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.ServiceProcess.ServiceBase" />
  <TypeSignature Language="VB.NET" Value="Public Class ServiceBase&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class ServiceBase : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type ServiceBase = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.ComponentModel.InstallerType(typeof(System.ServiceProcess.ServiceProcessInstaller))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("Microsoft.VisualStudio.Install.UserNTServiceDesigner, Microsoft.VisualStudio, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.ComponentModel.Design.IRootDesigner")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma classe base para um serviço que existirá como parte de um aplicativo de serviço. <see cref="T:System.ServiceProcess.ServiceBase" /> deve ser derivado do momento da criação de uma nova classe de serviço.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Derivar de <xref:System.ServiceProcess.ServiceBase> ao definir sua classe de serviço em um aplicativo de serviço. Substituições de qualquer serviço útil a <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos. Para obter funcionalidade adicional, você pode substituir <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> com comportamento específico em resposta a alterações no estado do serviço.  
  
 Um serviço é um executável de longa execução que não oferece suporte a uma interface do usuário, e que não pode ser executado sob a conta de logon do usuário. O serviço pode ser executado sem qualquer usuário que está sendo conectado ao computador.  
  
 Por padrão, os serviços executados na conta do sistema, que não é o mesmo que a conta de administrador. Você não pode alterar os direitos da conta do sistema. Como alternativa, você pode usar um <xref:System.ServiceProcess.ServiceProcessInstaller> para especificar uma conta de usuário sob a qual o serviço será executado.  
  
 Um executável pode conter mais de um serviço, mas deve conter um separado <xref:System.ServiceProcess.ServiceInstaller> para cada serviço. O <xref:System.ServiceProcess.ServiceInstaller> instância registra o serviço com o sistema. O instalador também associa cada serviço com um log de eventos que você pode usar para registrar comandos de serviço. O `main()` função no executável define quais serviços devem ser executados. O diretório de trabalho atual do serviço é o diretório do sistema, não o diretório no qual o executável está localizado.  
  
 Quando você inicia um serviço, o sistema localiza o executável e executa o <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método para o serviço, contido no executável. No entanto, que executa o serviço não é o mesmo que o executável. O executável carrega apenas o serviço. O serviço é acessado por meio do Gerenciador de controle de serviço (por exemplo, iniciado e interrompido).  
  
 O executável chama o <xref:System.ServiceProcess.ServiceBase> derivado de tempo de construtor o primeiro da classe é chamar o início do serviço. O <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método de manipulação de comandos é chamado imediatamente depois que o construtor é executado. O construtor não é executado novamente após a primeira vez em que o serviço tiver sido carregado, portanto, é necessário separar o processamento executado pelo construtor daquele executadas pelo <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Todos os recursos que podem ser liberados pelo <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deve ser criado em <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Criar recursos no construtor impede que eles sejam criadas corretamente se o serviço for iniciado novamente após <xref:System.ServiceProcess.ServiceBase.OnStop%2A> lançou os recursos.  
  
 O Gerenciador de controle de serviço (SCM) fornece uma maneira de interagir com o serviço. Você pode usar o SCM para passar o iniciar, parar, pausar, continuar ou comandos personalizados para o serviço. O SCM usa os valores de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> e <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> para determinar se o serviço aceita parar, pausar ou continuar comandos. Interromper, pausar e continuar são habilitados somente se do SCM contexto menus a propriedade correspondente <xref:System.ServiceProcess.ServiceBase.CanStop%2A> ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `true` da classe de serviço. Se habilitada, o comando é passado para o serviço, e <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> é chamado. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `false`, o método de manipulação de comandos correspondente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) não será processada, mesmo se você tiver implementado o método.  
  
 Você pode usar o <xref:System.ServiceProcess.ServiceController> faz de classe para fazer o que o SCM de forma programática usando uma interface do usuário. Você pode automatizar as tarefas disponíveis no console do. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A>, <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A>, ou <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `true` , mas não implementou um método de manipulação de comandos correspondente (como <xref:System.ServiceProcess.ServiceBase.OnStop%2A>) o sistema gerará uma exceção e ignora o comando.  
  
 Você não precisa implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, <xref:System.ServiceProcess.ServiceBase.OnStop%2A>, ou qualquer outro método <xref:System.ServiceProcess.ServiceBase>. No entanto, o comportamento do serviço é descrito em <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, portanto, no mínimo, esse membro deve ser substituído. O `main()` função do executável que registra o serviço no executável com o Gerenciador de controle de serviço chamando o <xref:System.ServiceProcess.ServiceBase.Run%2A> método. O <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> propriedade do <xref:System.ServiceProcess.ServiceBase> objeto passado para o <xref:System.ServiceProcess.ServiceBase.Run%2A> deve corresponder ao <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A> propriedade do instalador do serviço para o serviço.  
  
 Você pode usar `InstallUtil.exe` para instalar os serviços em seu sistema.  
  
> [!NOTE]
>  Você pode especificar um log diferente do log de eventos do aplicativo para receber uma notificação de chamadas de serviço, mas não a <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> nem o <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriedade pode gravar em um log personalizado. Definir <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> para `false` se você não quiser usar o registro em log automático.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.ServiceProcess.ServiceProcessInstaller" />
    <altmember cref="T:System.ServiceProcess.ServiceInstaller" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ServiceBase ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ServiceBase();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Cria uma nova instância da classe <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não crie uma instância da <xref:System.ServiceProcess.ServiceBase> classe. Em vez disso, derivar de <xref:System.ServiceProcess.ServiceBase> e instanciar sua classe derivada. O mínimo necessário implementar no construtor para uma classe herdada de <xref:System.ServiceProcess.ServiceBase> é definir o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> no seu componente. Nenhum outro processamento especificamente é necessária no construtor. Você deve tratar a maioria dos inicialização em <xref:System.ServiceProcess.ServiceBase.OnStart%2A> em vez de no construtor. Caso contrário, não há nenhuma garantia que os objetos serão reinicializados quando você reinicia um serviço depois que ele foi interrompido.  
  
 Se você substituir o construtor em sua classe derivada, chame o construtor de classe base em seu código.  
  
 O <xref:System.ServiceProcess.ServiceBase> construtor define <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> para `true`. Se você não deseja fazer automaticamente as chamadas para o serviço do Gerenciador de controle de serviço (SCM), defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> para `false`.  
  
 Se o executável contém um único serviço, o sistema chama o construtor do serviço quando início é selecionado do SCM e executa o destruidor se parar for chamado.  
  
 Se o executável contém vários serviços, chamar Start em um serviço faz com que os construtores a ser chamado para todos os serviços no executável, mas apenas o serviço especificado é iniciado. Destruidores para os serviços são executados juntos quando todos os serviços tenham sido interrompidos, não individualmente quando cada serviço é interrompido.  
  
> [!NOTE]
>  Se você substituir o construtor de classe base, você deve chamá-lo explicitamente no construtor da sua classe derivada.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      </Docs>
    </Member>
    <Member MemberName="AutoLog">
      <MemberSignature Language="C#" Value="public bool AutoLog { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoLog As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoLog { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoLog : bool with get, set" Usage="System.ServiceProcess.ServiceBase.AutoLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBAutoLog")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica se os comandos Start, Stop, Pause e Continue devem ser relatados no log de eventos.</summary>
        <value><see langword="true" /> para relatar informações no log de eventos; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Definindo <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> para `true` instrui o serviço para usar o log de eventos do aplicativo para relatar falhas de comando, bem como informações de alteração de estado para iniciar, parar, pausar e continuar o serviço de eventos. O nome do serviço é usado como o log <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType>.  
  
 Para relatar informações para um log de eventos personalizado em vez do log de aplicativo, defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false` e escrever instruções dentro do método de manipulação de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para postar no log apropriado.  
  
> [!NOTE]
>  O <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, que fornece a cadeia de caracteres de origem para o log de eventos deve ser definida antes que o serviço tenta gravar no log de eventos. Tentando acessar o log de eventos antes que o nome de origem é definido gera uma exceção.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.EventLog" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandlePowerEvent">
      <MemberSignature Language="C#" Value="public bool CanHandlePowerEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandlePowerEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandlePowerEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandlePowerEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandlePowerEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o serviço pode manipular notificações de alterações de status de energia do computador.</summary>
        <value><see langword="true" /> se o serviço manipular as alterações de status de energia do computador indicadas na classe <see cref="T:System.ServiceProcess.PowerBroadcastStatus" />; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando as alterações de status de energia do computador, o Gerenciador de controle de serviço (SCM) verifica se o serviço aceita comandos de eventos de energia usando o valor de <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> está `true`, o comando é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> método é chamado, se definido. Se <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> não está implementado na classe derivada, o SCM manipula o evento de energia por meio da classe base vazia <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Essa propriedade é modificada depois que o serviço é iniciado.</exception>
        <altmember cref="T:System.ServiceProcess.PowerBroadcastStatus" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
      </Docs>
    </Member>
    <Member MemberName="CanHandleSessionChangeEvent">
      <MemberSignature Language="C#" Value="public bool CanHandleSessionChangeEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHandleSessionChangeEvent" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property CanHandleSessionChangeEvent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHandleSessionChangeEvent { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanHandleSessionChangeEvent : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o serviço pode manipular eventos de alteração de sessão recebidos de uma sessão do servidor Host da Sessão da Área de Trabalho Remota.</summary>
        <value><see langword="true" /> Se o serviço pode manipular eventos de alteração de sessão do Terminal Server; Caso contrário, <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Essa propriedade é modificada depois que o serviço é iniciado.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanPauseAndContinue">
      <MemberSignature Language="C#" Value="public bool CanPauseAndContinue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanPauseAndContinue" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberSignature Language="VB.NET" Value="Public Property CanPauseAndContinue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanPauseAndContinue { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanPauseAndContinue : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o serviço pode estar em pausa e retomado.</summary>
        <value><see langword="true" /> se o serviço pode estar em pausa; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina o valor da <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> propriedade no construtor para o serviço.  
  
 Quando um serviço está em pausa, ele interrompe o que está fazendo. Quando você continua o serviço (ou por meio do Gerenciador de controle de serviço ou por meio de programação), <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> é executado.  
  
 Enviando uma solicitação de pausa para o serviço pode conservar recursos do sistema. Pausar não pode liberar todos os recursos do sistema, mas não de palavras irrelevantes. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> geralmente são implementados para executar o processamento do menor que <xref:System.ServiceProcess.ServiceBase.OnStop%2A> e <xref:System.ServiceProcess.ServiceBase.OnStart%2A>.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> está `true`, substitua <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar o processamento que deve ocorrer quando o Gerenciador de controle de serviço (SCM) transmite uma solicitação de pausar ou continuar para seu serviço. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve ser implementado para desfazer o processamento em <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> está `false`, o SCM não passa pausar ou continuar solicitações para o serviço, portanto, o <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos não serão chamados, mesmo se forem implementadas. No SCM, o `Pause` e `Continue` controles são desabilitados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `false`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O serviço já foi iniciado. A propriedade <see cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" /> não pode ser alterada depois que o serviço é iniciado.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanShutdown">
      <MemberSignature Language="C#" Value="public bool CanShutdown { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanShutdown" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberSignature Language="VB.NET" Value="Public Property CanShutdown As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanShutdown { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanShutdown : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanShutdown" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o serviço deve ser notificado quando o sistema está sendo desligado.</summary>
        <value><see langword="true" /> se o serviço precisar ser notificado quando o sistema estiver sendo desligado; caso contrário, <see langword="false" />.  O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> é `true`, o serviço é notificado quando o sistema está sendo desligado. Durante o desligamento, o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> método é chamado se ele tiver sido implementado na classe derivada.  
  
> [!NOTE]
>  Apenas o sistema deve fazer com que o <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> método a ser executado; o serviço pode chamá-lo, mas isso não é recomendado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O serviço já foi iniciado. A propriedade <see cref="P:System.ServiceProcess.ServiceBase.CanShutdown" /> não pode ser alterada depois que o serviço é iniciado.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="CanStop">
      <MemberSignature Language="C#" Value="public bool CanStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanStop" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.CanStop" />
      <MemberSignature Language="VB.NET" Value="Public Property CanStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanStop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.CanStop : bool with get, set" Usage="System.ServiceProcess.ServiceBase.CanStop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se o serviço pode ser interrompido depois de ser iniciado.</summary>
        <value><see langword="true" /> se o serviço puder ser interrompido e o método <see cref="M:System.ServiceProcess.ServiceBase.OnStop" /> chamado, caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando a interrupção for chamada em um serviço, o Gerenciador de controle de serviço (SCM) verifica se o serviço aceita comandos de parada usando o valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A>. Para a maioria dos serviços, o valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> é `true`, mas alguns serviços do sistema operacional, por exemplo, não permitir que o usuário para interrompê-los.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> está `true`, o comando Parar é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> método é chamado se ele está definido. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> não está implementado na classe derivada, as alças SCM a parada de comando por meio da classe base vazia <xref:System.ServiceProcess.ServiceBase.OnStop%2A?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O serviço já foi iniciado. A propriedade <see cref="P:System.ServiceProcess.ServiceBase.CanStop" /> não pode ser alterada depois que o serviço é iniciado.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="serviceBase.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Descarta os recursos (exceto a memória) usados pelo <see cref="T:System.ServiceProcess.ServiceBase" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chame <xref:System.ServiceProcess.ServiceBase.Dispose%2A> em sua classe derivada (e, com isso, no <xref:System.ServiceProcess.ServiceBase> classe) quando tiver terminado de usar a classe derivada. O <xref:System.ServiceProcess.ServiceBase.Dispose%2A> método deixa a classe derivada em um estado inutilizável. Depois de chamar <xref:System.ServiceProcess.ServiceBase.Dispose%2A>, você deve liberar todas as referências à classe derivada e <xref:System.ServiceProcess.ServiceBase> para que a memória que eles estavam ocupando pode ser recuperada pela coleta de lixo.  
  
> [!NOTE]
>  Sempre chamar <xref:System.ServiceProcess.ServiceBase.Dispose%2A> antes de liberar sua última referência para a classe derivada de <xref:System.ServiceProcess.ServiceBase>. Caso contrário, os recursos <xref:System.ServiceProcess.ServiceBase> e a classe derivada são usando será não ser liberado até que a coleta de lixo chama destruidores de objetos.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> geralmente é implementado para processar o código na <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, combinado com uma chamada para <xref:System.ServiceProcess.ServiceBase.Dispose%2A>. Se você optar por fazer isso em sua classe derivada, é comum implementar <xref:System.ServiceProcess.ServiceBase.OnStart%2A> alocar qualquer <xref:System.ServiceProcess.ServiceBase.Dispose%2A> lançado.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="EventLog">
      <MemberSignature Language="C#" Value="public virtual System.Diagnostics.EventLog EventLog { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.EventLog EventLog" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.EventLog" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EventLog As EventLog" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Diagnostics::EventLog ^ EventLog { System::Diagnostics::EventLog ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EventLog : System.Diagnostics.EventLog" Usage="System.ServiceProcess.ServiceBase.EventLog" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.EventLog</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um log de eventos que você pode usar para gravar a notificação de chamadas de comando de serviço, como iniciar e parar, no log de eventos do aplicativo.</summary>
        <value>Uma instância de <see cref="T:System.Diagnostics.EventLog" /> cuja origem é registrada no log de aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O construtor inicializa o <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriedade para a instância com o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.EventLog.Log%2A?displayProperty=nameWithType> conjunto de propriedades. A fonte é o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> do serviço, e o log é o log de aplicativo do computador. Esses valores são definidas automaticamente e não podem ser alterados para o registro automático de comandos do serviço.  
  
 Quando <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> é `true`, iniciar, parar, pausar, continuar e comandos personalizados são registrados automaticamente no log de eventos do aplicativo. Você pode usar o <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriedade para gravar mensagens adicionais para esse log também. As chamadas de componente <xref:System.Diagnostics.EventLog.WriteEntry%2A?displayProperty=nameWithType> usando este <xref:System.ServiceProcess.ServiceBase.EventLog%2A> membro.  
  
 Para relatar informações para um log de eventos personalizado em vez do log de aplicativo, defina <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> à `false` e escrever instruções dentro do método de manipulação de comandos <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para postar no log apropriado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.AutoLog" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
        <altmember cref="T:System.Diagnostics.EventLog" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.ServiceProcess.ServiceBase.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o código de saída do serviço.</summary>
        <value>O código de saída do serviço.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Defina o <xref:System.ServiceProcess.ServiceBase.ExitCode%2A> propriedade para um valor diferente de zero antes de parar o serviço para indicar um erro para o Gerenciador de controle de serviço.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxNameLength">
      <MemberSignature Language="C#" Value="public const int MaxNameLength = 80;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal int32 MaxNameLength = (80)" />
      <MemberSignature Language="DocId" Value="F:System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxNameLength As Integer  = 80" />
      <MemberSignature Language="C++ CLI" Value="public: int MaxNameLength = 80;" />
      <MemberSignature Language="F#" Value="val mutable MaxNameLength : int" Usage="System.ServiceProcess.ServiceBase.MaxNameLength" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <MemberValue>80</MemberValue>
      <Docs>
        <summary>Indica o tamanho máximo para um nome de serviço.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ServiceName e DisplayName ambos têm restrições de tamanho que devem ser observadas ao configurar as propriedades em sua classe de serviço.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.ServiceName" />
      </Docs>
    </Member>
    <Member MemberName="OnContinue">
      <MemberSignature Language="C#" Value="protected virtual void OnContinue ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContinue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnContinue" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContinue ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContinue();" />
      <MemberSignature Language="F#" Value="abstract member OnContinue : unit -&gt; unit&#xA;override this.OnContinue : unit -&gt; unit" Usage="serviceBase.OnContinue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnContinue" /> é executado quando o comando Continuar é enviado para o serviço pelo SCM (Gerenciador de Controle de Serviço). Especifica as ações a serem tomadas quando um serviço retoma o funcionamento normal após estar em pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Implemente <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para espelhar a resposta do seu aplicativo para <xref:System.ServiceProcess.ServiceBase.OnPause%2A>. Quando você continua o serviço (ou por meio do console de serviços ou por meio de programação), o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> de processamento é executado e o serviço ficará ativa novamente.  
  
 <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é de propriedade `true`.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> está `false`, o SCM não passa pausar ou continuar solicitações para o serviço, portanto, o <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos não serão chamados, mesmo se forem implementadas. No SCM, o `Pause` e `Continue` controles são desabilitados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnCustomCommand">
      <MemberSignature Language="C#" Value="protected virtual void OnCustomCommand (int command);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCustomCommand(int32 command) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCustomCommand (command As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCustomCommand(int command);" />
      <MemberSignature Language="F#" Value="abstract member OnCustomCommand : int -&gt; unit&#xA;override this.OnCustomCommand : int -&gt; unit" Usage="serviceBase.OnCustomCommand command" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="command">A mensagem de comando enviada ao serviço.</param>
        <summary>Quando implementado em uma classe derivada, <see cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" /> é executado quando o SCM (Gerenciador de Controle de Serviço) passa um comando personalizado para o serviço. Especifica as ações a serem aditadas quando ocorrer um comando com o valor do parâmetro especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> permite que você especifique uma funcionalidade adicional além de iniciar, parar, pausar e continuando serviços.  
  
 O SCM não examina o comando personalizado para verificar se o serviço oferece suporte a `command` parâmetro passado. Ele passa o comando personalizado diretamente para o serviço. Se o serviço não reconhecer o `command` parâmetro, ela não faz nada.  
  
 Comandos personalizados são gerados por um <xref:System.ServiceProcess.ServiceController.ExecuteCommand%2A> instrução em um <xref:System.ServiceProcess.ServiceController> componente. Usar uma instrução switch ou if... em seguida, condição para lidar com os comandos personalizados que você define no seu serviço.  
  
 Os únicos valores para um comando personalizado que você pode definir em seu aplicativo ou usar em <xref:System.ServiceProcess.ServiceBase.OnCustomCommand%2A> são aqueles entre 128 e 255. Inteiros abaixo 128 correspondem aos valores de reservadas pelo sistema.  
  
 Se o <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> é de propriedade `true`, comandos personalizados, como todos os outros comandos, gravam entradas de log de eventos para relatar se a execução do método teve êxito ou falha.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <Member MemberName="OnPause">
      <MemberSignature Language="C#" Value="protected virtual void OnPause ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPause" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPause ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPause();" />
      <MemberSignature Language="F#" Value="abstract member OnPause : unit -&gt; unit&#xA;override this.OnPause : unit -&gt; unit" Usage="serviceBase.OnPause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, é executado quando o comando Pausar é enviado para o serviço pelo SCM (Gerenciador de Controle de Serviço). Especifica ações a serem tomadas quando a execução for colocada em pausa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPause%2A> para especificar o processamento que ocorre quando o serviço recebe um comando para pausar. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é de propriedade `true`.  
  
 Quando você continuar um serviço pausado (ou por meio do console de serviços ou por meio de programação), o <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> processamento é executado, e o serviço ficará ativo novamente.  
  
 O comando Pause só permite que seu aplicativo reagir a um evento específico. <xref:System.ServiceProcess.ServiceBase.OnPause%2A> não faz nada para o serviço que você não defini-lo a fazer.  
  
 Enviando uma solicitação de pausa para o serviço pode conservar recursos do sistema porque pausar não precisa liberar todos os recursos do sistema. Por exemplo, se os threads foram abertos pelo processo, pausar um serviço em vez de interrompê-la pode permitir que os threads permanecer aberto, dispensando a necessidade para realocá-los quando o serviço continua. Se você definir pausar para liberar todos os recursos do sistema, ele se comporta como um comando de parada.  
  
 Definir <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> à `true`e substituir <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> para especificar o processamento que deve ocorrer quando o SCM transmite uma solicitação de pausar ou continuar para seu serviço. <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> deve ser implementado para desfazer o processamento em <xref:System.ServiceProcess.ServiceBase.OnPause%2A>.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> está `false`, o SCM não passa pausar ou continuar solicitações para o serviço, portanto, o <xref:System.ServiceProcess.ServiceBase.OnPause%2A> e <xref:System.ServiceProcess.ServiceBase.OnContinue%2A> métodos não serão chamados, mesmo se implementadas. No SCM, o `Pause` e `Continue` controles são desabilitados quando <xref:System.ServiceProcess.ServiceBase.CanPauseAndContinue%2A> é `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanPauseAndContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnPowerEvent">
      <MemberSignature Language="C#" Value="protected virtual bool OnPowerEvent (System.ServiceProcess.PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnPowerEvent(valuetype System.ServiceProcess.PowerBroadcastStatus powerStatus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnPowerEvent (powerStatus As PowerBroadcastStatus) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnPowerEvent(System::ServiceProcess::PowerBroadcastStatus powerStatus);" />
      <MemberSignature Language="F#" Value="abstract member OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool&#xA;override this.OnPowerEvent : System.ServiceProcess.PowerBroadcastStatus -&gt; bool" Usage="serviceBase.OnPowerEvent powerStatus" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="powerStatus" Type="System.ServiceProcess.PowerBroadcastStatus" />
      </Parameters>
      <Docs>
        <param name="powerStatus">Um <see cref="T:System.ServiceProcess.PowerBroadcastStatus" /> que indica uma notificação do sistema sobre seu status de energia.</param>
        <summary>Quando implementada em uma classe derivada, será executada quando o status de energia do computador for alterado. Isso se aplica a computadores laptop quando entram no modo suspenso, que não é o mesmo que um desligamento do sistema.</summary>
        <returns>Quando implementada em uma classe derivada, as necessidades do seu aplicativo determinam qual valor retornar. Por exemplo, se um status de difusão <see langword="QuerySuspend" /> for passado, você poderá fazer com que seu aplicativo rejeite a consulta retornando <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> para especificar o processamento que ocorre quando o evento do sistema indicado no <xref:System.ServiceProcess.PowerBroadcastStatus> enumeração ocorre – por exemplo, quando o computador é colocado no modo suspenso ou indica a energia da bateria fraca.  
  
 <xref:System.ServiceProcess.ServiceBase.OnPowerEvent%2A> deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanHandlePowerEvent%2A> é de propriedade `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandlePowerEvent" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnSessionChange">
      <MemberSignature Language="C#" Value="protected virtual void OnSessionChange (System.ServiceProcess.SessionChangeDescription changeDescription);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSessionChange(valuetype System.ServiceProcess.SessionChangeDescription changeDescription) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnSessionChange(System.ServiceProcess.SessionChangeDescription)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSessionChange (changeDescription As SessionChangeDescription)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSessionChange(System::ServiceProcess::SessionChangeDescription changeDescription);" />
      <MemberSignature Language="F#" Value="abstract member OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit&#xA;override this.OnSessionChange : System.ServiceProcess.SessionChangeDescription -&gt; unit" Usage="serviceBase.OnSessionChange changeDescription" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="changeDescription" Type="System.ServiceProcess.SessionChangeDescription" />
      </Parameters>
      <Docs>
        <param name="changeDescription">Uma estrutura que identifica o tipo de alteração.</param>
        <summary>Executa quando um evento de alteração é proveniente de uma sessão do servidor Host da Sessão da Área de Trabalho Remota.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve definir a <xref:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent%2A> propriedade para `true` para habilitar a execução desse método.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanHandleSessionChangeEvent" />
        <altmember cref="T:System.ServiceProcess.SessionChangeDescription" />
      </Docs>
    </Member>
    <Member MemberName="OnShutdown">
      <MemberSignature Language="C#" Value="protected virtual void OnShutdown ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShutdown() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnShutdown" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShutdown ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShutdown();" />
      <MemberSignature Language="F#" Value="abstract member OnShutdown : unit -&gt; unit&#xA;override this.OnShutdown : unit -&gt; unit" Usage="serviceBase.OnShutdown " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, é executado quando o sistema é desligado. Especifica o que deve ocorrer imediatamente antes do desligamento do sistema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> para especificar o processamento que ocorre quando o sistema é desligado.  
  
 Esse evento ocorre somente quando o sistema operacional é desligado, não quando o computador é desligado.  
  
 <xref:System.ServiceProcess.ServiceBase.OnShutdown%2A> deve ser substituído quando o <xref:System.ServiceProcess.ServiceBase.CanShutdown%2A> é de propriedade `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStart">
      <MemberSignature Language="C#" Value="protected virtual void OnStart (string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStart(string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStart (args As String())" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStart(cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member OnStart : string[] -&gt; unit&#xA;override this.OnStart : string[] -&gt; unit" Usage="serviceBase.OnStart args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="args">Dados passados pelo comando de início.</param>
        <summary>Quando implementado em uma classe derivada, é executado quando um comando Iniciar é enviado para o serviço pelo SCM (Gerenciador de Controle de Serviço) ou quando o sistema operacional é iniciado (para um serviço que inicia automaticamente). Especifica ações a serem tomadas quando o serviço for iniciado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para especificar o processamento que ocorre quando o serviço recebe um comando Start. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> é o método em que você especificar o comportamento do serviço. <xref:System.ServiceProcess.ServiceBase.OnStart%2A> pode levar argumentos como uma maneira de transmitir dados, mas esse uso é raro.  
  
> [!CAUTION]
>  Não use o construtor para executar o processamento deve estar no <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Use <xref:System.ServiceProcess.ServiceBase.OnStart%2A> para lidar com toda a inicialização do serviço. O construtor é chamado quando o executável do aplicativo é executado, não quando o serviço é executado. O executável será executado antes de <xref:System.ServiceProcess.ServiceBase.OnStart%2A>. Quando você continuar, por exemplo, o construtor não é chamado novamente porque o SCM já contém o objeto na memória. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> libera recursos alocados no construtor, em vez de em <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, os recursos necessários não seriam criados novamente na segunda vez que o serviço é chamado.  
  
 Serviços podem ser definidos para iniciar automaticamente quando o computador for reiniciado, definindo o <xref:System.ServiceProcess.ServiceInstaller.StartType%2A> no instalador do serviço para <xref:System.ServiceProcess.ServiceStartMode.Automatic>. Nessa situação, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> seria chamado na inicialização do sistema.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStart%2A> deve ser substituído na classe derivada. Para o serviço para ser útil, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devem ser implementadas em sua classe de serviço.  
  
 Processar argumentos de inicialização para o serviço no <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método, não no método Main. Os argumentos no `args` matriz de parâmetros pode ser definida manualmente na janela Propriedades para o serviço no console de serviços. Os argumentos digitados no console do não são salvas; eles são passados para o serviço de uma única vez quando o serviço é iniciado no painel de controle. Os argumentos que devem estar presente quando o serviço é iniciado automaticamente podem ser colocados no valor de cadeia de caracteres de ImagePath para a chave do registro do serviço (HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\\  *\< nome do serviço >*). Você pode obter os argumentos do registro usando o <xref:System.Environment.GetCommandLineArgs%2A> método, por exemplo: `string[] imagePathArgs = Environment.GetCommandLineArgs();`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="OnStop">
      <MemberSignature Language="C#" Value="protected virtual void OnStop ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.OnStop" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStop ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStop();" />
      <MemberSignature Language="F#" Value="abstract member OnStop : unit -&gt; unit&#xA;override this.OnStop : unit -&gt; unit" Usage="serviceBase.OnStop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Quando implementado em uma classe derivada, é executado quando o comando Parar é enviado para o serviço pelo SCM (Gerenciador de Controle de Serviço). Especifica ações a serem tomadas quando a execução do serviço parar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.ServiceProcess.ServiceBase.OnStop%2A> para especificar o processamento que ocorre quando o serviço recebe um comando de parada.  
  
 Quando o SCM recebe um comando de parada, ele usará o valor de <xref:System.ServiceProcess.ServiceBase.CanStop%2A> para verificar se o serviço aceita comandos de parada. Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> está `true`, o comando Parar é passado para o serviço e o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> método é chamado se ele está definido. Se <xref:System.ServiceProcess.ServiceBase.OnStop%2A> não está implementada no serviço, o SCM manipula o comando de parada.  
  
 Se <xref:System.ServiceProcess.ServiceBase.CanStop%2A> é `false`, o SCM ignora o comando Stop. Ele não é passado para o serviço. O comando parar retorna e gera uma exceção.  
  
 <xref:System.ServiceProcess.ServiceBase.OnStop%2A> deve ser substituído na classe derivada. Para o serviço para ser útil, <xref:System.ServiceProcess.ServiceBase.OnStart%2A> e <xref:System.ServiceProcess.ServiceBase.OnStop%2A> devem ser implementadas em sua classe de serviço.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnShutdown" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnCustomCommand(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="RequestAdditionalTime">
      <MemberSignature Language="C#" Value="public void RequestAdditionalTime (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RequestAdditionalTime(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.RequestAdditionalTime(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RequestAdditionalTime (milliseconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RequestAdditionalTime(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.RequestAdditionalTime : int -&gt; unit" Usage="serviceBase.RequestAdditionalTime milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">O tempo solicitado em milissegundos.</param>
        <summary>Solicita tempo adicional para uma operação pendente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ServiceProcess.ServiceBase.RequestAdditionalTime%2A> método é destinado a ser chamado pelo substituído <xref:System.ServiceProcess.ServiceBase.OnContinue%2A>, <xref:System.ServiceProcess.ServiceBase.OnPause%2A>, <xref:System.ServiceProcess.ServiceBase.OnStart%2A>, ou <xref:System.ServiceProcess.ServiceBase.OnStop%2A> métodos para solicitar mais tempo para uma operação pendente, para impedir que o Gerenciador de controle de serviço (SCM) marcando o serviço como não está respondendo.  Se a operação pendente não for um continuar, pausar, iniciar ou parar, um <xref:System.InvalidOperationException> é gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O serviço não está em um estado pendente.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnContinue" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnPause" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Run">
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fornece o ponto de entrada principal para um executável do serviço.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase service);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase service) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (service As ServiceBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(System::ServiceProcess::ServiceBase ^ service);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run service" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="service" Type="System.ServiceProcess.ServiceBase" />
      </Parameters>
      <Docs>
        <param name="service">Um <see cref="T:System.ServiceProcess.ServiceBase" /> que indica um serviço para iniciar.</param>
        <summary>Registra o executável para um serviço com o Gerenciador de Controle de Serviço (SCM).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga no `main()` função do executável para registrar o serviço com o Gerenciador de controle de serviço do serviço. Depois de chamar <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%29>, o Gerenciador de controle de serviço emite um comando de início, o que resulta em uma chamada para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A> método no serviço. O serviço não é iniciado até que o comando de início é executado.  
  
 O <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> método é chamado da mesma forma como <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> para aplicativos Windows Forms.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> está `true`, uma entrada é gravada no log de eventos se o serviço especificado pelo `service` parâmetro não pode ser iniciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="service" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Run">
      <MemberSignature Language="C#" Value="public static void Run (System.ServiceProcess.ServiceBase[] services);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Run(class System.ServiceProcess.ServiceBase[] services) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Run(System.ServiceProcess.ServiceBase[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Run (services As ServiceBase())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Run(cli::array &lt;System::ServiceProcess::ServiceBase ^&gt; ^ services);" />
      <MemberSignature Language="F#" Value="static member Run : System.ServiceProcess.ServiceBase[] -&gt; unit" Usage="System.ServiceProcess.ServiceBase.Run services" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="services" Type="System.ServiceProcess.ServiceBase[]" />
      </Parameters>
      <Docs>
        <param name="services">Uma matriz de instâncias ServiceBase que indicam os serviços a iniciar.</param>
        <summary>Registra o executável para vários serviços com o SCM (Gerenciador de Controle de Serviço).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga no `main()` função do executável para registrar os serviços com o Gerenciador de controle de serviço do serviço. Depois de chamar <xref:System.ServiceProcess.ServiceBase.Run%28System.ServiceProcess.ServiceBase%5B%5D%29>, o Gerenciador de controle de serviço emite comandos de início, que resultam em chamadas para o <xref:System.ServiceProcess.ServiceBase.OnStart%2A> métodos nos serviços. Os serviços não são iniciados até que os comandos de início são executados.  
  
 O <xref:System.ServiceProcess.ServiceBase.Run%2A?displayProperty=nameWithType> método é chamado da mesma maneira como o <xref:System.Windows.Forms.Application.Run%2A?displayProperty=nameWithType> método para aplicativos Windows Forms.  
  
 Se <xref:System.ServiceProcess.ServiceBase.AutoLog%2A> é `true`, uma entrada é gravada no log de eventos se qualquer serviço na matriz não for iniciado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Você não forneceu um serviço a ser iniciado. A matriz pode ser <see langword="null" /> ou vazia.</exception>
        <altmember cref="M:System.ServiceProcess.ServiceBase.#ctor" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStart(System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="ServiceHandle">
      <MemberSignature Language="C#" Value="protected IntPtr ServiceHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ServiceHandle" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ServiceHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IntPtr ServiceHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.ServiceHandle : nativeint" Usage="System.ServiceProcess.ServiceBase.ServiceHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a alça de controle de serviço para o serviço.</summary>
        <value>Uma estrutura <see cref="T:System.IntPtr" /> que contém a alça de controle de serviço para o serviço.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A alça de controle de serviço é usada para se comunicar com o Gerenciador de controle de serviço (SCM).  O identificador pode ser usado para atualizar as informações de status do Gerenciador de controle de serviço para o serviço de chamada não gerenciada usando o `SetServiceStatus` função.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para acesso a código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ServiceMainCallback">
      <MemberSignature Language="C#" Value="public void ServiceMainCallback (int argCount, IntPtr argPointer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ServiceMainCallback(int32 argCount, native int argPointer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.ServiceMainCallback(System.Int32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ServiceMainCallback (argCount As Integer, argPointer As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ServiceMainCallback(int argCount, IntPtr argPointer);" />
      <MemberSignature Language="F#" Value="member this.ServiceMainCallback : int * nativeint -&gt; unit" Usage="serviceBase.ServiceMainCallback (argCount, argPointer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;dotnet-plat-ext-2.1;netcore-2.1;netcore-2.2;dotnet-plat-ext-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="argCount" Type="System.Int32" />
        <Parameter Name="argPointer" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="argCount">O número de argumentos na matriz de argumentos.</param>
        <param name="argPointer">Uma estrutura <see cref="T:System.IntPtr" /> que aponta para uma matriz de argumentos.</param>
        <summary>Registra o manipulador de comandos e inicia o serviço.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ServiceName">
      <MemberSignature Language="C#" Value="public string ServiceName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ServiceName" />
      <MemberSignature Language="DocId" Value="P:System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberSignature Language="VB.NET" Value="Public Property ServiceName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ServiceName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.ServiceName : string with get, set" Usage="System.ServiceProcess.ServiceBase.ServiceName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ServiceProcess.ServiceProcessDescription("SBServiceName")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.TypeConverter("System.Diagnostics.Design.StringValueConverter, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o nome curto usado para identificar o serviço no sistema.</summary>
        <value>O nome do serviço.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> identifica o serviço para o Gerenciador de controle de serviço. O valor dessa propriedade deve ser idêntico ao nome registrado para o serviço no <xref:System.ServiceProcess.ServiceInstaller.ServiceName%2A?displayProperty=nameWithType> propriedade da classe do instalador correspondente. No código, o <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> do serviço geralmente é definido `main()` função do executável.  
  
 O <xref:System.ServiceProcess.ServiceBase.ServiceName%2A> também é usado para especificar o <xref:System.Diagnostics.EventLog.Source%2A?displayProperty=nameWithType> associado com o <xref:System.ServiceProcess.ServiceBase.EventLog%2A> propriedade. Isso <xref:System.ServiceProcess.ServiceBase.EventLog%2A> é uma instância que grava informações de comando de serviço no log de aplicativo.  
  
 O <xref:System.ServiceProcess.ServiceBase.ServiceName%2A>, que fornece a cadeia de caracteres de origem para o log de eventos deve ser definida antes que o serviço grava no log de eventos. Tentando acessar o log de eventos antes que o nome de origem é definido faz com que uma exceção seja lançada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O serviço já foi iniciado. A propriedade <see cref="P:System.ServiceProcess.ServiceBase.ServiceName" /> não pode ser alterada depois que o serviço é iniciado.</exception>
        <exception cref="T:System.ArgumentException">O nome especificado é uma cadeia de caracteres de tamanho zero ou é maior que <see cref="F:System.ServiceProcess.ServiceBase.MaxNameLength" /> ou o nome especificado contém caracteres de barra ou barra invertida.</exception>
        <altmember cref="P:System.ServiceProcess.ServiceInstaller.ServiceName" />
        <altmember cref="P:System.Diagnostics.EventLog.Source" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ServiceProcess.ServiceBase.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="serviceBase.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceProcess.ServiceController</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe o serviço em execução.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.ServiceProcess.ServiceBase.Stop%2A> método define o estado do serviço para indicar uma parada está pendente e chama o <xref:System.ServiceProcess.ServiceBase.OnStop%2A> método.  Depois que o aplicativo for interrompido, o estado do serviço é definido como parado. Se o aplicativo é um serviço hospedado, o domínio de aplicativo é descarregado.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.ServiceProcess.ServiceBase.CanStop" />
        <altmember cref="M:System.ServiceProcess.ServiceBase.OnStop" />
      </Docs>
    </Member>
  </Members>
</Type>