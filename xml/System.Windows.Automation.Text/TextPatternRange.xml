<Type Name="TextPatternRange" FullName="System.Windows.Automation.Text.TextPatternRange">
  <Metadata><Meta Name="ms.openlocfilehash" Value="04b05150fd153351bd0d4d4a5be88cb75ea6b5f8" /><Meta Name="ms.sourcegitcommit" Value="9dda17222b9f7d3edf130133bfb1370d5b410a4b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="09/22/2018" /><Meta Name="ms.locfileid" Value="46616842" /></Metadata><TypeSignature Language="C#" Value="public class TextPatternRange" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPatternRange extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Automation.Text.TextPatternRange" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPatternRange" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPatternRange" />
  <TypeSignature Language="F#" Value="type TextPatternRange = class" />
  <AssemblyInfo>
    <AssemblyName>UIAutomationClient</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa um intervalo de texto contínuo em um contêiner <see cref="T:System.Windows.Automation.TextPattern" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Automation.Text.TextPatternRange> pode representar um ponto de inserção, um subconjunto ou todo o texto em um <xref:System.Windows.Automation.TextPattern> contêiner.  
  
 Um <xref:System.Windows.Automation.Text.TextPatternRange> se tornará inválido caso um dos seguintes: o texto na <xref:System.Windows.Automation.TextPattern> contêiner é alterado devido a alguma atividade de usuário, ou o <xref:System.Windows.Automation.ValuePattern.SetValue%2A> método de <xref:System.Windows.Automation.ValuePattern> é usado para alterar programaticamente o valor do texto em que o <xref:System.Windows.Automation.TextPattern> recipiente.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Automation.Provider.ITextRangeProvider" />
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-overview.md">Visão Geral de Padrões de Controle de Automação de Interface de Usuário</related>
    <related type="Article" href="~/docs/framework/ui-automation/ui-automation-control-patterns-for-clients.md">Padrões de Controle para Clientes de Automação de IU</related>
  </Docs>
  <Members>
    <Member MemberName="AddToSelection">
      <MemberSignature Language="C#" Value="public void AddToSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToSelection();" />
      <MemberSignature Language="F#" Value="member this.AddToSelection : unit -&gt; unit" Usage="textPatternRange.AddToSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Adiciona à coleção do texto realçado em um contêiner de texto que dá suporte a várias seleções não contíguas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Move o ponto de inserção de texto para a área da nova seleção.  
  
 Fornece um intervalo de texto de degeneração move o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não der suporte a várias seleções não contíguas (por exemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um novo <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> idêntico ao <see cref="T:System.Windows.Automation.Text.TextPatternRange" /> original e herdando todas as propriedades do original.</summary>
        <returns>O novo intervalo de texto. Uma referência nula (<see langword="Nothing" /> no Visual Basic) nunca é retornada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como alternativa, crie um novo <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> do <xref:System.Windows.Automation.TextPattern> e mover os dois pontos de extremidade que correspondam aos pontos de extremidade do intervalo de texto original.  
  
 O novo intervalo de pode ser manipulado de forma independente do original.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1060](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1060)]  
  
 [!code-vb[UIATextPattern_snip#2060](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2060)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromChild(System.Windows.Automation.AutomationElement)" />
        <altmember cref="M:System.Windows.Automation.TextPattern.RangeFromPoint(System.Windows.Point)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public bool Compare (System.Windows.Automation.Text.TextPatternRange range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Compare(class System.Windows.Automation.Text.TextPatternRange range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Compare(System.Windows.Automation.Text.TextPatternRange)" />
      <MemberSignature Language="VB.NET" Value="Public Function Compare (range As TextPatternRange) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Compare(System::Windows::Automation::Text::TextPatternRange ^ range);" />
      <MemberSignature Language="F#" Value="member this.Compare : System.Windows.Automation.Text.TextPatternRange -&gt; bool" Usage="textPatternRange.Compare range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Windows.Automation.Text.TextPatternRange" />
      </Parameters>
      <Docs>
        <param name="range">Um intervalo de texto a ser comparado.</param>
        <summary>Retorna um valor <see cref="T:System.Boolean" /> que indica se o alcance (o ponto de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> até o ponto de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" />) de um intervalo de texto é igual a outro intervalo de texto.</summary>
        <returns><see langword="true" /> se o alcance dos dois intervalos de texto for idêntico, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1061](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1061)]  
  
 [!code-vb[UIATextPattern_snip#2061](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2061)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se o intervalo sendo comparado não vem do mesmo provedor de texto.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="CompareEndpoints">
      <MemberSignature Language="C#" Value="public int CompareEndpoints (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareEndpoints(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.CompareEndpoints(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareEndpoints (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareEndpoints(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.CompareEndpoints : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; int" Usage="textPatternRange.CompareEndpoints (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> do chamador.</param>
        <param name="targetRange">O intervalo de destino para comparação.</param>
        <param name="targetEndpoint">O ponto de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> ou <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> do destino.</param>
        <summary>Retorna um <see cref="T:System.Int32" /> que indica se dois intervalos de texto têm pontos de extremidade idênticos.</summary>
        <returns>Retorna um valor negativo se o ponto de extremidade do chamador ocorre antes no texto do que o ponto de extremidade de destino.  
  
Retorna zero se o ponto de extremidade do chamador está no mesmo local que o ponto de extremidade de destino.  
  
Retorna um valor positivo se o ponto de extremidade do chamador ocorre depois no texto do que o ponto de extremidade de destino.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Comparando os pontos de extremidade inicial e finais do mesmo intervalo de texto, você pode identificar se um intervalo de texto é degenerado ou se os pontos de extremidade estão na ordem de fluxo de lógica de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1062](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1062)]  
  
 [!code-vb[UIATextPattern_snip#2062](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2062)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Se o intervalo é uma referência nula (<see langword="Nothing" /> no Visual Basic).</exception>
        <exception cref="T:System.ArgumentException">Se o intervalo for de outro contêiner.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ExpandToEnclosingUnit">
      <MemberSignature Language="C#" Value="public void ExpandToEnclosingUnit (System.Windows.Automation.Text.TextUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExpandToEnclosingUnit(valuetype System.Windows.Automation.Text.TextUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit(System.Windows.Automation.Text.TextUnit)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExpandToEnclosingUnit (unit As TextUnit)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExpandToEnclosingUnit(System::Windows::Automation::Text::TextUnit unit);" />
      <MemberSignature Language="F#" Value="member this.ExpandToEnclosingUnit : System.Windows.Automation.Text.TextUnit -&gt; unit" Usage="textPatternRange.ExpandToEnclosingUnit unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
      </Parameters>
      <Docs>
        <param name="unit">A unidade textual.</param>
        <summary>Expande o intervalo de texto para o <see cref="T:System.Windows.Automation.Text.TextUnit" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o intervalo já é uma quantidade exata de unidades especificadas permanece inalterado.  
  
 Para que o <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> método a ser executado com êxito, uma sequência de ações é executada em segundo plano.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido em um intervalo de degeneração a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, tornando o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover a ambiguidade em situações onde um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) é inserido no texto" onde "{" e "}" é o texto de pontos de extremidade do intervalo.  
  
2.  O intervalo resultante é movido para trás na <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitada `unit` limites.  
  
3.  O intervalo é movido para frente ou para trás na <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo de degeneração, em seguida, movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por um solicitado `unit` limites.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
> [!NOTE]
>  Essas etapas são necessárias, pois é comum que um leitor de tela sejam lidos uma palavra inteira, frase ou parágrafo inteiro em qualquer posição do cursor virtual ou o ponto de inserção.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> respeita o texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> quanto à visibilidade do texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.ExpandToEnclosingUnit%2A> adia para a próxima maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é compatível com o controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1063](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1063)]  
  
 [!code-vb[UIATextPattern_snip#2063](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2063)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="FindAttribute">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindAttribute (System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindAttribute(class System.Windows.Automation.AutomationTextAttribute attribute, object value, bool backward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindAttribute(System.Windows.Automation.AutomationTextAttribute,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindAttribute (attribute As AutomationTextAttribute, value As Object, backward As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindAttribute(System::Windows::Automation::AutomationTextAttribute ^ attribute, System::Object ^ value, bool backward);" />
      <MemberSignature Language="F#" Value="member this.FindAttribute : System.Windows.Automation.AutomationTextAttribute * obj * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindAttribute (attribute, value, backward)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="backward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo a ser pesquisado.</param>
        <param name="value">O valor de atributo a ser pesquisado. Esse valor deve corresponder ao tipo especificado para o atributo.</param>
        <param name="backward"><see langword="true" /> se o último intervalo de texto que ocorre por último deve ser retornada em vez da primeira, caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que tem o valor de atributo especificado.</summary>
        <returns>Um intervalo de texto com um atributo e um valor de atributo correspondentes, caso contrário, nulo (<see langword="Nothing" /> no Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para pesquisar o documento inteiro.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1064](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1064)]  
  
 [!code-vb[UIATextPattern_snip#2064](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2064)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="FindText">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.Text.TextPatternRange FindText (string text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.Text.TextPatternRange FindText(string text, bool backward, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.FindText(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindText (text As String, backward As Boolean, ignoreCase As Boolean) As TextPatternRange" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::Text::TextPatternRange ^ FindText(System::String ^ text, bool backward, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.FindText : string * bool * bool -&gt; System.Windows.Automation.Text.TextPatternRange" Usage="textPatternRange.FindText (text, backward, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Text.TextPatternRange</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="backward" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="text">A cadeia de caracteres de texto a ser pesquisada.</param>
        <param name="backward"><see langword="true" /> se o último intervalo de texto que ocorre por último deve ser retornada em vez da primeira, caso contrário, <see langword="false" />.</param>
        <param name="ignoreCase"><see langword="true" /> se o uso de maiúsculas e minúsculas deve ser ignorado, caso contrário, <see langword="false" />.</param>
        <summary>Retorna um subconjunto do intervalo de texto que contém o texto especificado.</summary>
        <returns>Um intervalo de texto que corresponde ao texto especificado, caso contrário, nulo (<see langword="Nothing" /> no Visual Basic).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
> [!NOTE]
>  Use <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para pesquisar o documento inteiro.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1065](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1065)]  
  
 [!code-vb[UIATextPattern_snip#2065](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2065)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.TextPattern" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeValue">
      <MemberSignature Language="C#" Value="public object GetAttributeValue (System.Windows.Automation.AutomationTextAttribute attribute);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetAttributeValue(class System.Windows.Automation.AutomationTextAttribute attribute) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetAttributeValue(System.Windows.Automation.AutomationTextAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttributeValue (attribute As AutomationTextAttribute) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetAttributeValue(System::Windows::Automation::AutomationTextAttribute ^ attribute);" />
      <MemberSignature Language="F#" Value="member this.GetAttributeValue : System.Windows.Automation.AutomationTextAttribute -&gt; obj" Usage="textPatternRange.GetAttributeValue attribute" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attribute" Type="System.Windows.Automation.AutomationTextAttribute" />
      </Parameters>
      <Docs>
        <param name="attribute">O atributo de texto.</param>
        <summary>Retorna o valor do atributo especificado em todo o intervalo de texto.</summary>
        <returns>Retorna o valor do atributo especificado. Por exemplo, GetAttributeValue(TextPattern.FontNameAttribute) retornaria uma cadeia de caracteres que representa o nome da fonte, se for único, do intervalo de texto, ao passo que GetAttributeValue(TextPattern.IsItalicAttribute) retornaria um booliano.  
  
Retorna <see cref="F:System.Windows.Automation.TextPattern.MixedAttributeValue" /> se o valor do atributo especificado varia ao longo do intervalo de texto.  
  
Retorna <see cref="F:System.Windows.Automation.AutomationElement.NotSupported" /> se o atributo especificado não for compatível com o provedor ou com o controle.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Não há nenhuma diferenciação entre texto oculto e visível. Clientes de automação de interface do usuário podem usar <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> para verificar a visibilidade do texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1066](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1066)]  
  
 [!code-vb[UIATextPattern_snip#2066](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2066)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Se o atributo especificado não for válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetBoundingRectangles">
      <MemberSignature Language="C#" Value="public System.Windows.Rect[] GetBoundingRectangles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect[] GetBoundingRectangles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetBoundingRectangles" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBoundingRectangles () As Rect()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Rect&gt; ^ GetBoundingRectangles();" />
      <MemberSignature Language="F#" Value="member this.GetBoundingRectangles : unit -&gt; System.Windows.Rect[]" Usage="textPatternRange.GetBoundingRectangles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de retângulos delimitadores para cada linha de texto parcial ou totalmente visível em um intervalo de texto.</summary>
        <returns>Uma matriz de retângulos delimitadores para cada linha de texto total ou parcial em um intervalo de texto.  
  
Uma matriz vazia para um intervalo de texto de degeneração.  
  
Uma matriz vazia para um intervalo de texto que tem as coordenadas da tela colocando-o completamente fora da tela, rolado para fora da exibição ou obscurecido por uma janela sobreposta.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1067](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1067)]  
  
 [!code-vb[UIATextPattern_snip#2067](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2067)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement[] GetChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement[] GetChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetChildren" />
      <MemberSignature Language="VB.NET" Value="Public Function GetChildren () As AutomationElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Windows::Automation::AutomationElement ^&gt; ^ GetChildren();" />
      <MemberSignature Language="F#" Value="member this.GetChildren : unit -&gt; System.Windows.Automation.AutomationElement[]" Usage="textPatternRange.GetChildren " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera uma coleção de todos os objetos inseridos que estão dentro do intervalo de texto.</summary>
        <returns>Uma coleção de todos os objetos filho que estão dentro do intervalo. Os filhos que sobrepõem o intervalo, mas não estão totalmente dentro dele também serão incluídos na coleção.  
  
Retorna uma coleção vazia se não há nenhum objeto filho.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#getembeddedobjects)]
[!code-vb[UIATextPattern_snip#GetEmbeddedObjects](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#getembeddedobjects)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnclosingElement">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.AutomationElement GetEnclosingElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Automation.AutomationElement GetEnclosingElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetEnclosingElement" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnclosingElement () As AutomationElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Automation::AutomationElement ^ GetEnclosingElement();" />
      <MemberSignature Language="F#" Value="member this.GetEnclosingElement : unit -&gt; System.Windows.Automation.AutomationElement" Usage="textPatternRange.GetEnclosingElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.AutomationElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.Windows.Automation.AutomationElement" /> mais interno que inclui o intervalo de texto.</summary>
        <returns>O elemento mais interno que inclui o chamador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O delimitador <xref:System.Windows.Automation.AutomationElement>, geralmente, o provedor de texto que fornece o intervalo de texto. No entanto, se o provedor de texto é compatível com elementos filhos como tabelas ou hiperlinks, o elemento de fechamento pode ser um descendente do provedor de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1069](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1069)]  
  
 [!code-vb[UIATextPattern_snip#2069](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2069)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetText">
      <MemberSignature Language="C#" Value="public string GetText (int maxLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetText(int32 maxLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.GetText(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetText (maxLength As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetText(int maxLength);" />
      <MemberSignature Language="F#" Value="member this.GetText : int -&gt; string" Usage="textPatternRange.GetText maxLength" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxLength">O tamanho máximo da cadeia de caracteres a ser retornada. Use <c>-1</c> se não for necessário nenhum limite.</param>
        <summary>Retorna o texto sem formatação do intervalo de texto.</summary>
        <returns>O texto sem formatação do intervalo de texto, possivelmente truncado no <paramref name="maxLength" /> especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> respeita o texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> quanto à visibilidade do texto.  
  
 Se `maxLength` é maior que o comprimento do intervalo de texto do chamador, a cadeia de caracteres retornada será o texto sem formatação do intervalo de texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.GetText%2A> não serão afetados pela ordem dos pontos de extremidade no fluxo de texto; ele sempre retornará o texto entre os pontos de extremidade de início e término do intervalo de texto na ordem de fluxo de texto lógico.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1070](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1070)]  
  
 [!code-vb[UIATextPattern_snip#2070](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2070)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Se <paramref name="maxLength" /> for menor que -1.</exception>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="Move">
      <MemberSignature Language="C#" Value="public int Move (System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Move(valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Move(System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Move (unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Move(System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.Move : System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.Move (unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="unit">O limite da unidade de texto.</param>
        <param name="count">O número de unidades de texto a serem movidas. Um valor positivo move o intervalo de texto para frente, um valor negativo move o intervalo de texto para trás e 0 não tem nenhum efeito.</param>
        <summary>Move o intervalo de texto conforme o número de unidades de texto especificado.</summary>
        <returns>O número de unidades realmente movidas. Isso pode ser menos que o número solicitado se um dos pontos de extremidade do novo intervalo de texto for maior ou menor do que os pontos de extremidade de <see cref="P:System.Windows.Automation.TextPattern.DocumentRange" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas nos bastidores para que o <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> método a ser executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido em um intervalo de degeneração a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover a ambiguidade em situações onde um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) é inserido no texto" onde "{" e "}" é o texto de pontos de extremidade do intervalo.  
  
2.  O intervalo resultante é movido para trás na <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitada `unit` limites.  
  
3.  O intervalo é movido para frente ou para trás na <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> pelo número solicitado de `unit` limites.  
  
4.  O intervalo é expandido de um estado de intervalo de degeneração, em seguida, movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por um solicitado `unit` limites.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 O conteúdo textual (ou texto interno) de um contêiner de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto única e contínua na visualização de controle e exibição de conteúdo a [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] de árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário está recuperando o texto com a finalidade de citar, interpretar ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser feito por meio da chamada <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obter uma <xref:System.Windows.Automation.AutomationElement> para cada embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual foi recuperado.  
  
 ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto abrangidos por objetos inseridos.")  
Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> respeita o texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> quanto à visibilidade do texto.  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> adia para a próxima maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é compatível com o controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
> [!NOTE]
>  O texto não é alterado de forma alguma, como o intervalo de texto abrange apenas uma parte diferente do texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#StartTarget](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#starttarget)]
 [!code-vb[UIATextPattern_snip#StartTarget](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#starttarget)]  
[!code-csharp[UIATextPattern_snip#GetTextElement](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#gettextelement)]
[!code-vb[UIATextPattern_snip#GetTextElement](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#gettextelement)]  
[!code-csharp[UIATextPattern_snip#MoveSelection](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#moveselection)]
[!code-vb[UIATextPattern_snip#MoveSelection](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#moveselection)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByRange">
      <MemberSignature Language="C#" Value="public void MoveEndpointByRange (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextPatternRange targetRange, System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MoveEndpointByRange(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, class System.Windows.Automation.Text.TextPatternRange targetRange, valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint targetEndpoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByRange(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextPatternRange,System.Windows.Automation.Text.TextPatternRangeEndpoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MoveEndpointByRange (endpoint As TextPatternRangeEndpoint, targetRange As TextPatternRange, targetEndpoint As TextPatternRangeEndpoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MoveEndpointByRange(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextPatternRange ^ targetRange, System::Windows::Automation::Text::TextPatternRangeEndpoint targetEndpoint);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByRange : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextPatternRange * System.Windows.Automation.Text.TextPatternRangeEndpoint -&gt; unit" Usage="textPatternRange.MoveEndpointByRange (endpoint, targetRange, targetEndpoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="targetRange" Type="System.Windows.Automation.Text.TextPatternRange" />
        <Parameter Name="targetEndpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade a ser movido.</param>
        <param name="targetRange">Outro intervalo do mesmo provedor de texto.</param>
        <param name="targetEndpoint">Um ponto de extremidade no outro intervalo.</param>
        <summary>Move um ponto de extremidade de um intervalo de texto para o ponto de extremidade especificado de um segundo intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o ponto de extremidade que está sendo movido cruza o outro ponto de extremidade do mesmo intervalo de texto, em seguida, outro ponto de extremidade é movido também, resultando em um intervalo de degeneração e assegurar a ordenação correta dos pontos de extremidade (ou seja, <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> é sempre menor ou igual a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End>).  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1072](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1072)]  
  
 [!code-vb[UIATextPattern_snip#2072](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2072)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveEndpointByUnit">
      <MemberSignature Language="C#" Value="public int MoveEndpointByUnit (System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, System.Windows.Automation.Text.TextUnit unit, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 MoveEndpointByUnit(valuetype System.Windows.Automation.Text.TextPatternRangeEndpoint endpoint, valuetype System.Windows.Automation.Text.TextUnit unit, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit(System.Windows.Automation.Text.TextPatternRangeEndpoint,System.Windows.Automation.Text.TextUnit,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveEndpointByUnit (endpoint As TextPatternRangeEndpoint, unit As TextUnit, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int MoveEndpointByUnit(System::Windows::Automation::Text::TextPatternRangeEndpoint endpoint, System::Windows::Automation::Text::TextUnit unit, int count);" />
      <MemberSignature Language="F#" Value="member this.MoveEndpointByUnit : System.Windows.Automation.Text.TextPatternRangeEndpoint * System.Windows.Automation.Text.TextUnit * int -&gt; int" Usage="textPatternRange.MoveEndpointByUnit (endpoint, unit, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endpoint" Type="System.Windows.Automation.Text.TextPatternRangeEndpoint" />
        <Parameter Name="unit" Type="System.Windows.Automation.Text.TextUnit" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="endpoint">O ponto de extremidade a ser movido.</param>
        <param name="unit">A unidade textual para mover.</param>
        <param name="count">O número de unidades a serem movidas. Uma contagem positiva move o ponto de extremidade para frente. Uma contagem negativa move para trás. Uma contagem de 0 não tem nenhum efeito.</param>
        <summary>Move um ponto de extremidade do intervalo de texto conforme o número especificado de <see cref="T:System.Windows.Automation.Text.TextUnit" />s dentro do intervalo do documento.</summary>
        <returns>O número de unidades realmente movidos, que pode ser menor que o número solicitado se mover que o ponto de extremidade é executado no início ou no final do documento.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando for necessário atravessar o conteúdo de um intervalo de texto, uma série de etapas envolvidas nos bastidores para que o <xref:System.Windows.Automation.Text.TextPatternRange.Move%2A> método a ser executado com êxito.  
  
1.  O intervalo de texto é normalizado; ou seja, o intervalo de texto é recolhido em um intervalo de degeneração a <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade, o que torna o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> supérfluo de ponto de extremidade. Essa etapa é necessária para remover a ambiguidade em situações onde um intervalo de texto abrange `unit` limites; por exemplo, "{a U} RL [ https://www.microsoft.com/ ](https://www.microsoft.com/) é inserido no texto" onde "{" e "}" é o texto de pontos de extremidade do intervalo.  
  
2.  O intervalo resultante é movido para trás na <xref:System.Windows.Automation.TextPattern.DocumentRange%2A> para o início da solicitada `unit` limites.  
  
3.  O intervalo é expandido de um estado de intervalo de degeneração, em seguida, movendo o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.End> ponto de extremidade por um solicitado `unit` limites.  
  
 ![Ajustes de intervalo por Move & ExpandToEnclosingUnit](~/add/media/uia-textpattern-moveandexpand-examples.png "ajustes de intervalo por Move & ExpandToEnclosingUnit")  
Exemplos de como um intervalo de texto é ajustado para Move () e ExpandToEnclosingUnit)  
  
 O conteúdo textual (ou texto interno) de um contêiner de texto e um objeto inserido, como um hiperlink ou célula de tabela, é exposto como um fluxo de texto única e contínua na visualização de controle e exibição de conteúdo a [!INCLUDE[TLA2#tla_uiautomation](~/includes/tla2sharptla-uiautomation-md.md)] de árvore; objeto limites são ignorados. Se um cliente de automação de interface do usuário está recuperando o texto com a finalidade de citar, interpretar ou analisar de alguma maneira, o intervalo de texto deve ser verificado para casos especiais, como uma tabela com textuais conteúdos ou outros objetos inseridos. Isso pode ser feito por meio da chamada <xref:System.Windows.Automation.Text.TextPatternRange.GetChildren%2A> para obter uma <xref:System.Windows.Automation.AutomationElement> para cada embedded objeto e, em seguida, chamar <xref:System.Windows.Automation.TextPattern.RangeFromChild%2A> para obter um intervalo de texto para cada elemento; isso é feito de forma recursiva até que todo o conteúdo textual foi recuperado.  
  
 ![Intervalos de texto abrangidos por objetos inseridos. ] (~/add/media/uia-textpattern-embeddedobjecttextranges.png "Intervalos de texto abrangidos por objetos inseridos.")  
Exemplo de um fluxo de texto com objetos inseridos e seus intervalos abrangentes  
  
 <xref:System.Windows.Automation.Text.TextPatternRange.MoveEndpointByUnit%2A> adia para a próxima maior <xref:System.Windows.Automation.Text.TextUnit> com suporte se o determinado <xref:System.Windows.Automation.Text.TextUnit> não é compatível com o controle.  
  
 A ordem, da unidade menor ao maior, é listada abaixo.  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Character>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Format>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Word>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Line>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Paragraph>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Page>  
  
-   <xref:System.Windows.Automation.Text.TextUnit.Document>  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1073](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1073)]  
  
 [!code-vb[UIATextPattern_snip#2073](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2073)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFromSelection">
      <MemberSignature Language="C#" Value="public void RemoveFromSelection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFromSelection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.RemoveFromSelection" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFromSelection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFromSelection();" />
      <MemberSignature Language="F#" Value="member this.RemoveFromSelection : unit -&gt; unit" Usage="textPatternRange.RemoveFromSelection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove uma seção realçada de texto, correspondente aos pontos de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> do intervalo de texto de chamada de uma coleção existente do texto realçado em um contêiner de texto que dá suporte a várias seleções não contíguas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ponto de inserção de texto será movido para a área do realce removido.  
  
 Fornece um intervalo de texto de degeneração moverá o ponto de inserção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se o provedor de texto não der suporte a várias seleções não contíguas (por exemplo, <see cref="P:System.Windows.Automation.TextPattern.SupportedTextSelection" /> deve ter um valor de <see langword="Multiple" />).</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.Select" />
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignToTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignToTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignToTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignToTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="textPatternRange.ScrollIntoView alignToTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignToTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignToTop"><see langword="true" /> se o controle de texto deve ser rolado para que o intervalo de texto seja alinhado à parte superior do visor, <see langword="false" /> se ele deve ser alinhado à parte inferior do visor.</param>
        <summary>Faz com que o controle de texto role verticalmente até o intervalo do texto ser visível no visor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Automation.Text.TextPatternRange.ScrollIntoView%2A> respeita o texto oculto e visível. O cliente de automação de interface do usuário pode verificar o <xref:System.Windows.Automation.TextPattern.IsHiddenAttribute> quanto à visibilidade do texto. Se o intervalo de texto estiver oculta, o controle de texto rolará somente se o texto oculto tem uma âncora no visor.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1074](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1074)]  
  
 [!code-vb[UIATextPattern_snip#2074](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2074)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Se a rolagem não for compatível com o controle.</exception>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public void Select ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Select() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Automation.Text.TextPatternRange.Select" />
      <MemberSignature Language="VB.NET" Value="Public Sub Select ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Select();" />
      <MemberSignature Language="F#" Value="member this.Select : unit -&gt; unit" Usage="textPatternRange.Select " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Realça o texto no controle de texto correspondente aos pontos de extremidade <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start" /> e <see cref="F:System.Windows.Automation.Text.TextPatternRangeEndpoint.End" /> do intervalo de texto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um intervalo de texto de degeneração for fornecido, o ponto de inserção de texto será movido para o <xref:System.Windows.Automation.Text.TextPatternRangeEndpoint.Start> ponto de extremidade do intervalo de texto.  
  
   
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1075](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1075)]  
  
 [!code-vb[UIATextPattern_snip#2075](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2075)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ocorre quando a seleção de texto não é compatível com o controle de texto.</exception>
        <altmember cref="M:System.Windows.Automation.Text.TextPatternRange.AddToSelection" />
        <altmember cref="M:System.Windows.Automation.SelectionItemPattern.RemoveFromSelection" />
        <altmember cref="T:System.Windows.Automation.Text.TextPatternRangeEndpoint" />
      </Docs>
    </Member>
    <Member MemberName="TextPattern">
      <MemberSignature Language="C#" Value="public System.Windows.Automation.TextPattern TextPattern { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Automation.TextPattern TextPattern" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TextPattern As TextPattern" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Automation::TextPattern ^ TextPattern { System::Windows::Automation::TextPattern ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TextPattern : System.Windows.Automation.TextPattern" Usage="System.Windows.Automation.Text.TextPatternRange.TextPattern" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>UIAutomationClient</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.TextPattern</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Automation.TextPattern" /> associado ao intervalo de texto.</summary>
        <value>O provedor de texto.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[UIATextPattern_snip#1076](~/samples/snippets/csharp/VS_Snippets_Wpf/UIATextPattern_snip/CSharp/SearchWindow.cs#1076)]  
  
 [!code-vb[UIATextPattern_snip#2076](~/samples/snippets/visualbasic/VS_Snippets_Wpf/UIATextPattern_snip/VisualBasic/SearchWindow.vb#2076)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>