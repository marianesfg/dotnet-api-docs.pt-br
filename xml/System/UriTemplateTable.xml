<Type Name="UriTemplateTable" FullName="System.UriTemplateTable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0839dbe71ddeebe47969a326bd68957395980303" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39926602" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class UriTemplateTable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UriTemplateTable extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.UriTemplateTable" />
  <TypeSignature Language="VB.NET" Value="Public Class UriTemplateTable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UriTemplateTable" />
  <TypeSignature Language="F#" Value="type UriTemplateTable = class" />
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.ServiceModel.Web</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.ServiceModel.Web, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Uma classe que representa um conjunto associativo de objetos <see cref="T:System.UriTemplate" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.UriTemplateTable> é um conjunto associativo de <xref:System.UriTemplate> objetos associados a um objeto do desenvolvedor do escolhendo. Ele permite que você correspondência candidato recurso uniformes (URIs) com os modelos no conjunto e recuperar os dados associados com os modelos correspondentes. O conteúdo do <xref:System.UriTemplateTable> pode ser alterado até que o <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> método é chamado, momento em que um dos seguintes tipos de validação ocorre:  
  
-   Quando <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> é chamado passando `false`, o <xref:System.UriTemplateTable> verifica se a tabela não contém nenhum estruturalmente equivalente a vários modelos. Se ele encontrar um desses modelos, ele gerará uma exceção. Esse tipo de validação é usado em conjunto com <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> quando você deseja garantir que apenas um modelo corresponde a um URI de entrada.  
  
-   Quando <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> é chamado passando `true`, vários modelos de estruturalmente equivalente podem estar contidos em um <xref:System.UriTemplateTable>. No entanto, qualquer cadeia de caracteres de consulta nos modelos não deve ser ambíguas. cadeias de caracteres de consulta idênticos são permitidas. Para obter mais informações sobre cadeias de caracteres de consulta ambígua, consulte [UriTemplate e UriTemplateTable](~/docs/framework/wcf/feature-details/uritemplate-and-uritemplatetable.md).  
  
   
  
## Examples  
 O código a seguir mostra como criar uma <xref:System.UriTemplateTable>preenchê-lo e usá-lo para correspondência com um candidato <xref:System.Uri>.  
  
 [!code-csharp[UriTemplateTable#0](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#0)]
 [!code-vb[UriTemplateTable#0](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#0)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.UriTemplateTable" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.UriTemplateTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como instanciar o <xref:System.UriTemplateTable> classe.  
  
 [!code-csharp[UriTemplateTable#1](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#1)]
 [!code-vb[UriTemplateTable#1](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : seq&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt; -&gt; UriTemplateTable" Usage="new System.UriTemplateTable keyValuePairs" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="keyValuePairs">Uma coleção de pares chave/valor composta de modelos de URI e dados associados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.UriTemplateTable" /> com a coleção especificada de pares chave/valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como instanciar o <xref:System.UriTemplateTable> classe.  
  
 [!code-csharp[UriTemplateTable#2](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#2)]
 [!code-vb[UriTemplateTable#2](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : Uri -&gt; UriTemplateTable" Usage="new System.UriTemplateTable baseAddress" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Uma instância <see cref="T:System.Uri" /> que contém o endereço básico.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.UriTemplateTable" /> com o endereço básico especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como chamar esse construtor.  
  
 [!code-csharp[UriTemplateTable#3](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/program.cs#3)]
 [!code-vb[UriTemplateTable#3](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/program1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UriTemplateTable (Uri baseAddress, System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; keyValuePairs);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseAddress, class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; keyValuePairs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.#ctor(System.Uri,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.UriTemplate,System.Object}})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseAddress As Uri, keyValuePairs As IEnumerable(Of KeyValuePair(Of UriTemplate, Object)))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateTable(Uri ^ baseAddress, System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ keyValuePairs);" />
      <MemberSignature Language="F#" Value="new UriTemplateTable : Uri * seq&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt; -&gt; UriTemplateTable" Usage="new System.UriTemplateTable (baseAddress, keyValuePairs)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseAddress" Type="System.Uri" />
        <Parameter Name="keyValuePairs" Type="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="baseAddress">Uma instância <see cref="T:System.Uri" /> que contém o endereço básico.</param>
        <param name="keyValuePairs">Uma coleção de pares chave/valor composta de modelos de URI e dados associados.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.UriTemplateTable" /> com o endereço básico e a coleção de pares chave/valor especificados.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir mostra como chamar esse construtor.  
  
 [!code-csharp[UriTemplateTable#4](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#4)]
 [!code-vb[UriTemplateTable#4](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BaseAddress">
      <MemberSignature Language="C#" Value="public Uri BaseAddress { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri BaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.BaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public Property BaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ BaseAddress { Uri ^ get(); void set(Uri ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BaseAddress : Uri with get, set" Usage="System.UriTemplateTable.BaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém e define o endereço básico da instância <see cref="T:System.UriTemplateTable" />.</summary>
        <value>Um <see cref="T:System.Uri" /> que contém o endereço básico.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.UriTemplateTable.BaseAddress%2A> propriedade só pode ser definida antes de chamar <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> ou <xref:System.UriTemplateTable.Match%28System.Uri%29> ou <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> caso contrário, um <xref:System.InvalidOperationException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir mostra como acessar o <xref:System.UriTemplateTable.BaseAddress%2A> propriedade.  
  
 [!code-csharp[UriTemplateTable#5](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#5)]
 [!code-vb[UriTemplateTable#5](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.UriTemplateTable.IsReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que especifica se o <see cref="T:System.UriTemplateTable" /> é somente leitura.</summary>
        <value>
          <see langword="true" /> Se o <see cref="T:System.UriTemplateTable" /> propriedade for somente leitura; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.UriTemplateTable> é lido apenas após o <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> método é chamado.  
  
   
  
## Examples  
 O exemplo a seguir mostra como acessar o <xref:System.UriTemplateTable.IsReadOnly%2A> propriedade.  
  
 [!code-csharp[UriTemplateTable#6](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#6)]
 [!code-vb[UriTemplateTable#6](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyValuePairs">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate,object&gt;&gt; KeyValuePairs { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;class System.UriTemplate, object&gt;&gt; KeyValuePairs" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.KeyValuePairs" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property KeyValuePairs As IList(Of KeyValuePair(Of UriTemplate, Object))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ KeyValuePairs { System::Collections::Generic::IList&lt;System::Collections::Generic::KeyValuePair&lt;UriTemplate ^, System::Object ^&gt;&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyValuePairs : System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;UriTemplate, obj&gt;&gt;" Usage="System.UriTemplateTable.KeyValuePairs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Collections.Generic.KeyValuePair&lt;System.UriTemplate,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma coleção de pares chave/valor composta de objetos <see cref="T:System.UriTemplate" /> e seus dados associados.</summary>
        <value>Uma coleção de pares chave/valor que consistem em <see cref="T:System.UriTemplate" /> objetos e seus dados associados.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada <xref:System.UriTemplate> instância na tabela possui dados associados a ele. O <xref:System.UriTemplateTable.KeyValuePairs%2A> propriedade contém uma coleção de pares chave / valor onde a chave é um <xref:System.UriTemplate> instância e o valor é os dados associados a <xref:System.UriTemplate>. Valores só podem ser adicionados ao <xref:System.UriTemplateTable.KeyValuePairs%2A> propriedade antes de chamar <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> ou <xref:System.UriTemplateTable.Match%28System.Uri%29> ou <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> caso contrário, um <xref:System.NotSupportedException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir mostra como acessar o <xref:System.UriTemplateTable.KeyValuePairs%2A> propriedade.  
  
 [!code-csharp[UriTemplateTable#7](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#7)]
 [!code-vb[UriTemplateTable#7](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeReadOnly">
      <MemberSignature Language="C#" Value="public void MakeReadOnly (bool allowDuplicateEquivalentUriTemplates);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MakeReadOnly(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MakeReadOnly (allowDuplicateEquivalentUriTemplates As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MakeReadOnly(bool allowDuplicateEquivalentUriTemplates);" />
      <MemberSignature Language="F#" Value="member this.MakeReadOnly : bool -&gt; unit" Usage="uriTemplateTable.MakeReadOnly allowDuplicateEquivalentUriTemplates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowDuplicateEquivalentUriTemplates" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowDuplicateEquivalentUriTemplates">Especifica se a duplicação de instâncias <see cref="T:System.UriTemplate" /> equivalentes deve ser permitida no <see cref="T:System.UriTemplateTable" />.</param>
        <summary>Torna o <see cref="T:System.UriTemplateTable" /> somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando o <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> método é chamado, um dos seguintes tipos de validação ocorre:  
  
-   Quando <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> é chamado passando `false`, o <xref:System.UriTemplateTable> verifica se a tabela não contém nenhum estruturalmente equivalente a vários modelos. Se ele encontrar um desses modelos, uma exceção é lançada. Esse tipo de validação é usado em conjunto com <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> quando você deseja garantir que apenas um modelo corresponde a um URI de entrada.  
  
-   Quando <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> é chamado passando `true`, vários modelos de estruturalmente equivalente podem estar contidos em um <xref:System.UriTemplateTable>. No entanto, qualquer cadeia de caracteres de consulta nos modelos não deve ser ambíguas. cadeias de caracteres de consulta idênticos são permitidas. Esse tipo de validação é usado em conjunto com <xref:System.UriTemplateTable.Match%28System.Uri%29> quando várias correspondências de modelo são permitidas no URI candidato.  
  
 A primeira chamada para <xref:System.UriTemplateTable.MakeReadOnly%28System.Boolean%29> será respeitada, chamadas subsequentes serão ignoradas sem qualquer exceção que está sendo gerada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Match">
      <MemberSignature Language="C#" Value="public System.Collections.ObjectModel.Collection&lt;UriTemplateMatch&gt; Match (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.ObjectModel.Collection`1&lt;class System.UriTemplateMatch&gt; Match(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.Match(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::ObjectModel::Collection&lt;UriTemplateMatch ^&gt; ^ Match(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.Match : Uri -&gt; System.Collections.ObjectModel.Collection&lt;UriTemplateMatch&gt;" Usage="uriTemplateTable.Match uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.Collection&lt;System.UriTemplateMatch&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">O URI candidato.</param>
        <summary>Tenta corresponder um <see cref="T:System.Uri" /> candidato ao <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Uma coleção de instâncias <see cref="T:System.UriTemplateMatch" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método pode retornar várias correspondências.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar o <xref:System.UriTemplateTable.Match%28System.Uri%29> método.  
  
 [!code-csharp[UriTemplateTable#9](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#9)]
 [!code-vb[UriTemplateTable#9](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MatchSingle">
      <MemberSignature Language="C#" Value="public UriTemplateMatch MatchSingle (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.UriTemplateMatch MatchSingle(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.UriTemplateTable.MatchSingle(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UriTemplateMatch ^ MatchSingle(Uri ^ uri);" />
      <MemberSignature Language="F#" Value="member this.MatchSingle : Uri -&gt; UriTemplateMatch" Usage="uriTemplateTable.MatchSingle uri" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel.Web</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriTemplateMatch</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">O URI candidato.</param>
        <summary>Tenta corresponder um <see cref="T:System.Uri" /> candidato ao <see cref="T:System.UriTemplateTable" />.</summary>
        <returns>Uma instância <see cref="T:System.UriTemplateMatch" /> única.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método retorna, no máximo, uma correspondência. Se mais de uma correspondência for encontrada, um <xref:System.UriTemplateMatchException> é gerada.  
  
   
  
## Examples  
 O exemplo a seguir mostra como chamar o <xref:System.UriTemplateTable.MatchSingle%28System.Uri%29> método.  
  
 [!code-csharp[UriTemplateTable#10](~/samples/snippets/csharp/VS_Snippets_CFX/uritemplatetable/cs/snippets.cs#10)]
 [!code-vb[UriTemplateTable#10](~/samples/snippets/visualbasic/VS_Snippets_CFX/uritemplatetable/vb/snippets.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalBaseAddress">
      <MemberSignature Language="C#" Value="public Uri OriginalBaseAddress { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri OriginalBaseAddress" />
      <MemberSignature Language="DocId" Value="P:System.UriTemplateTable.OriginalBaseAddress" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalBaseAddress As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ OriginalBaseAddress { Uri ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OriginalBaseAddress : Uri" Usage="System.UriTemplateTable.OriginalBaseAddress" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.ServiceModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o endereço básico original.</summary>
        <value>O endereço básico original.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>