<Type Name="MathF" FullName="System.MathF">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6b72284d390ede7fa9e0265550f568899dce9d8d" /><Meta Name="ms.sourcegitcommit" Value="a9b8eb12d69b131f7c0de74d471798e44e863282" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="06/04/2019" /><Meta Name="ms.locfileid" Value="66501881" /></Metadata><TypeSignature Language="C#" Value="public static class MathF" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit MathF extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.MathF" />
  <TypeSignature Language="VB.NET" Value="Public Class MathF" />
  <TypeSignature Language="C++ CLI" Value="public ref class MathF abstract sealed" />
  <TypeSignature Language="F#" Value="type MathF = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece constantes e métodos estáticos para trigonométricas, logarítmicas e outras funções matemáticas comuns.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

Os campos e métodos estáticos do `MathF` classe correspondem do <xref:System.Math> classe, exceto que seus parâmetros sejam do tipo <xref:System.Single> em vez de <xref:System.Double>, e elas retornam <xref:System.Single> em vez de <xref:System.Double> valores.

         ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float x);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.MathF.Abs x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número maior ou igual a <see cref="F:System.Single.MinValue" />, mas menor ou igual a <see cref="F:System.Single.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número de ponto flutuante de precisão simples, x, tal que 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Single> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de ambos os 1.2e-03 e - 1.2e03 é 1.2e03.  
  
 Se `x` é igual a <xref:System.Single.NegativeInfinity> ou <xref:System.Single.PositiveInfinity>, o valor retornado é <xref:System.Single.PositiveInfinity>. Se `x` é igual a <xref:System.Single.NaN>, o valor retornado é <xref:System.Single.NaN>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static float Acos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acos(float x);" />
      <MemberSignature Language="F#" Value="static member Acos : single -&gt; single" Usage="System.MathF.Acos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa um cosseno, em que <paramref name="x" /> deve ser maior ou igual a -1, mas menor ou igual a 1.</param>
        <summary>Retorna o ângulo cujo cosseno é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que 0 ≤ θ ≤ π.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> &lt; -1 ou <paramref name="x" /> &gt; 1 ou <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static float Acosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Acosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Acosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Acosh(float x);" />
      <MemberSignature Language="F#" Value="static member Acosh : single -&gt; single" Usage="System.MathF.Acosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa um cosseno hiperbólico, em que <paramref name="x" /> deve ser maior ou igual a 1, mas menor ou igual a <see cref="F:System.Single.PositiveInfinity" />.</param>
        <summary>Retorna o ângulo cujo cosseno hiperbólico é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que 0 ≤ θ ≤ ∞.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> &lt; 1 ou <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static float Asin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asin(float x);" />
      <MemberSignature Language="F#" Value="static member Asin : single -&gt; single" Usage="System.MathF.Asin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa um seno, em que <paramref name="x" /> deve ser maior ou igual a -1, mas menor ou igual a 1.</param>
        <summary>Retorna o ângulo cujo seno é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -π/2 ≤ θ ≤ π/2.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> &lt; -1 ou <paramref name="x" /> &gt; 1 ou <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de retorno positivo representa um ângulo no sentido anti-horário do eixo x; um valor de retorno negativo representa um ângulo no sentido horário.  
  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static float Asinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Asinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Asinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Asinh(float x);" />
      <MemberSignature Language="F#" Value="static member Asinh : single -&gt; single" Usage="System.MathF.Asinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa um seno hiperbólico, em que <paramref name="x" /> deve ser maior ou igual a <see cref="F:System.Single.NegativeInfinity" />, mas menor ou igual a <see cref="F:System.Single.PositiveInfinity" />.</param>
        <summary>Retorna o ângulo cujo seno hiperbólico é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -∞ &lt; θ ≤ -1 ou 1 ≤ θ &lt; ∞. 
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static float Atan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan(float x);" />
      <MemberSignature Language="F#" Value="static member Atan : single -&gt; single" Usage="System.MathF.Atan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa uma tangente.</param>
        <summary>Retorna o ângulo cuja tangente é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -π/2 ≤ θ ≤ π/2.  
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, -π/2 arrendondado para precisão dupla (-1,5707963267949) se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" /> ou π/2 arrendondado para precisão dupla (1,5707963267949) se <paramref name="x" /> for igual a <see cref="F:System.Single.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de retorno positivo representa um ângulo no sentido anti-horário do eixo x; um valor de retorno negativo representa um ângulo no sentido horário.  
  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static float Atan2 (float y, float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atan2(float32 y, float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atan2(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Single, x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atan2(float y, float x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : single * single -&gt; single" Usage="System.MathF.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Single" />
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="y">A coordenada y de um ponto.</param>
        <param name="x">A coordenada x de um ponto.</param>
        <summary>Retorna o ângulo cuja tangente é o quociente de dois números especificados.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -π ≤ θ ≤ π e tan(θ) = <paramref name="y" /> / <paramref name="x" />, em que (<paramref name="x" />, <paramref name="y" />) é um ponto no plano cartesiano. Observe o seguinte: 
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 1, 0 &lt; θ &lt; π/2.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 2, π/2 &lt; θ ≤ π.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 3, -π &lt; θ &lt; -π/2.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 4, -π/2 &lt; θ &lt; 0.  
  
Para pontos em limites dos quadrantes, o valor retornado é o seguinte: 
-   Se y for 0 e x não for negativo, θ = 0.  
  
-   Se y for 0 e x for negativo, θ = π.  
  
-   Se y for positivo e x for 0, θ = π/2.  
  
-   Se y for negativo e x for 0, θ = - π/2.  
  
-   Se y for 0 e x for 0, θ = 0.  
  
Se <paramref name="x" /> ou <paramref name="y" /> for <see cref="F:System.Single.NaN" />, ou se <paramref name="x" /> e <paramref name="y" /> forem <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />, o método retornará <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o ângulo no plano cartesiano formado pelo eixo x e um vetor inicial da origem, (0,0) e terminando no ponto (x, y).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static float Atanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Atanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Atanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Atanh(float x);" />
      <MemberSignature Language="F#" Value="static member Atanh : single -&gt; single" Usage="System.MathF.Atanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">Um número que representa uma tangente hiperbólica, em que <paramref name="x" /> deve ser maior ou igual a -1, mas menor ou igual a 1.</param>
        <summary>Retorna o ângulo cuja tangente hiperbólica é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -∞ &lt; θ &lt;-1 ou 1 &lt; θ &lt; ∞.  
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> &lt; -1 ou <paramref name="x" /> &gt; 1 ou <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplique o valor retornado por 180 /<xref:System.MathF.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BitDecrement">
      <MemberSignature Language="C#" Value="public static float BitDecrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitDecrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitDecrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitDecrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitDecrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitDecrement : single -&gt; single" Usage="System.MathF.BitDecrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O valor a ser diminuído.</param>
        <summary>Retorna o próximo valor menor que é comparado como menor que <paramref name="x" />.</summary>
        <returns>O próximo valor menor que é comparado como menor que <paramref name="x" />.
  
- ou - 
 <see cref="F:System.Single.NegativeInfinity" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" />.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="BitIncrement">
      <MemberSignature Language="C#" Value="public static float BitIncrement (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 BitIncrement(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.BitIncrement(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BitIncrement (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float BitIncrement(float x);" />
      <MemberSignature Language="F#" Value="static member BitIncrement : single -&gt; single" Usage="System.MathF.BitIncrement x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O valor a ser incrementado.</param>
        <summary>Retorna o próximo valor maior que é maior que <paramref name="x" />.</summary>
        <returns>O próximo valor maior que é maior que <paramref name="x" />.
  
- ou - 
 <see cref="F:System.Single.PositiveInfinity" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.PositiveInfinity" />.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static float Cbrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cbrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cbrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cbrt(float x);" />
      <MemberSignature Language="F#" Value="static member Cbrt : single -&gt; single" Usage="System.MathF.Cbrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="x">O número cuja raiz cúbica deve ser encontrada.</param>
        <summary>Retorna a raiz cúbica de um número especificado.</summary>
        <returns>A raiz cúbica de <paramref name="x" />.
  
- ou - 
 <see cref="F:System.Single.NaN" /> se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />.</returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static float Ceiling (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Ceiling(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Ceiling(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Ceiling(float x);" />
      <MemberSignature Language="F#" Value="static member Ceiling : single -&gt; single" Usage="System.MathF.Ceiling x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna o menor valor integral maior ou igual ao número de ponto flutuante de precisão simples especificado.</summary>
        <returns>O menor valor integral maior ou igual a <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse valor será retornado. Observe que esse método retorna um <see cref="T:System.Single" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para positivo infinito. Em outras palavras, se `x` for positivo, a presença de qualquer componente fracionário causas `x` a ser arredondado para o próximo inteiro mais alto. Se `x` for negativo, a operação de arredondamento faz com que qualquer componente fracionário de `x` sejam descartadas. A operação desse método difere de <xref:System.MathF.Floor%28System.Single%29> método, que dá suporte ao arredondamento para negativo infinito.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="CopySign">
      <MemberSignature Language="C#" Value="public static float CopySign (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 CopySign(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.CopySign(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CopySign (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float CopySign(float x, float y);" />
      <MemberSignature Language="F#" Value="static member CopySign : single * single -&gt; single" Usage="System.MathF.CopySign (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Um número cuja magnitude é usada no resultado.</param>
        <param name="y">Um número cujo sinal é usado no resultado.</param>
        <summary>Retorna um valor com magnitude de <paramref name="x" /> e o sinal de <paramref name="y" />.</summary>
        <returns>Um valor com magnitude de <paramref name="x" /> e o sinal de <paramref name="y" />.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static float Cos (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cos(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cos(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cos(float x);" />
      <MemberSignature Language="F#" Value="static member Cos : single -&gt; single" Usage="System.MathF.Cos x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna o cosseno do ângulo especificado.</summary>
        <returns>O cosseno de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse método retornará <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static float Cosh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Cosh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Cosh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Cosh(float x);" />
      <MemberSignature Language="F#" Value="static member Cosh : single -&gt; single" Usage="System.MathF.Cosh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna o cosseno hiperbólico do ângulo especificado.</summary>
        <returns>O cosseno hiperbólico de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> será retornado. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.    
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const float E = 2.718282;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 E = (2.718282)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Single  = 2.718282" />
      <MemberSignature Language="C++ CLI" Value="public: float E = 2.718282;" />
      <MemberSignature Language="F#" Value="val mutable E : single" Usage="System.MathF.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>2.718282</MemberValue>
      <Docs>
        <summary>Representa a base logarítmica natural, especificada pela constante <see langword="e" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

O valor dessa constante é 2.71828175.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static float Exp (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Exp(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Exp(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Exp(float x);" />
      <MemberSignature Language="F#" Value="static member Exp : single -&gt; single" Usage="System.MathF.Exp x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número que especifica uma potência.</param>
        <summary>Retorna <see langword="e" /> elevado à potência especificada.</summary>
        <returns>O número <see langword="e" /> elevado à potência <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse valor será retornado. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" />, 0 será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` é uma constante matemática cujo valor é aproximadamente 2,71828.  
  
 Use o <xref:System.MathF.Pow%2A> método para calcular potências de outras bases.  
  
 <xref:System.MathF.Exp%2A> é o inverso de <xref:System.MathF.Log%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
        <altmember cref="M:System.MathF.Log(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static float Floor (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Floor(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Floor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Floor(float x);" />
      <MemberSignature Language="F#" Value="static member Floor : single -&gt; single" Usage="System.MathF.Floor x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples.</param>
        <summary>Retorna o maior valor integral menor ou igual ao número de ponto flutuante de precisão simples especificado.</summary>
        <returns>O maior valor integral menor ou igual a <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse valor será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para negativo infinito. Em outras palavras, se `x` for positivo, qualquer componente fracionária é truncada. Se `x` é negativo, a presença de qualquer componente fracionário faz com que ele seja arredondado para o menor inteiro. A operação desse método difere de <xref:System.MathF.Ceiling%2A> método, que dá suporte ao arredondamento para positivo infinito.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="FusedMultiplyAdd">
      <MemberSignature Language="C#" Value="public static float FusedMultiplyAdd (float x, float y, float z);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 FusedMultiplyAdd(float32 x, float32 y, float32 z) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.FusedMultiplyAdd(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FusedMultiplyAdd (x As Single, y As Single, z As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float FusedMultiplyAdd(float x, float y, float z);" />
      <MemberSignature Language="F#" Value="static member FusedMultiplyAdd : single * single * single -&gt; single" Usage="System.MathF.FusedMultiplyAdd (x, y, z)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="z" Type="System.Single" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O número deve ser multiplicado por <paramref name="y" />.</param>
        <param name="y">O número deve ser multiplicado por <paramref name="x" />.</param>
        <param name="z">O número a ser adicionado ao resultado de <paramref name="x" /> multiplicado por <paramref name="y" />.</param>
        <summary>Retorna (x * y) + z, arredondado como uma operação ternária.</summary>
        <returns>(x * y) + z, arredondado como uma operação ternária.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Isso calcula `(x * y)` como se a precisão infinita, adiciona `z` para que resultar como se a precisão infinita e Arredonda, por fim, para o mais próximo valor representável.
  
 Isso é diferente da sequência de não-combinados, qual seria a computação `(x * y)` como se a preicision infinito, arredondar o resultado para o mais próximo valor representável, adicione a 'z' para o resultado arredondado como se a precisão infinita e, finalmente, arredondar para mais próximo representável valor.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static float IEEERemainder (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 IEEERemainder(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.IEEERemainder(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float IEEERemainder(float x, float y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : single * single -&gt; single" Usage="System.MathF.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um dividendo.</param>
        <param name="y">Um divisor.</param>
        <summary>Retorna o resultado restante da divisão de um número especificado por outro número especificado.</summary>
        <returns>Um número igual a <paramref name="x" /> - (<paramref name="y" /> Q), em que Q é o quociente de <paramref name="x" /> / <paramref name="y" /> arredondado para o inteiro mais próximo (se <paramref name="x" /> / <paramref name="y" /> ficar entre dois inteiros, o inteiro par será retornado).  
  
Se <paramref name="x" /> – (<paramref name="y" /> Q) for igual a zero, o valor +0 será retornado se <paramref name="x" /> for positivo ou -0 se <paramref name="x" /> for negativo.  
  
Se <paramref name="y" /> = 0, <see cref="F:System.Single.NaN" /> é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação está em conformidade com a operação remainder definida na seção 5.1 do ANSI/IEEE Std 754-1985; Padrão IEEE para aritmética de ponto flutuante binário; Institute of elétrica e Electronics Engineers, Inc; 1985.  
  
 O <xref:System.MathF.IEEERemainder%2A> método não é igual a [operador de resto](~/docs/csharp/language-reference/operators/remainder-operator.md). Embora ambos retornem o resto após a divisão, as fórmulas que usam são diferentes. A fórmula para o <xref:System.MathF.IEEERemainder%2A> método é:  
  
```  
IEEERemainder = dividend - (divisor * MathF.Round(dividend / divisor))  
```  
  
 Por outro lado, a fórmula para o operador de restante é:  
  
```  
Remainder = (MathF.Abs(dividend) - (MathF.Abs(divisor) *   
            (MathF.Floor(MathF.Abs(dividend) / MathF.Abs(divisor))))) *   
            MathF.Sign(dividend)  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ILogB">
      <MemberSignature Language="C#" Value="public static int ILogB (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 ILogB(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ILogB(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ILogB (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int ILogB(float x);" />
      <MemberSignature Language="F#" Value="static member ILogB : single -&gt; int" Usage="System.MathF.ILogB x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O número cujo logaritmo deve ser encontrado.</param>
        <summary>Retorna o logaritmo inteiro de base 2 de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="x" /> 
 </term><description> Valor retornado 
 </description></listheader><item><term> Padrão 
 </term><description> O logaritmo inteiro de base 2 do <paramref name="x" />; ou seja, (int)log2(<paramref name="x" />).  
  
 </description></item><item><term> Zero 
 </term><description> <see cref="F:System.Int32.MinValue" />
  
 </description></item><item><term> Igual a <see cref="F:System.Single.NaN" /> ou <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NegativeInfinity" />
  
 </term><description> <see cref="F:System.Int32.MaxValue" />
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `x` é especificado como um número de base 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x);" />
      <MemberSignature Language="F#" Value="static member Log : single -&gt; single" Usage="System.MathF.Log x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">O número cujo logaritmo deve ser encontrado.</param>
        <summary>Retorna o logaritmo natural (de base <see langword="e" />) de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="x" /> 
 </term><description> Valor retornado 
 </description></listheader><item><term> Positivo 
 </term><description> O logaritmo natural de <paramref name="x" />; ou seja, ln <paramref name="x" /> ou log e <paramref name="x" /></description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativo 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `x` é especificado como um número de base 10.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.MathF.E" />
        <altmember cref="M:System.MathF.Exp(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static float Log (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Log : single * single -&gt; single" Usage="System.MathF.Log (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">O número cujo logaritmo deve ser encontrado.</param>
        <param name="newBase">A base do logaritmo.</param>
        <summary>Retorna o logaritmo de um número especificado em uma base especificada.</summary>
        <returns>Um dos valores na tabela a seguir. (+Infinito indica <see cref="F:System.Single.PositiveInfinity" />, -Infinito indica <see cref="F:System.Single.NegativeInfinity" /> e NaN indica <see cref="F:System.Single.NaN" />.) 
 <list type="table"><listheader><term><paramref name="x" /></term><description><paramref name="newBase" /></description><description> Valor retornado 
 </description></listheader><item><term><paramref name="x" />&gt; 0 
 </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -ou- (<paramref name="newBase" />&gt; 1) 
 </description><description> lognewBase(a) 
 </description></item><item><term><paramref name="x" />&lt; 0 
 </term><description> (nenhum valor) 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" />&lt; 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> != 1 
 </term><description><paramref name="newBase" /> = +Infinito 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = NaN 
 </term><description> (nenhum valor) 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" /> = NaN 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" /> = 1 
 </description><description> NaN 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> +Infinito 
 </description></item><item><term><paramref name="x" /> = 0 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> -Infinito 
 </description></item><item><term><paramref name="x" /> = +Infinito 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> -Infinito 
 </description></item><item><term><paramref name="x" /> = +Infinito 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> +Infinito 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> 0 
 </description></item><item><term><paramref name="x" /> = 1 
 </term><description><paramref name="newBase" /> = +Infinito 
 </description><description> 0 
 </description></item></list></returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static float Log10 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log10(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log10(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log10(float x);" />
      <MemberSignature Language="F#" Value="static member Log10 : single -&gt; single" Usage="System.MathF.Log10 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número cujo logaritmo deve ser localizado.</param>
        <summary>Retorna o logaritmo de base 10 de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="x" /> 
 </term><description> Valor retornado 
 </description></listheader><item><term> Positivo 
 </term><description> O log de base 10 de <paramref name="x" />; ou seja, log 10<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativo 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `x` é especificado como um número de base 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log2">
      <MemberSignature Language="C#" Value="public static float Log2 (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Log2(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Log2(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log2 (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Log2(float x);" />
      <MemberSignature Language="F#" Value="static member Log2 : single -&gt; single" Usage="System.MathF.Log2 x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Um número cujo logaritmo deve ser localizado.</param>
        <summary>Retorna o logaritmo de base 2 de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="x" /> 
 </term><description> Valor retornado 
 </description></listheader><item><term> Positivo 
 </term><description> O logaritmo de base 2 de <paramref name="x" />; ou seja, log 2<paramref name="x" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term> Negativo 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> Igual a <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `x` é especificado como um número de base 10.   
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.MathF.Max (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="y">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna o maior dos dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="x" /> ou <paramref name="y" />, o que for maior. Se <paramref name="x" />, <paramref name="y" /> ou ambos <paramref name="x" /> e <paramref name="y" /> forem igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxMagnitude">
      <MemberSignature Language="C#" Value="public static float MaxMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MaxMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MaxMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MaxMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MaxMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MaxMagnitude : single * single -&gt; single" Usage="System.MathF.MaxMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="y">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna a maior magnitude de dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="x" /> ou <paramref name="y" />, o que tiver a magnitude maior. Se <paramref name="x" />, <paramref name="y" /> ou ambos <paramref name="x" /> e <paramref name="y" /> forem igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.MathF.Min (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="y">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna o menor de dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="x" /> ou <paramref name="y" />, o que for menor. Se <paramref name="x" />, <paramref name="y" /> ou tanto <paramref name="x" /> quanto <paramref name="y" /> forem iguais a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="MinMagnitude">
      <MemberSignature Language="C#" Value="public static float MinMagnitude (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 MinMagnitude(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.MinMagnitude(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MinMagnitude (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float MinMagnitude(float x, float y);" />
      <MemberSignature Language="F#" Value="static member MinMagnitude : single * single -&gt; single" Usage="System.MathF.MinMagnitude (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="y" Type="System.Single" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="y">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna a menor magnitude de dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="x" /> ou <paramref name="y" />, o que tiver a magnitude menor. Se <paramref name="x" />, <paramref name="y" /> ou ambos <paramref name="x" /> e <paramref name="y" /> forem igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const float PI = 3.141593;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PI = (3.141593)" />
      <MemberSignature Language="DocId" Value="F:System.MathF.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Single  = 3.141593" />
      <MemberSignature Language="C++ CLI" Value="public: float PI = 3.141593;" />
      <MemberSignature Language="F#" Value="val mutable PI : single" Usage="System.MathF.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.141593</MemberValue>
      <Docs>
        <summary>Representa a razão entre a circunferência de um círculo e seu diâmetro, especificada pela constante π.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

O valor desse campo é 3.14159274.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static float Pow (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Pow(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Pow(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Single, y As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Pow(float x, float y);" />
      <MemberSignature Language="F#" Value="static member Pow : single * single -&gt; single" Usage="System.MathF.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples a ser elevado a uma potência.</param>
        <param name="y">Um número de ponto flutuante de precisão simples que especifica uma potência.</param>
        <summary>Retorna um número especificado elevado à potência especificada.</summary>
        <returns>O número <paramref name="x" /> elevado à potência <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir indica o valor de retorno quando vários valores ou intervalos de valores são especificados para o `x` e `y` parâmetros. Para obter mais informações, consulte <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> e <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
|Parâmetros|Valor retornado|  
|----------------|------------------|  
|`x` ou `y`  =  `NaN`.|`NaN`|  
|`x` = Qualquer valor exceto `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` é um número inteiro ímpar.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` é positivo, mas não é um inteiro ímpar.|`PositiveInfinity`|  
|`x` < 0, mas não `NegativeInfinity`; `y` não é um inteiro `NegativeInfinity`, ou `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y`  =  `NegativeInfinity` ou `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` < -1 ou `x` > 1; `y` = `NegativeInfinity`.|0|  
|`x` < -1 ou `x` > 1; `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` é qualquer valor exceto `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.MathF.Sqrt(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x);" />
      <MemberSignature Language="F#" Value="static member Round : single -&gt; single" Usage="System.MathF.Round x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples a ser arredondado.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão simples para o valor inteiro mais próximo e arredonda os valores de ponto médio para o número par mais próximo.</summary>
        <returns>O inteiro mais próximo de <paramref name="x" />. Se o componente fracionário de <paramref name="x" /> estiver entre dois inteiros, sendo um deles par e o outro ímpar, o número par será retornado. Observe que esse método retorna um <see cref="T:System.Single" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Esse método usa o padrão de arredondamento de convenção de <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>.

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Se o valor de `x` argumento for <xref:System.Single.NaN?displayProperty=nameWithType>, o método retorna <xref:System.Single.NaN?displayProperty=nameWithType>. Se `x` está <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Devido à perda de precisão que pode resultar de que representam valores decimais como números de ponto flutuante ou executar operações aritméticas em valores de ponto flutuante, em alguns casos o <see cref="M:System.MathF.Round(System.Single)" /> método não pode aparecer arredondar os valores de ponto médio para o inteiro par mais próximo.</para></block>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : single * int -&gt; single" Usage="System.MathF.Round (x, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples a ser arredondado.</param>
        <param name="digits">O número de dígitos fracionários no valor de retorno.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão simples para o número especificado de dígitos fracionários e arredonda os valores de ponto médio para o número par mais próximo.</summary>
        <returns>O número mais próximo de <paramref name="x" /> que contém um número de dígitos fracionários igual a <paramref name="digits" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
O valor da `digits` argumento pode variar de 0 a 6. Observe que 6 é o número máximo de dígitos integrais e fracionários compatíveis com o <xref:System.Single> tipo.

Esse método usa o padrão de arredondamento de convenção de <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>. 

[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Se o valor de `x` argumento for <xref:System.Single.NaN?displayProperty=nameWithType>, o método retorna <xref:System.Single.NaN?displayProperty=nameWithType>. Se `x` está <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> é menor que 0 ou maior que 6.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples a ser arredondado.</param>
        <param name="mode">Especificação de como arredondar <paramref name="x" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão simples para o inteiro mais próximo e usa a convenção de arredondamento especificada para os valores de ponto médio.</summary>
        <returns>O inteiro mais próximo de <paramref name="x" />. Se <paramref name="x" /> estiver entre dois inteiros, sendo um deles par e o outro ímpar, <paramref name="mode" /> determinará qual dos dois será retornado. Observe que esse método retorna um <see cref="T:System.Single" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Se o valor de `x` argumento for <xref:System.Single.NaN?displayProperty=nameWithType>, o método retorna <xref:System.Single.NaN?displayProperty=nameWithType>. Se `x` está <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static float Round (float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Round(float32 x, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Round(System.Single,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (x As Single, digits As Integer, mode As MidpointRounding) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Round(float x, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : single * int * MidpointRounding -&gt; single" Usage="System.MathF.Round (x, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples a ser arredondado.</param>
        <param name="digits">O número de dígitos fracionários no valor de retorno.</param>
        <param name="mode">Especificação de como arredondar <paramref name="x" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão simples para o número especificado de dígitos fracionários e usa a convenção de arredondamento especificada para os valores de ponto médio.</summary>
        <returns>O número mais próximo de <paramref name="x" /> que tem um número de dígitos fracionários igual a <paramref name="digits" />. Se <paramref name="x" /> tiver menos dígitos fracionários que <paramref name="digits" />, <paramref name="x" /> será retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

O valor da `digits` argumento pode variar de 0 a 6. Observe que 6 é o número máximo de dígitos integrais e fracionários compatíveis com o <xref:System.Single> tipo.


[!INCLUDE[midpoint-rounding](~/includes/floating-point-equality.md)]

Se o valor de `x` argumento for <xref:System.Single.NaN?displayProperty=nameWithType>, o método retorna <xref:System.Single.NaN?displayProperty=nameWithType>. Se `x` está <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="digits" /> é menor que 0 ou maior que 6.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleB">
      <MemberSignature Language="C#" Value="public static float ScaleB (float x, int n);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 ScaleB(float32 x, int32 n) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.ScaleB(System.Single,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ScaleB (x As Single, n As Integer) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float ScaleB(float x, int n);" />
      <MemberSignature Language="F#" Value="static member ScaleB : single * int -&gt; single" Usage="System.MathF.ScaleB (x, n)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="n" Type="System.Int32" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão simples que especifica o valor da base.</param>
        <param name="n">Um número de ponto flutuante de precisão simples que especifica a potência.</param>
        <summary>Retorna x * 2^n computado com eficiência.</summary>
        <returns>x * 2^n computado com eficiência.</returns>
        <remarks></remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (x As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float x);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.MathF.Sign x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número que indica o sinal de <paramref name="x" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="x" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="x" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="x" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks></remarks>
        <exception cref="T:System.ArithmeticException"><paramref name="x" /> é igual a <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static float Sin (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sin(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sin(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sin(float x);" />
      <MemberSignature Language="F#" Value="static member Sin : single -&gt; single" Usage="System.MathF.Sin x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna o seno do ângulo especificado.</summary>
        <returns>O seno de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse método retornará <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static float Sinh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sinh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sinh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sinh(float x);" />
      <MemberSignature Language="F#" Value="static member Sinh : single -&gt; single" Usage="System.MathF.Sinh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna o seno hiperbólico do ângulo especificado.</summary>
        <returns>O seno hiperbólico de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" />, <see cref="F:System.Single.PositiveInfinity" /> ou <see cref="F:System.Single.NaN" />, o método retornará um <see cref="T:System.Single" /> igual a <paramref name="x" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static float Sqrt (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Sqrt(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Sqrt(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Sqrt(float x);" />
      <MemberSignature Language="F#" Value="static member Sqrt : single -&gt; single" Usage="System.MathF.Sqrt x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">O número cuja raiz quadrada deve ser encontrada.</param>
        <summary>Retorna a raiz quadrada de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="x" /> 
 </term><description> Valor retornado 
 </description></listheader><item><term> Zero ou positivo 
 </term><description> A raiz quadrada positiva de <paramref name="x" />.  
  
 </description></item><item><term> Negativo 
 </term><description><see cref="F:System.Single.NaN" /></description></item><item><term> É igual a <see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term> É igual a <see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks></remarks>
        <altmember cref="M:System.MathF.Pow(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static float Tan (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tan(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tan(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tan(float x);" />
      <MemberSignature Language="F#" Value="static member Tan : single -&gt; single" Usage="System.MathF.Tan x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna a tangente do ângulo especificado.</summary>
        <returns>A tangente de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> ou <see cref="F:System.Single.PositiveInfinity" />, esse método retornará <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static float Tanh (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Tanh(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Tanh(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Tanh(float x);" />
      <MemberSignature Language="F#" Value="static member Tanh : single -&gt; single" Usage="System.MathF.Tanh x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um ângulo, medido em radianos.</param>
        <summary>Retorna a tangente hiperbólica do ângulo especificado.</summary>
        <returns>A tangente hiperbólica de <paramref name="x" />. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NegativeInfinity" />, esse método retornará -1. Se o valor for igual a <see cref="F:System.Single.PositiveInfinity" />, esse método retornará 1. Se <paramref name="x" /> for igual a <see cref="F:System.Single.NaN" />, esse método retornará <see cref="F:System.Single.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `x`, deve ser em radianos. Multiplique por <xref:System.MathF.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static float Truncate (float x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Truncate(float32 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.MathF.Truncate(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (x As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Truncate(float x);" />
      <MemberSignature Language="F#" Value="static member Truncate : single -&gt; single" Usage="System.MathF.Truncate x" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Um número a ser truncado.</param>
        <summary>Calcula a parte integral de um número de ponto flutuante de precisão simples especificado.</summary>
        <returns>A parte integral do <paramref name="x" />; ou seja, o número que permanece depois que os dígitos fracionários tiverem sido descartados ou um dos valores listados na tabela a seguir.  
  
 <list type="table"><listheader><term><paramref name="x" /></term><description> Valor retornado 
 </description></listheader><item><term><see cref="F:System.Single.NaN" /></term><description><see cref="F:System.Single.NaN" /></description></item><item><term><see cref="F:System.Single.NegativeInfinity" /></term><description><see cref="F:System.Single.NegativeInfinity" /></description></item><item><term><see cref="F:System.Single.PositiveInfinity" /></term><description><see cref="F:System.Single.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.MathF.Truncate%2A> Arredonda `x` para o inteiro mais próximo em direção a zero.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.MathF.Round" />
        <altmember cref="M:System.MathF.Ceiling(System.Single)" />
        <altmember cref="M:System.MathF.Floor(System.Single)" />
      </Docs>
    </Member>
  </Members>
</Type>
