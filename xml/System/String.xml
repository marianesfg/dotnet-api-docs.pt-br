<Type Name="String" FullName="System.String">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ee56099641516cbb76418e5c30c6cb4a8ffe9098" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462106" /></Metadata><TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa o texto como uma sequência de unidades de código UTF-16.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 Uma cadeia de caracteres é uma coleção sequencial de caracteres que é usada para representar texto. Um <xref:System.String> objeto é uma coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos que representam uma cadeia de caracteres; um <xref:System.Char?displayProperty=nameWithType> objeto corresponde a uma unidade de código UTF-16. O valor de <xref:System.String> objeto é o conteúdo da coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos e que o valor é imutável (ou seja, ele é somente leitura). Para obter mais informações sobre a imutabilidade de cadeias de caracteres, consulte a [imutabilidade e a classe StringBuilder](#Immutability) seção mais adiante neste tópico. O tamanho máximo de um <xref:System.String> objeto na memória é de 2 GB, ou cerca de 1 bilhão de caracteres.  
  
[!INCLUDE[interactive-note](~/includes/csharp-interactive-note-some.md)]

 Nesta seção:  
  
 [Criando uma instância de um objeto de cadeia de caracteres](#Instantiation)   
 [Objetos char e caracteres Unicode](#Characters)   
 [Cadeias de caracteres e o padrão Unicode](#Unicode)   
 [Cadeias de caracteres e caracteres nulos inseridos](#EmbeddedNulls)   
 [Cadeias de caracteres e índices](#Indexes)   
 [Cadeias de caracteres nulas e cadeias de caracteres vazias](#Nulls)   
 [Imutabilidade e a classe StringBuilder](#Immutability)   
 [Ordinal x operações sensíveis à cultura](#CultureSensitive)   
 [Normalização](#Normalization)   
 [Operações de cadeia de caracteres por categoria](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a>Criando uma instância de um objeto String  
 Você pode instanciar um <xref:System.String> objeto das seguintes maneiras:  
  
-   Atribuindo uma cadeia de caracteres literal a uma <xref:System.String> variável. Esse é o método mais comumente usado para a criação de uma cadeia de caracteres. O exemplo a seguir usa a atribuição para criar várias cadeias de caracteres. Observe que, em c#, como a barra invertida (\\) é um caractere de escape, barras invertidas literais em uma cadeia de caracteres devem ser escapadas ou cadeia de caracteres inteira deve ser @-quoted.  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp-interactive[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   Chamando um <xref:System.String> construtor de classe. O exemplo a seguir cria uma instância de cadeias de caracteres chamando vários construtores de classe. Observe que alguns dos construtores incluem ponteiros para matrizes de caracteres ou matrizes de bytes com sinal como parâmetros. Visual Basic não oferece suporte a chamadas para esses construtores. Para obter informações detalhadas sobre <xref:System.String> construtores, consulte o <xref:System.String.%23ctor%2A> resumo do construtor.  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp-interactive[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   Usando o operador de concatenação de cadeia de caracteres (+ em c# e & ou + no Visual Basic) para criar uma única cadeia de caracteres de qualquer combinação de <xref:System.String> instâncias e literais de cadeia de caracteres. O exemplo a seguir ilustra o uso do operador de concatenação de cadeia de caracteres.  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp-interactive[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   Recuperar uma propriedade ou chamando um método que retorna uma cadeia de caracteres. O exemplo a seguir usa os métodos do <xref:System.String> classe para extrair uma subcadeia de caracteres de uma cadeia de caracteres maior.  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp-interactive[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   Chamando um método de formatação para converter um valor ou o objeto em sua representação de cadeia de caracteres. O exemplo a seguir usa o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) recurso para inserir a representação de cadeia de caracteres de dois objetos em uma cadeia de caracteres.  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp-interactive[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a>Objetos Char e caracteres Unicode  
 Cada caractere em uma cadeia de caracteres é definido por um valor escalar Unicode, também chamado de um ponto de código Unicode ou o valor ordinal (numérico) do caractere Unicode. Cada ponto de código é codificado usando a codificação UTF-16, e o valor numérico de cada elemento da codificação é representado por um <xref:System.Char> objeto.  
  
> [!NOTE]
>  Observe que, como um <xref:System.String> instância consiste em uma coleção sequencial de unidades de código UTF-16, é possível criar um <xref:System.String> objeto que não é uma cadeia de caracteres Unicode bem formada. Por exemplo, é possível criar uma cadeia de caracteres que tem um substituto baixo sem um substituto alto correspondente. Embora alguns métodos, como os métodos de codificação e decodificação de objetos na <xref:System.Text> namespace, talvez executa verificações para garantir que as cadeias de caracteres estejam bem formadas, <xref:System.String> membros de classe não garantem que uma cadeia de caracteres seja bem formada.  
  
 Uma única <xref:System.Char> objeto normalmente representa um único ponto de código, ou seja, o valor numérico a <xref:System.Char> é igual ao ponto de código. Por exemplo, o ponto de código para o caractere "a" é U + 0061. No entanto, um ponto de código pode exigir mais de um elemento codificado (mais de um <xref:System.Char> objeto). O padrão Unicode define dois tipos de caracteres que correspondem a vários <xref:System.Char> objetos: graphemes e pontos de código suplementares do Unicode que correspondem aos caracteres os planos suplementares do Unicode.  
  
-   Uma grafema é representada por um caractere base, seguido por um ou mais caracteres de combinação. Por exemplo, o caractere ä é representado por um <xref:System.Char> objeto cujo ponto de código é seguido por um U + 0061 <xref:System.Char> objeto cujo ponto de código é a U + 0308. Esse caractere também pode ser definido por um único <xref:System.Char> objeto que tem um ponto de código de U + 00E4. Como mostra o exemplo a seguir, uma comparação sensível à cultura de igualdade indica que essas duas representações são iguais, embora uma comparação ordinal comum não faz isso. No entanto, se duas cadeias de caracteres são normalizadas, uma comparação ordinal também indica que eles são iguais. (Para obter mais informações sobre a normalização de cadeias de caracteres, consulte a [normalização](#Normalization) seção.)  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   Unicode (um par substituto) do ponto de código suplementar é representado por um <xref:System.Char> objeto cujo ponto de código é um substituto alto seguido por um <xref:System.Char> objeto cujo ponto de código é um substituto baixo. As unidades de código do intervalo de substitutos altos de U+D800 a U + DBFF. As unidades de código do intervalo de substitutos baixos de U+DC00 a U + DFFF. Pares substitutos são usados para representar caracteres nos 16 planos suplementares do Unicode. O exemplo a seguir cria um caractere alternativo e a passa para o <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> método para determinar se ele é um par substituto.  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp-interactive[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a>Cadeias de caracteres e o padrão Unicode  
 Caracteres em uma cadeia de caracteres são representados por unidades de código codificado em UTF-16, que correspondem aos <xref:System.Char> valores.  
  
 Cada caractere em uma cadeia de caracteres tem uma categoria de caractere Unicode associada, que é representada no .NET pelo <xref:System.Globalization.UnicodeCategory> enumeração. A categoria de um caractere ou um par alternativo pode ser determinada chamando o <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> método.  

[!INCLUDE[character-categories](~/includes/unicode-categories.md)]
  
 Além disso, o .NET dá suporte à comparação de cadeia de caracteres e classificação com base no padrão Unicode. Nas versões do .NET Framework por meio de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o .NET Framework mantém sua própria tabela de dados de cadeia de caracteres. Isso também é verdadeiro para as versões do .NET Framework começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 7. Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 8 e versões posteriores do sistema operacional Windows, os delegados de tempo de execução de cadeia de caracteres de comparação e ordenação de operações para o sistema operacional. No .NET Core, comparação cadeia de caracteres e informações de classificação é fornecida pelo [International Components for Unicode](http://site.icu-project.org/) bibliotecas. A tabela a seguir lista as versões do .NET e as versões do padrão Unicode em qual caractere de comparação e classificação baseiam-se.  
  
|Versão do .NET|Versão do Padrão Unicode|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[O Padrão Unicode, versão 4.0.0](https://www.unicode.org/versions/Unicode4.0.0/)|  
|O .NET Framework 2.0|[O Padrão Unicode, versão 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[O Padrão Unicode, versão 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[O Padrão Unicode, versão 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e posterior no Windows 7|[O Padrão Unicode, versão 5.0.0](https://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)] e posterior no Windows 8 e em sistemas operacionais Windows posteriores|[O Padrão Unicode, versão 6.3.0](https://www.unicode.org/versions/Unicode6.3.0/)|  
|.NET Core (todas as versões)|Depende da versão do padrão Unicode compatível com o sistema operacional subjacente.|

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a>Cadeias de caracteres e caracteres nulos inseridos  
 No .NET, um <xref:System.String> objeto pode incluir caracteres nulos inseridos, que contam como parte do comprimento da cadeia de caracteres. No entanto, em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres; ele não é considerado parte da cadeia de caracteres e não é contabilizado como parte do comprimento da cadeia de caracteres. Isso significa que as seguintes suposições comuns que programadores de C e C++ ou bibliotecas escritas em C ou C++ podem fazer sobre cadeias de caracteres não são necessariamente válidas quando aplicado a <xref:System.String> objetos:  
  
-   O valor retornado pela `strlen` ou `wcslen` funções não é necessariamente igual <xref:System.String.Length%2A?displayProperty=nameWithType>.  
  
-   A cadeia de caracteres criada pelo `strcpy_s` ou `wcscpy_s` funções não é necessariamente idêntica à cadeia de caracteres criada pelo <xref:System.String.Copy%2A?displayProperty=nameWithType> método.  
  
 Você deve garantir que esse código C e C++ nativo que instancia <xref:System.String> objetos e o código que é passado <xref:System.String> objetos por meio da plataforma de invocação, não presuma que um caractere nulo inserido marca o fim da cadeia de caracteres.  
  
 Caracteres nulos inseridos em uma cadeia de caracteres também são tratados diferentemente quando uma cadeia de caracteres é classificada (ou em comparação com) e quando uma cadeia de caracteres é pesquisada. Caracteres nulos são ignorados ao executar comparações sensíveis à cultura entre duas cadeias de caracteres, incluindo as comparações usando a cultura invariável. Elas são consideradas apenas para comparações ordinais ordinal ou diferencia maiusculas de minúsculas. Por outro lado, caracteres nulos inseridos são sempre considerados durante a pesquisa uma cadeia de caracteres com métodos como <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, e <xref:System.String.IndexOf%2A>.  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a>Cadeias de caracteres e índices  
 Um índice é a posição de um <xref:System.Char> objeto (não um caractere Unicode) em um <xref:System.String>. Um índice é um número não negativo, com base em zero que começa na primeira posição na cadeia de caracteres, que é a posição de índice zero. Um número de métodos de pesquisa, como <xref:System.String.IndexOf%2A> e <xref:System.String.LastIndexOf%2A>, retornar o índice de um caractere ou subcadeia de caracteres na instância de cadeia de caracteres.  
  
 O <xref:System.String.Chars%2A> propriedade permite que você acesse individuais <xref:System.Char> objetos por sua posição de índice na cadeia de caracteres. Porque o <xref:System.String.Chars%2A> propriedade é a propriedade padrão (no Visual Basic) ou o indexador (no c#), você pode acessar o indivíduo <xref:System.Char> objetos em uma cadeia de caracteres usando código como o seguinte. Esse código procura por espaço em branco ou caracteres de pontuação em uma cadeia de caracteres para determinar quantas palavras que contém a cadeia de caracteres.  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp-interactive[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 Porque o <xref:System.String> classe implementa o <xref:System.Collections.IEnumerable> interface, você também pode iterar por meio do <xref:System.Char> objetos em uma cadeia de caracteres usando um `foreach` constructo, como mostra o exemplo a seguir.  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp-interactive[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 Valores de índice consecutivas podem não corresponder a caracteres Unicode consecutivos, como um caractere pode ser codificado em Unicode como mais de um <xref:System.Char> objeto. Em particular, uma cadeia de caracteres pode conter vários caracteres unidades de texto que são formadas por um caractere base seguido por um ou mais caracteres de combinação ou por pares substitutos. Para trabalhar com caracteres Unicode em vez de <xref:System.Char> objetos, use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> e <xref:System.Globalization.TextElementEnumerator> classes. O exemplo a seguir ilustra a diferença entre o código que funciona com <xref:System.Char> objetos e o código que funciona com caracteres Unicode. Ele compara o número de caracteres ou elementos de texto em cada palavra da frase. A cadeia de caracteres inclui duas sequências de um caractere base, seguido por um caractere de combinação.  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp-interactive[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 Este exemplo funciona com elementos de texto usando o <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> método e o <xref:System.Globalization.TextElementEnumerator> classe para enumerar todos os elementos de texto em uma cadeia de caracteres. Você também pode recuperar uma matriz que contém o índice inicial de cada elemento de texto chamando o <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> método.  
  
 Para obter mais informações sobre como trabalhar com unidades de texto em vez de um indivíduo <xref:System.Char> valores, consulte o <xref:System.Globalization.StringInfo> classe.  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a>Cadeias de caracteres nulas e cadeias de caracteres vazias  
 É uma cadeia de caracteres que tenha sido declarada, mas não foi atribuída um valor `null`. A tentativa de chamar métodos em cadeia de caracteres gera um <xref:System.NullReferenceException>. Uma cadeia de caracteres nula é diferente de uma cadeia de caracteres vazia, o que é uma cadeia de caracteres cujo valor é "" ou <xref:System.String.Empty?displayProperty=nameWithType>. Em alguns casos, passando uma cadeia de caracteres nula ou uma cadeia de caracteres vazia como um argumento em uma chamada de método lançará uma exceção. Por exemplo, passar uma cadeia de caracteres nula para o <xref:System.Int32.Parse%2A?displayProperty=nameWithType> método lança um <xref:System.ArgumentNullException>e passando uma cadeia de caracteres vazia lança um <xref:System.FormatException>. Em outros casos, um argumento de método pode ser uma cadeia de caracteres nula ou uma cadeia de caracteres vazia. Por exemplo, se você estiver fornecendo um <xref:System.IFormattable> implementação para uma classe, que você deseja serão iguais a uma cadeia de caracteres nula e uma cadeia de caracteres vazia com o especificador de formato geral ("G").  
  
 O <xref:System.String> classe inclui os seguintes métodos de duas conveniência que permitem a você testar se uma cadeia de caracteres é `null` ou está vazio:  
  
-   <xref:System.String.IsNullOrEmpty%2A>, que indica se uma cadeia de caracteres é um `null` ou é igual a <xref:System.String.Empty?displayProperty=nameWithType>. Esse método elimina a necessidade de usar código como o seguinte:  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <xref:System.String.IsNullOrWhiteSpace%2A>, que indica se uma cadeia de caracteres é `null`, é igual a <xref:System.String.Empty?displayProperty=nameWithType>, ou consistir exclusivamente em caracteres de espaço em branco. Esse método elimina a necessidade de usar código como o seguinte:  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 O exemplo a seguir usa o <xref:System.String.IsNullOrEmpty%2A> método na <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação de um personalizado `Temperature` classe. O método dá suporte as cadeias de caracteres de formato "G", "C", "F" e "K". Se uma cadeia de caracteres de formato vazio ou um formato de cadeia de caracteres cujo valor é `null` é passado para o método, seu valor é alterado para a cadeia de caracteres de formato "G".  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a>Imutabilidade e a classe StringBuilder  
 Um <xref:System.String> objeto é chamado imutável (somente leitura), porque seu valor não pode ser modificado após ele ter sido criado. Métodos que aparecem para modificar uma <xref:System.String> objeto, na verdade, retornam um novo <xref:System.String> objeto que contém a modificação.  
  
 Como cadeias de caracteres são imutáveis, rotinas de manipulação de cadeia de caracteres que executam repetido adições ou exclusões para o que parece ser que uma única cadeia de caracteres pode exato uma penalidade de desempenho significativa. Por exemplo, o código a seguir usa um gerador de número aleatório para criar uma cadeia de caracteres com 1000 caracteres no intervalo 0x0001 para 0x052F. Embora o código parece usar concatenação de cadeia de caracteres para acrescentar um novo caractere na cadeia de caracteres existente denominada `str`, na verdade cria um novo <xref:System.String> objeto para cada operação de concatenação.  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 Você pode usar o <xref:System.Text.StringBuilder> classe, em vez do <xref:System.String> classe para operações que faça várias alterações no valor de uma cadeia de caracteres. Diferentemente das instâncias do <xref:System.String> classe, <xref:System.Text.StringBuilder> objeto é mutável; ao concatenar, acrescentar ou excluir subcadeias de caracteres de uma cadeia de caracteres, as operações são executadas em uma única cadeia de caracteres. Quando você tiver terminado de modificar o valor de uma <xref:System.Text.StringBuilder> do objeto, você pode chamar seu <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método convertê-la em uma cadeia de caracteres. O exemplo a seguir substitui o <xref:System.String> usado no exemplo anterior para concatenar 1000 caracteres aleatórios no intervalo como 0x0001 para 0x052F com um <xref:System.Text.StringBuilder> objeto.  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a>Ordinal x operações sensíveis à cultura  
 Os membros a <xref:System.String> classe realizar operações de (linguísticas) ordinal ou sensível à cultura em um <xref:System.String> objeto. Uma operação ordinal age no valor numérico de cada <xref:System.Char> objeto. Uma operação sensível à cultura atua no valor da <xref:System.String> objeto e maiusculas e minúsculas específicas da cultura de demora, classificação, formatação e regras de análise em consideração. Operações sensíveis à cultura são executadas no contexto de uma cultura explicitamente declarada ou a cultura atual implícita. Os dois tipos de operações podem produzir resultados muito diferentes quando elas forem executadas na mesma cadeia de caracteres.  
  
.NET também dá suporte a operações de cadeia de caracteres linguística insensível à cultura usando a cultura invariável (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), que é baseado em configurações de cultura do idioma inglês independentemente da região. Ao contrário de outras <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> configurações, as configurações da cultura invariável são garantidas para manter a consistência em um único computador, do sistema ao sistema e entre as versões do .NET. A cultura invariável pode ser visto como um tipo de caixa preta que garante a estabilidade das comparações de cadeia de caracteres e ordenação em todas as culturas.  
  
> [!IMPORTANT]
>  Se seu aplicativo toma uma decisão de segurança sobre um identificador simbólico, como um nome de arquivo ou pipe nomeado ou sobre os dados persistentes, como os dados com base em texto em um arquivo XML, a operação deve usar uma comparação ordinal em vez de uma comparação sensível à cultura. Isso é porque uma comparação sensível à cultura pode produzir resultados diferentes dependendo da cultura em vigor, enquanto que uma comparação ordinal depende exclusivamente o valor binário dos caracteres comparados.  
  
> [!IMPORTANT]
>  A maioria dos métodos que realizam operações de cadeia de caracteres incluem uma sobrecarga que tenha um parâmetro de tipo <xref:System.StringComparison>, que permite que você especifique se o método executa uma operação de ordinal ou sensível à cultura. Em geral, você deve chamar essa sobrecarga para deixar a intenção do seu método de chamada não criptografado. Para obter as práticas recomendadas e diretrizes para usar operações ordinais e sensíveis à cultura em cadeias de caracteres, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Operações para [maiusculas e minúsculas](#casing), [análise e formatação](#parsing), [comparação e classificação](#comparison), e [Testando a igualdade](#equality) pode ser qualquer um dos ordinal ou sensíveis à cultura. As seções a seguir discutem cada categoria de operação.  
  
> [!TIP]
>  Você sempre deve chamar uma sobrecarga de método que faz com que a intenção do seu método de chamada não criptografado. Por exemplo, em vez de chamar o <xref:System.String.Compare%28System.String%2CSystem.String%29> método para executar uma comparação sensível à cultura de duas cadeias de caracteres usando as convenções da cultura atual, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com um valor de <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> para o `comparisonType` argumento. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  

Você pode baixar as [Tabelas de peso de classificação](https://www.microsoft.com/en-us/download/details.aspx?id=10921), um conjunto de arquivos de texto que contêm informações sobre os pesos de caracteres usados em operações de classificação e comparação dos sistemas operacionais Windows, e a [Tabela de elemento de ordenação Unicode padrão](https://www.unicode.org/Public/UCA/latest/allkeys.txt), a tabela de peso de classificação para Linux e macOS.

<a name="casing"></a>   
### <a name="casing"></a>Maiúsculas  
 Regras de maiusculas e minúsculas determinam como alterar a capitalização de um caractere Unicode. Por exemplo, de letra minúscula em maiuscula. Muitas vezes, uma operação de maiusculas e minúsculas é executada antes de uma comparação de cadeia de caracteres. Por exemplo, uma cadeia de caracteres pode ser convertida em letras maiusculas para que ele pode ser comparado com outra cadeia de caracteres em maiusculas. Você pode converter os caracteres em uma cadeia de caracteres em minúsculas com a chamada a <xref:System.String.ToLower%2A> ou <xref:System.String.ToLowerInvariant%2A> método e você pode convertê-los em letras maiusculas, chamando o <xref:System.String.ToUpper%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Além disso, você pode usar o <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> método para converter uma cadeia de caracteres para capitalização de título.  

[!INCLUDE[platform-note](~/includes/c-and-posix-cultures.md)]  
  
 Operações de maiusculas e minúsculas podem ser baseadas nas regras da cultura atual, uma cultura específica ou a cultura invariável. Como mapeamentos de casos podem variar dependendo da cultura usada, o resultado de operações de maiusculas e minúsculas pode variar com base na cultura. As diferenças reais em maiusculas e minúsculas são de três tipos:  
  
-   Diferenças no mapeamento de maiusculas da LETRA maiuscula de LATINO I (u+0049), LATINO pequeno LETRA I (u+0069), LATINO LETRA maiuscula a I mesmo com ponto superior (U + 0130) e LATIN pequeno LETRA i sem PINGO I (U + 0131). No tr-TR (turco (Turquia)) e culturas de az-Latn-AZ (Azerbaijão, latino) e no tr, az e culturas neutras de az-Latn, o equivalente em minúsculas de LETRA maiuscula latina I é LATIM pequeno LETRA i sem PINGO I, e é o equivalente maiusculo LATINO pequeno LETRA I LETRA LATINA MAIUSCULA I COM PONTO ACIMA. Em outras culturas, incluindo a cultura invariável, LATINO pequeno LETRA I e maiuscula latina que são equivalentes maiusculos e minúsculos.  
  
     O exemplo a seguir demonstra como uma comparação de cadeia de caracteres projetada impedir o acesso de sistema de arquivos pode falhar se ele se baseia em uma comparação de maiusculas e minúsculas de cultura. (As convenções de capitalização da cultura invariável devem ter sido usadas.)  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   Diferenças nos mapeamentos de casos entre todas as outras culturas e a cultura invariável. Nesses casos, usando as regras de maiusculas e minúsculas da cultura invariável para alterar um caractere para maiusculas ou minúsculas retorna o mesmo caractere. Para todas as culturas, ele retorna um caractere diferente. Alguns dos caracteres afetados são listados na tabela a seguir.  
  
    |Caractere|Se alterado para|Retorna|  
    |---------------|-------------------|-------------|  
    |ENTRADA DE MÍCRON (U + 00B5)|Maiúsculas|LETRA MAIUSCULA GREGA MU (U +-39C)|  
    |LETRA LATINA MAIUSCULA I COM PONTO ACIMA (U + 0130)|Minúsculas|LETRA MINÚSCULA LATINA I (U+0069)|  
    |LETRA LATINA MINÚSCULA SEM PINGO EU (U + 0131)|Maiúsculas|LETRA LATINA MAIUSCULA I (U+0049)|  
    |LETRA LATINA MINÚSCULA LONGO S (U + 017F)|Maiúsculas|LETRA LATINA MAIUSCULA S (U + 0053)|  
    |LETRA LATINA MAIUSCULA 1!D COM LETRA MINÚSCULA Z COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 5)|Minúsculas|LETRA LATINA MINÚSCULA DZ COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 6)|  
    |COMBINANDO CARACTERE GREGO IOTA SUBSCRITO (U + 0345)|Maiúsculas|LETRA MAIUSCULA GREGA IOTA (U + 0399)|  
  
-   Diferenças nos mapeamentos de casos de duas letras maiusculas e minúsculas pares no intervalo de caracteres ASCII. Na maioria das culturas, um par de duas letras maiusculas e minúsculas é igual ao par equivalente duas letras maiusculo ou minúsculo. Isso não é verdadeiro para os seguintes pares de duas letras em culturas a seguir, porque em cada caso, eles são comparados com um dígrafo:  
  
    -   "lJ" e "nJ" a cultura hr-HR (Croata (Croácia)).  
  
    -   "cH" no cs-CZ (Tcheco (República Tcheca)) e culturas sk-SK (Eslovaco (Eslováquia)).  
  
    -   "aA" na cultura da-DK (dinamarquês (Dinamarca)).  
  
    -   "cS", "dZ", "dZS", "nY", "sZ", "tY" e "zS" na cultura hu-HU (húngaro (Hungria)).  
  
    -   "cH" e "lL" a cultura es-ES_tradnl (Espanhol (Espanha, tradicional)).  
  
    -   "cH", "gI", "kH", "nG" "HN", "pH", "qU", "tH" e "tR" na cultura vi-VN (vietnamita (Vietnã)).  
  
     No entanto, é incomum encontrar uma situação em que uma comparação sensível à cultura desses pares cria problemas, porque esses pares são incomuns em cadeias de caracteres fixas ou identificadores.  
  
 O exemplo a seguir ilustra algumas das diferenças nas regras de maiusculas e minúsculas entre culturas durante a conversão de cadeias de caracteres em maiusculas.  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a>Análise e formatação  
 Formatação e análise são operações inversas. Regras de formatação determinam como converter um valor, como uma data e hora ou um número, em sua representação de cadeia de caracteres, enquanto as regras de análise determinam como converter uma representação de cadeia de caracteres em um valor como uma data e hora. Tanto a formatação e regras de análise são dependentes de convenções culturais. O exemplo a seguir ilustra a ambiguidade que pode surgir ao interpretar uma cadeia de caracteres de data específicos de cultura. Sem saber as convenções da cultura usada para produzir uma cadeia de caracteres de data, não é possível saber se 01/03/2011, 1/3/2011 e 01/03/2011 representam 3 de janeiro de 2011 ou 1 de março de 2011.  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 Da mesma forma, como mostra o exemplo a seguir, uma única cadeia de caracteres pode produzir datas diferentes dependendo da cultura cujas convenções são usadas na operação de análise.  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a>Comparação da cadeia de caracteres e classificação  
 Convenções para comparar e classificar cadeias de caracteres variam de culturas. Por exemplo, a ordem de classificação pode se basear em fonética ou na representação visual de caracteres. Em idiomas do Leste Asiático, os caracteres são classificados pelo traço e radical de ideogramas. Também classificação depende das linguagens de ordem e culturas usam para o alfabeto. Por exemplo, o idioma dinamarquês tem um caractere de "Æ" que ele classifica após "Z" no alfabeto. Além disso, as comparações podem ser maiusculas e minúsculas ou maiusculas de minúsculas, e em alguns casos as regras de maiusculas e minúsculas também diferem por cultura. Comparação ordinal, por outro lado, usa os pontos de código Unicode dos caracteres individuais em uma cadeia de caracteres ao comparar e classificar cadeias de caracteres.  
  
 Regras de classificação determinam que a ordem alfabética de caracteres Unicode e cadeias de caracteres como dois comparam entre si. Por exemplo, o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método compara duas cadeias de caracteres com base no <xref:System.StringComparison> parâmetro. Se o valor do parâmetro for <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, o método executa uma comparação linguística que usa as convenções da cultura atual; se o valor do parâmetro for <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, o método executa uma comparação ordinal. Consequentemente, como mostra o exemplo seguinte, se a cultura atual é dos EUA Inglês, a primeira chamada para o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método (usando a comparação sensível à cultura) considera "a" menor que "A", mas considera a segunda chamada para o mesmo método (usando a comparação ordinal) "a" maior que "A".  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 .NET dá suporte a palavra, cadeia de caracteres e regras de classificação ordinal:  
  
-   Uma classificação de palavra executa uma comparação de cadeias de caracteres sensível a cultura, em que determinados caracteres não alfanuméricos Unicode podem ter pesos especiais atribuídos a eles. Por exemplo, o hífen (-) pode ter um peso muito pequeno atribuído a ele, de modo que "coop" e "co-op" apareçam próximos uns dos outros em uma lista classificada. Para obter uma lista da <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação do word, consulte a [operações de cadeia de caracteres por categoria](#ByCategory) seção.  
  
-   Uma classificação de cadeia de caracteres também executa uma comparação sensível à cultura. Ele é semelhante a uma classificação de palavra, exceto que há não há casos especiais, e todos os símbolos não alfanuméricos vêm antes de todos os caracteres Unicode de alfanumérico. Duas cadeias de caracteres podem ser comparadas usando regras de classificação de cadeia de caracteres chamando o <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> sobrecargas de método que tem um `options` parâmetro que é fornecido um valor de <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>. Observe que isso é o único método que o .NET fornece para comparar duas cadeias de caracteres usando regras de classificação de cadeia de caracteres.  
  
-   Uma classificação ordinal compara as cadeias de caracteres com base no valor numérico de cada objeto <xref:System.Char> na cadeia de caracteres. Uma comparação ordinal é automaticamente diferencia maiusculas de minúsculas porque as versões maiusculas e minúsculas de um caractere têm pontos de código diferentes. No entanto, se o caso não é importante, você pode especificar uma comparação ordinal que diferencia maiusculas e minúsculas. Isso é equivalente a converter a cadeia de caracteres em maiusculas usando a cultura invariável e, em seguida, executar uma comparação ordinal no resultado. Para obter uma lista de <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação ordinal, consulte a [operações de cadeia de caracteres por categoria](#ByCategory) seção.  
  
 Uma comparação sensível à cultura é qualquer comparação que usa explicitamente ou implicitamente um <xref:System.Globalization.CultureInfo> objeto, incluindo a cultura invariável especificado pelo <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propriedade. A cultura implícita é a cultura atual, que é especificada pela <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedades. Há uma variação considerável na ordem de classificação de caracteres alfabéticos (isto é, os caracteres para o qual o <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> propriedade retorna `true`) entre culturas. Você pode especificar uma comparação sensível à cultura que usa as convenções de uma cultura específica, fornecendo uma <xref:System.Globalization.CultureInfo> de objeto para um método de comparação de cadeia de caracteres como <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>. Você pode especificar uma comparação sensível à cultura que usa as convenções da cultura atual, fornecendo <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, ou qualquer membro do <xref:System.Globalization.CompareOptions> enumeração diferente de <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> ou <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> com um número apropriado sobrecarga da <xref:System.String.Compare%2A> método. Uma comparação sensível à cultura é geralmente adequada para classificação, enquanto uma comparação ordinal não é. Uma comparação ordinal é geralmente adequada para determinar se duas cadeias de caracteres são iguais (isto é, para determinar a identidade), enquanto uma comparação sensível à cultura não é.  
  
 O exemplo a seguir ilustra a diferença entre a comparação ordinal e de cultura. O exemplo será avaliado três cadeias de caracteres, "Apple", "Æble" e "AEble", usando as convenções das culturas da-DK e en-US e comparação ordinal (cada um deles é a cultura padrão no momento o <xref:System.String.Compare%2A> método é chamado). Como o idioma dinamarquês trata o caractere "Æ" como uma letra individual e classifica-o após "Z" no alfabeto, a cadeia de caracteres "Æble" é maior que "Apple". No entanto, "Æble" não é considerado equivalente a "AEble", "Æble" também é maior que "AEble". A cultura en-US não inclui a letra "Æ", mas trata como equivalente a "AE", que explica por que "Æble" é menor que "Apple" mas igual a "AEble". Comparação ordinal, por outro lado, considera "Apple" para ser menor que "Æble" e "Æble" seja maior que "AEble".  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 Use as seguintes diretrizes gerais para escolher um método de comparação de classificação ou a cadeia de caracteres apropriado:  
  
-   Se você quiser cadeias de caracteres a ser ordenadas com base na cultura do usuário, você deve pedi-las com base nas convenções da cultura atual. Se a cultura do usuário for alterado, a ordem de cadeias de caracteres classificadas também serão alterados adequadamente. Por exemplo, um aplicativo de dicionário de sinônimos deve sempre ser classificada palavras com base na cultura do usuário.  
  
-   Se você quiser cadeias de caracteres a ser ordenadas com base nas convenções de uma cultura específica, ordene-as, fornecendo um <xref:System.Globalization.CultureInfo> objeto que representa aquela cultura para um método de comparação. Por exemplo, em um aplicativo projetado para ensinar aos alunos um idioma específico, você deseja cadeias de caracteres a ser ordenadas com base nas convenções de uma das culturas que participa como palestrante nesse idioma.  
  
-   Se você deseja que a ordem de cadeias de caracteres permanecem inalterados entre culturas, você deve ordená-los com base nas convenções da cultura invariável ou usar uma comparação ordinal. Por exemplo, você usaria uma classificação ordinal para organizar os nomes de arquivos, processos, mutexes, ou pipes nomeados.  
  
-   Para obter uma comparação que envolve uma decisão de segurança (como se um nome de usuário é válido), você deve sempre executar um ordinal testar a igualdade chamando uma sobrecarga da <xref:System.String.Equals%2A> método.  
  
> [!NOTE]
>  A classificação sensíveis à cultura e maiusculas e minúsculas usadas na comparação de cadeia de caracteres de regras dependem da versão do .NET. No .NET Framework 4.5 e versões posteriores em execução no [!INCLUDE[win8](~/includes/win8-md.md)] sistema operacional, classificação, maiusculas e minúsculas, normalização e informações de caractere Unicode em conformidade com o padrão Unicode 6.0. Em outros sistemas operacionais Windows, ele é compatível com o padrão Unicode 5.0. No .NET Core, ele depende da versão do padrão Unicode com suporte pelo sistema operacional subjacente. 
  
 Para obter mais informações sobre palavra, cadeia de caracteres e regras de classificação ordinal, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tópico. Para obter recomendações adicionais sobre quando usar cada regra, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Normalmente, você não chamar cadeia de caracteres de métodos de comparação como <xref:System.String.Compare%2A> diretamente para determinar a ordem de classificação de cadeias de caracteres. Em vez disso, os métodos de comparação são chamados por métodos de classificação, como <xref:System.Array.Sort%2A?displayProperty=nameWithType> ou <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>. O exemplo a seguir executa quatro operações de classificação diferentes (classificação de palavra usando a cultura atual, classificação de palavra usando a cultura invariável, classificação ordinal e classificação de cadeia de caracteres usando a cultura invariável) sem chamar explicitamente um método de comparação de cadeia de caracteres Embora eles especificam o tipo de comparação a ser usado. Observe que cada tipo de classificação produz uma classificação exclusivo das cadeias de caracteres em sua matriz.  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  Internamente, o .NET usa chaves de classificação para dar suporte à comparação de cadeia de caracteres culturalmente confidenciais. Cada caractere em uma cadeia de caracteres é atribuída diversas categorias de pesos de classificação, incluindo alfabético, maiusculas e minúsculas e diacríticos. Uma chave de classificação, representado pelo <xref:System.Globalization.SortKey> de classe, fornece um repositório desses pesos para uma determinada cadeia de caracteres. Se seu aplicativo executa um grande número de pesquisa ou operações no mesmo conjunto de cadeias de caracteres de classificação, você pode melhorar o desempenho gerando e armazenando chaves de classificação para todas as cadeias de caracteres que ele usa. Quando uma operação de classificação ou comparação é necessária, você use as chaves de classificação em vez de cadeias de caracteres. Para mais informações, consulte a classe <xref:System.Globalization.SortKey>.  
  
 Se você não especificar uma convenção de comparação de cadeia de caracteres, métodos de classificação como <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> executar uma classificação sensível à cultura, diferencia maiusculas de minúsculas em cadeias de caracteres. O exemplo a seguir ilustra como mudar a cultura atual afeta a ordem das cadeias de caracteres classificadas em uma matriz. Ele cria uma matriz de três cadeias de caracteres. Primeiro, ele define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade para en-US e chama o <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> método. A ordem de classificação resultante é com base em convenções de classificação para a cultura do inglês (Estados Unidos). Em seguida, o exemplo define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade para da-DK e chama o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método novamente. Observe como a ordem de classificação resultante difere dos resultados en-US porque ele usa as convenções de classificação para dinamarquês (Dinamarca).  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  Se seu objetivo principal na comparação de cadeias de caracteres é determinar se eles forem iguais, você deve chamar o <xref:System.String.Equals%2A?displayProperty=nameWithType> método. Normalmente, você deve usar <xref:System.String.Equals%2A> para realizar uma comparação ordinal. O <xref:System.String.Compare%2A?displayProperty=nameWithType> método destina-se principalmente para classificar cadeias de caracteres.  
  
 Métodos de pesquisa de cadeia de caracteres, como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar comparações de cadeia de caracteres sensíveis à cultura ou ordinal. O exemplo a seguir ilustra as diferenças entre as comparações ordinais e sensível à cultura usando o <xref:System.String.IndexOf%2A> método. Uma pesquisa sensível à cultura em que a cultura atual é inglês (Estados Unidos) considera a subcadeia de caracteres "oe" para corresponder a Ligadura "œ". Como um hífen (U + 00AD) é um caractere de largura zero, a pesquisa trata o hífen como equivalente a <xref:System.String.Empty> e encontra uma correspondência no início da cadeia de caracteres. Uma pesquisa ordinal, por outro lado, não encontra uma correspondência em ambos os casos.  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a>Pesquisar cadeias de caracteres  
 Métodos de pesquisa de cadeia de caracteres, como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar sensíveis à cultura ou comparações de cadeia de caracteres ordinais para determinar se um caractere ou uma subcadeia de caracteres for encontrada em uma cadeia de caracteres especificada.  
  
 Os métodos de pesquisa na <xref:System.String> classe procurar por um caractere individual, como o <xref:System.String.IndexOf%2A> método ou um de um conjunto de caracteres, como o <xref:System.String.IndexOfAny%2A> método, realizam uma pesquisa ordinal. Para executar uma pesquisa sensível à cultura por um caractere, você deve chamar um <xref:System.Globalization.CompareInfo> método, como <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> ou <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>. Observe que os resultados da pesquisa por um caractere usando a comparação ordinal e sensível à cultura podem ser muito diferentes. Por exemplo, uma pesquisa por um caractere pré-composto do Unicode, como a Ligadura "Æ" (U + 00 C 6) pode corresponder a qualquer ocorrência de seus componentes na sequência correta, como "AE" (U + 041U + 0045), dependendo da cultura. O exemplo a seguir ilustra a diferença entre o <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> e <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> métodos ao procurar por um caractere individual. A Ligadura "æ" (U + 00E6) é encontrada na cadeia de caracteres "aérea" ao usar as convenções da cultura en-US, mas não ao usar as convenções da cultura da-DK ou ao executar uma comparação ordinal.  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 Por outro lado, <xref:System.String> métodos de pesquisa para uma cadeia de caracteres em vez de um caractere de realiza uma pesquisa sensível à cultura se opções de pesquisa não forem especificadas explicitamente por um parâmetro de tipo de classe <xref:System.StringComparison>. A única exceção é <xref:System.String.Contains%2A>, que executa uma pesquisa ordinal.  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a>Testando igualdade  
 Use o <xref:System.String.Compare%2A?displayProperty=nameWithType> método para determinar a relação entre duas cadeias de caracteres na ordem de classificação. Normalmente, isso é uma operação sensível à cultura. Por outro lado, chame o <xref:System.String.Equals%2A?displayProperty=nameWithType> método para testar a igualdade. Como o teste de igualdade normalmente compara a entrada do usuário com alguma cadeia de caracteres conhecida, como um nome de usuário válido, uma senha ou um caminho de sistema de arquivos, normalmente é uma operação ordinal.  
  
> [!WARNING]
>  É possível testar a igualdade chamando o <xref:System.String.Compare%2A?displayProperty=nameWithType> método e determinar se o valor de retorno é zero. No entanto, essa prática não é recomendada. Para determinar se duas cadeias de caracteres são iguais, você deve chamar uma das sobrecargas do <xref:System.String.Equals%2A?displayProperty=nameWithType> método. A sobrecarga preferencial para chamar é a instância <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método ou estático <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, porque ambos os métodos incluem um <xref:System.StringComparison?displayProperty=nameWithType> parâmetro que especifica explicitamente o tipo de comparação.  
  
 O exemplo a seguir ilustra o perigo de realizar uma comparação sensível à cultura para igualdade quando um ordinal de um deve ser usado em vez disso. Nesse caso, a intenção do código é proibir o acesso do sistema de arquivos de URLs que começam com "FILE://" ou "file://" ao executar uma comparação não diferencia maiusculas de início de uma URL com a cadeia de caracteres "FILE://". No entanto, se uma comparação sensível à cultura é executada usando a cultura de turco (Turquia) em uma URL que começa com "file://", a comparação de igualdade falhará, porque o turco equivalente em maiusculas "i" minúsculo é "İ" em vez de "I". Como resultado, o acesso do sistema de arquivos inadvertidamente é permitido. Por outro lado, se uma comparação ordinal é executada, a comparação de igualdade for bem-sucedida, e acesso de sistema de arquivos será negado.  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a>Normalização  
 Alguns caracteres Unicode têm várias representações. Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 Várias representações para um único caractere complicam a pesquisa, classificação, correspondência e outras operações de cadeia de caracteres.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária de um caractere Unicode para qualquer uma das suas representações binárias equivalentes. Normalização pode usar vários algoritmos, chamados de formulários de normalização que seguem regras diferentes. .NET dá suporte a formulários de normalização Unicode C, D, KC e KD. Cadeias de caracteres foram normalizadas para o mesmo formulário de normalização, eles podem ser comparados usando a comparação ordinal.  
  
 Uma comparação ordinal é uma comparação binária do valor escalar Unicode correspondente <xref:System.Char> objetos em cada cadeia de caracteres. O <xref:System.String> classe inclui uma série de métodos que podem realizar uma comparação ordinal, incluindo o seguinte:  
  
-   Nenhuma sobrecarga da <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, e <xref:System.String.LastIndexOf%2A> métodos que inclui um <xref:System.StringComparison> parâmetro. O método executa uma comparação ordinal, se você fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase> para esse parâmetro.  
  
-   As sobrecargas de <xref:System.String.CompareOrdinal%2A> método.  
  
-   Métodos que utilizam a comparação ordinal por padrão, como <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, e <xref:System.String.Split%2A>.  
  
-   Métodos de pesquisa para um <xref:System.Char> valor ou para os elementos em um <xref:System.Char> matriz em uma instância de cadeia de caracteres. Esses métodos incluem <xref:System.String.IndexOf%28System.Char%29> e <xref:System.String.Split%28System.Char%5B%5D%29>.  
  
 Você pode determinar se uma cadeia de caracteres é normalizada para o formulário de normalização C chamando o <xref:System.String.IsNormalized?displayProperty=nameWithType> método, ou você pode chamar o <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para determinar se uma cadeia de caracteres é normalizada para um formulário de normalização especificado. Você também pode chamar o <xref:System.String.Normalize?displayProperty=nameWithType> método para converter uma cadeia de caracteres em formato de normalização C, ou você pode chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para converter uma cadeia de caracteres em um formato de normalização especificado. Para obter informações passo a passo sobre a normalização e comparando cadeias de caracteres, consulte a <xref:System.String.Normalize> e <xref:System.String.Normalize%28System.Text.NormalizationForm%29> métodos.  
  
 O exemplo simples a seguir ilustra a normalização de cadeia de caracteres. Ele define a letra "ố" de três maneiras diferentes em três cadeias de caracteres diferentes e usa uma comparação ordinal de igualdade para determinar o que cada cadeia de caracteres é diferente de outras duas cadeias de caracteres. Ele converte cada cadeia de caracteres para os formulários de normalização com suporte e executa novamente uma comparação ordinal de cada cadeia de caracteres em um formulário de normalização especificada. Em cada caso, o segundo teste de igualdade mostra que as cadeias de caracteres são iguais.  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 Para obter mais informações sobre a normalização e formulários de normalização, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, bem como [Unicode Standard Annex #15: Formulários de normalização Unicode](https://unicode.org/reports/tr15/) e o [perguntas Frequentes de normalização](https://www.unicode.org/faq/normalization.html) no site do site unicode.org.  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a>Operações da cadeia de caracteres por categoria  
 O <xref:System.String> classe fornece membros para comparar cadeias de caracteres, cadeias de caracteres para igualdade, localizando caracteres ou subcadeias de caracteres em uma cadeia de caracteres, modificando uma cadeia de caracteres, extraindo subcadeias de caracteres de uma cadeia de caracteres, combinar cadeias de caracteres, formatação de valores, uma cadeia de caracteres, a cópia de teste e Normalizando uma cadeia de caracteres.  
  
### <a name="comparing-strings"></a>Comparando cadeias de caracteres  
 Você pode comparar cadeias de caracteres para determinar sua posição relativa na ordem de classificação usando os seguintes <xref:System.String> métodos:  
  
-   <xref:System.String.Compare%2A> Retorna um inteiro que indica o relacionamento entre uma cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação.  
  
-   <xref:System.String.CompareOrdinal%2A> Retorna um inteiro que indica o relacionamento entre uma cadeia de caracteres para uma segunda cadeia de caracteres com base em uma comparação dos seus pontos de código.  
  
-   <xref:System.String.CompareTo%2A> Retorna um inteiro que indica o relacionamento entre a instância atual da cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação. O <xref:System.String.CompareTo%28System.String%29> método fornece a <xref:System.IComparable> e <xref:System.IComparable%601> implementações para o <xref:System.String> classe.  
  
### <a name="testing-strings-for-equality"></a>Testando igualdade das cadeias de caracteres  
 Você chama o <xref:System.String.Equals%2A> método para determinar se duas cadeias de caracteres são iguais. A instância <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> e estático <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> sobrecargas permitem que você especifique se a comparação é ordinal ou sensível à cultura, e se o caso é considerado ou ignorado. A maioria dos testes de igualdade são ordinais e comparações de igualdade que determinam o acesso a um recurso do sistema (como um objeto do sistema de arquivos) devem ser sempre ordinal.  
  
### <a name="finding-characters-in-a-string"></a>Localizando caracteres em uma cadeia de caracteres  
 O <xref:System.String> classe inclui dois tipos de métodos de pesquisa:  
  
-   Os métodos que retornam um <xref:System.Boolean> valor para indicar se uma subcadeia de caracteres específica está presente em uma instância de cadeia de caracteres. Isso inclui o <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, e <xref:System.String.StartsWith%2A> métodos.  
  
-   Métodos que indicam a posição inicial de uma subcadeia de caracteres em uma instância de cadeia de caracteres. Isso inclui o <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, e <xref:System.String.LastIndexOfAny%2A> métodos.  
  
> [!WARNING]
>  Se você quiser pesquisar uma cadeia de caracteres para um determinado padrão em vez de uma subcadeia de caracteres específica, você deve usar expressões regulares. Para obter mais informações, consulte [expressões regulares do .NET](~/docs/standard/base-types/regular-expressions.md).  
  
### <a name="modifying-a-string"></a>Modificando uma cadeia de caracteres  
 O <xref:System.String> classe inclui os seguintes métodos que aparecem para modificar o valor de uma cadeia de caracteres:  
  
-   <xref:System.String.Insert%2A> Insere uma cadeia de caracteres atual <xref:System.String> instância.  
  
-   <xref:System.String.PadLeft%2A> Insere uma ou mais ocorrências de um caractere especificado no início de uma cadeia de caracteres.  
  
-   <xref:System.String.PadRight%2A> Insere uma ou mais ocorrências de um caractere especificado no final de uma cadeia de caracteres.  
  
-   <xref:System.String.Remove%2A> Exclui uma subcadeia de caracteres de atual <xref:System.String> instância.  
  
-   <xref:System.String.Replace%2A> substitui uma subcadeia de caracteres por outra subcadeia de caracteres atual <xref:System.String> instância.  
  
-   <xref:System.String.ToLower%2A> e <xref:System.String.ToLowerInvariant%2A> converter todos os caracteres em uma cadeia de caracteres em minúsculas.  
  
-   <xref:System.String.ToUpper%2A> e <xref:System.String.ToUpperInvariant%2A> converter todos os caracteres em uma cadeia de caracteres em maiusculas.  
  
-   <xref:System.String.Trim%2A> Remove todas as ocorrências de um caractere de início e no final de uma cadeia de caracteres.  
  
-   <xref:System.String.TrimEnd%2A> Remove todas as ocorrências de um caractere de final de uma cadeia de caracteres.  
  
-   <xref:System.String.TrimStart%2A> Remove todas as ocorrências de um caractere do início de uma cadeia de caracteres.  
  
> [!IMPORTANT]
>  Todos os métodos de modificação de cadeia de caracteres retornam um novo <xref:System.String> objeto. Eles não modificam o valor da instância atual.  
  
### <a name="extracting-substrings-from-a-string"></a>Extraindo subcadeias de caracteres de uma cadeia de caracteres  
 O <xref:System.String.Split%2A?displayProperty=nameWithType> método separa uma única cadeia de caracteres em várias cadeias de caracteres. Sobrecargas do método permitem que você especifique vários delimitadores, para determinar o número máximo de subcadeias de caracteres que o método extrai e para determinar se as cadeias de caracteres vazias (que ocorrem quando os delimitadores sejam adjacentes) são incluídas entre as cadeias de caracteres retornadas.  
  
### <a name="combining-strings"></a>Combinando cadeias de caracteres  
 O seguinte <xref:System.String> métodos podem ser usados para concatenação de cadeia de caracteres:  
  
-   <xref:System.String.Concat%2A> combina as subcadeias de caracteres de um ou mais em uma única cadeia de caracteres.  
  
-   <xref:System.String.Join%2A> Concatena uma ou mais subcadeias de caracteres em um único elemento e adiciona um separador entre cada subcadeia de caracteres.  
  
### <a name="formatting-values"></a>Formatando valores  
 O <xref:System.String.Format%2A?displayProperty=nameWithType> método usa o recurso de formatação composta para substituir um ou mais espaços reservados para uma cadeia de caracteres com a representação de cadeia de caracteres de um objeto ou valor. O <xref:System.String.Format%2A> método geralmente é usado para fazer o seguinte:  
  
-   Para inserir a representação de cadeia de caracteres de um valor numérico em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de um valor de data e hora em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de um valor de enumeração em uma cadeia de caracteres.  
  
-   Para inserir a representação de cadeia de caracteres de algum objeto que dá suporte a <xref:System.IFormattable> interface em uma cadeia de caracteres.  
  
-   Para justificar à direita ou justificar à esquerda de uma subcadeia de caracteres em um campo dentro de uma cadeia de caracteres maior.  
  
 Para obter informações detalhadas sobre a formatação de operações e exemplos, consulte o <xref:System.String.Format%2A> Resumo da sobrecarga.  
  
### <a name="copying-a-string"></a>Copiando uma cadeia de caracteres  
 Você pode chamar o seguinte <xref:System.String> métodos para fazer uma cópia de uma cadeia de caracteres:  
  
-   <xref:System.String.Clone%2A> Retorna uma referência a um existente <xref:System.String> objeto.  
  
-   <xref:System.String.Copy%2A> cria uma cópia de uma cadeia de caracteres existente.  
  
-   <xref:System.String.CopyTo%2A> copia uma parte de uma cadeia de caracteres em uma matriz de caracteres.  
  
### <a name="normalizing-a-string"></a>Normalizando uma cadeia de caracteres  
 Em Unicode, um único caractere pode ter vários pontos de código. Normalização converte esses caracteres equivalentes na mesma representação binária. O <xref:System.String.Normalize%2A?displayProperty=nameWithType> método executa a normalização e a <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> método determina se uma cadeia de caracteres é normalizada.  
  
 Para obter mais informações e um exemplo, consulte o [normalização](#Normalization) seção neste tópico.  

 ]]></format>
    </remarks>
    <related type="ExternalDocumentation" href="https://www.microsoft.com/en-us/download/details.aspx?id=10921">Classificação de sistemas operacionais de tabelas de peso para Windows</related>
    <related type="ExternalDocumentation" href="https://www.unicode.org/Public/UCA/latest/allkeys.txt">Padrão Unicode agrupamento Elemeent tabela, para Linux e macOS</related>
    <threadsafe>Este tipo é thread-safe.</threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
    <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Práticas recomendadas para o uso de cadeias de caracteres no .NET Framework</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nesta seção:  
  
 [Sintaxe de construtor sobrecarregada](#Syntax)   
 [Parâmetros](#Params)   
 [Exceções](#Exceptions)   
 [Qual método chamar?](#Tasks)   
 [Criando cadeias de caracteres](#Creating_Strings)   
 [Manipulação de cadeias de caracteres repetitivas](#Repetitive)   
 Exemplos de cadeias de caracteres ao instanciar:   
 [Usar a atribuição de cadeia de caracteres](#Ctor1_Example)  
 [Usando uma matriz de caracteres](#Ctor2_Example)  
 [Usando uma parte de uma matriz de caracteres e repetindo um único caractere](#Ctor3_Example)  
 [Usando um ponteiro para uma matriz de caracteres](#Ctor4_Example)  
 [Usando um ponteiro e um intervalo de uma matriz](#Ctor5_Example)  
 [Usando um ponteiro para uma matriz de bytes com sinal](#Ctor6_Example)  
[Informações de versão](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a>Sintaxe de construtor sobrecarregada  
 Construtores de cadeia de caracteres se enquadram em duas categorias: aqueles sem parâmetros de ponteiro e aqueles com parâmetros de ponteiro. Os construtores que usam ponteiros não são compatíveis com CLS. Além disso, o Visual Basic não suporta o uso de ponteiros e c# requer código que usa ponteiros para ser executado em um contexto inseguro. Para obter mais informações, consulte [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).  
  
 Para obter orientação adicional sobre como escolher uma sobrecarga, consulte [qual método devo chamar?](#Tasks)  
  
 `String(Char[] value)`  
 Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode. Este construtor copia caracteres Unicode ([exemplo](#Ctor2_Example)).  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode, uma posição do caractere inicial dentro dessa matriz e um comprimento ([exemplo](#Ctor3_Example)).  
  
 `String(Char c, Int32 count)`  
 Inicializa a nova instância para o valor indicada por um caractere Unicode especificado repetido um número de vezes especificado ([exemplo](#Ctor3_Example)).  
  
 `String(char* value)`  
 **(Não compatível com CLS)**  Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode terminada por um caractere nulo (U + 0000 ou '\0'). ([exemplo](#Ctor4_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 **(Não compatível com CLS)**  Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode, uma posição do caractere inicial dentro dessa matriz e um comprimento. O construtor copia os caracteres Unicode de `value` começando no índice `startIndex` e termina no índice `startIndex`  +  `length` - 1 ([exemplo](#Ctor5_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value)`  
 **(Não compatível com CLS)**  Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits. A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). O construtor processa caracteres de `value` começando no local especificado pelo ponteiro até que um caractere nulo (0x00) seja atingido ([exemplo](#Ctor6_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 **(Não compatível com CLS)**  Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial dentro dessa matriz e um comprimento.  A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>). O construtor processa caracteres do valor começando `startIndex` e termina em `startIndex`  +  `length` - 1 ([exemplo](#Ctor6_Example)).  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 **(Não compatível com CLS)**  Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz, um comprimento de e um <xref:System.Text.Encoding> objeto.  
  
 Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parâmetros  
 Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que não incluem um parâmetro de ponteiro. Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>[]|Uma matriz de caracteres Unicode.|  
|`c`|<xref:System.Char>|Um caractere Unicode.|  
|`startIndex`|<xref:System.Int32>|A posição inicial no `value` do primeiro caractere na nova cadeia de caracteres.<br /><br /> Valor padrão: 0|  
|`length`|<xref:System.Int32>|O número de caracteres em `value` para incluir na nova cadeia de caracteres.<br /><br /> Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`count`|<xref:System.Int32>|O número de vezes que o caractere `c` é repetido na nova cadeia de caracteres. Se `count` for zero, o valor do novo objeto é <xref:System.String.Empty?displayProperty=nameWithType>.|  
  
 Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que incluem um parâmetro de ponteiro. Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> - ou -<br /><br /> <xref:System.SByte>\*|Um ponteiro para uma matriz terminada em nulo de caracteres Unicode ou uma matriz de inteiros com sinal de 8 bits. Se `value` está `null` ou uma matriz vazia, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.|  
|`startIndex`|<xref:System.Int32>|O índice do elemento da matriz que define o primeiro caractere na nova cadeia de caracteres.<br /><br /> Valor padrão: 0|  
|`length`|<xref:System.Int32>|O número de elementos da matriz para usar para criar a nova cadeia de caracteres. Se o comprimento for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>.<br /><br /> Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType>|  
|`enc`|<xref:System.Text.Encoding>|Um objeto que especifica como o `value` matriz é codificada.<br /><br /> Valor padrão: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, ou a página de código ANSI atual do sistema|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Exceções  
 Aqui está uma lista de exceções geradas por construtores que não incluem os parâmetros de ponteiro.  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|`value` é `null`.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|`startIndex`,`length`, ou `count` é menor que zero.<br /><br /> - ou -<br /><br /> A soma de `startIndex` e `length` é maior que o número de elementos em `value`.<br /><br /> - ou -<br /><br /> `count` é menor que zero.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 Aqui está uma lista de exceções geradas por construtores que incluem parâmetros de ponteiro.  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|`value` Especifica uma matriz que contém um caractere Unicode inválido.<br /><br /> - ou -<br /><br /> `value` ou `value`  +  `startIndex` Especifica um endereço que é menor que 64K.<br /><br /> - ou -<br /><br /> Uma nova <xref:System.String> instância não pôde ser inicializada a partir de `value` porque a matriz de bytes `value` não usa a codificação de página de código padrão.|Todos os construtores com ponteiros.|  
|<xref:System.ArgumentNullException>|`value` é nulo.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|O processo atual não tem acesso de leitura a todos os caracteres endereçados.<br /><br /> - ou -<br /><br /> `startIndex` ou `length` é menor que zero, `value` + `startIndex` causa um estouro do ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.<br /><br /> - ou -<br /><br /> O comprimento da nova cadeia de caracteres é muito grande para alocar.|Todos os construtores com ponteiros.|  
|<xref:System.AccessViolationException>|`value`, ou `value`  +  `startIndex`  +  `length` -1, especifica um endereço inválido.|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Qual método devo chamar?  
  
|Para|Chamada ou uso|  
|--------|-----------------|  
|Crie uma cadeia de caracteres.|Atribuição de uma cadeia de caracteres literal ou uma cadeia de caracteres existente ([exemplo](#Ctor1_Example))|  
|Crie uma cadeia de caracteres de uma matriz de caractere inteiro.|<xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))|  
|Crie uma cadeia de caracteres de uma parte de uma matriz de caracteres.|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))|  
|Crie uma cadeia de caracteres que se repete o mesmo caractere várias vezes.|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))|  
|Crie uma cadeia de caracteres de um ponteiro para uma Unicode ou uma matriz de caractere largo.|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|Crie uma cadeia de caracteres de uma parte de uma Unicode ou uma matriz de caractere largo usando seu ponteiro.|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|Criar uma cadeia de caracteres de um C++ `char` matriz.|<xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> - ou -<br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|Crie uma cadeia de caracteres ASCII.|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a>Criando cadeias de caracteres  
 Usado com mais frequência técnica para criar cadeias de caracteres de forma programática é uma atribuição simples, conforme ilustrado na [Este exemplo](#Ctor1_Example). O <xref:System.String> classe também inclui quatro tipos de sobrecargas de construtor que permitem que você crie cadeias de caracteres entre os seguintes valores:  
  
-   De uma matriz de caracteres (uma matriz de caracteres codificada em UTF-16). Você pode criar um novo <xref:System.String> objeto dos caracteres em toda a matriz ou uma parte dele. O <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor copia todos os caracteres na matriz para a nova cadeia de caracteres. O <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor copia os caracteres de índice `startIndex` índice `startIndex`  +  `length` -1 para a nova cadeia de caracteres. Se `length` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
     Se seu código instancia repetidamente cadeias de caracteres que têm o mesmo valor, você pode melhorar o desempenho do aplicativo por meio de um meio alternativo de criação de cadeias de caracteres. Para obter mais informações, consulte [tratando cadeias de caracteres repetitivas](#Repetitive).  
  
-   De um único caractere que é zero duplicado, uma, ou mais vezes, usando o <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> construtor. Se `count` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   De um ponteiro para uma matriz de caracteres terminada em nulo, usando o <xref:System.String.%23ctor%28System.Char%2A%29> ou <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor. A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres. O construtor copia uma sequência de caracteres Unicode começando a partir o ponteiro especificado ou o ponteiro especificado adição `startIndex` e continuando até o final da matriz ou para `length` caracteres. Se `value` for um ponteiro nulo ou `length` for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>. Se a operação de cópia continua até o final da matriz e a matriz não é terminada em nulo, o comportamento do construtor é dependente do sistema. Uma condição desse tipo pode causar uma violação de acesso.  
  
     Se a matriz contiver quaisquer caracteres nulos inseridos (U + 0000 ou '\0') e o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos. O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos que inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> método. Como o endereço é o início da matriz e todos os elementos na matriz devem ser adicionadas à cadeia de caracteres, o construtor cria uma instância de uma cadeia de caracteres com dez caracteres, incluindo dois nulos incorporados. Por outro lado, se a mesma matriz é passada para o <xref:System.String.%23ctor%28System.Char%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclua o primeiro caractere nulo.  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     A matriz deve conter caracteres Unicode. No C++, isso significa que a matriz de caracteres deve ser definido como o gerenciado <xref:System.Char>tipo [] ou não gerenciado`wchar_t`tipo [].  
  
     Se o <xref:System.String.%23ctor%28System.Char%2A%29> sobrecarga é chamada e a matriz não é terminada em nulo, ou se o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada e `startIndex`  +  `length`-1 inclui um intervalo que ela fora da memória alocada para a sequência de caracteres, o comportamento do construtor é dependente do sistema e pode ocorrer uma violação de acesso. Além disso, no processador Intel Itanium, chamadas para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor pode lançar um <xref:System.DataMisalignedException> exceção. Se isso ocorrer, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> em vez disso.  
  
-   De um ponteiro para uma matriz de bytes com sinal. A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres. A sequência de bytes pode ser interpretada por meio da página de código padrão de codificação ou uma codificação pode ser especificada na chamada do construtor. Se o construtor tenta criar uma instância de uma cadeia de caracteres de uma matriz de inteira que não é terminada em nulo, ou se o intervalo da matriz de `value`  +  `startIndex` à `value`  +  `startIndex`  +  `length` -1 está fora da memória alocada para a matriz, o comportamento desse construtor é dependente do sistema e pode ocorrer uma violação de acesso.  
  
     Os três construtores que incluem uma matriz de bytes com sinal como um parâmetro são projetados principalmente para converter um C++ `char` de matriz para uma cadeia de caracteres, conforme mostrado neste exemplo:  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     Se a matriz contiver quaisquer caracteres nulos ('\0') ou bytes cujo valor é 0 e o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos. O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos que inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> método. Como o endereço é o início da matriz e todos os elementos na matriz devem ser adicionadas à cadeia de caracteres, o construtor cria uma instância de uma cadeia de caracteres com dez caracteres, incluindo dois nulos incorporados. Por outro lado, se a mesma matriz é passada para o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclua o primeiro caractere nulo.  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     Porque o <xref:System.String.%23ctor%28System.SByte%2A%29> e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> construtores interpretam `value` usando a página de código ANSI padrão, chamar esses construtores com matrizes de byte idênticos pode criar cadeias de caracteres que têm valores diferentes em sistemas diferentes.  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a>Identificando cadeias de caracteres repetitivas  
 Os aplicativos que analisam ou decodificar fluxos de texto geralmente usam o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor ou o <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para converter as sequências de caracteres em uma cadeia de caracteres. Repetidamente, criando novas cadeias de caracteres com o mesmo valor em vez de criar e reutilizar uma cadeia de caracteres desperdiça memória. Se você provavelmente criar o mesmo valor de cadeia de caracteres repetidamente chamando o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de adiantamento de construtor, mesmo se você não souber em quais esses valores de cadeia de caracteres idênticos podem ser, você pode usar uma tabela de pesquisa em vez disso.  
  
 Por exemplo, suponha que você ler e analisar um fluxo de caracteres de um arquivo que contém as marcas XML e atributos. Quando você analisa o fluxo, você encontrar repetidamente determinados tokens (ou seja, sequências de caracteres que têm um significado simbólico). Tokens equivalentes às cadeias de caracteres "0", "1", "true" e "false" têm probabilidade de ocorrer com frequência em um fluxo XML.  
  
 Em vez de converter cada token em uma nova cadeia de caracteres, você pode criar um <xref:System.Xml.NameTable?displayProperty=nameWithType> objeto para armazenar cadeias de caracteres que ocorrem com frequência. O <xref:System.Xml.NameTable> objeto melhora o desempenho, porque ele recupera cadeias de caracteres armazenadas sem alocação de memória temporária. Quando você encontrar um token, use o <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para recuperar o token da tabela. Se o token existir, o método retorna a cadeia de caracteres correspondente. Se o token não existe, use o <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para inserir o token na tabela e obter a cadeia de caracteres correspondente.  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a>Exemplo 1: usando atribuição da cadeia de caracteres  
 O exemplo a seguir cria uma nova cadeia de caracteres, atribuindo a ela um literal de cadeia de caracteres. Ele cria uma segunda cadeia de caracteres, atribuindo o valor da primeira cadeia de caracteres a ele. Essas são as duas formas mais comuns para instanciar um novo <xref:System.String> objeto.  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a>Exemplo 2: usando uma matriz de caracteres  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma matriz de caracteres.  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a>Exemplo 3: usando uma parte de uma matriz de caracteres e repetindo um único caractere  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma parte de uma matriz de caracteres e como criar um novo <xref:System.String> objeto que contém várias ocorrências de um único caractere.  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a>Exemplo 4: usando um ponteiro para uma matriz de caracteres  
 O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto de um ponteiro para uma matriz de caracteres. O exemplo c# deve ser compilado usando o `/unsafe` comutador de compilador.  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a>Exemplo 5: criando uma instância de uma cadeia de caracteres a partir de um ponteiro e um intervalo de uma matriz  
 O exemplo a seguir examina os elementos de uma matriz de caracteres por um período ou um ponto de exclamação. Se um for encontrado, ele cria uma instância de uma cadeia de caracteres dos caracteres na matriz que precedem o símbolo de pontuação. Caso contrário, ele cria uma instância de uma cadeia de caracteres com todo o conteúdo da matriz. O exemplo c# deve ser compilado usando o `/unsafe` comutador de compilador.  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a>Exemplo 6: criando uma instância de uma cadeia de caracteres a partir de um ponteiro para uma matriz de bytes assinados  
 O exemplo a seguir demonstra como você pode criar uma instância das <xref:System.String> classe com o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor.  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a>Informações de versão  
 .NET Framework  
 Todas as sobrecargas são suportadas em: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
  
 .NET Framework Client Profile  
 Todas as sobrecargas são suportadas em: 4, 3.5 SP1  
  
 Biblioteca de Classes Portátil  
 Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte  
  
 .NET para aplicativos da Windows Store  
 Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte em: Windows 8  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres Unicode terminada em nulo.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">O processo atual não tem acesso de leitura a todos os caracteres endereçados.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> especifica uma matriz que contém um caractere Unicode inválido ou <paramref name="value" /> especifica um endereço menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres Unicode.</param>
        <summary>Inicializa uma nova instância de <see cref="T:System.String" /> classe para o valor indicado por uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros de 8 bits com sinal com terminação nula. Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro para uma matriz de inteiros de 8 bits com sinal.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado em ANSI.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">O comprimento da nova cadeia de caracteres a ser inicializada, que é determinado pelo caractere de terminação nula <paramref name="value" />, é muito grande para ser alocado.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" /> especifica um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">Um caractere Unicode.</param>
        <param name="count">O número de vezes que <paramref name="c" /> ocorre.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um caractere Unicode repetido um número de vezes especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de caracteres Unicode.</param>
        <param name="startIndex">A posição inicial dentro de <paramref name="value" />.</param>
        <param name="length">O número de caracteres dentro de <paramref name="value" /> a ser usado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um tamanho.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero, <paramref name="value" /> + <paramref name="startIndex" /> causa um estouro do ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> especifica uma matriz que contém um caractere Unicode inválido ou <paramref name="value" /> + <paramref name="startIndex" /> especifica um endereço menor que 64000.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Uma matriz de caracteres Unicode.</param>
        <param name="startIndex">A posição inicial dentro de <paramref name="value" />.</param>
        <param name="length">O número de caracteres dentro de <paramref name="value" /> a ser usado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um comprimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
- ou - 
A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o número de elementos em <paramref name="value" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros com sinal de 8 bits. Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</param>
        <param name="startIndex">A posição inicial dentro de <paramref name="value" />.</param>
        <param name="length">O número de caracteres dentro de <paramref name="value" /> a ser usado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz e um comprimento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
- ou - 
O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é grande demais para a plataforma atual; ou seja, o cálculo do endereço estourou.  
  
- ou - 
O comprimento da nova cadeia de caracteres a ser inicializada é muito grande para alocar.</exception>
        <exception cref="T:System.ArgumentException">O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é menor que 64K.  
  
- ou - 
Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado em ANSI.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="enc" Type="System.Text.Encoding" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Um ponteiro para uma matriz de inteiros com sinal de 8 bits.</param>
        <param name="startIndex">A posição inicial dentro de <paramref name="value" />.</param>
        <param name="length">O número de caracteres dentro de <paramref name="value" /> a ser usado.</param>
        <param name="enc">Um objeto que especifica como a matriz é referenciada por <paramref name="value" /> é codificada. Se <paramref name="enc" /> for <see langword="null" />, a codificação ANSI será assumida.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz, um comprimento e um objeto <see cref="T:System.Text.Encoding" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
- ou - 
O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é grande demais para a plataforma atual; ou seja, o cálculo do endereço estourou.  
  
- ou - 
O comprimento da nova cadeia de caracteres a ser inicializada é muito grande para alocar.</exception>
        <exception cref="T:System.ArgumentException">O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é menor que 64K.  
  
- ou - 
Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado conforme especificado por <paramref name="enc" />.</exception>
        <exception cref="T:System.AccessViolationException"><paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[Index index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(valuetype System.Index)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Index) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[Index] { char get(Index index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Index) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Uma posição na cadeia de caracteres atual.</param>
        <summary>Obtém o objeto <see cref="T:System.Char" /> em uma posição especificada no atual objeto <see cref="T:System.String" />.</summary>
        <value>O objeto na posição <paramref name="index" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `index` parâmetro é baseado em zero.  
  
 Essa propriedade retorna o <xref:System.Char> objeto na posição especificada pelo `index` parâmetro. No entanto, um caractere Unicode pode ser representado por mais de um <xref:System.Char>. Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> caracteres de classe para trabalhar com o Unicode em vez de <xref:System.Char> objetos. Para obter mais informações, consulte a seção "Char caracteres objetos e Unicode" o <xref:System.String> visão geral da classe.  
  
 No c#, o <xref:System.String.Chars%2A> propriedade é um indexador. No Visual Basic, é a propriedade padrão do <xref:System.String> classe. Cada <xref:System.Char> objeto na cadeia de caracteres pode ser acessado por meio de código como o seguinte.  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar esse indexador em uma rotina para validar uma cadeia de caracteres.  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> é maior ou igual ao tamanho desse objeto ou menor que zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public string this[Range range] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Chars(valuetype System.Range)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Range)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(range As Range) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ default[Range] { System::String ^ get(Range range); };" />
      <MemberSignature Language="F#" Value="member this.Chars(Range) : string" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma referência a essa instância de <see cref="T:System.String" />.</summary>
        <returns>Esta instância de <see cref="T:System.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado não é uma cópia independente dessa instância; ele é simplesmente outra exibição dos mesmos dados. Use o <xref:System.String.Copy%2A> ou <xref:System.String.CopyTo%2A> método para criar um separado <xref:System.String> objeto com o mesmo valor que esta instância.  
  
 Porque o <xref:System.String.Clone%2A> método simplesmente retorna a instância de cadeia de caracteres existente, há poucos motivos para chamá-lo diretamente.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Todas as sobrecargas do <xref:System.String.Compare%2A> método retornar um inteiro com sinal de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
|Valor|Condição|  
|-----------|---------------|  
|Menor que zero|A primeira subcadeia de caracteres precede a segunda subcadeia de caracteres na ordem de classificação.|  
|Zero|As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou `length` é zero.|  
|Maior que zero|A primeira subcadeia de caracteres segue a segunda subcadeia de caracteres na ordem de classificação.|  
  
> [!WARNING]
>  Sempre que possível, você deve chamar uma sobrecarga da <xref:System.String.Compare%2A> método inclui um <xref:System.StringComparison> parâmetro. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/b9f0bf53-e2de-4116-8ce9-d4f91a1df4f7">Práticas recomendadas para o uso de cadeias de caracteres no .NET Framework</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.Compare%28System.String%2CSystem.String%29> método para comparar os três conjuntos de cadeias de caracteres.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 No exemplo a seguir, o `ReverseStringComparer` classe demonstra como você pode avaliar duas cadeias de caracteres com o <xref:System.String.Compare%2A> método.  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação sensível à cultura de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  
  
[!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)] 
Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o `comparisonType` parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra que o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> método é equivalente a usar <xref:System.String.ToUpper%2A> ou <xref:System.String.ToLower%2A> ao comparar cadeias de caracteres.  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação sensível à cultura, não diferencia maiusculas de "animal" com "Ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  
  
[!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)] 
Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras a serem usadas na comparação.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> está na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso dos termos de comparação ou usar o word (sensível à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 O exemplo a seguir compara três versões da letra "I". Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <exception cref="T:System.NotSupportedException"><see cref="T:System.StringComparison" /> não é suportado.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Um objeto que fornece as informações de comparação específicas da cultura.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, bem como usando informações culturais específicas para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como a cultura pode afetar uma comparação. Em tcheco - cultura da República Tcheca, "ch" é um único caractere que é maior que "d". No entanto, em inglês - Estados Unidos cultura, "ch" consiste em dois caracteres e "c" é menor que "d".  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação não diferencia maiusculas de "animal" com "Ani-sites perigosos" (usando um hífen ou U + 00AD) usando a invariável cultura indica que duas cadeias de caracteres são equivalentes.  
  
[!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)] 
Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <param name="culture">A cultura que fornece as informações de comparação específicas da cultura.</param>
        <param name="options">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas cadeias de caracteres na ordem de classificação.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica o relacionamento léxico entre <paramref name="strA" /> e <paramref name="strB" />, como é mostrado na tabela a seguir 
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> ocorre na mesma posição que <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética dos caracteres individuais. Por exemplo, uma determinada cultura poderia especificar que determinadas combinações de caracteres ser tratado como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que preceda ou segui-lo.  
  
> [!CAUTION]
>  O <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método é projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar se um valor retornado de zero). Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 A comparação pode ser especificada por ainda mais a `options` parâmetro, que consiste em um ou mais membros do <xref:System.Globalization.CompareOptions> enumeração. No entanto, pois a finalidade desse método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores não têm nenhum efeito.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maiores do que uma referência nula e duas referências nulas forem comparados como iguais uns aos outros.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres restantes é considerada maior.  
  
   
  
## Examples  
 O exemplo a seguir compara duas cadeias de caracteres de três maneiras diferentes: usando comparação Linguística para a cultura en-US; usando a comparação diferencia maiusculas de minúsculas Linguística para a cultura en-US; e usando uma comparação ordinal. Ele ilustra como os três métodos de comparação produzem três resultados diferentes.  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. O <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para></block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <summary>Compara subcadeias de dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA` e, na `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
- ou - 
<paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <summary>Compara as subcadeias de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA`e, na `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!WARNING]
>  Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método. Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 O nome do caminho precisa ser comparados de uma maneira invariável. O código correto para fazer isso é o seguinte.  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 O exemplo a seguir executa duas comparações de duas subcadeias de caracteres que diferem apenas no caso. A primeira comparação diferencia maiusculas e minúsculas e a segunda comparação considera caso.  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
- ou - 
<paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="5" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras a serem usadas na comparação.</param>
        <summary>Compara as subcadeias de caracteres de dois especificado <see cref="T:System.String" /> objetos usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou o parâmetro <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA` e, na `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero, não posicionar um. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso dos termos de comparação ou usar o word (sensível à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres.  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
- ou - 
O <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição da subcadeia de caracteres dentro de <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição da subcadeia de caracteres dentro de <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">Um objeto que fornece as informações de comparação específicas da cultura.</param>
        <summary>Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas e usando informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</summary>
        <returns>Um número inteiro que indica a relação lexical entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA`e, na `strB` em `indexB`. Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero, não posicionar um. O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um. O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais. Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.  
  
 A comparação é realizada usando-se regras de classificação de palavras. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Um ou ambos os comparandos podem ser `null`. Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
 Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura. Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 Compare o nome do caminho para "file" que usa uma comparação ordinal. O código correto para fazer isso é o seguinte:  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 O exemplo a seguir compara duas subcadeias de caracteres usando diferentes culturas e ignorando o caso de subcadeias de caracteres. A escolha da cultura afeta como a letra "I" é comparado.  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
- ou - 
<paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexA" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="strB" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="indexB" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="length" Type="System.Int32" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">A posição inicial da subcadeia de caracteres dentro de <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">A posição inicial da subcadeia de caracteres dentro de <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <param name="culture">Um objeto que fornece as informações de comparação específicas da cultura.</param>
        <param name="options">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</param>
        <summary>Compara duas subcadeias de caracteres <see cref="T:System.String" /> especificadas usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas subcadeias de caracteres na ordem de classificação.</summary>
        <returns>Um número inteiro com relacionamento léxico entre as duas subcadeias de caracteres, como é mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação ou <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As subcadeias de caracteres a ser comparado Iniciar em `strA` na posição `indexA` e, na `strB` na posição `indexB`. O comprimento da primeira subcadeia de caracteres é o comprimento da `strA` menos `indexA`. O comprimento da segunda subcadeia de caracteres é o comprimento da `strB` menos `indexB`.  
  
 O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`. Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética dos caracteres individuais. Por exemplo, uma determinada cultura poderia especificar que determinadas combinações de caracteres ser tratado como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que preceda ou segui-lo.  
  
> [!CAUTION]
>  O <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método é projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas subcadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar se um valor retornado de zero). Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Uma ou ambas `strA` e `strB` pode ser `null`. Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maiores do que uma referência nula e duas referências nulas forem comparados como iguais uns aos outros.  
  
 A comparação pode ser especificada por ainda mais a `options` parâmetro, que consiste em um ou mais membros do <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração. No entanto, pois a finalidade desse método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores não têm nenhum efeito.  
  
 A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas. No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres restantes é considerada maior. O valor de retorno é o resultado da última comparação realizada.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método para comparar os sobrenomes de duas pessoas. Ele, em seguida, as lista em ordem alfabética.  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="indexA" /> é maior que <paramref name="strA" /><see langword=".Length" />.  
  
- ou - 
 <paramref name="indexB" /> é maior que <paramref name="strB" /><see langword=".Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.  
  
- ou - 
<paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" /> e <paramref name="length" /> é maior que zero.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para></block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara dois objetos <see cref="T:System.String" /> avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada cadeia de caracteres.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser comparada.</param>
        <param name="strB">A segunda cadeia de caracteres a ser comparada.</param>
        <summary>Compara dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada cadeia de caracteres.</summary>
        <returns>Um número inteiro que indica a relação lexical entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description><paramref name="strA" /> é menor que <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="strA" /> e <paramref name="strB" /> são iguais.  
  
 </description></item><item><term> Maior que zero 
 </term><description><paramref name="strA" /> é maior que <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para executar uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal, chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`. Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais. Se houver apenas um dos valores `null`, o método considera o valor não nulo seja maior.  
  
   
  
## Examples  
 O exemplo a seguir executa e comparação ordinal de duas cadeias de caracteres que diferem apenas no caso.  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">A primeira cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexA">O índice inicial da subcadeia de caracteres em <paramref name="strA" />.</param>
        <param name="strB">A segunda cadeia de caracteres a ser usada na comparação.</param>
        <param name="indexB">O índice inicial da subcadeia de caracteres em <paramref name="strB" />.</param>
        <param name="length">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</param>
        <summary>Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada subcadeia de caracteres.</summary>
        <returns>Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> é menor que a subcadeia de caracteres em <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> As subcadeias de caracteres são iguais ou <paramref name="length" /> é zero.  
  
 </description></item><item><term> Maior que zero 
 </term><description> A subcadeia de caracteres em <paramref name="strA" /> é maior que a subcadeia de caracteres em <paramref name="strB" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.  
  
 O número de caracteres em comparação é menor do que o comprimento da `strA` menos `indexA`, o comprimento de `strB` menos `indexB`, e `length`.  
  
 Esse método executa uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>. Para executar uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal, chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.  
  
 Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`. Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais. Se houver apenas um dos valores `null`, o método considera o valor não nulo seja maior.  
  
   
  
## Examples  
 O exemplo a seguir demonstra que <xref:System.String.CompareOrdinal%2A> e <xref:System.String.Compare%2A> usar diferentes ordens de classificação.  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="strA" /> não é <see langword="null" /> e <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="strB" /> não é <see langword="null" /> e <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.  
  
- ou - 
 <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Compara esta instância com um objeto especificado ou com <see cref="T:System.String" /> e retorna um inteiro que indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação que o objeto especificado ou <see cref="T:System.String" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ambas as sobrecargas do <xref:System.String.CompareTo%2A> método executar comparação sensível à cultura e maiusculas de minúsculas. Você não pode usar esse método para executar comparações insensíveis à cultura ou ordinal. Para maior clareza do código, é recomendável que você evite a <xref:System.String.CompareTo%2A> método e chamar o <xref:System.String.Compare%2A> método em vez disso.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Um objeto avaliado como um <see cref="T:System.String" />.</param>
        <summary>Compara essa instância com um <see cref="T:System.Object" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme o <see cref="T:System.Object" /> especificado.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="value" />.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> Esta instância precede <paramref name="value" />.  
  
 </description></item><item><term> Zero 
 </term><description> Esta instância tem a mesma posição na ordem de classificação que <paramref name="value" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> Esta instância segue <paramref name="value" />.  
  
- ou - 
 <paramref name="value" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` deve ser um <xref:System.String> objeto.  
  
> [!CAUTION]
>  O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes. Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
 Para obter mais informações sobre o comportamento desse método, consulte a seção comentários do <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método com um <xref:System.Object>. Porque ele tenta comparar um <xref:System.String> da instância para uma `TestClass` do objeto, o método lança um <xref:System.ArgumentException>.  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> não é um <see cref="T:System.String" />.</exception>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.Object)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  
  
[!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)] 
Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Compara essa instância com um objeto <see cref="T:System.String" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme a cadeia de caracteres especificada.</summary>
        <returns>Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="strB" />.  
  
 <list type="table"><listheader><term> Valor 
 </term><description> Condição 
 </description></listheader><item><term> Menor que zero 
 </term><description> Esta instância precede <paramref name="strB" />.  
  
 </description></item><item><term> Zero 
 </term><description> Esta instância tem a mesma posição na ordem de classificação que <paramref name="strB" />.  
  
 </description></item><item><term> Maior que zero 
 </term><description> Esta instância segue <paramref name="strB" />.  
  
- ou - 
 <paramref name="strB" /> é <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.  
  
> [!CAUTION]
>  O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética. Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes. Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.  
  
 Para obter mais informações sobre o comportamento desse método, consulte a seção comentários do <xref:System.String.Compare%28System.String%2CSystem.String%29> método.  
  
 Esse método implementa o <xref:System.IComparable%601?displayProperty=nameWithType> da interface e executa um pouco melhor do que o <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> método, porque ele não precisa determinar se o `strB` argumento é um tipo de valor mutável que deve ser boxed e tem que converter seu parâmetro de um <xref:System.Object> para um <xref:System.String>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método a ser comparado a instância atual da cadeia de caracteres com outra cadeia de caracteres.  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 O exemplo a seguir demonstra as versões genéricas e não genéricas do método CompareTo para vários tipos de valor e referência.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Entre conjuntos de caracteres estão caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, uma comparação de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  
  
[!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)] 
Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para></block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena uma ou mais instâncias de <see cref="T:System.String" /> ou as representações <see cref="T:System.String" /> dos valores de uma ou mais instâncias de <see cref="T:System.Object" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="values">Um objeto de coleção que implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> e cujo argumento de tipo genérico é <see cref="T:System.String" />.</param>
        <summary>Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />.</summary>
        <returns>As cadeias de caracteres concatenadas em <paramref name="values" /> ou <see cref="F:System.String.Empty" /> se <paramref name="values" /> for um <see langword="IEnumerable(Of String)" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores. Para especificar um delimitador entre cada membro do `values`, chame o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 Uma <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer elemento nulo em `values`.  
  
 Se `values` está vazio `IEnumerable(Of String)`, o método retorna <xref:System.String.Empty?displayProperty=nameWithType>. Se `values` está `null`, o método lança um <xref:System.ArgumentNullException> exceção.  
  
 <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres. Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta). O exemplo a seguir passa um `List(Of String)` objeto que contém as letras maiusculas ou minúsculas do alfabeto para uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M"). O `IEnumerable(Of String)` coleção retornada pela <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O objeto a ser representado ou <see langword="null" />.</param>
        <summary>Cria a representação de cadeia de caracteres de um objeto especificado.</summary>
        <returns>A representação da cadeia de caracteres do valor de <paramref name="arg0" /> ou <see cref="F:System.String.Empty" /> se <paramref name="arg0" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Concat%28System.Object%29> método representa `arg0` como uma cadeia de caracteres chamando seu sem parâmetros `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objeto que contém os elementos a serem concatenados.</param>
        <summary>Concatena as representações de cadeia de caracteres dos elementos em uma matriz <see cref="T:System.Object" /> especificada.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores dos elementos em <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto na `args` chamando o Next sem parâmetros `ToString` método desse objeto; ele não adicione qualquer delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.Object> matriz.  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <block subset="none" type="usage"><para>Esse método não é chamado pelo código C++. O compilador C++ resolve chamadas para <see cref="Overload:System.String.Concat" /> que tem quatro ou mais parâmetros de objeto como uma chamada para <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para></block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">Uma matriz de instâncias de cadeia de caracteres.</param>
        <summary>Concatena os elementos de uma matriz <see cref="T:System.String" /> especificada.</summary>
        <returns>Os elementos concatenados de <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores.  
  
 Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.String> matriz.  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de dois objetos especificados.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `arg0` e `arg1` chamando o Next sem parâmetros `ToString` método de `arg0` e `arg1`; não adiciona qualquer delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.  
  
 Se um dos argumentos é uma referência de matriz, o método concatena uma cadeia de caracteres que representa essa matriz, em vez de seus membros (por exemplo, "System.String[]").  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <summary>Concatena duas instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" /> e <paramref name="str1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0` e `str1`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir concatena, o meio e o último nome de uma pessoa.  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <param name="arg2">O terceiro objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de três objetos especificados.</summary>
        <returns>As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `arg0`, `arg1`, e `arg2` chamando sem parâmetro `ToString` método de cada objeto; não adiciona qualquer delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <param name="str2">A terceira cadeia de caracteres a ser concatenada.</param>
        <summary>Concatena três instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" />, <paramref name="str1" /> e <paramref name="str2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0`, `str1`, e `str2`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Concat%2A> método para concatenar três cadeias de caracteres e exibe o resultado.  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg3" Type="System.Object" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="arg0">O primeiro objeto a ser concatenado.</param>
        <param name="arg1">O segundo objeto a ser concatenado.</param>
        <param name="arg2">O terceiro objeto a ser concatenado.</param>
        <param name="arg3">O quarto objeto a ser concatenado.</param>
        <summary>Concatena as representações de cadeia de caracteres de quatro objetos especificados e quaisquer objetos especificados em uma lista de parâmetros opcionais de tamanho variável.</summary>
        <returns>A representação de cadeia de caracteres concatenada de cada valor na lista de parâmetros.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Esta API não compatível com CLS. A alternativa compatível com CLS é <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>. Os compiladores c# e Visual Basic resolver automaticamente uma chamada para esse método como uma chamada para <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 O método concatena a cada objeto na lista de parâmetros ao chamar seu sem parâmetros `ToString` método; ele não adicione qualquer delimitadores.  
  
 <xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.  
  
> [!NOTE]
>  O último parâmetro do <xref:System.String.Concat%2A> método é uma lista delimitada por vírgulas opcional de um ou mais objetos adicionais a serem concatenados.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o uso do <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para concatenar uma lista de parâmetros variáveis. Nesse caso, o método é chamado com nove parâmetros.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Esse método é marcado com o <see langword="vararg" /> palavra-chave, o que significa que ele oferece suporte a um número variável de parâmetros. O método pode ser chamado de Visual C++, mas ele não pode ser chamado de código c# ou Visual Basic. Os compiladores c# e Visual Basic resolver chamadas a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> como chamadas para <see cref="M:System.String.Concat(System.Object[])" />.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(valuetype System.ReadOnlySpan`1&lt;char&gt; str0, valuetype System.ReadOnlySpan`1&lt;char&gt; str1, valuetype System.ReadOnlySpan`1&lt;char&gt; str2, valuetype System.ReadOnlySpan`1&lt;char&gt; str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As ReadOnlySpan(Of Char), str1 As ReadOnlySpan(Of Char), str2 As ReadOnlySpan(Of Char), str3 As ReadOnlySpan(Of Char)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(ReadOnlySpan&lt;char&gt; str0, ReadOnlySpan&lt;char&gt; str1, ReadOnlySpan&lt;char&gt; str2, ReadOnlySpan&lt;char&gt; str3);" />
      <MemberSignature Language="F#" Value="static member Concat : ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; * ReadOnlySpan&lt;char&gt; -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str1" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str2" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="str3" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="3" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="str0">To be added.</param>
        <param name="str1">To be added.</param>
        <param name="str2">To be added.</param>
        <param name="str3">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">A primeira sequência de caracteres a ser concatenada.</param>
        <param name="str1">A segunda sequência de caracteres a ser concatenada.</param>
        <param name="str2">A terceira cadeia de caracteres a ser concatenada.</param>
        <param name="str3">A quarta cadeia de caracteres a ser concatenada.</param>
        <summary>Concatena quatro instâncias especificadas de <see cref="T:System.String" />.</summary>
        <returns>A concatenação de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> e <paramref name="str3" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena `str0`, `str1`, `str2`, e `str3`; ele não adicione qualquer delimitadores.  
  
> [!NOTE]
>  Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)  
>   
>  , para concatenar cadeias de caracteres.  
  
 Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de quatro – letra de palavras e armazena suas letras individuais em uma matriz de cadeia de caracteres para embaralhá-los. Em seguida, ele chama o <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> método remontar as palavras embaralhadas.  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos membros de <paramref name="values" />.</typeparam>
        <param name="values">Um objeto de coleção que implementa a interface do <see cref="T:System.Collections.Generic.IEnumerable`1" />.</param>
        <summary>Concatena os membros de uma implementação <see cref="T:System.Collections.Generic.IEnumerable`1" />.</summary>
        <returns>Os membros concatenados em <paramref name="values" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores.  
  
 Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.  
  
 <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um <xref:System.Collections.Generic.IEnumerable%601> coleção sem primeiro converter os elementos nas cadeias de caracteres. Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta), como mostra o exemplo. A representação de cadeia de caracteres de cada objeto na <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada por meio da chamada do objeto `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir define um muito simples `Animal` classe que contém o nome do animal e a ordem ao qual ele pertence. Em seguida, ele define uma <xref:System.Collections.Generic.List%601> objeto para conter um número de `Animal` objetos. O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método de extensão é chamado para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Roedor". O resultado é passado para o <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método e exibidos no console.  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Retorna um valor que indica se uma subcadeia especificada ocorre nesta cadeia de caracteres.</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> ocorrer nesta cadeia de caracteres, ou se <paramref name="value" /> for a cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura). A pesquisa começa na posição do primeiro caractere da cadeia de caracteres e continua até a última posição de caractere.  
  
 Para determinar se uma cadeia de caracteres contém uma subcadeia de caracteres especificada, usando algo diferente de uma comparação ordinal (como comparação sensível à cultura, ou a comparação diferencia maiusculas de minúsculas ordinal), você pode criar um método personalizado. O exemplo a seguir ilustra um exemplo dessa abordagem. Ele define uma <xref:System.String> método de extensão que inclui um <xref:System.StringComparison> parâmetro e indica se uma cadeia de caracteres contém uma subcadeia de caracteres ao usar o formulário especificado de comparação de cadeia de caracteres.  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 O exemplo a seguir, em seguida, chama o `Contains` método de extensão para determinar se uma subcadeia de caracteres é encontrada em uma cadeia de caracteres ao usar comparação ordinal e diferencia maiusculas de minúsculas comparação ordinal.  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 Se você estiver interessado na posição da subcadeia de caracteres `value` na instância atual, você pode chamar o <xref:System.String.IndexOf%2A> método para obter a posição inicial da primeira ocorrência, ou você pode chamar o <xref:System.String.LastIndexOf%2A> posição do método a ser obtido a partir do seu última ocorrência. O exemplo inclui uma chamada para o <xref:System.String.IndexOf%28System.String%29> método se uma subcadeia de caracteres for encontrada em uma instância de cadeia de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir determina se a cadeia de caracteres "raposa" é uma subcadeia de caracteres de aspas uma familiar. Se "raposa" for encontrado na cadeia de caracteres, ele também exibe sua posição inicial.  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres a ser copiada.</param>
        <summary>Cria uma nova instância de <see cref="T:System.String" /> com o mesmo valor que um <see cref="T:System.String" /> especificado.</summary>
        <returns>Uma nova cadeia de caracteres com o mesmo valor que <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Copy%2A> método retorna um <xref:System.String> objeto que tem o mesmo valor de cadeia de caracteres original, mas representa uma referência de objeto diferente. Ele é diferente de uma operação de atribuição, que atribui uma referência de cadeia de caracteres existente a uma variável de objeto adicionais. O exemplo ilustra a diferença.  
  
   
  
## Examples  
 O exemplo a seguir cria dois objetos de cadeia de caracteres com valores diferentes. Quando ele chama o <xref:System.String.Copy%2A> método para atribuir o primeiro valor para a segunda cadeia de caracteres, a saída indica que as cadeias de caracteres representam as referências de objeto diferentes, embora seus valores agora são iguais. Por outro lado, quando a primeira cadeia de caracteres é atribuída à segunda cadeia de caracteres, duas cadeias de caracteres tiverem valores idênticos, porque eles representam a mesma referência de objeto.  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">O índice do primeiro caractere nessa instância a ser copiada.</param>
        <param name="destination">Uma matriz de caracteres Unicode para a qual caracteres nessa instância são copiados.</param>
        <param name="destinationIndex">O índice em <paramref name="destination" /> no qual a operação de cópia é iniciada.</param>
        <param name="count">O número de caracteres nesta instância a serem copiados para <paramref name="destination" />.</param>
        <summary>Copia um número especificado de caracteres de uma posição especificada nesta instância para uma posição especificada em uma matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia `count` caracteres da `sourceIndex` posição dessa instância para o `destinationIndex` posição do `destination` matriz de caracteres. Esse método não redimensiona o `destination` matriz de caracteres; ele deve ter um número suficiente de elementos para acomodar os caracteres copiados ou o método lança um <xref:System.ArgumentOutOfRangeException>.  
  
 `sourceIndex` e `destinationIndex` são baseados em zero.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.CopyTo%2A> método.  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> é negativo 
- ou - 
 <paramref name="sourceIndex" /> não identifica uma posição na instância atual.  
  
- ou - 
 <paramref name="destinationIndex" /> não identifica um índice válido na matriz <paramref name="destination" />.  
  
- ou - 
 <paramref name="count" /> é maior que o comprimento da subcadeia de <paramref name="sourceIndex" /> até final desta instância 
- ou - 
 <paramref name="count" /> é maior que o comprimento da submatriz de <paramref name="destinationIndex" /> até final da matriz <paramref name="destination" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Representa a cadeia de caracteres vazia. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor desse campo é a cadeia de caracteres de comprimento zero, "".  
  
 No código do aplicativo, esse campo é mais comumente usado em atribuições para inicializar uma variável de cadeia de caracteres em uma cadeia de caracteres vazia. Para testar se o valor de uma cadeia de caracteres é `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, use o <xref:System.String.IsNullOrEmpty%2A> método.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o fim desta instância de cadeia de caracteres corresponde a uma cadeia de caracteres especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <summary>Determina se o final desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</summary>
        <returns><see langword="true" /> se <paramref name="value" /> corresponder ao final dessa instância; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método compara `value` à subcadeia de caracteres no final desta instância que é o mesmo tamanho que `value`e retorna uma indicação se eles forem iguais. Para que seja igual, `value` deve ser uma referência a essa mesma instância ou corresponde ao final dessa instância.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir indica se cada cadeia de caracteres em uma matriz termina com um ponto (".").  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 O exemplo a seguir define uma `StripEndTags` método que usa o <xref:System.String.EndsWith%28System.String%29> método para remover as marcas de fim HTML do final de uma linha. Observe que o `StripEndTags` método é chamado recursivamente para garantir que as várias marcas de fim HTML no final da linha são removidas.  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para determinar se uma cadeia de caracteres termina com uma subcadeia de caracteres específica usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que determina como essa cadeia de caracteres e <paramref name="value" /> são comparados.</param>
        <summary>Determina se o fim dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado ao uso da opção de comparação especificada.</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.EndsWith%2A> método compara o `value` parâmetro à subcadeia de caracteres no final dessa cadeia de caracteres e retorna um valor que indica se eles são iguais. Para que seja igual, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve corresponder ao final dessa cadeia de caracteres. O tipo de comparação executada pelo <xref:System.String.EndsWith%2A> método depende do valor da `comparisonType` parâmetro.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres termina com uma subcadeia de caracteres específica. Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">As informações culturais que determinam como essa instância e <paramref name="value" /> são comparadas. Se <paramref name="culture" /> for <see langword="null" />, a cultura atual será usada.</param>
        <summary>Determina se o final dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método compara os `value` parâmetro para a subcadeia de caracteres no final dessa cadeia de caracteres que é o mesmo tamanho que `value`e retorna um valor que indica se eles são iguais. Para que seja igual, `value` deve ser uma referência a essa mesma instância ou corresponde ao final dessa cadeia de caracteres.  
  
 Esse método executa uma comparação de (sensível à cultura) do word usando a cultura e maiusculas e minúsculas especificada.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres ocorre no final da outra cadeia de caracteres. O <xref:System.String.EndsWith%2A> método é chamado várias vezes com diferenciação de maiusculas e minúsculas e diferentes culturas que influenciam os resultados da pesquisa.  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="EnumerateRunes">
      <MemberSignature Language="C#" Value="public System.Text.StringRuneEnumerator EnumerateRunes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Text.StringRuneEnumerator EnumerateRunes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EnumerateRunes" />
      <MemberSignature Language="VB.NET" Value="Public Function EnumerateRunes () As StringRuneEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Text::StringRuneEnumerator EnumerateRunes();" />
      <MemberSignature Language="F#" Value="member this.EnumerateRunes : unit -&gt; System.Text.StringRuneEnumerator" Usage="string.EnumerateRunes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.StringRuneEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se dois objetos <see cref="T:System.String" /> têm o mesmo valor.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Determina se essa instância e um objeto especificado, que também deve ser um objeto <see cref="T:System.String" />, têm o mesmo valor.</summary>
        <returns><see langword="true" /> se <paramref name="obj" /> for um <see cref="T:System.String" /> e seu valor for o mesmo que o dessa instância; caso contrário, <see langword="false" />.  Se <paramref name="obj" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com esta instância.</param>
        <summary>Determina se essa instância e outro objeto <see cref="T:System.String" /> especificado têm o mesmo valor.</summary>
        <returns><see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual ao valor dessa instância; caso contrário, <see langword="false" />. Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método. Ele compara a palavra concatenada título "File" com uma palavra equivalente, seu equivalente em minúsculas, seu equivalente em maiusculas e uma palavra que contém LATINO pequeno LETRA i sem PINGO I (U + 0131) em vez de LATINO pequeno LETRA I (u+0069). Porque o <xref:System.String.Equals%28System.String%29> método executa uma comparação ordinal, somente a comparação com uma palavra idêntica retorna `true`.  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor.</summary>
        <returns><see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />. Se tanto <paramref name="a" /> quanto <paramref name="b" /> forem <see langword="null" />, o método retornará <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada com esta instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica como as cadeias de caracteres serão comparadas.</param>
        <summary>Determina se essa cadeia de caracteres e um objeto <see cref="T:System.String" /> especificado têm o mesmo valor. Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</summary>
        <returns><see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual a essa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso de duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de cadeia de caracteres que consiste em letras maiusculas "I", "i" em letras minúsculas e "ı" sem pingo. Em seguida, ele chama o <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método para compará-los por meio de cada possível <xref:System.StringComparison> valor de enumeração.  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 O exemplo a seguir compara os quatro conjuntos de palavras por meio de cada membro do <xref:System.StringComparison> enumeração.  As comparações usam as convenções das culturas Sami (Suécia superior) e inglês (Estados Unidos). Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalente na cultura en-US, mas não na cultura Sami (Norte Suécia).  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="b" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a comparação.</param>
        <summary>Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor. Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</summary>
        <returns><see langword="true" /> se o valor do parâmetro <paramref name="a" /> for igual ao valor do parâmetro <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso de duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.  
  
   
  
## Examples  
 O exemplo a seguir compara os quatro conjuntos de palavras por meio de cada membro do <xref:System.StringComparison> enumeração.  As comparações usam as convenções das culturas Sami (Suécia superior) e inglês (Estados Unidos). Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalente na cultura en-US, mas não na cultura Sami (Norte Suécia).  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte o valor de objetos em cadeias de caracteres com base nos formatos especificados e os insere em outra cadeia de caracteres.  
  
Se você não estiver familiarizado com o método `String.Format`, consulte a seção [Introdução ao método String.Format](#Starting) para obter uma visão geral rápida.  
  
Consulte a seção [Comentários](#remarks-top) para ver a documentação geral do método `String.Format`.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 Nesta seção:  
  
 [Comece com o método String. Format](#Starting)   
 [Qual método chamar?](#FTaskList)   
 [O método Format resumido](#Format_Brief)   
 [O item de formato](#FormatItem)   
 [Como os argumentos são formatados](#HowFormatted)   
 [Itens de formato que têm o mesmo índice](#SameIndex)   
 [Formatação e cultura](#Format_Culture)   
 [Operações de formatação personalizadas](#Format_Custom)   
 [String.Format Q & A](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a>Comece com o método String. Format  
 Use <xref:System.String.Format%2A?displayProperty=nameWithType> se você precisar inserir o valor de um objeto, variável ou expressão em outra cadeia de caracteres. Por exemplo, você pode inserir o valor de uma <xref:System.Decimal> valor em uma cadeia de caracteres para exibi-lo ao usuário como uma única cadeia de caracteres:  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 E você pode controlar esse valor de formatação:  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 Além de formatação, você também pode controlar espaçamento e alinhamento.  
  
 ### <a name="inserting-a-string"></a>Inserindo uma cadeia de caracteres  

 <xref:System.String.Format%2A?displayProperty=nameWithType> começa com uma cadeia de caracteres de formato, seguida por um ou mais objetos ou expressões que serão convertidas em cadeias de caracteres e inseridas em um local especificado na cadeia de caracteres de formato. Por exemplo:  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 O `{0}` no formato de cadeia de caracteres é um item de formato. `0` é o índice do objeto cujo valor de cadeia de caracteres será inserido nessa posição. (Os índices começam com 0). Se o objeto a ser inserido não é uma cadeia de caracteres, seu `ToString` método é chamado para convertê-lo em um antes de inseri-lo na cadeia de caracteres resultante.  
  
 Aqui está outro exemplo que usa dois itens de formato e dois objetos na lista de objetos:  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 Você pode ter quantos itens de formato e a quantidade de objetos na lista de objetos que você deseja, desde que o índice de cada item de formato tem um objeto correspondente na lista de objetos. Você também não precisa se preocupar sobre qual sobrecarga você chamar; o compilador irá selecionar aquela que for apropriada para você.  
  
 ### <a name="controlling-formatting"></a>Controlando a formatação  
 Você pode seguir o índice de um item de formato com uma cadeia de caracteres de formato para controlar como um objeto é formatado. Por exemplo, `{0:d}` aplica-se a cadeia de caracteres de formato "d" para o primeiro objeto na lista de objetos. Aqui está um exemplo com um único objeto e dois itens de formato:  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 Um número de suporte de tipos de formato de cadeias de caracteres, incluindo todos os tipos numéricos (ambos [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) Formatar cadeias de caracteres), todas as datas e horas (tanto [padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Formatar cadeias de caracteres) e intervalos de tempo (ambos [padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md) Formatar cadeias de caracteres), todos os tipos de enumeração [tipos de enumeração ](~/docs/standard/base-types/enumeration-format-strings.md), e [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx). Você também pode adicionar suporte para cadeias de caracteres de formato para seus próprios tipos.  
  
 ### <a name="controlling-spacing"></a>Controlar o espaçamento  
 Você pode definir a largura da cadeia de caracteres que é inserida na cadeia de caracteres de resultado usando sintaxe como `{0,12}`, que insere uma cadeia de caracteres de 12 caracteres. Nesse caso, a representação de cadeia de caracteres do primeiro objeto é alinhado à direita no campo de 12 caracteres.  (Se a representação de cadeia de caracteres do primeiro objeto é mais de 12 caracteres de comprimento, no entanto, a largura preferencial do campo será ignorada e a cadeia de caracteres inteira é inserida na cadeia de caracteres de resultado.)  
  
 O exemplo a seguir define um campo de 6 caracteres para conter a cadeia de caracteres "Ano" e algumas cadeias de caracteres do ano, bem como um campo de 15 caracteres para conter a cadeia de caracteres "População" e alguns dados de população. Observe que os caracteres são alinhados à direita no campo.  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a>Controlar o alinhamento  
 Por padrão, cadeias de caracteres são alinhados à direita em seu campo se você especificar uma largura de campo. Para alinhar à esquerda cadeias de caracteres em um campo, você preceda a largura do campo com um sinal negativo, tais como `{0,-12}` para definir um campo de 12 caracteres alinhada à esquerda.  
  
 O exemplo a seguir é semelhante ao anterior, exceto pelo fato de ele alinha à esquerda os rótulos e os dados.  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <xref:System.String.Format%2A?displayProperty=nameWithType> faz uso de recurso de formatação composta. Para obter mais informações, veja [Formatação de composição](~/docs/standard/base-types/composite-formatting.md).  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a>Qual método devo chamar?  
  
|Para|Call|  
|--------|----------|  
|Formate um ou mais objetos usando as convenções da cultura atual.|Exceto para as sobrecargas que incluem uma `provider` parâmetro, o restante <xref:System.String.Format%2A> sobrecargas incluem um <xref:System.String> parâmetro seguido por um ou mais parâmetros de objeto. Por isso, você não precisa determinar qual <xref:System.String.Format%2A> sobrecarga que você pretende chamar. O compilador de linguagem seleciona a sobrecarga apropriada dentre as sobrecargas que não têm um `provider` parâmetro, com base em sua lista de argumentos. Por exemplo, se sua lista de argumentos tiver cinco argumentos, o compilador chama o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método.|  
|Formate um ou mais objetos usando as convenções de uma cultura específica.|Cada <xref:System.String.Format%2A> sobrecarga que começa com um `provider` parâmetro é seguido por um <xref:System.String> parâmetro e um ou mais parâmetros do objeto. Por isso, você não precisa determinar qual específicas <xref:System.String.Format%2A> sobrecarga que você pretende chamar. O compilador de linguagem seleciona a sobrecarga apropriada dentre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos. Por exemplo, se sua lista de argumentos tiver cinco argumentos, o compilador chama o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método.|  
|Executar uma operação de formatação personalizada com uma <xref:System.ICustomFormatter> implementação ou um <xref:System.IFormattable> implementação.|Qualquer um dos quatro sobrecargas com um `provider` parâmetro. O compilador seleciona a sobrecarga apropriada dentre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos.|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a>O método Format resumido 

 Cada sobrecarga da <xref:System.String.Format%2A> usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para incluir com base em zero espaços reservados indexados, chamados *formatar itens*, em uma cadeia de caracteres de formato composto. Em tempo de execução, cada item de formato é substituído pela representação de cadeia de caracteres do argumento correspondente em uma lista de parâmetros. Se o valor do argumento for `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>. Por exemplo, a seguinte chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método inclui uma cadeia de caracteres de formato com três itens de formato {0}, {1}, e {2}e uma lista de argumentos com três itens.  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a>O item de formato  
 Um item de formato tem a seguinte sintaxe:  
  
```  
{index[,alignment][:formatString]}  
```  
 
 Colchetes indicam elementos opcionais. As chaves de abertura e fechamento são necessárias. (Para incluir uma literal abertura ou fechamento na cadeia de caracteres de formato, consulte o [chaves de escape](~/docs/standard/base-types/composite-formatting.md#escaping-braces) seção o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) artigo.)  
  
 Por exemplo, um item de formato para formatar um valor de moeda pode aparecer como este:  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 Um item de formato tem os seguintes elementos:  
  
 *index*  
 O índice baseado em zero do argumento cuja representação de cadeia de caracteres deve ser incluído nessa posição na cadeia de caracteres. Se esse argumento for `null`, uma cadeia de caracteres vazia será incluída nessa posição na cadeia de caracteres.  
  
 *alignment*  
 Opcional. Um inteiro com sinal que indica o comprimento total do campo em que o argumento é inserido e se ele estiver alinhado à direita (um inteiro positivo) ou alinhado à esquerda (um inteiro negativo). Se você omitir *alinhamento*, a representação de cadeia de caracteres do argumento correspondente é inserida em um campo sem espaços à esquerda ou direita.  
  
 Se o valor de *alinhamento* é menor que o comprimento do argumento a ser inserido, *alinhamento* será ignorado e o comprimento da representação de cadeia de caracteres do argumento é usado como a largura do campo.  
  
 *formatString*  
 Opcional. Uma cadeia de caracteres que especifica o formato de cadeia de caracteres de resultado do argumento correspondente. Se você omitir *formatString*, o argumento correspondente sem parâmetros `ToString` método é chamado para produzir sua representação de cadeia de caracteres. Se você especificar *formatString*, o argumento referenciado pelo item de formato deve implementar o <xref:System.IFormattable> interface. Os tipos que oferecem suporte a cadeias de caracteres de formato incluem:  
  
-   Todos os tipos de ponto flutuante e integrais. (Consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)  
  
-   <xref:System.DateTime> e <xref:System.DateTimeOffset>. (Consulte [cadeias de caracteres de formato de data e hora padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [cadeias de caracteres de formato de data e hora personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)  
  
-   Todos os tipos de enumeração. (Consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).)  
  
-   valores <xref:System.TimeSpan>. (Consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de caracteres de formato TimeSpan personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).)  
  
-   GUIDs. (Consulte o <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> método.)  
  
 No entanto, observe que qualquer tipo personalizado pode implementar <xref:System.IFormattable> ou estender um tipo existente <xref:System.IFormattable> implementação.  
  
 O exemplo a seguir usa o `alignment` e `formatString` argumentos para produzir saída formatada.  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a>Como os argumentos são formatados  
 Itens de formato são processados em sequência, desde o início da cadeia de caracteres. Cada item de formato tem um índice que corresponde a um objeto na lista de argumentos do método. O <xref:System.String.Format%2A> recupera o argumento de método e sua representação de cadeia de caracteres é derivado da seguinte maneira:  
  
-   Se o argumento for `null`, o método insere <xref:System.String.Empty?displayProperty=nameWithType> na cadeia de caracteres de resultado. Você não precisa se preocupar com a manipulação de um <xref:System.NullReferenceException> para argumentos nulos. 
  
-   Se você chamar o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> sobrecarga e a `provider` do objeto <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementação retorna não nulo <xref:System.ICustomFormatter> implementação, o argumento é passado para sua <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método. Se o item de formato inclui um *formatString* argumento, ele é passado como o primeiro argumento para o método. Se o <xref:System.ICustomFormatter> implementação está disponível e produz uma cadeia de caracteres não-nulo, cadeia de caracteres é retornada como a representação de cadeia de caracteres do argumento; caso contrário, a próxima etapa é executada.  
  
-   Se o argumento implementa o <xref:System.IFormattable> interface, seu <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação é chamada.  
  
-   O argumento sem parâmetros `ToString` método, que substitui ou herda de uma implementação da classe base, é chamado.  
  
 Para obter um exemplo que intercepta as chamadas para o <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> método e permite que você veja quais informações o <xref:System.String.Format%2A> passes de método para um método de formatação para cada item de formato em uma cadeia de caracteres de formato de composição, consulte [exemplo: Um provedor de interceptação e formatador de algarismo romano](#Format7_Example).  

 Para obter mais informações, consulte o [ordem de processamento](~/docs/standard/base-types/composite-formatting.md##processing-order) seção o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) artigo.  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a>Itens de formato que têm o mesmo índice  
 O <xref:System.String.Format%2A> método lança um <xref:System.FormatException> exceção se o índice de um item do índice é maior que ou igual ao número de argumentos na lista de argumentos. No entanto, `format` pode incluir mais itens de formato que o número de argumentos, desde que vários itens de formato têm o mesmo índice. Na chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%29> método no exemplo a seguir, a lista de argumentos tem um único argumento, mas a cadeia de caracteres de formato inclui dois itens de formato: um exibe o valor decimal de um número e o outro exibe seu valor hexadecimal.  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a>Formatação e cultura  
 Em geral, os objetos na lista de argumentos são convertidos em suas representações de cadeia de caracteres usando as convenções da cultura atual, que é retornado pelo <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedade. Você pode controlar esse comportamento, chamando uma das sobrecargas de <xref:System.String.Format%2A> que inclui um `provider` parâmetro. O `provider` parâmetro é um <xref:System.IFormatProvider> o processo de implementação que fornece informações de formatação específicas da cultura e personalizadas que são usadas para moderar a formatação.  
  
 O <xref:System.IFormatProvider> interface tem um único membro, <xref:System.IFormatProvider.GetFormat%2A>, que é responsável por retornar o objeto que fornece informações de formatação. .NET tem três <xref:System.IFormatProvider> implementações que fornecem a formatação de cultura específica:  
  
-   <xref:System.Globalization.CultureInfo>. Sua <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna uma cultura específica <xref:System.Globalization.NumberFormatInfo> objeto para a formatação de valores numéricos e uma cultura específica <xref:System.Globalization.DateTimeFormatInfo> objeto para a formatação de valores de data e hora.  
  
-   <xref:System.Globalization.DateTimeFormatInfo>, que é usado para formatação de cultura específica de valores de data e hora. Seu <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> método retorna ele próprio.  
  
-   <xref:System.Globalization.NumberFormatInfo>, que é usado para formatação de cultura específica de valores numéricos. Seu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propriedade retorna ele próprio. 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a>Operações de formatação personalizadas  
 Você também pode chamar qualquer uma das sobrecargas do <xref:System.String.Format%2A> método que tem um `provider` parâmetro do tipo <xref:System.IFormatProvider> para executar operações de formatação personalizadas. Por exemplo, você pode formatar um número inteiro como um número de identificação ou como um número de telefone. Para executar a formatação personalizada, sua `provider` argumento deve implementar ambas as <xref:System.IFormatProvider> e <xref:System.ICustomFormatter> interfaces. Quando o <xref:System.String.Format%2A> método recebe um <xref:System.ICustomFormatter> implementação como o `provider` argumento, o <xref:System.String.Format%2A> chamadas de método seu <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementação e solicita um objeto do tipo <xref:System.ICustomFormatter>. Em seguida, chama retornado <xref:System.ICustomFormatter> do objeto <xref:System.ICustomFormatter.Format%2A> método para cada item de formato na cadeia de caracteres composta de formato passado para ele.  
  
 Para obter mais informações sobre como fornecer soluções personalizadas de formatação, consulte [como: Definir e usar provedores de formato numérico personalizado](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) e <xref:System.ICustomFormatter>. Para obter um exemplo que converte números inteiros em números formatados de personalizado, consulte [exemplo: Uma operação de formatação personalizada](#Format6_Example). Veja um exemplo que converte bytes sem sinal em numerais romanos, [exemplo: Um provedor de interceptação e formatador de algarismo romano](#Format7_Example).  
  
<a name="Format6_Example"></a>   
### <a name="example-a-custom-formatting-operation"></a>Exemplo: Uma operação de formatação personalizada  
 Este exemplo define um provedor de formato que formata um valor inteiro como um número de conta do cliente no formato x-xxxxx-xx.  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example"></a>   
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a>Exemplo: Um provedor de interceptação e formatador de algarismo romano  
 Este exemplo define um provedor de formato personalizado que implementa o <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfaces fazer duas coisas:  
  
-   Ele exibe os parâmetros passados para seus <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementação. Isso nos permite ver quais parâmetros a <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método está passando para a implementação de formatação personalizada para cada objeto que ele tenta formatar. Isso pode ser útil quando você estiver depurando seu aplicativo.  
  
-   Se o objeto a ser formatado for um valor de byte sem sinal que deve ser formatada usando a cadeia de caracteres de formato padrão "R", o formatador personalizado formata o valor numérico como um numeral romano.  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a>String.Format Q & A  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a>Por que você recomenda interpolação de cadeia de caracteres em chamadas para o `String.Format` método?

Interpolação de cadeia de caracteres é:

- Mais flexível. Ele pode ser usado em qualquer cadeia de caracteres sem a necessidade de uma chamada para um método que dá suporte à formatação de composição. Caso contrário, você precisará chamar o <xref:System.String.Format%2A> método ou outro método que oferece suporte a formatação de composição, como <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>. 

- Mais legível. Como a expressão a ser inserido em uma cadeia de caracteres aparece na expressão interpolada em vez de em uma lista de argumentos, cadeias de caracteres interpoladas são muito mais fácil para o código e ler. Devido a sua maior legibilidade, cadeias de caracteres interpoladas podem substituir não apenas as chamadas para métodos de formato composto, mas eles também podem ser usados em operações de concatenação de cadeia de caracteres para produzir um código mais conciso e mais claro. 

Uma comparação dos seguintes exemplos de código ilustra a superioridade do cadeias de caracteres interpoladas ao longo de concatenação de cadeia de caracteres e chamadas para métodos de formatação de composição. O uso de várias operações de concatenação de cadeia de caracteres no exemplo a seguir produz código detalhado e difícil de ler.

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

Em contraste, o uso de cadeias de caracteres interpoladas no exemplo a seguir produz código mais conciso e bem mais claro que a instrução de concatenação de cadeia de caracteres e a chamada para o <xref:System.String.Format%2A> método no exemplo anterior.

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a>Onde posso encontrar uma lista de cadeias de caracteres de formato predefinido que pode ser usado com itens de formato?  
  
-   Para todos os tipos de ponto flutuante e integrais, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Para obter valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Para obter valores de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Para <xref:System.TimeSpan> valores, consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de caracteres de formato de intervalo de tempo personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).  
  
-   Para <xref:System.Guid> valores, consulte a seção de comentários do <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> página de referência.  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a>Como controlar o alinhamento das cadeias de caracteres resultado substituir itens de formato?  
 A sintaxe geral de um item de formato é:  
  
```  
{index[,alignment][: formatString]}  
```  
  
 em que *alinhamento* é um inteiro com sinal que define a largura do campo. Se esse valor for negativo, o texto do campo é alinhado à esquerda. Se ele for positivo, o texto é alinhado à direita.  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a>Como controlar o número de dígitos após o separador decimal?  
 Todos os [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) exceto "D" (que é usado com apenas números inteiros), "G", "R" e "X" permitir que um especificador de precisão que define o número de dígitos decimais na cadeia de caracteres de resultado. O exemplo a seguir usa cadeias de caracteres de formato numérico padrão para controlar o número de dígitos decimais na cadeia de caracteres de resultado.  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 Se você estiver usando um [cadeia de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), use o especificador de formato "0" para controlar o número de dígitos decimais na cadeia de caracteres resultante, como mostra o exemplo a seguir.  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a>Como controlar o número de dígitos integrais?  
 Por padrão, operações de formatação exibem somente os dígitos integrais de diferente de zero. Se você estiver formatando números inteiros, você pode usar um especificador de precisão com "D" e "X" cadeias de caracteres de formato padrão para controlar o número de dígitos.  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 Você pode preencher um inteiro ou um número de ponto flutuante com zeros à esquerda para produzir uma cadeia de caracteres de resultado com um número especificado de dígitos integrais usando o "0" [especificador de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), como mostra o exemplo a seguir.  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a>Quantos itens podem incluir na lista formato?  
 Não há nenhum limite prático. O segundo parâmetro do <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método é marcado com o <xref:System.ParamArrayAttribute> atributo, que permite que você inclua uma lista delimitada por ponto ou uma matriz de objetos como sua lista de formato.  
  
<a name="braces"></a>
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a>Como incluir a chaves literais ("{" e "}") na cadeia de caracteres de resultado?  
 Por exemplo, como evitar a seguinte chamada de método, gere um <xref:System.FormatException> exceção?  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 Um simples de abertura ou fechamento é sempre interpretado como o início ou final de um item de formato. Para ser interpretado literalmente, ela deverá ser substituída. Você fazer o escape de uma chave com a adição de outra chave ("{{" e "}}" em vez de "{" e "}"), conforme mostrado no seguinte chamada de método:  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 No entanto, as chaves de escape ainda são facilmente mal interpretadas. É recomendável que você inclua chaves na lista de formato e usa itens de formato para inseri-los na cadeia de caracteres de resultado, como mostra o exemplo a seguir.  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a>Por que minha chamada ao método String. Format lança uma FormatException?  
 A causa mais comum da exceção é que o índice de um item de formato não corresponde a um objeto na lista de formato. Normalmente, isso indica que você já misnumbered os índices dos itens de formato ou você esqueceu de incluir um objeto na lista de formato. A tentativa de incluir uma chave esquerda ou direita sem escape caractere também gera um <xref:System.FormatException>. Ocasionalmente, a exceção é o resultado de um erro de digitação; Por exemplo, um erro típico é incorretamente "[" (o colchete esquerdo), em vez de "{" (a chave à esquerda).  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a>Se o método Format(System.IFormatProvider,System.String,System.Object[]) dá suporte a matrizes de parâmetro, por que meu código lançar uma exceção quando eu uso uma matriz?  
 Por exemplo, o código a seguir gera um <xref:System.FormatException> exceção:  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 Este é um problema de resolução de sobrecarga do compilador. Porque o compilador não pode converter uma matriz de inteiros em uma matriz de objetos, ele trata a matriz de inteiros como um único argumento, para que ele chama o <xref:System.String.Format%28System.String%2CSystem.Object%29> método. A exceção é gerada porque há quatro itens de formato, mas apenas um único item na lista de formato.  
  
 Como o Visual Basic nem c# pode converter uma matriz de inteiros para uma matriz de objetos, você precisa executar a conversão antes de chamar o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método. O exemplo a seguir fornece uma implementação.  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

Ver vários exemplos que chamam a <xref:System.String.Format%2A> método são intercalados por meio de [comentários](#remarks) seção deste artigo.  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

Você também pode baixar um conjunto completo de `String.Format` exemplos, que são incluídos uma [projeto .NET Core 2.0 para c#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) e uma [projeto .NET Core 2.0 para o Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), da [dotnet / repositório GitHub de exemplos](https://github.com/dotnet/samples).

Seguem alguns exemplos incluídos neste artigo:

### <a name="create-a-format-string"></a>Criar uma cadeia de caracteres de formato

[Inserindo uma cadeia de caracteres](#inserting-a-string)  
[O item de formato](#the-format-item)  
[Itens de formato que têm o mesmo índice](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a>Controlar a saída formatada

[Controlando a formatação](#controlling-formatting)  
[Controlar o espaçamento](#controlling-spacing)  
[Controlar o alinhamento](#controlling-alignment)  
[Controlar o número de dígitos integrais](#how-do-i-control-the-number-of-integral-digits)  
[Controlando o número de dígitos após o separador decimal](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[Incluindo chaves literais em uma cadeia de caracteres de resultado](#braces)  

### <a name="make-format-strings-culture-sensitive"></a>Tornar sensível à cultura de cadeias de caracteres de formato

[Formatação sensível à cultura](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a>Personalizar a operação de formatação

[Uma operação de formatação personalizada](#example-a-custom-formatting-operation)  
[Um provedor de interceptação e formatador de algarismo romano](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Substitui um ou mais itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de um objeto especificado.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de uma expressão em sua representação de cadeia de caracteres e inserir essa representação em uma cadeia de caracteres. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a>Exemplo: Formatando um único argumento  
 
 O exemplo a seguir usa o <xref:System.String.Format%28System.String%2CSystem.Object%29> método para inserir a idade de um indivíduo no meio de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">O item de formato em <paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato não é zero.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</param>
        <summary>Substitui o item de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres de um objeto correspondente em uma matriz especificada.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de quatro ou mais expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. Uma vez que o `args` parâmetro é marcado com o <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atributo, você pode passar os objetos para o método como argumentos individuais ou como um <xref:System.Object> matriz. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a>Exemplo: Formatando mais de três argumentos  
 
 Este exemplo cria uma cadeia de caracteres que contém dados sobre a temperatura alta e baixa em uma determinada data. A cadeia de caracteres de formato de composição tem cinco itens de formato no exemplo de c# e seis no exemplo do Visual Basic. Dois dos itens de formato definem a largura da representação de cadeia de caracteres do valor de seu correspondente e o primeiro item de formato também inclui um padrão de data e a cadeia de caracteres de formato de hora.  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 Você também pode passar os objetos a serem formatados como uma matriz em vez de uma lista de argumentos.  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que zero, ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O objeto a ser formatado.</param>
        <summary>Substitui o item ou itens de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres do objeto correspondente. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual o item ou itens de formato foram substituídos pela representação de cadeia de caracteres do <paramref name="arg0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de uma expressão em sua representação de cadeia de caracteres e inserir essa representação em uma cadeia de caracteres. Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado. O método converte `arg0` em sua representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString ( String, IFormatProvider)** método. Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato não é zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="args">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres pelas representações cadeia de caracteres de objetos correspondentes em uma matriz especificada. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter quatro ou mais expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado. O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método. Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a>Exemplo: Formatação sensível à cultura  
 Este exemplo usa o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método para exibir a representação de cadeia de caracteres de alguns valores de data e hora e valores numéricos usando várias culturas diferentes.  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que zero, ou maior ou igual ao tamanho da matriz <paramref name="args" />.</exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de dois objetos especificados.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de duas expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a>Exemplo: Formatando dois argumentos  
 
 Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> método para exibir dados de tempo e a temperatura armazenados em um genérico <xref:System.Collections.Generic.Dictionary%602> objeto. Observe que a cadeia de caracteres de formato tem três itens de formato, embora existam apenas dois objetos a serem formatados. Isso ocorre porque o primeiro objeto na lista (um valor de data e hora) é usado pelos itens de formato de dois: O primeiro formato item exibe a hora e a segunda exibe a data.  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato não é zero nem um.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
        <related type="Article" href="~/docs/standard/base-types/standard-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-date-and-time-format-strings.md">Cadeias de caracteres de formato de data e hora personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Cadeias de caracteres de formato numérico padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Cadeias de caracteres de formato numérico personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/standard-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan padrão</related>
        <related type="Article" href="~/docs/standard/base-types/custom-timespan-format-strings.md">Cadeias de caracteres de formato TimeSpan personalizado</related>
        <related type="Article" href="~/docs/standard/base-types/enumeration-format-strings.md">Cadeias de caracteres de formato de enumeração</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de dois objetos especificados. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) converter duas expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado. O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método. Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato não é zero nem um.</exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de três objetos especificados.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor das três expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a>Exemplo: Formatando três argumentos  
 
 Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para criar uma cadeia de caracteres que ilustra o resultado de um valor booliano `And` operação com dois valores inteiros. Observe que a cadeia de caracteres de formato inclui seis itens de formato, mas o método tem apenas três itens na lista de parâmetros, porque cada item é formatada de duas maneiras diferentes.  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que zero ou maior que dois.</exception>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Tipos de formatação no .NET</related>
        <related type="Article" href="~/docs/standard/base-types/composite-formatting.md">Formatação composta</related>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="format" Type="System.String" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg0" Type="System.Object" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg1" Type="System.Object" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arg2" Type="System.Object" Index="4" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <param name="format">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</param>
        <param name="arg0">O primeiro objeto a ser formatado.</param>
        <param name="arg1">O segundo objeto a ser formatado.</param>
        <param name="arg2">O terceiro objeto a ser formatado.</param>
        <summary>Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de três objetos especificados. Um parâmetro fornece informações de formatação específicas da cultura.</summary>
        <returns>Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) converter três expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres. Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado. O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método. Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="format" /> é <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="format" /> é inválido.  
  
- ou - 
O índice de um item de formato é menor que zero ou maior que dois.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Recupera um objeto que pode iterar os caracteres individuais nessa cadeia de caracteres.</summary>
        <returns>Um objeto enumerador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> Em vez de chamar o <xref:System.String.GetEnumerator%2A> método para recuperar um <xref:System.CharEnumerator> do objeto que você usar para enumerar uma cadeia de caracteres, em vez disso, use o constructo de iteração da sua linguagem (em c#, no C + + c++ /CLI CLR e no Visual Basic). [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) em c#, [para cada](/cpp/dotnet/for-each-in) no C + + c++ /CLI CLR, e [para cada](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) no Visual Basic).
  
 Esse método permite que você iterar os caracteres individuais em uma cadeia de caracteres. Por exemplo, o Visual Basic `For Each` e c# `foreach` instruções invocar esse método para retornar um <xref:System.CharEnumerator> objeto que pode fornecer acesso somente leitura aos caracteres nesta instância de cadeia de caracteres.  
  
   
  
## Examples  
 O exemplo a seguir itera os caracteres em várias cadeias de caracteres e exibe informações sobre seus caracteres individuais. Ele usa a construção de iteração de linguagem em vez de uma chamada para o <xref:System.String.GetEnumerator%2A> método.  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o código hash desta cadeia de caracteres.</summary>
        <returns>Um código de hash do inteiro assinado de 32 bits.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento de <xref:System.String.GetHashCode%2A> depende de sua implementação, o que pode ser alterado de uma versão do common language runtime para outro. Um motivo por que isso pode acontecer é melhorar o desempenho de <xref:System.String.GetHashCode%2A>.  
  
> [!IMPORTANT]
>  Se dois objetos de cadeia de caracteres são iguais, o <xref:System.String.GetHashCode%2A> método retorna valores idênticos. No entanto, não há um valor de código hash exclusivo para cada valor de cadeia de caracteres exclusiva. Cadeias de caracteres diferentes podem retornar o mesmo código hash.  
>   
>  O código de hash em si não é garantido para ser estável. Códigos de hash para cadeias de caracteres idênticas podem ser diferentes entre implementações do .NET, entre as versões do .NET e entre plataformas do .NET (por exemplo, 32 bits e 64 bits) para uma única versão do .NET. Em alguns casos, pode até mesmo diferem por domínio de aplicativo. Isso implica que as duas execuções subsequentes do mesmo programa podem retornar códigos de hash diferente.  
>   
>  Como resultado, hash códigos nunca devem ser usados fora do domínio de aplicativo no qual eles foram criados, eles nunca devem ser usados como campos de chave em uma coleção e nunca deve ser mantidos.  
>   
>  Por fim, não use o código de hash em vez de um valor retornado por uma função de hash criptográfica, se você precisar de um hash criptograficamente forte. Para hashes criptográficos, use uma classe derivada de <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.  
>   
>  Para obter mais informações sobre códigos de hash, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
 Em aplicativos da área de trabalho, você pode usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) para gerar códigos de hash exclusivo em uma base domínio de aplicativo. Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash. O exemplo a seguir mostra como usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md). Ele define uma gerar códigos de hash exclusivo em uma base domínio de aplicativo. Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash. O exemplo a seguir mostra como usar o. Ele define uma `DisplayString` classe que inclui uma constante de cadeia de caracteres privados, `s`, cujo valor é "Esta é uma cadeia de caracteres." Também inclui um método `ShowStringHashCode` que exibe o valor de cadeia de caracteres e seu código de hash com o nome do domínio do aplicativo no qual o método está sendo executado.  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 Quando você executa o exemplo sem fornecer um arquivo de configuração, ele exibe uma saída semelhante à seguinte. Observe que os códigos hash para a cadeia de caracteres são idênticos nos dois domínios de aplicativo.  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 Entretanto, se você adicionar o seguinte arquivo de configuração ao diretório de exemplo e, então, executar o exemplo, os códigos hash da mesma cadeia de caracteres diferirão de acordo com o domínio de aplicativo.  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 Quando o arquivo de configuração estiver presente, o exemplo exibe a saída a seguir:  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  Códigos de hash são usados para inserir e recuperar objetos com chave das tabelas de hash com eficiência. No entanto, os códigos de hash não identificam exclusivamente as cadeias de caracteres. Cadeias de caracteres idênticas têm códigos hash igual, mas o common language runtime também pode atribuir o mesmo código hash para cadeias de caracteres diferentes. Além disso, os códigos hash podem variar por versão do .NET, plataforma dentro de uma única versão e domínio do aplicativo. Por isso, você não deve serializar ou manter valores de hash de código, nem deve você usá-los como chaves em uma tabela de hash ou dicionário.  
  
 Para obter informações adicionais sobre o uso dos códigos de hash e o `GetHashCode` método, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.GetHashCode%2A> método usando várias cadeias de caracteres de entrada.  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>O valor retornado por <see cref="M:System.String.GetHashCode" /> é dependente de plataforma. Ele é diferente nas versões de 32 bits e 64 bits do .NET Framework. Ele também pode ser diferente entre as versões do .NET Framework e .NET Core.</para></block>
        <altmember cref="M:System.Object.GetHashCode" />
        <related type="Article" href="https://msdn.microsoft.com/library/c08125d6-56cc-4b23-b482-813ff85dc630">&lt;UseRandomizedStringHashAlgorithm&gt; elemento</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; -&gt; int" Usage="System.string.GetHashCode value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.ReadOnlySpan{System.Char},System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (value As ReadOnlySpan(Of Char), comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(ReadOnlySpan&lt;char&gt; value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : ReadOnlySpan&lt;char&gt; * StringComparison -&gt; int" Usage="System.string.GetHashCode (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna o <see cref="T:System.TypeCode" /> para a classe <see cref="T:System.String" />.</summary>
        <returns>A constante enumerada, <see cref="F:System.TypeCode.String" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir exibe a <xref:System.TypeCode> constante enumerada para o <xref:System.String> tipo.  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Relata o índice de base zero da primeira ocorrência de uma cadeia de caracteres ou um caractere Unicode especificado nesta instância. O método retorna -1 caso o caractere ou a cadeia de caracteres não seja encontrado nessa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode pesquisar um <xref:System.String> para um caractere usando o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso essa cadeia de caracteres seja encontrada ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa na posição do primeiro caractere dessa instância e continua até que a última posição de caractere.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%29> método sempre retorna 0 (zero) para indicar que a correspondência for encontrada no início da instância atual. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%29> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen condicional é um caractere ignorável, o resultado é o mesmo como se o hífen não havia sido incluído no `value`. Ao procurar por um hífen somente, o método retorna 0 (zero) para indicar que encontrou uma correspondência no início da cadeia de caracteres.  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 O exemplo a seguir procura "n" em "animal". Porque os índices de cadeia de caracteres começam em zero em vez de um, o <xref:System.String.IndexOf%28System.String%29> método indica que o "n" na posição 1.  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para determinar a posição inicial de um nome do animal em uma sentença. Ele usa essa posição para inserir um adjetivo que descreve o animal em sentença.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu `comparisonType` parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 A pesquisa varia de `startIndex` até o final da cadeia de caracteres.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho da cadeia de caracteres.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">O caractere a buscar.</param>
        <param name="comparisonType">Um valor de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres. Um parâmetro especifica o tipo de pesquisa a ser usado para o caractere especificado.</summary>
        <returns>O índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

A numeração de índice começa do zero.  
  
O `comparisonType` parâmetro é um <xref:System.StringComparison> membro de enumeração que especifica se a pesquisa para o `value` argumento usa a cultura atual ou invariável, é diferencia maiusculas de minúsculas ou maiusculas de minúsculas ou usa a palavra ou regras de comparação ordinal.
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa no `startIndex` caractere posição dessa instância e continua até que a última posição de caractere.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 O exemplo a seguir procura todas as ocorrências de uma cadeia de caracteres especificada dentro de uma cadeia de caracteres de destino.  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres que ocorre após uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu `comparisonType` parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice do parâmetro <paramref name="value" /> caso essa cadeia de caracteres seja encontrada, ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 O exemplo a seguir demonstra três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método sempre retorna 0 (zero) para indicar que a correspondência for encontrada no início da instância atual.  
  
No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, como o hífen é um caractere ignorável, uma pesquisa sensível à cultura retorna o mesmo valor que será retornado se o hífen não foram incluídos na cadeia de caracteres de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen em uma cadeia de caracteres com êxito e relata que está ausente da segunda cadeia de caracteres.  
  
[!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência do caractere especificado nessa instância. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1. O caractere na `startIndex`  +  `count` não está incluído na pesquisa.  
  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
- ou - 
 <paramref name="startIndex" /> é maior que o tamanho desta cadeia de caracteres.  
  
- ou - 
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual. A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1. O caractere na `startIndex`  +  `count` não está incluído na pesquisa.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir do terceiro ao sexto posições de caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências da cadeia de caracteres "OL" dentro de uma subcadeia de caracteres de outra cadeia de caracteres. Observe que o número de caracteres a serem pesquisadas deve ser recalculado para cada iteração de pesquisa.  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
- ou - 
 <paramref name="startIndex" /> é maior que o tamanho desta cadeia de caracteres.  
  
- ou - 
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para usar as regras de comparação da cultura atual para executar esta operação, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu `comparisonType` parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Os parâmetros especificam a posição de pesquisa inicial na cadeia de caracteres atual e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0. O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres. Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir da posição do terceiro caractere duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
[!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual. Parâmetros especificam a posição inicial de pesquisa na cadeia de caracteres de atual, o número de caracteres na cadeia de caracteres atual para pesquisar e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Índice de numeração começa em 0 (zero). O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.  
  
 A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1. O caractere na `startIndex`  +  `count` não está incluído na pesquisa.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
- ou - 
 <paramref name="startIndex" /> é maior que o tamanho desta instância.  
  
- ou - 
 <paramref name="count" /> é maior que o tamanho da cadeia de caracteres menos <paramref name="startIndex" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir do terceiro ao sexto posições de caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen, seguido por um "m", o método não retorna o índice do hífen virtual, mas em vez disso, retorna o índice do "m", quando ele executa uma comparação sensível à cultura. O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
[!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Relata o índice da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode. O método retorna -1 caso os caracteres na matriz não sejam encontrados nessa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas. Se `anyOf` é uma matriz vazia, localiza o método uma correspondência no início da cadeia de caracteres (ou seja, no índice zero).  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza a primeira vogal em uma cadeia de caracteres.  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode. A pesquisa é iniciada em uma posição de caractere especificada.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.  
  
 A pesquisa varia de `startIndex` até o final da cadeia de caracteres.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é negativo.  
  
- ou - 
 <paramref name="startIndex" /> é maior que o número de caracteres nessa instância.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode. A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</summary>
        <returns>A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1. O caractere na `startIndex`  +  `count` não está incluído na pesquisa.  
  
 A numeração de índice começa do zero. O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.  
  
 A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
- ou - 
 <paramref name="count" /> + <paramref name="startIndex" /> é maior que o número de caracteres nesta instância.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de índice baseado em zero da inserção.</param>
        <param name="value">A cadeia de caracteres a ser inserida.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual uma cadeia de caracteres especificada é inserida em uma posição de índice especificada nesta instância.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a esta instância, mas com <paramref name="value" /> inserido na posição <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `startIndex` é igual ao comprimento dessa instância, `value` é acrescentado ao final dessa instância.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual `value` é inserida na instância atual.  
  
 Por exemplo, o valor de retorno `"abc".Insert(2, "XYZ")` é "abXYZc".  
  
   
  
## Examples  
 O exemplo a seguir insere um caractere de espaço em que a quarta posição de caractere (o caractere no índice 3) de uma cadeia de caracteres.  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 O aplicativo de console a seguir solicita que os usuários insiram um ou mais adjetivos para descrever dois animais. Em seguida, ele chama o <xref:System.String.Insert%2A> método para inserir o texto inserido pelo usuário em uma cadeia de caracteres.  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é negativo ou maior que o comprimento dessa instância.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">Uma cadeia de caracteres para pesquisar no pool interno.</param>
        <summary>Recupera a referência do sistema para o <see cref="T:System.String" /> especificado.</summary>
        <returns>A referência do sistema para <paramref name="str" />, se interno; caso contrário, uma nova referência para uma cadeia de caracteres com o valor de <paramref name="str" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime preserva o armazenamento de cadeia de caracteres por manter uma tabela, o pool interno, que contém uma única referência para cada literal cadeia de caracteres exclusiva declarados ou criado por meio de programação em seu programa de chamada. Consequentemente, uma instância de uma cadeia de caracteres literal com um valor específico existe somente uma vez no sistema.  
  
 Por exemplo, se você atribuir a mesma cadeia de caracteres literal a diversas variáveis, o tempo de execução recupera a mesma referência para a cadeia de caracteres literal do pool interno e atribui a cada variável.  
  
 O <xref:System.String.Intern%2A> método usa o pool interno para pesquisar uma cadeia de caracteres igual ao valor de `str`. Se existir uma cadeia de caracteres, sua referência no pool interno é retornada. Se a cadeia de caracteres não existir, uma referência a `str` é adicionado ao pool interno, em seguida, essa referência é retornada.  
  
 No exemplo a seguir, a cadeia de caracteres s1, que tem um valor de "MyTest", já é internalizadas porque ele é um literal no programa. O <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe gera um novo objeto de cadeia de caracteres que tem o mesmo valor de s1. Uma referência a essa cadeia de caracteres é atribuída para s2. O <xref:System.String.Intern%2A> método procura uma cadeia de caracteres que tem o mesmo valor de s2. Como existe uma cadeia de caracteres, o método retorna a mesma referência é atribuída ao s1. Essa referência, em seguida, é atribuída ao s3. Referências s1 e S2 comparam diferentes porque elas se referem a objetos diferentes; referências de s1 e s3 comparam como iguais porque elas se referem à mesma cadeia de caracteres.  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 Compare este método para o <xref:System.String.IsInterned%2A> método.  
  
## <a name="version-considerations"></a>Considerações da versão  
 No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], o <xref:System.String.Intern%2A> método será revertido para seu comportamento no .NET Framework 1.0 e 1.1 em relação à centralização da cadeia de caracteres vazia. No exemplo a seguir, a variável `str1` for atribuído a uma referência ao <xref:System.String.Empty>e a variável `str2` é atribuído a referência ao <xref:System.String.Empty> que é retornado ao chamar o <xref:System.String.Intern%2A> método depois de converter um <xref:System.Text.StringBuilder>objeto cujo valor é <xref:System.String.Empty> para uma cadeia de caracteres. Em seguida, as referências contidas `str1` e `str2` são comparadas quanto à igualdade.  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 No [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], e [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` e `str2` são iguais. No [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] e [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` e `str2` não são iguais.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Se você estiver tentando reduzir a quantidade total de memória aloca de seu aplicativo, tenha em mente que a centralização de uma cadeia de caracteres tem dois efeitos colaterais indesejados. Em primeiro lugar, a memória alocada para internalizadas <xref:System.String> objetos não provavelmente ser liberado até que o common language runtime (CLR) é encerrado. A razão é que a referência do CLR para o interno <xref:System.String> object pode persistir após seu aplicativo ou até mesmo seu domínio de aplicativo, será encerrado. Em segundo lugar, para o estágio de uma cadeia de caracteres, você deve primeiro criar a cadeia de caracteres. A memória usada pelo <xref:System.String> objeto ainda deve ser alocado, mesmo que a memória eventualmente será coletado como lixo.  
  
 O .NET Framework versão 2.0 introduz o <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membro de enumeração. O <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membro marca um assembly como não exigindo centralização da cadeia de caracteres literal. Você pode aplicar <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> a um assembly usando o <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atributo. Além disso, quando você usa o [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para compilar um assembly com antecedência sobre o tempo de execução, cadeias de caracteres não são internalizadas nos módulos.  
  
   
  
## Examples  
 O exemplo a seguir usa três cadeias de caracteres são iguais em valor para determinar se uma cadeia de caracteres criada recentemente e uma cadeia de caracteres interno são iguais.  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres para pesquisar no pool interno.</param>
        <summary>Recupera uma referência a um <see cref="T:System.String" /> especificado.</summary>
        <returns>Uma referência a <paramref name="str" /> se ele estiver no pool interno de Common Language Runtime; caso contrário, <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O common language runtime mantém automaticamente uma tabela, chamada pool interno, que contém uma única instância de cada constante de literal de cadeia de caracteres exclusiva declarado em um programa, bem como qualquer instância exclusiva do <xref:System.String> você adicionar programaticamente chamando o <xref:System.String.Intern%2A> método.  
  
 Armazenamento de cadeia de caracteres preserva a pool interno. Se você atribuir uma constante de cadeia de caracteres literal a diversas variáveis, cada variável é definida para referenciar a mesma constante no pool interno em vez de referenciar várias instâncias diferentes do <xref:System.String> que têm valores idênticos.  
  
 Este método pesquisa `str` no pool interno. Se `str` já foi internalizadas, uma referência a essa instância é retornado; caso contrário, `null` será retornado.  
  
 Compare este método para o <xref:System.String.Intern%2A> método.  
  
 Esse método não retorna um valor booliano. Se você chamar o método porque você deseja que um valor booliano que indica se uma determinada cadeia de caracteres é internalizada, você pode usar código como o seguinte.  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  Começando com o .NET Framework versão 2.0, você pode substituir o uso do pool interno de quando você usa o [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para instalar um assembly no cache de imagem nativa em um computador local. Para obter mais informações, consulte Considerações de desempenho na seção comentários para o <xref:System.String.Intern%2A> propriedade.  
  
   
  
## Examples  
 O exemplo a seguir demonstra que as cadeias de caracteres literais sejam internalizadas automaticamente pelo compilador.  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="str" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Indica se esta cadeia de caracteres está em um formulário de normalização Unicode específico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se essa cadeia de caracteres está no formulário C de normalização Unicode.</summary>
        <returns><see langword="true" /> se essa cadeia de caracteres estiver no formulário C de normalização; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. Atualmente, o .NET dá suporte a formulários de normalização C, D, KC e KD.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres com êxito é normalizada para várias formas de normalização.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage"><para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Um formato de normalização Unicode.</param>
        <summary>Indica se esta cadeia de caracteres está no formulário de normalização Unicode especificado.</summary>
        <returns><see langword="true" /> se esta cadeia de caracteres estiver no formulário de normalização especificado pelo parâmetro <paramref name="normalizationForm" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. Atualmente, o .NET dá suporte a formulários de normalização C, D, KC e KD.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.String.IsNormalized%2A> e <xref:System.String.Normalize%2A> métodos.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage"><para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para></block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser testada.</param>
        <summary>Indica se a cadeia de caracteres especificada é <see langword="null" /> ou uma cadeia de caracteres vazia ("").</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou uma cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrEmpty%2A> é um método de conveniência que permite que você teste simultaneamente se um <xref:System.String> está `null` ou seu valor é <xref:System.String.Empty?displayProperty=nameWithType>. É equivalente ao seguinte código:  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 Você pode usar o <xref:System.String.IsNullOrWhiteSpace%2A> método para testar se é uma cadeia de caracteres `null`, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>, ou consiste apenas em caracteres de espaço em branco.  
  
## <a name="what-is-a-null-string"></a>O que é uma cadeia de caracteres nula?

É uma cadeia de caracteres `null` se ele não tiver sido atribuído um valor (em C++ e Visual Basic) ou se explicitamente foi atribuído um valor de `null`. Embora o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso tratar normalmente uma cadeia de caracteres nula, como mostra o exemplo abaixo, tentar chame um se seus membros lança um <xref:System.NullReferenceException>.  
  
[!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
[!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
[!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a>O que é uma cadeia de caracteres vazia?  

Uma cadeia de caracteres estará vazia se ele for explicitamente atribuído a uma cadeia de caracteres vazia ("") ou <xref:System.String.Empty?displayProperty=nameWithType>. Uma cadeia de caracteres vazia tem um <xref:System.String.Length%2A> igual a 0.  O exemplo a seguir cria uma cadeia de caracteres vazia e exibe seu valor e seu comprimento.  
  
[!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
[!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
[!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
## Examples  
 O exemplo a seguir examina três cadeias de caracteres e determina se cada cadeia de caracteres tem um valor, é uma cadeia de caracteres vazia ou é `null`.  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser testada.</param>
        <summary>Indica se uma cadeia de caracteres especificada é <see langword="null" />, vazia ou consiste apenas em caracteres de espaço em branco.</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou <see cref="F:System.String.Empty" />, ou se <paramref name="value" /> consistir exclusivamente em caracteres de espaço em branco.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.IsNullOrWhiteSpace%2A> é um método de conveniência que é semelhante ao código a seguir, exceto que ele oferece desempenho superior:  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 Os caracteres de espaço em branco são definidos pelo padrão Unicode. O <xref:System.String.IsNullOrWhiteSpace%2A> método interpreta qualquer caractere que retorna um valor de `true` quando ele é passado para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método como um caractere de espaço em branco.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de cadeia de caracteres e, em seguida, passa cada elemento da matriz para o <xref:System.String.IsNullOrWhiteSpace%2A> método.  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena os elementos de uma matriz especificada ou os membros de uma coleção, usando o separador especificado entre cada elemento ou membro.</summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador.<paramref name="separator" /> estará incluído na cadeia de caracteres retornada somente se <paramref name="values" /> tiver mais de um elemento.</param>
        <param name="values">Uma coleção que contém as cadeias de caracteres a serem concatenadas.</param>
        <summary>Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />, usando o separador especificado entre cada membro.</summary>
        <returns>Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
 <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres. Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta). O exemplo a seguir passa um `List(Of String)` objeto que contém as letras maiusculas ou minúsculas do alfabeto para uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M"). O `IEnumerable(Of String)` coleção retornada pela <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Object[]" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <paramref name="separator" /> estará incluído na cadeia de caracteres retornada somente se <paramref name="values" /> tiver mais de um elemento.</param>
        <param name="values">Uma matriz que contém os elementos a concatenar.</param>
        <summary>Concatena os elementos de uma matriz de objetos, usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres composta pelos elementos de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `separator` está `null` ou se qualquer elemento de `values` diferente do primeiro elemento é `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usado em vez disso. Consulte as notas de seção chamadores, se o primeiro elemento da `values` é `null`.  
  
 <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> é um método de conveniência que permite a concatenação de cada elemento em uma matriz de objetos sem uma conversão explícita de seus elementos em cadeias de caracteres. A representação de cadeia de caracteres de cada objeto na matriz é derivada por meio da chamada do objeto `ToString` método.  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado em uma matriz de inteiro, que, em seguida, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> método.  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Se o primeiro elemento da <paramref name="values" /> está <see langword="null" />, o <see cref="M:System.String.Join(System.String,System.Object[])" /> método concatene os elementos na <paramref name="values" /> , mas retorna <see cref="F:System.String.Empty" />. Um número de soluções alternativas para esse problema está disponível. É a maneira mais fácil atribuir um valor de <see cref="F:System.String.Empty" /> para o primeiro elemento da matriz, como o exemplo a seguir mostra.  
  
[!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para></block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <paramref name="separator" /> estará incluído na cadeia de caracteres retornada somente se <paramref name="value" /> tiver mais de um elemento.</param>
        <param name="value">Uma matriz que contém os elementos a concatenar.</param>
        <summary>Concatena todos os elementos de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres que consiste nos elementos em <paramref name="value" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="value" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "grape" e "pear" `Join(separator, value)` retorna "apple, laranja, grape, pear".  
  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer elemento em `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Join%2A> método.  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="value" Type="System.String[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">A cadeia de caracteres a ser usada como um separador. <paramref name="separator" /> estará incluído na cadeia de caracteres retornada somente se <paramref name="value" /> tiver mais de um elemento.</param>
        <param name="value">Uma matriz que contém os elementos a concatenar.</param>
        <param name="startIndex">O primeiro elemento em <paramref name="value" /> a ser usado.</param>
        <param name="count">O número de elementos de <paramref name="value" /> a ser usado.</param>
        <summary>Concatena os elementos especificados de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</summary>
        <returns>Uma cadeia de caracteres que consiste em cadeias de caracteres em <paramref name="value" /> delimitada pela cadeia de caracteres <paramref name="separator" />.  
  
- ou - 
 <see cref="F:System.String.Empty" /> se <paramref name="count" /> for zero, <paramref name="value" /> não tiver elementos ou <paramref name="separator" /> e todos os elementos de <paramref name="value" /> forem <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "grape" e "pear" `Join(separator, value, 1, 2)` retorna "laranja, grape".  
  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer elemento em `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
   
  
## Examples  
 O exemplo a seguir concatena dois elementos de uma matriz de nomes de frutas.  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="count" /> é menor que 0.  
  
- ou - 
 <paramref name="startIndex" /> mais <paramref name="count" /> é maior que o número de elementos em <paramref name="value" />.</exception>
        <exception cref="T:System.OutOfMemoryException">Sem memória.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos membros de <paramref name="values" />.</typeparam>
        <param name="separator">A cadeia de caracteres a ser usada como um separador.<paramref name="separator" /> estará incluído na cadeia de caracteres retornada somente se <paramref name="values" /> tiver mais de um elemento.</param>
        <param name="values">Uma coleção que contém os objetos a serem concatenados.</param>
        <summary>Concatena os membros de uma coleção, usando o separador especificado entre cada membro.</summary>
        <returns>Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />. Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar. Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.  
  
 <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> é um método de conveniência que permite a concatenação de cada membro de um <xref:System.Collections.Generic.IEnumerable%601> coleção sem primeiro convertê-las em cadeias de caracteres. A representação de cadeia de caracteres de cada objeto na <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada por meio da chamada do objeto `ToString` método.  
  
 Esse método é determinado útil com expressões de consulta integrada à linguagem LINQ (consulta). Por exemplo, o código a seguir define um muito simples `Animal` classe que contém o nome do animal e a ordem ao qual ele pertence. Em seguida, ele define uma <xref:System.Collections.Generic.List%601> objeto que contém um número de `Animal` objetos. O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método de extensão é chamado para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Roedor". O resultado é passado para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100. Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo inteiro, que, em seguida, ele passa para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="values" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Relata a posição de índice de base zero da última ocorrência de uma cadeia de caracteres ou um caractere Unicode especificado nesta instância. O método retorna -1 caso o caractere ou a cadeia de caracteres não seja encontrado nessa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância.</summary>
        <returns>A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 Esse método começa a procurar na última posição de caracteres dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir define uma `ExtractFilename` método que usa o <xref:System.String.LastIndexOf%28System.Char%29> método para localizar o último caractere de separador de diretório em uma cadeia de caracteres e extrair o nome do arquivo da cadeia de caracteres. Se o arquivo existir, o método retorna o nome do arquivo sem o caminho.  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</summary>
        <returns>A posição do índice inicial com base em zero de <paramref name="value" />, se a cadeia de caracteres for encontrada, ou -1, caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na posição do último caractere dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%28System.String%29> método sempre retorna <xref:System.String.Length%2A?displayProperty=nameWithType> -1, que representa a última posição de índice na instância atual. No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%29> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen condicional é um caractere ignorável, o resultado é o mesmo como se o hífen não havia sido incluído no `value`. Ao procurar por um hífen somente, o método retorna 6 e 5. Esses valores correspondem ao índice do último caractere em duas cadeias de caracteres.  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 O exemplo a seguir remove a abertura e fechamento de marcas HTML de uma cadeia de caracteres se as marcas begin e end a cadeia de caracteres. Se uma cadeia de caracteres termina com um fechamento caractere de colchete (">"), o exemplo usa o <xref:System.String.LastIndexOf%2A> método para localizar o início da marca de fim.  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para localizar o último índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> -1. esse método inicia a pesquisa no `startIndex` posição dessa instância e continua para trás até o início da instância atual até que de caracteres `value` for encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma cadeia de caracteres, trabalhando no final da cadeia de caracteres para o início da cadeia de caracteres.  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na `startIndex` caracteres a posição dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar uma subcadeia de caracteres que inclui um hífen (U + 00AD) e que precede ou inclui o "m" final em uma cadeia de caracteres. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, pois o hífen na cadeia de caracteres de pesquisa é ignorado, chamando o método para localizar uma subcadeia de caracteres que consiste o hífen e o "m" retorna a posição do "m" na cadeia de caracteres, enquanto que chamá-lo para localizar um substrin g que consiste o hífen e "n" retorna a posição de "n". Quando a cadeia de caracteres de pesquisa contém apenas o hífen, o método retorna o índice do "m", que representa o valor de `startIndex`.  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na cadeia de caracteres de destino, trabalhando no final da cadeia de caracteres de destino para o início da cadeia de caracteres de destino.  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para localizar o índice de uma subcadeia de caracteres que precede uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual. Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial com base em zero do parâmetro <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 caso não seja. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
 A pesquisa começa na posição do último caractere dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="options" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método sempre retorna <see cref="P:System.String.Length" /> -1, que representa a última posição de índice na instância atual.  
  
No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, como o hífen é um caractere ignorável, uma pesquisa sensível à cultura retorna o mesmo valor que será retornado se o hífen não foram incluídos na cadeia de caracteres de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen em uma cadeia de caracteres com êxito e relata que está ausente da segunda cadeia de caracteres.  
  
[!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O caractere Unicode a ser buscado.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice que começa com zero da última ocorrência do caractere Unicode especificado em uma subcadeia de caracteres dentro dessa instância. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 Esse método começa a procurar na `startIndex` caracteres de posição e continua para trás até o início dessa instância até que `value` for encontrado ou `count` foram examinadas posições de caractere. Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma subcadeia de caracteres, trabalhando no final da subcadeia de caracteres para o início da subcadeia de caracteres.  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" /> + 1 é menor que zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na `startIndex` caracteres a posição dessa instância e continua para trás até o início até que `value` for encontrado ou `count` foram examinadas posições de caractere. Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres.  
  
 Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
 Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%2A> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa. No exemplo a seguir, o <xref:System.String.LastIndexOf%2A> método é usado para localizar a posição de um hífen (U + 00AD) em dois caracteres que precedem o último "m" de duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na subcadeia de caracteres, trabalhando no final da subcadeia de caracteres para o início da subcadeia de caracteres.  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é negativo.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é negativo.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é maior que o tamanho dessa instância.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> - <paramref name="count" />+ 1 especifica uma posição que não está dentro desta instância.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="start" /> é menor que -1 ou maior que zero.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> é maior que 1.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para executar essa operação usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres. Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na `startIndex` caracteres de posição e continua para trás até que `value` for encontrado ou a posição do primeiro caractere foi examinada. Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m", começando com o último "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
[!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para></block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="startIndex" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="3" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser buscada.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <param name="comparisonType">Um dos valores de enumeração que especifica as regras para a pesquisa.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere. Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</summary>
        <returns>A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />. Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero. Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.  
  
 A pesquisa começa na `startIndex` caracteres de posição e continua para trás até que `value` for encontrado ou `count` foram examinadas posições de caractere. Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres.  
  
 O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.  
  
   
  
## Examples  
 A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é negativo.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é negativo.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é maior que o tamanho dessa instância.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> + 1 - <paramref name="count" /> especifica uma posição que não está dentro dessa instância.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="start" /> é menor que -1 ou maior que zero.  
  
- ou - 
A instância atual é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> é maior que 1.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
        <block subset="none" type="usage"><para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  
  
No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguido por um "m" em todos, mas a primeira posição de caractere antes do final "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen, seguido por um "m", o método não retorna o índice do hífen virtual, mas em vez disso, retorna o índice do "m", quando ele executa uma comparação sensível à cultura. O método só retorna o índice do hífen condicional na primeira cadeia de caracteres quando executa uma comparação ordinal.  
  
[!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode. O método retorna -1 caso os caracteres na matriz não sejam encontrados nessa instância.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método começa a procurar na última posição de caracteres dessa instância e continua para trás até o início até um caractere em `anyOf` for encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode. A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método começa a procurar na `startIndex` de caracteres dessa instância e continua para trás até o início até um caractere na posição de `anyOf` for encontrado ou a posição do primeiro caractere foi examinada. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> especifica uma posição que não está dentro dessa instância.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</param>
        <param name="startIndex">A posição inicial da pesquisa. A pesquisa continua de <paramref name="startIndex" /> até o início dessa instância.</param>
        <param name="count">O número de posições de caractere a serem examinadas.</param>
        <summary>Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode. A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</summary>
        <returns>A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A numeração de índice começa do zero.  
  
 Esse método começa a procurar na `startIndex` de caracteres dessa instância e continua para trás até o início até um caractere na posição do `anyOf` for encontrado ou `count` foram examinadas posições de caractere. A pesquisa diferencia maiúsculas de minúsculas.  
  
 Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos. Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.  
  
   
  
## Examples  
 O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="anyOf" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.  
  
- ou - 
A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> menos <paramref name="count" /> + 1 é menor que zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de caracteres no objeto <see cref="T:System.String" /> atual.</summary>
        <value>O número de caracteres na cadeia de caracteres atual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Length%2A> propriedade retorna o número de <xref:System.Char> objetos nesta instância, não o número de caracteres Unicode. O motivo é que um caractere Unicode pode ser representado por mais de um <xref:System.Char>. Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe para trabalhar com cada caractere Unicode em vez de cada <xref:System.Char>.  
  
 Em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres. No .NET, um caractere nulo pode ser inserido em uma cadeia de caracteres. Quando uma cadeia de caracteres inclui um ou mais caracteres de null, eles são incluídos no comprimento da cadeia de caracteres total. Por exemplo, na seguinte cadeia de caracteres, as subcadeias de caracteres "abc" e "def" são separados por um caractere nulo. O <xref:System.String.Length%2A> propriedade retorna 7, que indica que ele inclui os seis caracteres alfabéticos, bem como o caractere nulo.  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Length%2A> propriedade.  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres cuja representação binária está em um formulário de normalização Unicode específico.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C Unicode.</summary>
        <returns>Uma nova cadeia de caracteres normalizada cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":  
  
-   U+1EAF  
  
-   U+0103 U+0301  
  
-   U+0061 U+0306 U+0301  
  
 A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. .NET oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, eles podem ser comparados usando a comparação ordinal.  
  
 Para normalizar e comparar duas cadeias de caracteres, faça o seguinte:  
  
1.  Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.  
  
2.  Chamar o <xref:System.String.Normalize> método normalizar as cadeias de caracteres para o formulário de normalização C.  
  
3.  Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinais, tais como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento. Para classificar uma matriz de cadeias de caracteres normalizadas, passe uma `comparer` valor de <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado, em seguida, lista os pontos de código na cadeia de caracteres normalizada.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage"><para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">Um formato de normalização Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização Unicode especificado.</summary>
        <returns>Uma nova cadeia de caracteres cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização especificado pelo parâmetro <paramref name="normalizationForm" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos. A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.  
  
 O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere. A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes. .NET oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, eles podem ser comparados usando a comparação ordinal.  
  
 Para normalizar e comparar duas cadeias de caracteres, faça o seguinte:  
  
1.  Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.  
  
2.  Chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29> método normalizar as cadeias de caracteres a um formulário de normalização especificada.  
  
3.  Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinais, tais como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento. Para classificar uma matriz de cadeias de caracteres normalizadas, passe uma `comparer` valor de <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.  
  
4.  Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.  
  
 Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado, em seguida, lista os pontos de código na cadeia de caracteres normalizada.  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A instância atual contém caracteres Unicode inválidos.</exception>
        <block subset="none" type="usage"><para>O método <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método pode lançar uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para></block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se duas cadeias de caracteres especificadas têm o mesmo valor.</summary>
        <returns><see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.op_Equality%2A> método define a operação do operador de igualdade para os <xref:System.String> classe. Ele permite que o código, como a mostrada na seção de exemplo. O operador, por sua vez, chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e insensível à cultura).  
  
> [!NOTE]
>  O compilador do Visual Basic não resolve o operador de igualdade como uma chamada para o <xref:System.String.op_Equality%2A> método. Em vez disso, o operador de igualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o operador de igualdade.  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <param name="b">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</param>
        <summary>Determina se duas cadeias de caracteres especificadas têm valores diferentes.</summary>
        <returns><see langword="true" /> se o valor de <paramref name="a" /> for diferente do valor de <paramref name="b" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.op_Inequality%2A> método define a operação do operador de desigualdade para o <xref:System.String> classe.   Ele permite que o código, como a mostrada na seção exemplos.  
  
 O <xref:System.String.op_Inequality%2A> operador por sua vez chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e insensível à cultura).  
  
> [!NOTE]
>  O compilador do Visual Basic não resolve o operador de desigualdade como uma chamada para o <xref:System.String.op_Inequality%2A> método. Em vez disso, o operador de desigualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o operador de desigualdade.  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres de um comprimento especificado no qual o início da cadeia de caracteres atual é preenchido com espaços ou com um caractere Unicode especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os com espaços à esquerda, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de espaços necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um espaço de Unicode é definido como 0x0020 hexadecimal.  
  
 O <xref:System.String.PadLeft%28System.Int32%29> método preenche o início da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte direita da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à esquerda para que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> é menor que zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <param name="paddingChar">Um caractere de preenchimento de Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os à esquerda com um caractere Unicode especificado, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> método preenche o início da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte direita da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com líderes `paddingChar` caracteres de modo que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> é menor que zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres de um comprimento especificado no qual o fim da cadeia de caracteres atual é preenchido com espaços ou com um caractere Unicode especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os com espaços à direita, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com quantos caracteres forem necessários para criar um tamanho de <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um espaço de Unicode é definido como 0x0020 hexadecimal.  
  
 O <xref:System.String.PadRight%28System.Int32%29> método preenche o final da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte esquerda da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à direita, para que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> é menor que zero.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</param>
        <param name="paddingChar">Um caractere de preenchimento de Unicode.</param>
        <summary>Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os à direita com um caractere Unicode especificado, para um tamanho total especificado.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />. No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente. Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> método preenche o final da cadeia de caracteres retornada. Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte esquerda da cadeia de caracteres.  
  
> [!NOTE]
>  Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com à direita `paddingChar` caracteres de modo que seu tamanho total é `totalWidth` caracteres.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="totalWidth" /> é menor que zero.</exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres na qual um número especificado de caracteres da cadeia de caracteres atual é excluído.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição baseada em zero para iniciar a exclusão de caracteres.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual, começando na posição especificada e continuando até a última posição, foram excluídos.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa cadeia de caracteres, exceto os caracteres removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseados em zero. O valor da `startIndex` parâmetro pode variar de zero, a menos que o comprimento da instância de cadeia de caracteres.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres da posição `startIndex` ao final da cadeia de caracteres original tenha sido removido.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.Remove%2A> método. O próximo ao último caso remove todo o texto a partir do índice especificado até o final da cadeia de caracteres. O último caso remove três caracteres, começando do índice especificado.  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> especifica uma posição que não está nessa cadeia de caracteres.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição baseada em zero para iniciar a exclusão de caracteres.</param>
        <param name="count">O número de caracteres a ser excluído.</param>
        <summary>Retorna uma nova cadeia de caracteres em que um número especificado de caracteres na instância atual que começa na posição especificada foi excluído.</summary>
        <returns>Uma nova cadeia de caracteres equivalente a essa instância, exceto os caracteres removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseados em zero. O valor da `startIndex` parâmetro pode variar de zero, a menos que o comprimento da instância de cadeia de caracteres.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual o número de caracteres especificado pelo `count` parâmetro foram removidos. Os caracteres são removidos na posição especificada por `startIndex`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode remover o nome do meio de um nome completo.  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> especificam uma posição fora dessa instância.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências de um caractere Unicode especificado ou <see cref="T:System.String" /> na cadeia de caracteres atual são substituídas por outro caractere Unicode especificado ou por <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">O caractere Unicode a ser substituído.</param>
        <param name="newChar">O caractere Unicode para substituir todas as ocorrências de <paramref name="oldChar" />.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências de um caractere Unicode especificado nessa instância são substituídas por outro caractere Unicode especificado.</summary>
        <returns>Uma cadeia de caracteres equivalente a essa instância, com exceção de que todas as instâncias de <paramref name="oldChar" /> são substituídas por <paramref name="newChar" />. Se <paramref name="oldChar" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e insensível à cultura) para localizar `oldChar`.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldChar` são substituídos por `newChar`.  
  
 Como esse método retorna a cadeia de caracteres modificada, é possível encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original. Chamadas de método são executadas da esquerda para a direita. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir cria uma lista de valores separados por vírgula, substituindo vírgulas para os espaços em branco entre uma série de números.  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">A cadeia de caracteres a ser substituída.</param>
        <param name="newValue">A cadeia de caracteres para substituir todas as ocorrências de <paramref name="oldValue" />.</param>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências de uma cadeia de caracteres especificada na instância atual são substituídas por outra cadeia de caracteres especificada.</summary>
        <returns>Uma cadeia de caracteres equivalente à atual cadeia de caracteres, com exceção de que todas as instâncias de <paramref name="oldValue" /> são substituídas por <paramref name="newValue" />. Se <paramref name="oldValue" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `newValue` está `null`, todas as ocorrências de `oldValue` são removidos.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldValue` são substituídos por `newValue`.  
  
 Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e insensível à cultura) para localizar `oldValue`.  
  
 Como esse método retorna a cadeia de caracteres modificada, é possível encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original. Chamadas de método são executadas da esquerda para a direita. O exemplo a seguir fornece uma ilustração.  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar o <xref:System.String.Replace%2A> método para corrigir um erro de ortografia.  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="oldValue" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="oldValue" /> é a cadeia de caracteres vazia ("").</exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="newValue" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma matriz de cadeia de caracteres que contém as subcadeias de caracteres nesta instância delimitadas por elementos de uma cadeia de caracteres especificada ou da matriz de caracteres Unicode.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.String.Split%2A> é usado para dividir uma cadeia de caracteres delimitada em subcadeias de caracteres. Você pode usar uma matriz de caracteres para especificar zero, um ou vários caracteres de delimitação (o <xref:System.String.Split%28System.Char%5B%5D%29> método), ou você pode usar uma matriz de caracteres para especificar zero, uma ou várias cadeias de caracteres de delimitação. Sobrecargas do <xref:System.String.Split%2A> método permitem que você limite o número de subcadeias de caracteres retornada pelo método (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> método), para determinar se cadeias de caracteres vazias são incluídas nas subcadeias de caracteres retornadas (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> métodos, ou ambos (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> métodos).  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

### <a name="alternatives-to-stringsplit"></a>Alternativas para String. Split

 O <xref:System.String.Split%2A> método nem sempre é a melhor maneira de dividir uma cadeia de caracteres delimitada em subcadeias de caracteres. Se você não deseja extrair todas as subcadeias de caracteres de uma cadeia de caracteres delimitada, ou se você quiser analisar uma cadeia de caracteres com base em um padrão em vez de um conjunto de caracteres do delimitador, considere alternativas a seguir.  
  
### <a name="regular-expressions"></a>Expressões regulares  
 Se suas cadeias de caracteres estão em conformidade com um padrão fixo, você pode usar uma expressão regular para extrair e manipular seus elementos. Por exemplo, se as cadeias de caracteres assumem a forma "*número* *operando* *número*" você pode usar um [expressão regular](~/docs/standard/base-types/regular-expressions.md) para extrair e lidar com o elementos da cadeia de caracteres. Veja um exemplo:  
  
 [!code-csharp-interactive[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 O padrão de expressão regular `(\d+)\s+([-+*/])\s+(\d+)` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`(\d+)`|Faça a correspondência de um ou mais dígitos decimais. Este é o primeiro grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`([-+*/])`|Corresponder ao sinal de um operador aritmético (+, -, *, ou /). Este é o segundo grupo de captura.|  
|`\s+`|Corresponde a um ou mais caracteres de espaço em branco.|  
|`(\d+)`|Faça a correspondência de um ou mais dígitos decimais. Este é o terceiro grupo de captura.|  
  
 Você também pode usar uma expressão regular para extrair subcadeias de caracteres de uma cadeia de caracteres com base em um padrão em vez de um conjunto fixo de caracteres. Isso é um cenário comum quando qualquer uma dessas condições ocorre:  
  
-   Um ou mais dos caracteres delimitador não sempre funciona como um delimitador no <xref:System.String> instância.  
  
-   A sequência e o número de caracteres de delimitador é desconhecido ou variável.  
  
 Por exemplo, o <xref:System.String.Split%2A> método não pode ser usado para dividir a cadeia de caracteres a seguir, porque o número de `\n` (em c#) ou `vbCrLf` (no Visual Basic) caracteres é variável, e eles não servem sempre como delimitadores.  
  
```text
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
```  
  
 Uma expressão regular pode dividir essa cadeia de caracteres com facilidade, como mostra o exemplo a seguir.  
  
 [!code-csharp-interactive[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 O padrão de expressão regular `\[([^\[\]]+)\]` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\[`|Corresponde a um colchete de abertura.|  
|`([^\[\]]+)`|Corresponde a qualquer caractere que não é uma colchete de abertura ou um fechamento uma ou mais vezes. Este é o primeiro grupo de captura.|  
|`\]`|Corresponde a um colchete de fechamento.|  
  
 O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método é quase idêntico ao <xref:System.String.Split%2A?displayProperty=nameWithType>, exceto que ele divide uma cadeia de caracteres com base em um padrão de expressão regular, em vez de um conjunto de caracteres fixa. Por exemplo, o exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir uma cadeia de caracteres que contém as subcadeias de caracteres delimitadas por várias combinações de outros caracteres e hifens.  
  
 [!code-csharp-interactive[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 O padrão de expressão regular `\s-\s?[+*]?\s?-\s` é definido como este:  
  
|Padrão|Descrição|  
|-------------|-----------------|  
|`\s-`|Corresponde a um caractere de espaço em branco seguido por um hífen.|  
|`\s?`|Faça a correspondência de nenhum ou um caractere de espaço em branco.|  
|`[+*]?`|Corresponde a zero ou uma ocorrência de qualquer um de + ou * caractere.|  
|`\s?`|Faça a correspondência de nenhum ou um caractere de espaço em branco.|  
|`-\s`|Corresponde a um hífen seguido por um caractere de espaço em branco.|  
  
### <a name="search-methods-and-the-substring-method"></a>Métodos de pesquisa e o método Substring  
 Se você não estiver interessado em todas as subcadeias de caracteres em uma cadeia de caracteres, você talvez prefira trabalhar com um dos métodos de comparação de cadeia de caracteres que retorna o índice no qual a correspondência começa. Em seguida, você pode chamar o <xref:System.String.Substring%2A> método para extrair a subcadeia de caracteres que você deseja. Os métodos de comparação de cadeia de caracteres incluem:  
  
-   <xref:System.String.IndexOf%2A>, que retorna o índice baseado em zero da primeira ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.IndexOfAny%2A>, que retorna o índice baseado em zero na instância atual de cadeia de caracteres da primeira ocorrência de qualquer caractere em uma matriz de caracteres.  
  
-   <xref:System.String.LastIndexOf%2A>, que retorna o índice baseado em zero da última ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.  
  
-   <xref:System.String.LastIndexOfAny%2A>, que retorna um índice baseado em zero na instância atual de cadeia de caracteres da última ocorrência de qualquer caractere em uma matriz de caracteres.  
  
 O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para localizar os períodos em uma cadeia de caracteres. Ele usa o <xref:System.String.Substring%2A> método para retornar frases completas.  
  
 [!code-csharp-interactive[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma cadeia de caracteres é delimitada por um conjunto conhecido de caracteres, você pode usar o <xref:System.String.Split%28System.Char%5B%5D%29> método para separá-lo em subcadeias de caracteres.   
  
### <a name="return-value-details"></a>Detalhes do valor de retorno  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada. Por exemplo, se a matriz de separador inclui o caractere "-" e o valor da instância atual de cadeia de caracteres "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Se dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento correspondente na matriz retornada contém <xref:System.String.Empty>. Estes são alguns exemplos:  
  
|Valor da cadeia de caracteres|Separador|Matriz retornada|  
|------------------|---------------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c}) (Visual Basic)|{"42", "", "12", "", "19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"42", "", "12", "", "19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|null (C#)<br /><br /> Nada (Visual Basic)|{"Darb", "Smarba"}|  
  
### <a name="the-separator-array"></a>A matriz de separador  
 Cada elemento do separador define um delimitador separado que consiste em um único caractere. Se o `separator` argumento for `null` ou não contiver caracteres, o método trata caracteres de espaço em branco como delimitadores. Os caracteres de espaço em branco são definidos por padrão; Unicode elas retornam `true` se eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
### <a name="stringsplitchar-and-compiler-overload-resolution"></a>Resolução de sobrecarga do compilador e String.Split(Char[])  
 Embora o único parâmetro para essa sobrecarga de <xref:System.String.Split%2A?displayProperty=nameWithType> é uma matriz de caracteres, você pode chamá-lo com um único caractere, como mostra o exemplo a seguir.  
  
 [!code-csharp-interactive[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 Porque o `separator` parâmetro seja decorado com o <xref:System.ParamArrayAttribute> atributo, os compiladores irá interpretar um único caractere como uma matriz de caracteres de elemento único. Isso não for o caso para outros <xref:System.String.Split%2A?displayProperty=nameWithType> sobrecargas que incluem uma `separator` parâmetro; deve passar essas sobrecargas explicitamente uma matriz de caracteres como o `separator` argumento.  
  
### <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%28System.Char%5B%5D%29> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por um ou mais dos caracteres no `separator` de matriz e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%28System.Char%5B%5D%29> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Se seu aplicativo exija desempenho ideal ou gerenciar a alocação de memória é essencial para seu aplicativo, considere usar o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método. Você também tem a opção de usar o <xref:System.String.Compare%2A> método para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Para dividir uma cadeia de caracteres em um caractere separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar um caractere separador na cadeia de caracteres. Para dividir uma cadeia de caracteres em uma cadeia de caracteres de separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar o primeiro caractere da cadeia de caracteres de separador. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
## Examples  
 O exemplo a seguir demonstra como extrair palavras individuais de um bloco de texto, tratando o espaço em branco e sinais de pontuação como delimitadores. A matriz de caracteres passada para o `separator` parâmetro do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método consiste em um caractere de espaço e um caractere de tabulação, junto com alguns símbolos de pontuação comuns.  
  
 [!code-csharp-interactive[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz. Especifique também o número máximo de subcadeias de caracteres a serem retornadas.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.  
  
 Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância. Se `count` for zero, uma matriz vazia será retornada.  
  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Se dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.  
  
 A tabela a seguir fornece exemplos.  
  
|Valor da cadeia de caracteres|Separador|Count|Matriz retornada|  
|------------------|---------------|-----------|--------------------|  
|"42, 12, 19"|new Char[] {',', ' '} (C#)<br /><br /> Char() = {","c, " "c} (Visual Basic)|2|{"42", " 12, 19"}|  
|"42..12..19"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|4|{"42", "", "12", ".19"}|  
|"Banana"|new Char[] {'.'} (C#)<br /><br /> Char() = {"."c} (Visual Basic)|2|{"Banana"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] {} (C#)<br /><br /> Char() = {} (Visual Basic)|1|{"Darb\nSmarba"} (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] nulo (C#)<br /><br /> Char() = Nothing|2|{"Darb", "Smarba"}|  
|"Darb\nSmarba" (C#)<br /><br /> "Darb" & vbLf & "Smarba" (Visual Basic)|novo Char [] nulo (C#)<br /><br /> Char() = Nothing|100|{"Darb", "Smarba"}|  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como `count` afeta o número de cadeias de caracteres retornadas por <xref:System.String.Split%2A>.  
  
 [!code-csharp-interactive[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é negativo.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Detalhes do valor de retorno  
 Os caracteres delimitadores (os caracteres no `separator` matriz) não estão incluídos nos elementos da matriz retornada. Por exemplo, se o `separator` matriz inclui o caractere "-" e o valor da instância atual de cadeia de caracteres "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.  
  
 Cada elemento da `separator` define um delimitador separado que consiste em um único caractere. Se o `options` argumento for <xref:System.StringSplitOptions.None>e dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty?displayProperty=nameWithType>. Por exemplo, se `separator` inclui dois elementos, "-" e "\_", o valor da instância de cadeia de caracteres é "-\_aa -\_" e o valor da `options` argumento é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de cadeia de caracteres com os seguintes cinco elementos:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" caractere no índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" caractere no índice 0 e o caractere "_" no índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o caractere "_" no índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o "-" caractere no índice 5.  
  
### <a name="the-separator-array"></a>A matriz de separador  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga do compilador falha. Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
### <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por um ou mais dos caracteres no `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em subcadeias de caracteres com base nas cadeias de caracteres em uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando uma cadeia de caracteres é delimitada por um conjunto conhecido de cadeias de caracteres, você pode usar o <xref:System.String.Split%2A> método para separá-lo em subcadeias de caracteres.  
  
### <a name="return-value-details"></a>Detalhes do valor de retorno  
 Cadeias de caracteres de delimitador não estão incluídas nos elementos da matriz retornada. Por exemplo, se o `separator` matriz inclui a cadeia de caracteres "-" e o valor da instância atual de cadeia de caracteres "aa - bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".  
  
 Se esta instância não contém qualquer uma das cadeias de caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.  
  
 Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.  
  
 Cada elemento da `separator` define um delimitador separado que consiste em um ou mais caracteres. Se o `options` argumento for <xref:System.StringSplitOptions.None>e dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty?displayProperty=nameWithType>. Por exemplo, se `separator` inclui dois elementos, "-" e "\_", o valor da instância de cadeia de caracteres é "-\_aa -\_" e o valor da `options` argumento é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de cadeia de caracteres com os seguintes cinco elementos:  
  
1.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" a subcadeia de caracteres no índice 0.  
  
2.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" subcadeia de caracteres no índice 0 e a subcadeia de caracteres "_" no índice 1.  
  
3.  "aa",  
  
4.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue a subcadeia de caracteres "_" no índice 4.  
  
5.  <xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o "-" a subcadeia de caracteres no índice 5.  
  
### <a name="the-separator-array"></a>A matriz de separador  
 Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador. Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string". Retorna a matriz de quatro elementos a seguir: {"This", "is", "a", "string". }.  
  
 Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.  
  
 Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga do compilador falha. Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
### <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais das cadeias de caracteres a `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
 O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").  
  
 Para evitar resultados ambíguos quando cadeias de caracteres no `separator` têm caracteres em comum, o <xref:System.String.Split%2A> operação continua desde o início até o final do valor da instância e corresponde ao primeiro elemento no `separator` que é igual a um delimitador no instância. A ordem na qual as subcadeias de caracteres são encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.  
  
 Por exemplo, considere uma instância cujo valor é "abcdef". Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação de divisão seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "f". Isso ocorre porque a subcadeia de caracteres na instância, "bcde" é encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.  
  
 No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação de divisão seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "ef". Isso ocorre porque "bcd" é o primeiro delimitador no `separator` que corresponde a um delimitador na instância. Se a ordem dos separadores de foi revertida de modo que o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "def".  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a diferença nas matrizes retornado ao chamar uma cadeia de caracteres <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> método com seus `options` parâmetro igual a <xref:System.StringSplitOptions.None?displayProperty=nameWithType> e <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.  
  
 [!code-csharp-interactive[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 O exemplo a seguir define uma matriz de separadores que incluem a pontuação e caracteres de espaço em branco. Passar essa matriz, juntamente com um valor de <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> para o <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> método retorna uma matriz que consiste em palavras individuais da cadeia de caracteres.  
  
 [!code-csharp-interactive[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 Observe que o método é chamado com o `options` argumento definido como <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>. Isso impede que a matriz retornada incluindo <xref:System.String.Empty?displayProperty=nameWithType> valores que representam correspondências de subcadeia de caracteres vazia entre sinais de pontuação e caracteres de espaço em branco.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.  
  
 Se esta instância não contém nenhum dos caracteres na `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância. Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha. Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo de NULL. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 Se o `count` parâmetro é zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia é retornada.  
  
 Cada elemento de `separator` define um caractere delimitador à parte. Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="count" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="options" Type="System.StringSplitOptions" Index="2" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="separator">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</param>
        <param name="count">O número máximo de subcadeias de caracteres a serem retornadas.</param>
        <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</param>
        <summary>Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nas cadeias de caracteres de uma matriz. Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</summary>
        <returns>Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />. Para obter mais informações, consulte a seção Comentários.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
### <a name="return-value-details"></a>Detalhes do valor de retorno  
 Cadeias de caracteres de delimitador não estão incluídas nos elementos da matriz retornada.  
  
 Se esta instância não contém qualquer uma das cadeias de caracteres `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância. Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores. Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>. No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha. Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`. O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 Se o `count` parâmetro é zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia é retornada.  
  
 Cada elemento da `separator` define um delimitador separado que consiste em um ou mais caracteres. Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.  
  
 Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.  
  
 Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.  
  
### <a name="the-separator-array"></a>A matriz de separador  
 Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador. Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string". retornará essa matriz de quatro elementos: {"This", "is", "a", "string". }.  
  
### <a name="comparison-details"></a>Detalhes de comparação  
 O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais das cadeias de caracteres a `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.  
  
 O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas. Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.  
  
 O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").  
  
 Para evitar resultados ambíguos quando cadeias de caracteres no `separator` têm caracteres em comum, o <xref:System.String.Split%2A> método continua desde o início até o final do valor da instância e corresponde ao primeiro elemento no `separator` que é igual a um delimitador no instância. A ordem na qual as subcadeias de caracteres são encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.  
  
 Por exemplo, considere uma instância cujo valor é "abcdef". Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação de divisão seria "a" e "f". Isso ocorre porque a subcadeia de caracteres na instância, "bcde" é encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.  
  
 No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação de divisão seria "a" e "ef". Isso ocorre porque "bcd" é o primeiro delimitador no `separator` que corresponde a um delimitador na instância. Se a ordem dos separadores de foi revertida de modo que o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria "a" e "def".  
  
### <a name="performance-considerations"></a>Considerações sobre desempenho  
 Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz. Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.  
  
 Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres. Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora. Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.  
  
 Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método. Isso reduz significativamente a sobrecarga adicional de cada chamada de método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp-interactive[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count" /> é negativo.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</exception>
        <block subset="none" type="usage"><para>No [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] e em versões anteriores, caso o método <see cref="M:System.String.Split(System.Char[])" /> receba um <paramref name="separator" /> que é <see langword="null" /> ou não contém nenhum caractere, o método usa um conjunto um pouco diferente de caracteres para dividir a cadeia de caracteres do método <see cref="M:System.String.Trim(System.Char[])" /> para cortar a cadeia de caracteres. Começando com o .NET Framework 4, ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Determina se o começo desta instância de cadeia de caracteres corresponde a uma cadeia de caracteres especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <summary>Determina se o começo desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</summary>
        <returns><see langword="true" /> se o <paramref name="value" /> corresponde ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método compara `value` à subcadeia de caracteres no início desta instância que é o mesmo tamanho que `value`e retorna uma indicação se eles forem iguais. Como iguais `value` deve ser uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início dessa instância.  
  
 Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.  
  
   
  
## Examples  
 O exemplo a seguir define uma `StripStartTags` método que usa o <xref:System.String.StartsWith%28System.String%29> método para remover o HTML começar marcas desde o início de uma cadeia de caracteres. Observe que o `StripStartTags` método é chamado recursivamente para garantir que as várias marcas de início HTML no início da linha são removidas. O exemplo não remove as marcas HTML inseridas em uma cadeia de caracteres.  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para determinar se uma cadeia de caracteres começa com uma subcadeia de caracteres específica usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para></block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="comparisonType" Type="System.StringComparison" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <param name="comparisonType">Um dos valores de enumeração que determina como essa cadeia de caracteres e <paramref name="value" /> são comparados.</param>
        <summary>Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado à opção de comparação especificada.</summary>
        <returns><see langword="true" /> se essa instância começar com <paramref name="value" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.StartsWith%2A> método compara o `value` parâmetro à subcadeia de caracteres no início dessa cadeia de caracteres e retorna um valor que indica se eles são iguais. Para que seja igual, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve corresponder ao início dessa cadeia de caracteres. O tipo de comparação executada pelo <xref:System.String.StartsWith%2A> método depende do valor da `comparisonType` parâmetro. A comparação pode usar as convenções da cultura atual (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> e <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) ou a cultura invariável (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> e <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), ou pode consistir em uma comparação de caractere por caractere de pontos de código (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>). A comparação também pode ser diferencia maiusculas de minúsculas (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, ou <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), ou ele pode ignorar maiusculas e minúsculas (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).  
  
   
  
## Examples  
 O exemplo a seguir procura a cadeia de caracteres "a" no início de uma cadeia de caracteres mais tempo que começa com a palavra "The". Como a saída do exemplo mostra uma chamada para o <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> método que executa uma comparação que diferencia maiusculas de minúsculas mas insensível à cultura não corresponde a cadeia de caracteres, enquanto uma chamada que executa uma comparação insensitive cultura e maiusculas corresponde a cadeia de caracteres.  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 O exemplo a seguir determina se uma cadeia de caracteres começa com uma subcadeia de caracteres específica. Inicializa uma matriz bidimensional de cadeia de caracteres. O primeiro elemento na segunda dimensão contém uma cadeia de caracteres e o segundo elemento contém a cadeia de caracteres a ser pesquisado no início da primeira cadeia de caracteres. Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada. Observe que quando a instância de cadeia de caracteres contém uma ligadura, comparações sensíveis à cultura com seus caracteres consecutivos correspondam bem-sucedida.  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser comparada.</param>
        <param name="ignoreCase"><see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</param>
        <param name="culture">As informações culturais que determinam como essa cadeia de caracteres e <paramref name="value" /> são comparados. Se <paramref name="culture" /> for <see langword="null" />, a cultura atual será usada.</param>
        <summary>Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</summary>
        <returns><see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método compara os `value` parâmetro para a subcadeia de caracteres no início dessa cadeia de caracteres que é o mesmo tamanho que `value`e retorna um valor que indica se eles são iguais. Como iguais `value` deve ser uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início dessa instância.  
  
 Esse método executa uma comparação usando a cultura e maiusculas e minúsculas especificada.  
  
   
  
## Examples  
 O exemplo a seguir determina se uma cadeia de caracteres ocorre no início de outra cadeia de caracteres. O <xref:System.String.StartsWith%2A> método é chamado várias vezes com diferenciação de maiusculas e minúsculas e diferentes culturas que influenciam os resultados da pesquisa.  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera uma subcadeia de caracteres desta instância.  
  
Esse membro está sobrecarregado. Para informação completa sobre esse membro, incluindo sintaxe, uso e exemplos, clique em um nome na lista de sobrecargas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Index startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Index startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Index)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Index) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Index startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : Index -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Index" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="startIndex">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</param>
        <summary>Recupera uma subcadeia de caracteres desta instância. A subcadeia de caracteres começa em uma posição de caractere especificado e continua até o final da cadeia de caracteres.</summary>
        <returns>Uma cadeia de caracteres equivalente à subcadeia de caracteres que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você chama o <xref:System.String.Substring%28System.Int32%29> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa em uma posição de caractere especificado e termina no final da cadeia de caracteres. A posição do caractere inicial é baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1. Para extrair uma subcadeia de caracteres que começa em uma posição de caractere especificado e termina antes do final da cadeia de caracteres, chame o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres que começa no `startIndex` posição na cadeia de caracteres atual.  
  
 Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou sequência de caracteres, chame um método como <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> para obter o valor de `startIndex`. O segundo exemplo ilustra isso. ele extrai um valor de chave que inicia uma posição de caractere após o caractere "=".  
  
 Se `startIndex` é igual a zero, o método retorna a cadeia de caracteres original inalterada.  
   
  
## Examples  
 O exemplo a seguir demonstra a obtenção de uma subcadeia de caracteres de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere de igual na cadeia de caracteres. A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai o nome da chave, que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método. A chamada para o <xref:System.String.Substring%28System.Int32%29> método, em seguida, extrai o valor atribuído à chave. Ele começa em uma posição de caractere depois o caractere de igual e estende até o final da cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> for menor que zero ou maior que o comprimento dessa instância.</exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (Range range);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(valuetype System.Range range) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Range)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(Range range);" />
      <MemberSignature Language="F#" Value="member this.Substring : Range -&gt; string" Usage="string.Substring range" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="range" Type="System.Range" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="range">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</param>
        <param name="length">O número de caracteres na subcadeia de caracteres.</param>
        <summary>Recupera uma subcadeia de caracteres desta instância. A subcadeia de caracteres começa em uma posição de caractere especificado e tem um comprimento especificado.</summary>
        <returns>Uma cadeia de caracteres é equivalente à subcadeia de caracteres de comprimento <paramref name="length" /> que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância e <paramref name="length" /> for zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você chama o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa em uma posição de caractere especificado e termina antes do final da cadeia de caracteres. A posição do caractere inicial é baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1. Para extrair uma subcadeia de caracteres que começa na posição do caractere especificada e continua até o final da cadeia de caracteres, chame o <xref:System.String.Substring%28System.Int32%29> método.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres com `length` caracteres a partir de `startIndex` posição na cadeia de caracteres atual.  
  
 O `length` parâmetro representa o número total de caracteres a serem extraídos da instância atual de cadeia de caracteres. Isso inclui o caractere inicial foi encontrado no índice `startIndex`.  Em outras palavras, o <xref:System.String.Substring%2A> método tenta extrair caracteres de índice `startIndex` índice `startIndex`  +  `length` - 1.  
  
 Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou sequência de caracteres, chame um método como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o valor de `startIndex`.  
  
 Se a subcadeia de caracteres se estende do `startIndex` a uma sequência de caracteres especificada, você pode chamar um método, como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o índice do caractere final ou sequência de caracteres.  Em seguida, você pode converter esse valor em uma posição de índice na cadeia de caracteres da seguinte maneira:  
  
-   Se você procurar por um único caractere que é marcar o final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  -  `startIndex` + 1, onde `endIndex` é o valor de retorno a <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método. O exemplo a seguir extrai um bloco contínuo de caracteres "b" de uma cadeia de caracteres.  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   Se você já procurou por vários caracteres que são marcar o final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  +  `endMatchLength`  -  `startIndex`, onde `endIndex` é o valor retornado do <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método, e `endMatchLength` é o comprimento da sequência de caracteres que marca o final da subcadeia de caracteres. O exemplo a seguir extrai um bloco de texto que contém um XML `<definition>` elemento.  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   Se o caractere ou cadeia de caracteres não está incluída no final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  -  `startIndex`, onde `endIndex` é o valor de retorno a <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método.  
  
 Se `startIndex` é igual a zero e é igual a, o comprimento da cadeia de caracteres atual, o método retorna a cadeia de caracteres original inalterada.  
  
   
  
## Examples  
 O exemplo a seguir ilustra uma chamada simples para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método que extrai os dois caracteres de uma cadeia de caracteres começando na sexta posição de caractere (isto é, no índice cinco).  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método em três casos a seguir para isolar as subcadeias de caracteres dentro de uma cadeia de caracteres. Nos dois casos as subcadeias de caracteres são usadas em comparações e o terceiro caso uma exceção é gerada porque parâmetros inválidos foram especificados.  
  
-   Ele extrai o caractere único e a terceira posição na cadeia de caracteres (no índice 2) e o compara com um "c". Essa comparação retorna `true`.  
  
-   Ele extrai caracteres começando na quarta posição na cadeia de caracteres (no índice 3) e passa-o para o <xref:System.String.IsNullOrEmpty%2A> método. Isso retorna true, porque a chamada para o <xref:System.String.Substring%2A> retorno do método <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Ele tenta extrair um caractere começando na quarta posição na cadeia de caracteres. Como não há nenhum caractere nessa posição, a chamada de método lança um <xref:System.ArgumentOutOfRangeException> exceção.  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere de igual na cadeia de caracteres. A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai o nome da chave, que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método. A chamada para o <xref:System.String.Substring%28System.Int32%29> método, em seguida, extrai o valor atribuído à chave. Ele começa em uma posição de caractere depois o caractere de igual e estende até o final da cadeia de caracteres.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">A soma de <paramref name="startIndex" /> e <paramref name="length" /> indica uma posição que não está dentro dessa instância.  
  
- ou - 
 <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator" ExplicitInterfaceMemberName="System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</summary>
        <returns>Um enumerador fortemente tipado que pode ser usado para iterar pelo objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele pode ser usado somente quando o <xref:System.String> instância é convertida para um <xref:System.Collections.Generic.IEnumerable%601> objeto de interface. Para obter mais informações, consulte o método <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</summary>
        <returns>Um enumerador que pode ser usado para iterar pela coleção atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.Collections.IEnumerable>. Para obter mais informações, consulte o método <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Este parâmetro é ignorado.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" /> se o valor da cadeia de caracteres atual for <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> se o valor da cadeia de caracteres atual for <see cref="F:System.Boolean.FalseString" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor da cadeia de caracteres atual não é <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</summary>
        <returns>O caractere no índice 0 no objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">O tipo do objeto retornado.</param>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ChangeType%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidCastException">O valor do objeto <see cref="T:System.String" /> atual não pode ser convertido para o tipo especificado pelo parâmetro <paramref name="type" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt16.MaxValue" /> ou menor que <see cref="F:System.UInt16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</exception>
        <exception cref="T:System.OverflowException">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt32.MaxValue" /> ou menor que <see cref="F:System.UInt32.MinValue" /></exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>O valor convertido do objeto <see cref="T:System.String" /> atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>. A alternativa recomendada é chamar o <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia os caracteres nesta instância para uma matriz de caracteres Unicode.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Copia os caracteres nesta instância para uma matriz de caracteres Unicode.</summary>
        <returns>Uma matriz de caracteres Unicode cujos elementos são os caracteres individuais desta instância. Se a instância for uma cadeia de caracteres vazia, a matriz retornada estará vazia e terá comprimento zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia cada caractere (ou seja, cada <xref:System.Char> objeto) em uma cadeia de caracteres para uma matriz de caracteres. O primeiro caractere copiado está no índice zero da matriz de caracteres retornada; o último caractere copiado está no índice <xref:System.Array.Length%2A?displayProperty=nameWithType> - 1.  
  
 Para criar uma cadeia de caracteres dos caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor.  
  
 Para criar uma matriz de bytes que contém os caracteres codificados em uma cadeia de caracteres, instanciar apropriado <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> método. Algumas das codificações disponíveis no .NET standard incluem o seguinte:  
  
|Codificando|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obter mais informações, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.ToCharArray%2A> método para extrair os caracteres em uma cadeia de caracteres para uma matriz de caracteres. Ele exibe a cadeia de caracteres original e os elementos na matriz.  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 O exemplo a seguir define uma cadeia de caracteres que contém os caracteres que atuam como delimitadores em uma cadeia de caracteres delimitada. Em seguida, ele chama o <xref:System.String.ToCharArray%2A> método para criar uma matriz de caracteres que pode ser passada para o <xref:System.String.Split%28System.Char%5B%5D%29> método para separar a cadeia de caracteres delimitada em seus subcadeias de caracteres individuais.  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">A posição inicial de uma subcadeia de caracteres nesta instância.</param>
        <param name="length">O comprimento da subcadeia de caracteres nesta instância.</param>
        <summary>Copia os caracteres em uma subcadeia de caracteres especificada nesta instância para uma matriz de caracteres Unicode.</summary>
        <returns>Uma matriz de caracteres Unicode cujos elementos são o número de caracteres <paramref name="length" /> nesta instância a partir da posição do caractere <paramref name="startIndex" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia os caracteres em uma parte de uma cadeia de caracteres para uma matriz de caracteres. Para criar uma cadeia de caracteres de um intervalo de caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor.  
  
 O `startIndex` parâmetro é baseado em zero. Ou seja, o índice do primeiro caractere na instância de cadeia de caracteres é zero.  
  
 Se `length` for zero, a matriz retornada está vazia e tem comprimento zero. Se esta instância for `null` ou uma cadeia de caracteres vazia (""), a matriz retornada está vazia e tem comprimento zero.  
  
 Para criar uma matriz de bytes que contém os caracteres codificados em uma parte de uma cadeia de caracteres, instanciar apropriado <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> método. Algumas das codificações disponíveis no .NET standard incluem:  
  
|Codificando|Object|  
|--------------|------------|  
|ASCII|<xref:System.Text.ASCIIEncoding>|  
|UTF-7|<xref:System.Text.UTF7Encoding>|  
|UTF-8|<xref:System.Text.UTF8Encoding>|  
|UTF-16|<xref:System.Text.UnicodeEncoding>|  
|UTF-32|<xref:System.Text.UTF32Encoding>|  
  
 Para obter mais informações, consulte [codificação de caracteres no .NET](~/docs/standard/base-types/character-encoding.md).  
  
   
  
## Examples  
 O exemplo a seguir converte uma subcadeia de caracteres dentro de uma cadeia de caracteres em uma matriz de caracteres, em seguida, enumera e exibe os elementos da matriz.  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.  
  
- ou - 
 A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o comprimento desta instância.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em minúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em minúsculas.</summary>
        <returns>Uma cadeia de caracteres em letras minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método leva em conta as regras de maiusculas e minúsculas da cultura atual.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 A operação de maiusculas e minúsculas que resulta de chamar o <xref:System.String.ToLower> método considera as convenções de capitalização da cultura atual. Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos. Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToLower> método) e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte várias cadeias de caracteres casos mistas em minúsculas.  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para converter um caractere em minúsculas usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para seu <paramref name="culture" /> parâmetro.</para></block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
        <summary>Retorna uma cópia desta cadeia de caracteres convertida em minúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</summary>
        <returns>O equivalente da cadeia de caracteres atual em minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a maneira como o caso da cadeia de caracteres é alterado.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você passar o <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> método uma <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em consideração. Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte duas cadeias de caracteres em maiusculas para minúsculas usando as culturas Inglês-Estados Unidos e Turco-Turquia e, em seguida, compara as cadeias de caracteres em minúsculas. As cadeias de caracteres maiusculos são idênticas, exceto para cada ocorrência do Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, a outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em minúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</summary>
        <returns>O equivalente da cadeia de caracteres atual em minúsculas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cultura invariável representa uma cultura insensível. Ele está associado com o idioma inglês, mas não com um país ou região específica. Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de uma maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToLowerInvariant%2A> método. O <xref:System.String.ToLowerInvariant%2A> método é equivalente a `ToLower(CultureInfo.InvariantCulture)`. O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas. O <xref:System.String.ToLowerInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão sem diferenciação de cada palavra. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz diferencia maiusculas de minúsculas, com base na ordem de elementos na matriz de letras minúsculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Converte o valor dessa instância em um <see cref="T:System.String" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</summary>
        <returns>A cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Como esse método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente. Ele geralmente é chamado implicitamente em uma operação, como mostra o exemplo de formatação de composição.  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.String.ToString%2A> método. Observe que o exemplo não chama explicitamente o <xref:System.String.ToString%2A> método. Em vez disso, o método é chamado implicitamente, o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) recurso.  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">(Reservado) Um objeto que fornece informações de formatação específicas de cultura.</param>
        <summary>Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</summary>
        <returns>A cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `provider` é reservado e não participar no momento, esta operação.  
  
 Como esse método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em maiúsculas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia dessa cadeia de caracteres convertida em maiúsculas.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método usa as regras de maiusculas e minúsculas da cultura atual para converter cada caractere na instância atual em seu equivalente em maiusculas. Se um caractere não tiver um equivalente em letras maiusculas, ele será incluído inalterado na cadeia de caracteres retornada.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
 O <xref:System.String.ToUpper%2A> método geralmente é usado para converter uma cadeia de caracteres em maiusculas, para que ele pode ser usado em uma comparação que diferencia maiusculas de minúsculas. Um método melhor para executar a comparação diferencia maiusculas de minúsculas é chamar um método de comparação de cadeia de caracteres que tem um <xref:System.StringComparison> parâmetro cujo valor é definido como <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> para obter uma comparação sensível à cultura, diferencia maiusculas de minúsculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 A operação de maiusculas e minúsculas que resulta de chamar o <xref:System.String.ToUpper> método considera as convenções de capitalização da cultura atual. Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToUpper> método) e executa com mais eficiência.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.String.ToUpper%2A> método para converter uma série de cadeias de caracteres de um caractere que contêm cada caractere nos conjuntos de caracteres estendido-A Latim básico, Latim-1 suplementar e latinos. Ele então exibe cada cadeia de caracteres cujo caractere maiusculo é diferente do seu caractere em minúsculas.  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Conforme explicado em [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a ser especificado explicitamente. Para converter uma cadeia de caracteres em maiusculas usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para seu <paramref name="culture" /> parâmetro.</para></block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="culture">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</param>
        <summary>Retorna uma cópia desta cadeia de caracteres convertida em maiúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a maneira como no caso de uma cadeia de caracteres é alterado.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você passar o <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> método uma <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em consideração. Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método. Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.  
  
   
  
## Examples  
 O exemplo a seguir converte uma cadeia de caracteres minúsculos em duas cadeias de caracteres em maiusculas usando as culturas Inglês-Estados Unidos e Turco-Turquia e, em seguida, compara as cadeias de caracteres em maiusculas. As cadeias de caracteres maiusculos são idênticas, exceto para cada ocorrência do Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, a outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="culture" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em maiúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</summary>
        <returns>O equivalente, em maiúsculas, da cadeia de caracteres atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cultura invariável representa uma cultura insensível. Ele está associado com o idioma inglês, mas não com um país ou região específica. Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.  
  
 Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de uma maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToUpperInvariant%2A> método. O <xref:System.String.ToUpperInvariant%2A> método é equivalente a `ToUpper(CultureInfo.InvariantCulture)`. O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.  
  
> [!NOTE]
>  Este método não altera o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.  
  
## <a name="security-considerations"></a>Considerações sobre segurança  
 Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.  
  
   
  
## Examples  
 O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas. O <xref:System.String.ToUpperInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão sem diferenciação de cada palavra. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz diferencia maiusculas de minúsculas, com base na ordem de elementos na matriz de letras maiusculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna uma nova cadeia de caracteres na qual todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificados do objeto <see cref="T:System.String" /> atual são removidas.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os caracteres de espaço em branco à esquerda e à direita do objeto <see cref="T:System.String" /> atual.</summary>
        <returns>A cadeia de caracteres que permanece depois que todos os caracteres de espaço em branco forem removidos do início e do final da cadeia de caracteres atual. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Trim%2A> método Remove todos os caracteres de espaço em branco à esquerda e à direita da cadeia de caracteres atual. Cada operação de corte à esquerda e à direita é interrompido quando um caractere de espaço em branco não é encontrado. Por exemplo, se a cadeia de caracteres atual é "abc xyz", o <xref:System.String.Trim%2A> método retorna "abc xyz". Para remover os caracteres de espaço em branco entre as palavras em uma cadeia de caracteres, use [expressões regulares do .NET](~/docs/standard/base-types/regular-expressions.md).  
  
> [!NOTE]
>  Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres de espaço em branco à esquerda e à direita encontrados na instância atual são removidos.  
  
 Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de espaço em branco, o método retornará <xref:System.String.Empty>.  
  
 Os caracteres de espaço em branco são definidos pelo padrão Unicode. O <xref:System.String.Trim> método remove quaisquer caracteres à esquerda e à direita que produzem um valor de retorno `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Trim?displayProperty=nameWithType> método para remover qualquer espaço em branco extra de cadeias de caracteres inseridas pelo usuário antes de concatená-las.  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e mantém uma lista interna de caracteres de espaço em branco que esse método corta a versões anteriores. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> retornar valor quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método na [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e versões posteriores não não remover. Além disso, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço limitado de não-SEPARAÇÃO (U + 202F) e espaço de MATEMÁTICA de médio (U + 205F).</para></block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início e do final da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.Trim%2A> método Remove da cadeia de caracteres atual, todos os caracteres à esquerda e à direita que estão no `trimChars` parâmetro. Cada um à direita e cortar a operação é interrompida quando um caractere que não esteja em `trimChars` for encontrado. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.Trim%2A> método retorna "abc456xyz".  
  
> [!NOTE]
>  Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os esquerda e à direita `trimChars` encontrados na instância atual de caracteres são removidos.  
  
 Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de `trimChars` de matriz, o método retorna <xref:System.String.Empty>.  
  
 Se `trimChars` está `null` ou uma matriz vazia, este método remove quaisquer caracteres à esquerda ou direita que resultam no retorno de método `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método,  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> método para remover espaço, asterisco (*) e apóstrofo (') caracteres de uma cadeia de caracteres.  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método na [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]e versões posteriores não não remover. Além disso, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço limitado de não-SEPARAÇÃO (U + 202F) e espaço de MATEMÁTICA de médio (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do final da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco Unicode serão removidos. Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.TrimEnd%2A> método Remove da cadeia de caracteres atual, todos os caracteres à direita que estão no `trimChars` parâmetro. A operação de corte é interrompido quando o primeiro caractere que não esteja em `trimChars` é encontrado no final da cadeia de caracteres. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimEnd%2A> método retorna "123abc456xyz".  
  
> [!NOTE]
>  Se o <xref:System.String.TrimEnd%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual caracteres tudo à direita encontrados no `trimChars` são removidos da cadeia de caracteres atual.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como você pode usar o <xref:System.String.TrimEnd%28System.Char%5B%5D%29> método Cortar espaços em branco ou marcas de pontuação do final de uma cadeia de caracteres.  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método na [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e versões posteriores não não remover. Além disso, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço limitado de não-SEPARAÇÃO (U + 202F) e espaço de MATEMÁTICA de médio (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</param>
        <summary>Remove todas as ocorrências à esquerda de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</summary>
        <returns>A cadeia de caracteres que permanece depois que todas as ocorrências de caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início da cadeia de caracteres atual. Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.String.TrimStart%2A> método Remove da cadeia de caracteres atual, todos os caracteres à esquerda que estão no `trimChars` parâmetro. A operação de corte é interrompido quando um caractere que não esteja em `trimChars` for encontrado. Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimStart%2A> método retorna "abc456xyz789".  
  
> [!NOTE]
>  Se o <xref:System.String.TrimStart%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual. Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres de espaço em branco à esquerda encontrados na instância atual são removidos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a funcionalidade básica do <xref:System.String.TrimStart%2A> método:

 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]

 O exemplo a seguir usa o <xref:System.String.TrimStart%2A> método Cortar espaços em branco e caracteres de comentário das linhas de código-fonte. O `StripComments` método encapsula uma chamada para <xref:System.String.TrimStart%2A> e passa uma matriz de caracteres que contém um espaço e o caractere de comentário, que é um apóstrofo (') no Visual Basic e uma barra (/) em c#. O <xref:System.String.TrimStart%2A> método também é chamado para remover o espaço em branco ao avaliar se uma cadeia de caracteres é um comentário.  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 O exemplo a seguir mostra uma chamada para o método `StripComments`.  
  
 [!code-csharp[System.String.TrimStart#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#3)]
 [!code-vb[System.String.TrimStart#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>O [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método na [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] e versões posteriores não não remover. Além disso, o <see cref="M:System.String.Trim" /> método no [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço limitado de não-SEPARAÇÃO (U + 202F) e espaço de MATEMÁTICA de médio (U + 205F).</para></block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>