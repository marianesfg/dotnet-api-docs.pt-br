<Type Name="String" FullName="System.String">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="bca6cb70cbbc34b4d8170b379576027df0dbb65e" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37731846" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class String : ICloneable, IComparable, IComparable&lt;string&gt;, IConvertible, IEquatable&lt;string&gt;, System.Collections.Generic.IEnumerable&lt;char&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit string extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;char&gt;, class System.Collections.IEnumerable, class System.ICloneable, class System.IComparable, class System.IComparable`1&lt;string&gt;, class System.IConvertible, class System.IEquatable`1&lt;string&gt;" />
  <TypeSignature Language="DocId" Value="T:System.String" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class String&#xA;Implements ICloneable, IComparable, IComparable(Of String), IConvertible, IEnumerable(Of Char), IEquatable(Of String)" />
  <TypeSignature Language="C++ CLI" Value="public ref class String sealed : ICloneable, IComparable, IComparable&lt;System::String ^&gt;, IConvertible, IEquatable&lt;System::String ^&gt;, System::Collections::Generic::IEnumerable&lt;char&gt;" />
  <TypeSignature Language="F#" Value="type string = class&#xA;    interface IComparable&#xA;    interface ICloneable&#xA;    interface IConvertible&#xA;    interface IEnumerable&#xA;    interface IComparable&lt;string&gt;&#xA;    interface seq&lt;char&gt;&#xA;    interface IEquatable&lt;string&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Char&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.String&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.String&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="58835-101">Representa o texto como uma sequência de unidades de código UTF-16.</span>
      <span class="sxs-lookup">
        <span data-stu-id="58835-101">Represents text as a sequence of UTF-16 code units.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
 <span data-ttu-id="58835-102">Uma cadeia de caracteres é uma coleção sequencial de caracteres que é usada para representar texto.</span><span class="sxs-lookup"><span data-stu-id="58835-102">A string is a sequential collection of characters that is used to represent text.</span></span> <span data-ttu-id="58835-103">Um <xref:System.String> objeto é uma coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos que representam uma cadeia de caracteres; um <xref:System.Char?displayProperty=nameWithType> objeto corresponde a uma unidade de código UTF-16.</span><span class="sxs-lookup"><span data-stu-id="58835-103">A <xref:System.String> object is a sequential collection of <xref:System.Char?displayProperty=nameWithType> objects that represent a string; a <xref:System.Char?displayProperty=nameWithType> object corresponds to a UTF-16 code unit.</span></span> <span data-ttu-id="58835-104">O valor de <xref:System.String> objeto é o conteúdo da coleção sequencial de <xref:System.Char?displayProperty=nameWithType> objetos e que o valor é imutável (ou seja, ele é somente leitura).</span><span class="sxs-lookup"><span data-stu-id="58835-104">The value of the <xref:System.String> object is the content of the sequential collection of <xref:System.Char?displayProperty=nameWithType> objects, and that value is immutable (that is, it is read-only).</span></span> <span data-ttu-id="58835-105">Para obter mais informações sobre a imutabilidade de cadeias de caracteres, consulte a [imutabilidade e a classe StringBuilder](#Immutability) seção mais adiante neste tópico.</span><span class="sxs-lookup"><span data-stu-id="58835-105">For more information about the immutability of strings, see the [Immutability and the StringBuilder class](#Immutability) section later in this topic.</span></span> <span data-ttu-id="58835-106">O tamanho máximo de um <xref:System.String> objeto na memória é de 2 GB, ou cerca de 1 bilhão de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-106">The maximum size of a <xref:System.String> object in memory is 2GB, or about 1 billion characters.</span></span>  
  
 <span data-ttu-id="58835-107">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="58835-107">In this section:</span></span>  
  
 <span data-ttu-id="58835-108">[Criando uma instância de um objeto de cadeia de caracteres](#Instantiation) </span><span class="sxs-lookup"><span data-stu-id="58835-108">[Instantiating a String object](#Instantiation) </span></span>  
 <span data-ttu-id="58835-109">[Objetos char e caracteres Unicode](#Characters) </span><span class="sxs-lookup"><span data-stu-id="58835-109">[Char objects and Unicode characters](#Characters) </span></span>  
 <span data-ttu-id="58835-110">[Cadeias de caracteres e o padrão Unicode](#Unicode) </span><span class="sxs-lookup"><span data-stu-id="58835-110">[Strings and The Unicode Standard](#Unicode) </span></span>  
 <span data-ttu-id="58835-111">[Cadeias de caracteres e caracteres nulos inseridos](#EmbeddedNulls) </span><span class="sxs-lookup"><span data-stu-id="58835-111">[Strings and embedded null characters](#EmbeddedNulls) </span></span>  
 <span data-ttu-id="58835-112">[Cadeias de caracteres e índices](#Indexes) </span><span class="sxs-lookup"><span data-stu-id="58835-112">[Strings and indexes](#Indexes) </span></span>  
 <span data-ttu-id="58835-113">[Cadeias de caracteres nulas e cadeias de caracteres vazias](#Nulls) </span><span class="sxs-lookup"><span data-stu-id="58835-113">[Null strings and empty strings](#Nulls) </span></span>  
 <span data-ttu-id="58835-114">[Imutabilidade e a classe StringBuilder](#Immutability) </span><span class="sxs-lookup"><span data-stu-id="58835-114">[Immutability and the StringBuilder class](#Immutability) </span></span>  
 <span data-ttu-id="58835-115">[Ordinal x operações sensíveis à cultura](#CultureSensitive) </span><span class="sxs-lookup"><span data-stu-id="58835-115">[Ordinal vs. culture-sensitive operations](#CultureSensitive) </span></span>  
 <span data-ttu-id="58835-116">[Normalização](#Normalization) </span><span class="sxs-lookup"><span data-stu-id="58835-116">[Normalization](#Normalization) </span></span>  
 [<span data-ttu-id="58835-117">Operações de cadeia de caracteres por categoria</span><span class="sxs-lookup"><span data-stu-id="58835-117">String operations by category</span></span>](#ByCategory)  
  
<a name="Instantiation"></a>   
## <a name="instantiating-a-string-object"></a><span data-ttu-id="58835-118">Criando uma instância de um objeto String</span><span class="sxs-lookup"><span data-stu-id="58835-118">Instantiating a String object</span></span>  
 <span data-ttu-id="58835-119">Você pode instanciar um <xref:System.String> objeto das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="58835-119">You can instantiate a <xref:System.String> object in the following ways:</span></span>  
  
-   <span data-ttu-id="58835-120">Atribuindo uma cadeia de caracteres literal a uma <xref:System.String> variável.</span><span class="sxs-lookup"><span data-stu-id="58835-120">By assigning a string literal to a <xref:System.String> variable.</span></span> <span data-ttu-id="58835-121">Esse é o método mais comumente usado para a criação de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-121">This is the most commonly used method for creating a string.</span></span> <span data-ttu-id="58835-122">O exemplo a seguir usa a atribuição para criar várias cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-122">The following example uses assignment to create several strings.</span></span> <span data-ttu-id="58835-123">Observe que, em c#, como a barra invertida (\\) é um caractere de escape, barras invertidas literais em uma cadeia de caracteres devem ser escapadas ou cadeia de caracteres inteira deve ser @-quoted.</span><span class="sxs-lookup"><span data-stu-id="58835-123">Note that in C#, because the backslash (\\) is an escape character, literal backslashes in a string must be escaped or the entire string must be @-quoted.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate1.cpp#1)]
     [!code-csharp[System.String.Class.Instantiate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#1)]
     [!code-vb[System.String.Class.Instantiate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#1)]  
  
-   <span data-ttu-id="58835-124">Chamando um <xref:System.String> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="58835-124">By calling a <xref:System.String> class constructor.</span></span> <span data-ttu-id="58835-125">O exemplo a seguir cria uma instância de cadeias de caracteres chamando vários construtores de classe.</span><span class="sxs-lookup"><span data-stu-id="58835-125">The following example instantiates strings by calling several class constructors.</span></span> <span data-ttu-id="58835-126">Observe que alguns dos construtores incluem ponteiros para matrizes de caracteres ou matrizes de bytes com sinal como parâmetros.</span><span class="sxs-lookup"><span data-stu-id="58835-126">Note that some of the constructors include pointers to character arrays or signed byte arrays as parameters.</span></span> <span data-ttu-id="58835-127">Visual Basic não oferece suporte a chamadas para esses construtores.</span><span class="sxs-lookup"><span data-stu-id="58835-127">Visual Basic does not support calls to these constructors.</span></span> <span data-ttu-id="58835-128">Para obter informações detalhadas sobre <xref:System.String> construtores, consulte o <xref:System.String.%23ctor%2A> resumo do construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-128">For detailed information about <xref:System.String> constructors, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate2.cpp#2)]
     [!code-csharp[System.String.Class.Instantiate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#2)]
     [!code-vb[System.String.Class.Instantiate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#2)]  
  
-   <span data-ttu-id="58835-129">Usando o operador de concatenação de cadeia de caracteres (+ em c# e & ou + no Visual Basic) para criar uma única cadeia de caracteres de qualquer combinação de <xref:System.String> instâncias e literais de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-129">By using the string concatenation operator (+ in C# and & or + in Visual Basic) to create a single string from any combination of <xref:System.String> instances and string literals.</span></span> <span data-ttu-id="58835-130">O exemplo a seguir ilustra o uso do operador de concatenação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-130">The following example illustrates the use of the string concatenation operator.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#3)]
     [!code-csharp[System.String.Class.Instantiate#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#3)]
     [!code-vb[System.String.Class.Instantiate#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#3)]  
  
-   <span data-ttu-id="58835-131">Recuperar uma propriedade ou chamando um método que retorna uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-131">By retrieving a property or calling a method that returns a string.</span></span> <span data-ttu-id="58835-132">O exemplo a seguir usa os métodos do <xref:System.String> classe para extrair uma subcadeia de caracteres de uma cadeia de caracteres maior.</span><span class="sxs-lookup"><span data-stu-id="58835-132">The following example uses the methods of the <xref:System.String> class to extract a substring from a larger string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#4)]
     [!code-csharp[System.String.Class.Instantiate#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#4)]
     [!code-vb[System.String.Class.Instantiate#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#4)]  
  
-   <span data-ttu-id="58835-133">Chamando um método de formatação para converter um valor ou o objeto em sua representação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-133">By calling a formatting method to convert a value or object to its string representation.</span></span> <span data-ttu-id="58835-134">O exemplo a seguir usa o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) recurso para inserir a representação de cadeia de caracteres de dois objetos em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-134">The following example uses the                [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature to embed the string representation of two objects into a string.</span></span>  
  
     [!code-cpp[System.String.Class.Instantiate#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.instantiate/cpp/string.instantiate3.cpp#5)]
     [!code-csharp[System.String.Class.Instantiate#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.instantiate/cs/program.cs#5)]
     [!code-vb[System.String.Class.Instantiate#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.instantiate/vb/instantiate1.vb#5)]  
  
<a name="Characters"></a>   
## <a name="char-objects-and-unicode-characters"></a><span data-ttu-id="58835-135">Objetos Char e caracteres Unicode</span><span class="sxs-lookup"><span data-stu-id="58835-135">Char objects and Unicode characters</span></span>  
 <span data-ttu-id="58835-136">Cada caractere em uma cadeia de caracteres é definido por um valor escalar Unicode, também chamado de um ponto de código Unicode ou o valor ordinal (numérico) do caractere Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-136">Each character in a string is defined by a Unicode scalar value, also called a Unicode code point or the ordinal (numeric) value of the Unicode character.</span></span> <span data-ttu-id="58835-137">Cada ponto de código é codificado usando a codificação UTF-16, e o valor numérico de cada elemento da codificação é representado por um <xref:System.Char> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-137">Each code point is encoded by using UTF-16 encoding, and the numeric value of each element of the encoding is represented by a <xref:System.Char> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-138">Observe que, como um <xref:System.String> instância consiste em uma coleção sequencial de unidades de código UTF-16, é possível criar um <xref:System.String> objeto que não é uma cadeia de caracteres Unicode bem formada.</span><span class="sxs-lookup"><span data-stu-id="58835-138">Note that, because a <xref:System.String> instance consists of a sequential collection of UTF-16 code units, it is possible to create a <xref:System.String> object that is not a well-formed Unicode string.</span></span> <span data-ttu-id="58835-139">Por exemplo, é possível criar uma cadeia de caracteres que tem um substituto baixo sem um substituto alto correspondente.</span><span class="sxs-lookup"><span data-stu-id="58835-139">For example, it is possible to create a string that has a low surrogate without a corresponding high surrogate.</span></span> <span data-ttu-id="58835-140">Embora alguns métodos, como os métodos de codificação e decodificação de objetos na <xref:System.Text> namespace, talvez executa verificações para garantir que as cadeias de caracteres estejam bem formadas, <xref:System.String> membros de classe não garantem que uma cadeia de caracteres seja bem formada.</span><span class="sxs-lookup"><span data-stu-id="58835-140">Although some methods, such as the methods of encoding and decoding objects in the <xref:System.Text> namespace, may performs checks to ensure that strings are well-formed, <xref:System.String> class members don't ensure that a string is well-formed.</span></span>  
  
 <span data-ttu-id="58835-141">Uma única <xref:System.Char> objeto normalmente representa um único ponto de código, ou seja, o valor numérico a <xref:System.Char> é igual ao ponto de código.</span><span class="sxs-lookup"><span data-stu-id="58835-141">A single <xref:System.Char> object usually represents a single code point; that is, the numeric value of the <xref:System.Char> equals the code point.</span></span> <span data-ttu-id="58835-142">Por exemplo, o ponto de código para o caractere "a" é U + 0061.</span><span class="sxs-lookup"><span data-stu-id="58835-142">For example, the code point for the character "a" is U+0061.</span></span> <span data-ttu-id="58835-143">No entanto, um ponto de código pode exigir mais de um elemento codificado (mais de um <xref:System.Char> objeto).</span><span class="sxs-lookup"><span data-stu-id="58835-143">However, a code point might require more than one encoded element (more than one <xref:System.Char> object).</span></span> <span data-ttu-id="58835-144">O padrão Unicode define dois tipos de caracteres que correspondem a vários <xref:System.Char> objetos: graphemes e pontos de código suplementares do Unicode que correspondem aos caracteres os planos suplementares do Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-144">The Unicode standard defines two types of characters that correspond to multiple <xref:System.Char> objects: graphemes, and Unicode supplementary code points that correspond to characters in the Unicode supplementary planes.</span></span>  
  
-   <span data-ttu-id="58835-145">Uma grafema é representada por um caractere base, seguido por um ou mais caracteres de combinação.</span><span class="sxs-lookup"><span data-stu-id="58835-145">A grapheme is represented by a base character followed by one or more combining characters.</span></span> <span data-ttu-id="58835-146">Por exemplo, o caractere ä é representado por um <xref:System.Char> objeto cujo ponto de código é seguido por um U + 0061 <xref:System.Char> objeto cujo ponto de código é a U + 0308.</span><span class="sxs-lookup"><span data-stu-id="58835-146">For example, the character ä is represented by a <xref:System.Char> object whose code point is U+0061 followed by a <xref:System.Char> object whose code point is U+0308.</span></span> <span data-ttu-id="58835-147">Esse caractere também pode ser definido por um único <xref:System.Char> objeto que tem um ponto de código de U + 00E4.</span><span class="sxs-lookup"><span data-stu-id="58835-147">This character can also be defined by a single <xref:System.Char> object that has a code point of U+00E4.</span></span> <span data-ttu-id="58835-148">Como mostra o exemplo a seguir, uma comparação sensível à cultura de igualdade indica que essas duas representações são iguais, embora uma comparação ordinal comum não faz isso.</span><span class="sxs-lookup"><span data-stu-id="58835-148">As the following example shows, a culture-sensitive comparison for equality indicates that these two representations are equal, although an ordinary ordinal comparison does not.</span></span> <span data-ttu-id="58835-149">No entanto, se duas cadeias de caracteres são normalizadas, uma comparação ordinal também indica que eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-149">However, if the two strings are normalized, an ordinal comparison also indicates that they are equal.</span></span> <span data-ttu-id="58835-150">(Para obter mais informações sobre a normalização de cadeias de caracteres, consulte a [normalização](#Normalization) seção.)</span><span class="sxs-lookup"><span data-stu-id="58835-150">(For more information on normalizing strings, see the [Normalization](#Normalization) section.)</span></span>  
  
     [!code-cpp[System.String.Class#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char1.cpp#2)]
     [!code-csharp[System.String.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/grapheme1.cs#2)]
     [!code-vb[System.String.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/grapheme1.vb#2)]  
  
-   <span data-ttu-id="58835-151">Unicode (um par substituto) do ponto de código suplementar é representado por um <xref:System.Char> objeto cujo ponto de código é um substituto alto seguido por um <xref:System.Char> objeto cujo ponto de código é um substituto baixo.</span><span class="sxs-lookup"><span data-stu-id="58835-151">A Unicode supplementary code point (a surrogate pair) is represented by a <xref:System.Char> object whose code point is a high surrogate followed by a <xref:System.Char> object whose code point is a low surrogate.</span></span> <span data-ttu-id="58835-152">As unidades de código do intervalo de substitutos altos de U+D800 a U + DBFF.</span><span class="sxs-lookup"><span data-stu-id="58835-152">The code units of high surrogates range from U+D800 to U+DBFF.</span></span> <span data-ttu-id="58835-153">As unidades de código do intervalo de substitutos baixos de U+DC00 a U + DFFF.</span><span class="sxs-lookup"><span data-stu-id="58835-153">The code units of low surrogates range from U+DC00 to U+DFFF.</span></span> <span data-ttu-id="58835-154">Pares substitutos são usados para representar caracteres nos 16 planos suplementares do Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-154">Surrogate pairs are used to represent characters in the 16 Unicode supplementary planes.</span></span> <span data-ttu-id="58835-155">O exemplo a seguir cria um caractere alternativo e a passa para o <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> método para determinar se ele é um par substituto.</span><span class="sxs-lookup"><span data-stu-id="58835-155">The following example creates a surrogate character and passes it to the <xref:System.Char.IsSurrogatePair%28System.Char%2CSystem.Char%29?displayProperty=nameWithType> method to determine whether it is a surrogate pair.</span></span>  
  
     [!code-cpp[System.String.Class#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.char2.cpp#3)]
     [!code-csharp[System.String.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/surrogate1.cs#3)]
     [!code-vb[System.String.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/surrogate1.vb#3)]  
  
<a name="Unicode"></a>   
## <a name="strings-and-the-unicode-standard"></a><span data-ttu-id="58835-156">Cadeias de caracteres e o padrão Unicode</span><span class="sxs-lookup"><span data-stu-id="58835-156">Strings and The Unicode Standard</span></span>  
 <span data-ttu-id="58835-157">Caracteres em uma cadeia de caracteres são representados por unidades de código codificado em UTF-16, que correspondem aos <xref:System.Char> valores.</span><span class="sxs-lookup"><span data-stu-id="58835-157">Characters in a string are represented by UTF-16 encoded code units, which correspond to <xref:System.Char> values.</span></span>  
  
 <span data-ttu-id="58835-158">Cada caractere em uma cadeia de caracteres tem uma categoria de caractere Unicode associada, que é representada no .NET Framework pelo <xref:System.Globalization.UnicodeCategory> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-158">Each character in a string has an associated Unicode character category, which is represented in the .NET Framework by the <xref:System.Globalization.UnicodeCategory> enumeration.</span></span> <span data-ttu-id="58835-159">A categoria de um caractere ou um par alternativo pode ser determinada chamando o <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-159">The category of a character or a surrogate pair can be determined by calling the <xref:System.Globalization.CharUnicodeInfo.GetUnicodeCategory%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-160">.NET mantém sua própria tabela de caracteres e suas categorias correspondentes, que garante que uma versão específica de uma implementação do .NET em execução em diferentes plataformas retorna informações de categoria de caracteres idênticas.</span><span class="sxs-lookup"><span data-stu-id="58835-160">.NET maintains its own table of characters and their corresponding categories, which ensures that a specific version of a .NET implementation running on different platforms returns identical character category information.</span></span> <span data-ttu-id="58835-161">A tabela a seguir lista as versões do .NET e as versões do padrão Unicode na qual suas categorias de caractere são baseadas.</span><span class="sxs-lookup"><span data-stu-id="58835-161">The following table lists .NET versions and the versions of the Unicode Standard on which their character categories are based.</span></span>  
  
|<span data-ttu-id="58835-162">Versão do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="58835-162">.NET Framework version</span></span>|<span data-ttu-id="58835-163">Versão do padrão Unicode</span><span class="sxs-lookup"><span data-stu-id="58835-163">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="58835-164">O padrão Unicode, versão 4.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-164">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="58835-165">O .NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="58835-165">The .NET Framework 2.0</span></span>|[<span data-ttu-id="58835-166">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-166">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="58835-167">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-167">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="58835-168">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-168">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]|[<span data-ttu-id="58835-169">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-169">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v451](~/includes/net-v451-md.md)]|[<span data-ttu-id="58835-170">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-170">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v452](~/includes/net-v452-md.md)]|[<span data-ttu-id="58835-171">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-171">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v46](~/includes/net-v46-md.md)]|[<span data-ttu-id="58835-172">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-172">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v461](~/includes/net-v461-md.md)]|[<span data-ttu-id="58835-173">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-173">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  
|[!INCLUDE[net_v462](~/includes/net-v462-md.md)]|[<span data-ttu-id="58835-174">O padrão Unicode, versão 8.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-174">The Unicode Standard, Version 8.0.0</span></span>](https://www.unicode.org/versions/Unicode8.0.0/)|  
|<span data-ttu-id="58835-175">.NET core (todas as versões)</span><span class="sxs-lookup"><span data-stu-id="58835-175">.NET Core (all versions)</span></span>|[<span data-ttu-id="58835-176">O padrão Unicode, versão 8.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-176">The Unicode Standard, Version 8.0.0</span></span>](https://www.unicode.org/versions/Unicode8.0.0/)|
  
 <span data-ttu-id="58835-177">Além disso, o .NET Framework dá suporte à comparação de cadeia de caracteres e classificação com base no padrão Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-177">In addition, the .NET Framework supports string comparison and sorting based on the Unicode standard.</span></span> <span data-ttu-id="58835-178">Nas versões do .NET Framework por meio de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], o .NET Framework mantém sua própria tabela de dados de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-178">In versions of the .NET Framework through the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the .NET Framework maintains its own table of string data.</span></span> <span data-ttu-id="58835-179">Isso também é verdadeiro para as versões do .NET Framework começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 7.</span><span class="sxs-lookup"><span data-stu-id="58835-179">This is also true of versions of the .NET Framework starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Windows 7.</span></span> <span data-ttu-id="58835-180">Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no Windows 8 e versões posteriores do sistema operacional Windows, os delegados de tempo de execução de cadeia de caracteres de comparação e ordenação de operações para o sistema operacional.</span><span class="sxs-lookup"><span data-stu-id="58835-180">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on Window 8 and later versions of the Windows operating system, the runtime delegates string comparison and sorting operations to the operating system.</span></span> <span data-ttu-id="58835-181">A tabela a seguir lista as versões do .NET Framework e as versões do padrão Unicode em qual caractere de comparação e classificação baseiam-se.</span><span class="sxs-lookup"><span data-stu-id="58835-181">The following table lists the versions of the .NET Framework and the versions of the Unicode Standard on which character comparison and sorting are based.</span></span>  
  
|<span data-ttu-id="58835-182">Versão do .NET Framework</span><span class="sxs-lookup"><span data-stu-id="58835-182">.NET Framework version</span></span>|<span data-ttu-id="58835-183">Versão do padrão Unicode</span><span class="sxs-lookup"><span data-stu-id="58835-183">Version of the Unicode Standard</span></span>|  
|----------------------------|-------------------------------------|  
|[!INCLUDE[net_v11_long](~/includes/net-v11-long-md.md)]|[<span data-ttu-id="58835-184">O padrão Unicode, versão 4.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-184">The Unicode Standard, Version 4.0.0</span></span>](https://www.unicode.org/versions/Unicode4.0.0/)|  
|<span data-ttu-id="58835-185">O .NET Framework 2.0</span><span class="sxs-lookup"><span data-stu-id="58835-185">The .NET Framework 2.0</span></span>|[<span data-ttu-id="58835-186">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-186">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]|[<span data-ttu-id="58835-187">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-187">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]|[<span data-ttu-id="58835-188">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-188">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="58835-189"> e posterior no Windows 7</span><span class="sxs-lookup"><span data-stu-id="58835-189"> and later on Windows 7</span></span>|[<span data-ttu-id="58835-190">O padrão Unicode, versão 5.0.0</span><span class="sxs-lookup"><span data-stu-id="58835-190">The Unicode Standard, Version 5.0.0</span></span>](http://www.unicode.org/versions/Unicode5.0.0)|  
|[!INCLUDE[net_v45](~/includes/net-v45-md.md)]<span data-ttu-id="58835-191"> e posterior no Windows 8 e em sistemas operacionais Windows posteriores</span><span class="sxs-lookup"><span data-stu-id="58835-191"> and later on Windows 8 and later Windows operating systems</span></span>|[<span data-ttu-id="58835-192">O padrão Unicode, versão 6.3.0</span><span class="sxs-lookup"><span data-stu-id="58835-192">The Unicode Standard, Version 6.3.0</span></span>](https://www.unicode.org/versions/Unicode6.3.0/)|  

<span data-ttu-id="58835-193">No .NET Core, as operações de classificação e comparação se baseiam [versão 8.0.0 do padrão Unicode](https://www.unicode.org/versions/Unicode8.0.0/).</span><span class="sxs-lookup"><span data-stu-id="58835-193">In .NET Core, sorting and comparison operations are based on [Version 8.0.0 of the Unicode Standard](https://www.unicode.org/versions/Unicode8.0.0/).</span></span>

<a name="EmbeddedNulls"></a>   
## <a name="strings-and-embedded-null-characters"></a><span data-ttu-id="58835-194">Cadeias de caracteres e caracteres nulos inseridos</span><span class="sxs-lookup"><span data-stu-id="58835-194">Strings and embedded null characters</span></span>  
 <span data-ttu-id="58835-195">No .NET Framework, um <xref:System.String> objeto pode incluir caracteres nulos inseridos, que contam como parte do comprimento da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-195">In the .NET Framework, a <xref:System.String> object can include embedded null characters, which count as a part of the string's length.</span></span> <span data-ttu-id="58835-196">No entanto, em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres; ele não é considerado parte da cadeia de caracteres e não é contabilizado como parte do comprimento da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-196">However, in some languages such as C and C++, a null character indicates the end of a string;it is not considered a part of the string and is not counted as part of the string's length.</span></span> <span data-ttu-id="58835-197">Isso significa que as seguintes suposições comuns que programadores de C e C++ ou bibliotecas escritas em C ou C++ podem fazer sobre cadeias de caracteres não são necessariamente válidas quando aplicado a <xref:System.String> objetos:</span><span class="sxs-lookup"><span data-stu-id="58835-197">This means that the following common assumptions that C and C++ programmers or libraries written in C or C++ might make about strings are not necessarily valid when applied to <xref:System.String> objects:</span></span>  
  
-   <span data-ttu-id="58835-198">O valor retornado pela `strlen` ou `wcslen` funções não é necessariamente igual <xref:System.String.Length%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-198">The value returned by the `strlen` or `wcslen` functions does not necessarily equal <xref:System.String.Length%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="58835-199">A cadeia de caracteres criada pelo `strcpy_s` ou `wcscpy_s` funções não é necessariamente idêntica à cadeia de caracteres criada pelo <xref:System.String.Copy%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-199">The string created by the `strcpy_s` or `wcscpy_s` functions is not necessarily identical to the string created by the <xref:System.String.Copy%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-200">Você deve garantir que esse código C e C++ nativo que instancia <xref:System.String> objetos e o código que é passado <xref:System.String> objetos por meio da plataforma de invocação, não presuma que um caractere nulo inserido marca o fim da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-200">You should ensure that native C and C++ code that instantiates <xref:System.String> objects, and code that is passed <xref:System.String> objects through platform invoke, don't assume that an embedded null character marks the end of the string.</span></span>  
  
 <span data-ttu-id="58835-201">Caracteres nulos inseridos em uma cadeia de caracteres também são tratados diferentemente quando uma cadeia de caracteres é classificada (ou em comparação com) e quando uma cadeia de caracteres é pesquisada.</span><span class="sxs-lookup"><span data-stu-id="58835-201">Embedded null characters in a string are also treated differently when a string is sorted (or compared) and when a string is searched.</span></span> <span data-ttu-id="58835-202">Caracteres nulos são ignorados ao executar comparações sensíveis à cultura entre duas cadeias de caracteres, incluindo as comparações usando a cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="58835-202">Null characters are ignored when performing culture-sensitive comparisons between two strings, including comparisons using the invariant culture.</span></span> <span data-ttu-id="58835-203">Elas são consideradas apenas para comparações ordinais ordinal ou diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-203">They are considered only for ordinal or case-insensitive ordinal comparisons.</span></span> <span data-ttu-id="58835-204">Por outro lado, caracteres nulos inseridos são sempre considerados durante a pesquisa uma cadeia de caracteres com métodos como <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, e <xref:System.String.IndexOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-204">On the other hand, embedded null characters are always considered when searching a string with methods such as <xref:System.String.Contains%2A>, <xref:System.String.StartsWith%2A>, and <xref:System.String.IndexOf%2A>.</span></span>  
  
<a name="Indexes"></a>   
## <a name="strings-and-indexes"></a><span data-ttu-id="58835-205">Cadeias de caracteres e índices</span><span class="sxs-lookup"><span data-stu-id="58835-205">Strings and indexes</span></span>  
 <span data-ttu-id="58835-206">Um índice é a posição de um <xref:System.Char> objeto (não um caractere Unicode) em um <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="58835-206">An index is the position of a <xref:System.Char> object (not a Unicode character) in a <xref:System.String>.</span></span> <span data-ttu-id="58835-207">Um índice é um número não negativo, com base em zero que começa na primeira posição na cadeia de caracteres, que é a posição de índice zero.</span><span class="sxs-lookup"><span data-stu-id="58835-207">An index is a zero-based, nonnegative number that starts from the first position in the string, which is index position zero.</span></span> <span data-ttu-id="58835-208">Um número de métodos de pesquisa, como <xref:System.String.IndexOf%2A> e <xref:System.String.LastIndexOf%2A>, retornar o índice de um caractere ou subcadeia de caracteres na instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-208">A number of search methods, such as <xref:System.String.IndexOf%2A> and <xref:System.String.LastIndexOf%2A>, return the index of a character or substring in the string instance.</span></span>  
  
 <span data-ttu-id="58835-209">O <xref:System.String.Chars%2A> propriedade permite que você acesse individuais <xref:System.Char> objetos por sua posição de índice na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-209">The <xref:System.String.Chars%2A> property lets you access individual <xref:System.Char> objects by their index position in the string.</span></span> <span data-ttu-id="58835-210">Porque o <xref:System.String.Chars%2A> propriedade é a propriedade padrão (no Visual Basic) ou o indexador (no c#), você pode acessar o indivíduo <xref:System.Char> objetos em uma cadeia de caracteres usando código como o seguinte.</span><span class="sxs-lookup"><span data-stu-id="58835-210">Because the <xref:System.String.Chars%2A> property is the default property (in Visual Basic) or the indexer (in C#), you can access the individual <xref:System.Char> objects in a string by using code such as the following.</span></span> <span data-ttu-id="58835-211">Esse código procura por espaço em branco ou caracteres de pontuação em uma cadeia de caracteres para determinar quantas palavras que contém a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-211">This code looks for white space or punctuation characters in a string to determine how many words the string contains.</span></span>  
  
 [!code-cpp[System.String.Class#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index1.cpp#4)]
 [!code-csharp[System.String.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index1.cs#4)]
 [!code-vb[System.String.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index1.vb#4)]  
  
 <span data-ttu-id="58835-212">Porque o <xref:System.String> classe implementa o <xref:System.Collections.IEnumerable> interface, você também pode iterar por meio do <xref:System.Char> objetos em uma cadeia de caracteres usando um `foreach` constructo, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-212">Because the <xref:System.String> class implements the <xref:System.Collections.IEnumerable> interface, you can also iterate through the <xref:System.Char> objects in a string by using a `foreach` construct, as the following example shows.</span></span>  
  
 [!code-cpp[System.String.Class#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index2.cpp#5)]
 [!code-csharp[System.String.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index2.cs#5)]
 [!code-vb[System.String.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index2.vb#5)]  
  
 <span data-ttu-id="58835-213">Valores de índice consecutivas podem não corresponder a caracteres Unicode consecutivos, como um caractere pode ser codificado em Unicode como mais de um <xref:System.Char> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-213">Consecutive index values might not correspond to consecutive Unicode characters, because a Unicode character might be encoded as more than one <xref:System.Char> object.</span></span> <span data-ttu-id="58835-214">Em particular, uma cadeia de caracteres pode conter vários caracteres unidades de texto que são formadas por um caractere base seguido por um ou mais caracteres de combinação ou por pares substitutos.</span><span class="sxs-lookup"><span data-stu-id="58835-214">In particular, a string may contain multi-character units of text that are formed by a base character followed by one or more combining characters or by surrogate pairs.</span></span> <span data-ttu-id="58835-215">Para trabalhar com caracteres Unicode em vez de <xref:System.Char> objetos, use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> e <xref:System.Globalization.TextElementEnumerator> classes.</span><span class="sxs-lookup"><span data-stu-id="58835-215">To work with Unicode characters instead of <xref:System.Char> objects, use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> and <xref:System.Globalization.TextElementEnumerator> classes.</span></span> <span data-ttu-id="58835-216">O exemplo a seguir ilustra a diferença entre o código que funciona com <xref:System.Char> objetos e o código que funciona com caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-216">The following example illustrates the difference between code that works with <xref:System.Char> objects and code that works with Unicode characters.</span></span> <span data-ttu-id="58835-217">Ele compara o número de caracteres ou elementos de texto em cada palavra da frase.</span><span class="sxs-lookup"><span data-stu-id="58835-217">It compares the number of characters or text elements in each word of a sentence.</span></span> <span data-ttu-id="58835-218">A cadeia de caracteres inclui duas sequências de um caractere base, seguido por um caractere de combinação.</span><span class="sxs-lookup"><span data-stu-id="58835-218">The string includes two sequences of a base character followed by a combining character.</span></span>  
  
 [!code-cpp[System.String.Class#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.index3.cpp#6)]
 [!code-csharp[System.String.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/index3.cs#6)]
 [!code-vb[System.String.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/index3.vb#6)]  
  
 <span data-ttu-id="58835-219">Este exemplo funciona com elementos de texto usando o <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> método e o <xref:System.Globalization.TextElementEnumerator> classe para enumerar todos os elementos de texto em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-219">This example works with text elements by using the <xref:System.Globalization.StringInfo.GetTextElementEnumerator%2A?displayProperty=nameWithType> method and the <xref:System.Globalization.TextElementEnumerator> class to enumerate all the text elements in a string.</span></span> <span data-ttu-id="58835-220">Você também pode recuperar uma matriz que contém o índice inicial de cada elemento de texto chamando o <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-220">You can also retrieve an array that contains the starting index of each text element by calling the <xref:System.Globalization.StringInfo.ParseCombiningCharacters%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-221">Para obter mais informações sobre como trabalhar com unidades de texto em vez de um indivíduo <xref:System.Char> valores, consulte o <xref:System.Globalization.StringInfo> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-221">For more information about working with units of text rather than individual <xref:System.Char> values, see the <xref:System.Globalization.StringInfo> class.</span></span>  
  
<a name="Nulls"></a>   
## <a name="null-strings-and-empty-strings"></a><span data-ttu-id="58835-222">Cadeias de caracteres nulas e cadeias de caracteres vazias</span><span class="sxs-lookup"><span data-stu-id="58835-222">Null strings and empty strings</span></span>  
 <span data-ttu-id="58835-223">É uma cadeia de caracteres que tenha sido declarada, mas não foi atribuída um valor `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-223">A string that has been declared but has not been assigned a value is `null`.</span></span> <span data-ttu-id="58835-224">A tentativa de chamar métodos em cadeia de caracteres gera um <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="58835-224">Attempting to call methods on that string throws a <xref:System.NullReferenceException>.</span></span> <span data-ttu-id="58835-225">Uma cadeia de caracteres nula é diferente de uma cadeia de caracteres vazia, o que é uma cadeia de caracteres cujo valor é "" ou <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-225">A null string is different from an empty string, which is a string whose value is "" or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-226">Em alguns casos, passando uma cadeia de caracteres nula ou uma cadeia de caracteres vazia como um argumento em uma chamada de método lançará uma exceção.</span><span class="sxs-lookup"><span data-stu-id="58835-226">In some cases, passing either a null string or an empty string as an argument in a method call throws an exception.</span></span> <span data-ttu-id="58835-227">Por exemplo, passar uma cadeia de caracteres nula para o <xref:System.Int32.Parse%2A?displayProperty=nameWithType> método lança um <xref:System.ArgumentNullException>e passando uma cadeia de caracteres vazia lança um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="58835-227">For example, passing a null string to the <xref:System.Int32.Parse%2A?displayProperty=nameWithType> method throws an <xref:System.ArgumentNullException>, and passing an empty string throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="58835-228">Em outros casos, um argumento de método pode ser uma cadeia de caracteres nula ou uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="58835-228">In other cases, a method argument can be either a null string or an empty string.</span></span> <span data-ttu-id="58835-229">Por exemplo, se você estiver fornecendo um <xref:System.IFormattable> implementação para uma classe, que você deseja serão iguais a uma cadeia de caracteres nula e uma cadeia de caracteres vazia com o especificador de formato geral ("G").</span><span class="sxs-lookup"><span data-stu-id="58835-229">For example, if you are providing an <xref:System.IFormattable> implementation for a class, you want to equate both a null string and an empty string with the general ("G") format specifier.</span></span>  
  
 <span data-ttu-id="58835-230">O <xref:System.String> classe inclui os seguintes métodos de duas conveniência que permitem a você testar se uma cadeia de caracteres é `null` ou está vazio:</span><span class="sxs-lookup"><span data-stu-id="58835-230">The <xref:System.String> class includes the following two convenience methods that enable you to test whether a string is `null` or empty:</span></span>  
  
-   <span data-ttu-id="58835-231"><xref:System.String.IsNullOrEmpty%2A>, que indica se uma cadeia de caracteres é um `null` ou é igual a <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-231"><xref:System.String.IsNullOrEmpty%2A>, which indicates whether a string is either `null` or is equal to  <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-232">Esse método elimina a necessidade de usar código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-232">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#1)]
     [!code-csharp[System.String.Class.Null#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#1)]
     [!code-vb[System.String.Class.Null#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#1)]  
  
-   <span data-ttu-id="58835-233"><xref:System.String.IsNullOrWhiteSpace%2A>, que indica se uma cadeia de caracteres é `null`, é igual a <xref:System.String.Empty?displayProperty=nameWithType>, ou consistir exclusivamente em caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-233"><xref:System.String.IsNullOrWhiteSpace%2A>, which indicates whether a string is `null`, equals <xref:System.String.Empty?displayProperty=nameWithType>, or consists exclusively of white-space characters.</span></span> <span data-ttu-id="58835-234">Esse método elimina a necessidade de usar código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-234">This method eliminates the need to use code such as the following:</span></span>  
  
     [!code-cpp[System.String.Class.Null#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#2)]
     [!code-csharp[System.String.Class.Null#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#2)]
     [!code-vb[System.String.Class.Null#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#2)]  
  
 <span data-ttu-id="58835-235">O exemplo a seguir usa o <xref:System.String.IsNullOrEmpty%2A> método na <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação de um personalizado `Temperature` classe.</span><span class="sxs-lookup"><span data-stu-id="58835-235">The following example uses the <xref:System.String.IsNullOrEmpty%2A> method in the <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation of a custom `Temperature` class.</span></span> <span data-ttu-id="58835-236">O método dá suporte as cadeias de caracteres de formato "G", "C", "F" e "K".</span><span class="sxs-lookup"><span data-stu-id="58835-236">The method supports the "G", "C", "F", and "K" format strings.</span></span> <span data-ttu-id="58835-237">Se uma cadeia de caracteres de formato vazio ou um formato de cadeia de caracteres cujo valor é `null` é passado para o método, seu valor é alterado para a cadeia de caracteres de formato "G".</span><span class="sxs-lookup"><span data-stu-id="58835-237">If an empty format string or a format string whose value is `null` is passed to the method, its value is changed to the "G" format string.</span></span>  
  
 [!code-cpp[System.String.Class.Null#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.class.null/cpp/string.null.cpp#3)]
 [!code-csharp[System.String.Class.Null#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.class.null/cs/nullorempty1.cs#3)]
 [!code-vb[System.String.Class.Null#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.class.null/vb/nullorempty1.vb#3)]  
  
<a name="Immutability"></a>   
## <a name="immutability-and-the-stringbuilder-class"></a><span data-ttu-id="58835-238">Imutabilidade e a classe StringBuilder</span><span class="sxs-lookup"><span data-stu-id="58835-238">Immutability and the StringBuilder class</span></span>  
 <span data-ttu-id="58835-239">Um <xref:System.String> objeto é chamado imutável (somente leitura), porque seu valor não pode ser modificado após ele ter sido criado.</span><span class="sxs-lookup"><span data-stu-id="58835-239">A <xref:System.String> object is called immutable (read-only), because its value cannot be modified after it has been created.</span></span> <span data-ttu-id="58835-240">Métodos que aparecem para modificar uma <xref:System.String> objeto, na verdade, retornam um novo <xref:System.String> objeto que contém a modificação.</span><span class="sxs-lookup"><span data-stu-id="58835-240">Methods that appear to modify a <xref:System.String> object actually return a new <xref:System.String> object that contains the modification.</span></span>  
  
 <span data-ttu-id="58835-241">Como cadeias de caracteres são imutáveis, rotinas de manipulação de cadeia de caracteres que executam repetido adições ou exclusões para o que parece ser que uma única cadeia de caracteres pode exato uma penalidade de desempenho significativa.</span><span class="sxs-lookup"><span data-stu-id="58835-241">Because strings are immutable, string manipulation routines that perform repeated additions or deletions to what appears to be a single string can exact a significant performance penalty.</span></span> <span data-ttu-id="58835-242">Por exemplo, o código a seguir usa um gerador de número aleatório para criar uma cadeia de caracteres com 1000 caracteres no intervalo 0x0001 para 0x052F.</span><span class="sxs-lookup"><span data-stu-id="58835-242">For example, the following code uses a random number generator to create a string with 1000 characters in the range 0x0001 to 0x052F.</span></span> <span data-ttu-id="58835-243">Embora o código parece usar concatenação de cadeia de caracteres para acrescentar um novo caractere na cadeia de caracteres existente denominada `str`, na verdade cria um novo <xref:System.String> objeto para cada operação de concatenação.</span><span class="sxs-lookup"><span data-stu-id="58835-243">Although the code appears to use string concatenation to append a new character to the existing string named `str`, it actually creates a new <xref:System.String> object for each concatenation operation.</span></span>  
  
 [!code-cpp[System.String.Class#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder1.cpp#15)]
 [!code-csharp[System.String.Class#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable.cs#15)]
 [!code-vb[System.String.Class#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable.vb#15)]  
  
 <span data-ttu-id="58835-244">Você pode usar o <xref:System.Text.StringBuilder> classe, em vez do <xref:System.String> classe para operações que faça várias alterações no valor de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-244">You can use the <xref:System.Text.StringBuilder> class instead of the <xref:System.String> class for operations that make multiple changes to the value of a string.</span></span> <span data-ttu-id="58835-245">Diferentemente das instâncias do <xref:System.String> classe, <xref:System.Text.StringBuilder> objeto é mutável; ao concatenar, acrescentar ou excluir subcadeias de caracteres de uma cadeia de caracteres, as operações são executadas em uma única cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-245">Unlike instances of the <xref:System.String> class, <xref:System.Text.StringBuilder> objects are mutable; when you concatenate, append, or delete substrings from a string, the operations are performed on a single string.</span></span> <span data-ttu-id="58835-246">Quando você tiver terminado de modificar o valor de uma <xref:System.Text.StringBuilder> do objeto, você pode chamar seu <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> método convertê-la em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-246">When you have finished modifying the value of a <xref:System.Text.StringBuilder> object, you can call its <xref:System.Text.StringBuilder.ToString%2A?displayProperty=nameWithType> method to convert it to a string.</span></span> <span data-ttu-id="58835-247">O exemplo a seguir substitui o <xref:System.String> usado no exemplo anterior para concatenar 1000 caracteres aleatórios no intervalo como 0x0001 para 0x052F com um <xref:System.Text.StringBuilder> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-247">The following example replaces the <xref:System.String> used in the previous example to concatenate 1000 random characters in the range to  0x0001 to 0x052F with a <xref:System.Text.StringBuilder> object.</span></span>  
  
 [!code-cpp[System.String.Class#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.stringbuilder2.cpp#16)]
 [!code-csharp[System.String.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/immutable1.cs#16)]
 [!code-vb[System.String.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/immutable1.vb#16)]  
  
<a name="CultureSensitive"></a>   
## <a name="ordinal-vs-culture-sensitive-operations"></a><span data-ttu-id="58835-248">Ordinal x operações sensíveis à cultura</span><span class="sxs-lookup"><span data-stu-id="58835-248">Ordinal vs. culture-sensitive operations</span></span>  
 <span data-ttu-id="58835-249">Os membros a <xref:System.String> classe realizar operações de (linguísticas) ordinal ou sensível à cultura em um <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-249">Members of the <xref:System.String> class perform either ordinal or culture-sensitive (linguistic) operations on a <xref:System.String> object.</span></span> <span data-ttu-id="58835-250">Uma operação ordinal age no valor numérico de cada <xref:System.Char> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-250">An ordinal operation acts on the numeric value of each <xref:System.Char> object.</span></span> <span data-ttu-id="58835-251">Uma operação sensível à cultura atua no valor da <xref:System.String> objeto e maiusculas e minúsculas específicas da cultura de demora, classificação, formatação e regras de análise em consideração.</span><span class="sxs-lookup"><span data-stu-id="58835-251">A culture-sensitive operation acts on the value of the <xref:System.String> object, and takes culture-specific casing, sorting, formatting, and parsing rules into account.</span></span> <span data-ttu-id="58835-252">Operações sensíveis à cultura são executadas no contexto de uma cultura explicitamente declarada ou a cultura atual implícita.</span><span class="sxs-lookup"><span data-stu-id="58835-252">Culture-sensitive operations execute in the context of an explicitly declared culture or the implicit current culture.</span></span> <span data-ttu-id="58835-253">Os dois tipos de operações podem produzir resultados muito diferentes quando elas forem executadas na mesma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-253">The two kinds of operations can produce very different results when they are performed on the same string.</span></span>  
  
 <span data-ttu-id="58835-254">O .NET Framework também oferece suporte a operações de cadeia de caracteres linguística insensível à cultura usando a cultura invariável (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), que é baseado em configurações de cultura do idioma inglês independentemente da região.</span><span class="sxs-lookup"><span data-stu-id="58835-254">The .NET Framework also supports culture-insensitive linguistic string operations by using the invariant culture (<xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>), which is loosely based on the culture settings of the English language independent of region.</span></span> <span data-ttu-id="58835-255">Ao contrário de outras <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> configurações, as configurações da cultura invariável são garantidas para manter a consistência em um único computador, do sistema ao sistema e entre as versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="58835-255">Unlike other <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> settings, the settings of the invariant culture are guaranteed to remain consistent on a single computer, from system to system, and across versions of the .NET Framework.</span></span> <span data-ttu-id="58835-256">A cultura invariável pode ser visto como um tipo de caixa preta que garante a estabilidade das comparações de cadeia de caracteres e ordenação em todas as culturas.</span><span class="sxs-lookup"><span data-stu-id="58835-256">The invariant culture can be seen as a kind of black box that ensures stability of string comparisons and ordering across all cultures.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-257">Se seu aplicativo toma uma decisão de segurança sobre um identificador simbólico, como um nome de arquivo ou pipe nomeado ou sobre os dados persistentes, como os dados com base em texto em um arquivo XML, a operação deve usar uma comparação ordinal em vez de uma comparação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-257">If your application makes a security decision about a symbolic identifier such as a file name or named pipe, or about persisted data such as the text-based data in an XML file, the operation should use an ordinal comparison instead of a culture-sensitive comparison.</span></span> <span data-ttu-id="58835-258">Isso é porque uma comparação sensível à cultura pode produzir resultados diferentes dependendo da cultura em vigor, enquanto que uma comparação ordinal depende exclusivamente o valor binário dos caracteres comparados.</span><span class="sxs-lookup"><span data-stu-id="58835-258">This is because a culture-sensitive comparison can yield different results depending on the culture in effect, whereas an ordinal comparison depends solely on the binary value of the compared characters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-259">A maioria dos métodos que realizam operações de cadeia de caracteres incluem uma sobrecarga que tenha um parâmetro de tipo <xref:System.StringComparison>, que permite que você especifique se o método executa uma operação de ordinal ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-259">Most methods that perform string operations include an overload that has a parameter of type <xref:System.StringComparison>, which enables you to specify whether the method performs an ordinal or culture-sensitive operation.</span></span> <span data-ttu-id="58835-260">Em geral, você deve chamar essa sobrecarga para deixar a intenção do seu método de chamada não criptografado.</span><span class="sxs-lookup"><span data-stu-id="58835-260">In general, you should call this overload to make the intent of your method call clear.</span></span> <span data-ttu-id="58835-261">Para obter as práticas recomendadas e diretrizes para usar operações ordinais e sensíveis à cultura em cadeias de caracteres, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-261">For best practices and guidance for using ordinal and culture-sensitive operations on strings, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-262">Operações para [maiusculas e minúsculas](#casing), [análise e formatação](#parsing), [comparação e classificação](#comparison), e [Testando a igualdade](#equality) pode ser qualquer um dos ordinal ou sensíveis à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-262">Operations for [casing](#casing), [parsing and formatting](#parsing), [comparison and sorting](#comparison), and [testing for equality](#equality) can be either ordinal or culture-sensitive.</span></span> <span data-ttu-id="58835-263">As seções a seguir discutem cada categoria de operação.</span><span class="sxs-lookup"><span data-stu-id="58835-263">The following sections discuss each category of operation.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="58835-264">Você sempre deve chamar uma sobrecarga de método que faz com que a intenção do seu método de chamada não criptografado.</span><span class="sxs-lookup"><span data-stu-id="58835-264">You should always call a method overload that makes the intent of your method call clear.</span></span> <span data-ttu-id="58835-265">Por exemplo, em vez de chamar o <xref:System.String.Compare%28System.String%2CSystem.String%29> método para executar uma comparação sensível à cultura de duas cadeias de caracteres usando as convenções da cultura atual, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com um valor de <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> para o `comparisonType` argumento.</span><span class="sxs-lookup"><span data-stu-id="58835-265">For example, instead of calling the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to perform a culture-sensitive comparison of two strings by using the conventions of the current culture, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with a value of <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> for the `comparisonType` argument.</span></span> <span data-ttu-id="58835-266">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-266">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
<a name="casing"></a>   
### <a name="casing"></a><span data-ttu-id="58835-267">Maiúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-267">Casing</span></span>  
 <span data-ttu-id="58835-268">Regras de maiusculas e minúsculas determinam como alterar a capitalização de um caractere Unicode. Por exemplo, de letra minúscula em maiuscula.</span><span class="sxs-lookup"><span data-stu-id="58835-268">Casing rules determine how to change the capitalization of a Unicode character; for example, from lowercase to uppercase.</span></span> <span data-ttu-id="58835-269">Muitas vezes, uma operação de maiusculas e minúsculas é executada antes de uma comparação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-269">Often, a casing operation is performed before a string comparison.</span></span> <span data-ttu-id="58835-270">Por exemplo, uma cadeia de caracteres pode ser convertida em letras maiusculas para que ele pode ser comparado com outra cadeia de caracteres em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-270">For example, a string might be converted to uppercase so that it can be compared with another uppercase string.</span></span> <span data-ttu-id="58835-271">Você pode converter os caracteres em uma cadeia de caracteres em minúsculas com a chamada a <xref:System.String.ToLower%2A> ou <xref:System.String.ToLowerInvariant%2A> método e você pode convertê-los em letras maiusculas, chamando o <xref:System.String.ToUpper%2A> ou <xref:System.String.ToUpperInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-271">You can convert the characters in a string to lowercase by calling the <xref:System.String.ToLower%2A> or <xref:System.String.ToLowerInvariant%2A> method, and you can convert them to uppercase by calling the <xref:System.String.ToUpper%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="58835-272">Além disso, você pode usar o <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> método para converter uma cadeia de caracteres para capitalização de título.</span><span class="sxs-lookup"><span data-stu-id="58835-272">In addition, you can use the <xref:System.Globalization.TextInfo.ToTitleCase%2A?displayProperty=nameWithType> method to convert a string to title case.</span></span>  
  
 <span data-ttu-id="58835-273">Operações de maiusculas e minúsculas podem ser baseadas nas regras da cultura atual, uma cultura específica ou a cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="58835-273">Casing operations can be based on the rules of the current culture, a specified culture, or the invariant culture.</span></span> <span data-ttu-id="58835-274">Como mapeamentos de casos podem variar dependendo da cultura usada, o resultado de operações de maiusculas e minúsculas pode variar com base na cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-274">Because case mappings can vary depending on the culture used, the result of casing operations can vary based on culture.</span></span> <span data-ttu-id="58835-275">As diferenças reais em maiusculas e minúsculas são de três tipos:</span><span class="sxs-lookup"><span data-stu-id="58835-275">The actual differences in casing are of three kinds:</span></span>  
  
-   <span data-ttu-id="58835-276">Diferenças no mapeamento de maiusculas da LETRA maiuscula de LATINO I (u+0049), LATINO pequeno LETRA I (u+0069), LATINO LETRA maiuscula a I mesmo com ponto superior (U + 0130) e LATIN pequeno LETRA i sem PINGO I (U + 0131).</span><span class="sxs-lookup"><span data-stu-id="58835-276">Differences in the case mapping of LATIN CAPITAL LETTER I (U+0049), LATIN SMALL LETTER I (U+0069), LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130), and LATIN SMALL LETTER DOTLESS I (U+0131).</span></span> <span data-ttu-id="58835-277">No tr-TR (turco (Turquia)) e culturas de az-Latn-AZ (Azerbaijão, latino) e no tr, az e culturas neutras de az-Latn, o equivalente em minúsculas de LETRA maiuscula latina I é LATIM pequeno LETRA i sem PINGO I, e é o equivalente maiusculo LATINO pequeno LETRA I LETRA LATINA MAIUSCULA I COM PONTO ACIMA.</span><span class="sxs-lookup"><span data-stu-id="58835-277">In the tr-TR (Turkish (Turkey)) and az-Latn-AZ (Azerbaijan, Latin) cultures, and in the tr, az, and az-Latn neutral cultures, the lowercase equivalent of LATIN CAPITAL LETTER I is LATIN SMALL LETTER DOTLESS I, and the uppercase equivalent of LATIN SMALL LETTER I is LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span> <span data-ttu-id="58835-278">Em outras culturas, incluindo a cultura invariável, LATINO pequeno LETRA I e maiuscula latina que são equivalentes maiusculos e minúsculos.</span><span class="sxs-lookup"><span data-stu-id="58835-278">In all other cultures, including the invariant culture, LATIN SMALL LETTER I and LATIN CAPITAL LETTER I are lowercase and uppercase equivalents.</span></span>  
  
     <span data-ttu-id="58835-279">O exemplo a seguir demonstra como uma comparação de cadeia de caracteres projetada impedir o acesso de sistema de arquivos pode falhar se ele se baseia em uma comparação de maiusculas e minúsculas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-279">The following example demonstrates how a string comparison designed to prevent file system access can fail if it relies on a culture-sensitive casing comparison.</span></span> <span data-ttu-id="58835-280">(As convenções de capitalização da cultura invariável devem ter sido usadas.)</span><span class="sxs-lookup"><span data-stu-id="58835-280">(The casing conventions of the invariant culture should have been used.)</span></span>  
  
     [!code-csharp[System.String.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case2.cs#17)]
     [!code-vb[System.String.Class#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case2.vb#17)]  
  
-   <span data-ttu-id="58835-281">Diferenças nos mapeamentos de casos entre todas as outras culturas e a cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="58835-281">Differences in case mappings between the invariant culture and all other cultures.</span></span> <span data-ttu-id="58835-282">Nesses casos, usando as regras de maiusculas e minúsculas da cultura invariável para alterar um caractere para maiusculas ou minúsculas retorna o mesmo caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-282">In these cases, using the casing rules of the invariant culture to change a character to uppercase or lowercase returns the same character.</span></span> <span data-ttu-id="58835-283">Para todas as culturas, ele retorna um caractere diferente.</span><span class="sxs-lookup"><span data-stu-id="58835-283">For all other cultures, it returns a different character.</span></span> <span data-ttu-id="58835-284">Alguns dos caracteres afetados são listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-284">Some of the affected characters are listed in the following table.</span></span>  
  
    |<span data-ttu-id="58835-285">Caractere</span><span class="sxs-lookup"><span data-stu-id="58835-285">Character</span></span>|<span data-ttu-id="58835-286">Se alterado para</span><span class="sxs-lookup"><span data-stu-id="58835-286">If changed to</span></span>|<span data-ttu-id="58835-287">Retorna</span><span class="sxs-lookup"><span data-stu-id="58835-287">Returns</span></span>|  
    |---------------|-------------------|-------------|  
    |<span data-ttu-id="58835-288">ENTRADA DE MÍCRON (U + 00B5)</span><span class="sxs-lookup"><span data-stu-id="58835-288">MICRON SIGN (U+00B5)</span></span>|<span data-ttu-id="58835-289">Maiúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-289">Uppercase</span></span>|<span data-ttu-id="58835-290">LETRA MAIUSCULA GREGA MU (U +-39C)</span><span class="sxs-lookup"><span data-stu-id="58835-290">GREEK CAPITAL LETTER MU (U+-39C)</span></span>|  
    |<span data-ttu-id="58835-291">LETRA LATINA MAIUSCULA I COM PONTO ACIMA (U + 0130)</span><span class="sxs-lookup"><span data-stu-id="58835-291">LATIN CAPITAL LETTER I WITH DOT ABOVE (U+0130)</span></span>|<span data-ttu-id="58835-292">Minúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-292">Lowercase</span></span>|<span data-ttu-id="58835-293">LETRA MINÚSCULA LATINA I (U+0069)</span><span class="sxs-lookup"><span data-stu-id="58835-293">LATIN SMALL LETTER I (U+0069)</span></span>|  
    |<span data-ttu-id="58835-294">LETRA LATINA MINÚSCULA SEM PINGO EU (U + 0131)</span><span class="sxs-lookup"><span data-stu-id="58835-294">LATIN SMALL LETTER DOTLESS I (U+0131)</span></span>|<span data-ttu-id="58835-295">Maiúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-295">Uppercase</span></span>|<span data-ttu-id="58835-296">LETRA LATINA MAIUSCULA I (U+0049)</span><span class="sxs-lookup"><span data-stu-id="58835-296">LATIN CAPITAL LETTER I (U+0049)</span></span>|  
    |<span data-ttu-id="58835-297">LETRA LATINA MINÚSCULA LONGO S (U + 017F)</span><span class="sxs-lookup"><span data-stu-id="58835-297">LATIN SMALL LETTER LONG S (U+017F)</span></span>|<span data-ttu-id="58835-298">Maiúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-298">Uppercase</span></span>|<span data-ttu-id="58835-299">LETRA LATINA MAIUSCULA S (U + 0053)</span><span class="sxs-lookup"><span data-stu-id="58835-299">LATIN CAPITAL LETTER S (U+0053)</span></span>|  
    |<span data-ttu-id="58835-300">LETRA LATINA MAIUSCULA 1!D COM LETRA MINÚSCULA Z COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 5)</span><span class="sxs-lookup"><span data-stu-id="58835-300">LATIN CAPITAL LETTER D WITH SMALL LETTER Z WITH CARON (U+01C5)</span></span>|<span data-ttu-id="58835-301">Minúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-301">Lowercase</span></span>|<span data-ttu-id="58835-302">LETRA LATINA MINÚSCULA DZ COM ACENTO CIRCUNFLEXO INVERTIDO (U + 01C 6)</span><span class="sxs-lookup"><span data-stu-id="58835-302">LATIN SMALL LETTER DZ WITH CARON (U+01C6)</span></span>|  
    |<span data-ttu-id="58835-303">COMBINANDO CARACTERE GREGO IOTA SUBSCRITO (U + 0345)</span><span class="sxs-lookup"><span data-stu-id="58835-303">COMBINING GREEK YPOGEGRAMMENI (U+0345)</span></span>|<span data-ttu-id="58835-304">Maiúsculas</span><span class="sxs-lookup"><span data-stu-id="58835-304">Uppercase</span></span>|<span data-ttu-id="58835-305">LETRA MAIUSCULA GREGA IOTA (U + 0399)</span><span class="sxs-lookup"><span data-stu-id="58835-305">GREEK CAPITAL LETTER IOTA (U+0399)</span></span>|  
  
-   <span data-ttu-id="58835-306">Diferenças nos mapeamentos de casos de duas letras maiusculas e minúsculas pares no intervalo de caracteres ASCII.</span><span class="sxs-lookup"><span data-stu-id="58835-306">Differences in case mappings of two-letter mixed-case pairs in the ASCII character range.</span></span> <span data-ttu-id="58835-307">Na maioria das culturas, um par de duas letras maiusculas e minúsculas é igual ao par equivalente duas letras maiusculo ou minúsculo.</span><span class="sxs-lookup"><span data-stu-id="58835-307">In most cultures, a two-letter mixed-case pair is equal to the equivalent two-letter uppercase or lowercase pair.</span></span> <span data-ttu-id="58835-308">Isso não é verdadeiro para os seguintes pares de duas letras em culturas a seguir, porque em cada caso, eles são comparados com um dígrafo:</span><span class="sxs-lookup"><span data-stu-id="58835-308">This is not true for the following two-letter pairs in the following cultures, because in each case they are compared to a digraph:</span></span>  
  
    -   <span data-ttu-id="58835-309">"lJ" e "nJ" a cultura hr-HR (Croata (Croácia)).</span><span class="sxs-lookup"><span data-stu-id="58835-309">"lJ" and "nJ" in the hr-HR (Croatian (Croatia)) culture.</span></span>  
  
    -   <span data-ttu-id="58835-310">"cH" no cs-CZ (Tcheco (República Tcheca)) e culturas sk-SK (Eslovaco (Eslováquia)).</span><span class="sxs-lookup"><span data-stu-id="58835-310">"cH" in the cs-CZ (Czech (Czech Republic)) and sk-SK (Slovak (Slovakia)) cultures.</span></span>  
  
    -   <span data-ttu-id="58835-311">"aA" na cultura da-DK (dinamarquês (Dinamarca)).</span><span class="sxs-lookup"><span data-stu-id="58835-311">"aA" in the da-DK (Danish (Denmark)) culture.</span></span>  
  
    -   <span data-ttu-id="58835-312">"cS", "dZ", "dZS", "nY", "sZ", "tY" e "zS" na cultura hu-HU (húngaro (Hungria)).</span><span class="sxs-lookup"><span data-stu-id="58835-312">"cS", "dZ", "dZS", "nY", "sZ", "tY", and "zS" in the hu-HU (Hungarian (Hungary)) culture.</span></span>  
  
    -   <span data-ttu-id="58835-313">"cH" e "lL" a cultura es-ES_tradnl (Espanhol (Espanha, tradicional)).</span><span class="sxs-lookup"><span data-stu-id="58835-313">"cH" and "lL" in the es-ES_tradnl (Spanish (Spain, Traditional Sort)) culture.</span></span>  
  
    -   <span data-ttu-id="58835-314">"cH", "gI", "kH", "nG" "HN", "pH", "qU", "tH" e "tR" na cultura vi-VN (vietnamita (Vietnã)).</span><span class="sxs-lookup"><span data-stu-id="58835-314">"cH", "gI", "kH", "nG" "nH", "pH", "qU', "tH", and "tR" in the vi-VN (Vietnamese (Vietnam)) culture.</span></span>  
  
     <span data-ttu-id="58835-315">No entanto, é incomum encontrar uma situação em que uma comparação sensível à cultura desses pares cria problemas, porque esses pares são incomuns em cadeias de caracteres fixas ou identificadores.</span><span class="sxs-lookup"><span data-stu-id="58835-315">However, it is unusual to encounter a situation in which a culture-sensitive comparison of these pairs creates problems, because these pairs are uncommon in fixed strings or identifiers.</span></span>  
  
 <span data-ttu-id="58835-316">O exemplo a seguir ilustra algumas das diferenças nas regras de maiusculas e minúsculas entre culturas durante a conversão de cadeias de caracteres em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-316">The following example illustrates some of the differences in casing rules between cultures when converting strings to uppercase.</span></span>  
  
 [!code-cpp[System.String.Class#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.casing.cpp#7)]
 [!code-csharp[System.String.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/case1.cs#7)]
 [!code-vb[System.String.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/case1.vb#7)]  
  
<a name="parsing"></a>   
### <a name="parsing-and-formatting"></a><span data-ttu-id="58835-317">Análise e formatação</span><span class="sxs-lookup"><span data-stu-id="58835-317">Parsing and formatting</span></span>  
 <span data-ttu-id="58835-318">Formatação e análise são operações inversas.</span><span class="sxs-lookup"><span data-stu-id="58835-318">Formatting and parsing are inverse operations.</span></span> <span data-ttu-id="58835-319">Regras de formatação determinam como converter um valor, como uma data e hora ou um número, em sua representação de cadeia de caracteres, enquanto as regras de análise determinam como converter uma representação de cadeia de caracteres em um valor como uma data e hora.</span><span class="sxs-lookup"><span data-stu-id="58835-319">Formatting rules determine how to convert a value, such as a date and time or a number, to its string representation, whereas parsing rules determine how to convert a string representation to a value such as a date and time.</span></span> <span data-ttu-id="58835-320">Tanto a formatação e regras de análise são dependentes de convenções culturais.</span><span class="sxs-lookup"><span data-stu-id="58835-320">Both formatting and parsing rules are dependent on cultural conventions.</span></span> <span data-ttu-id="58835-321">O exemplo a seguir ilustra a ambiguidade que pode surgir ao interpretar uma cadeia de caracteres de data específicos de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-321">The following example illustrates the ambiguity that can arise when interpreting a culture-specific date string.</span></span> <span data-ttu-id="58835-322">Sem saber as convenções da cultura usada para produzir uma cadeia de caracteres de data, não é possível saber se 01/03/2011, 1/3/2011 e 01/03/2011 representam 3 de janeiro de 2011 ou 1 de março de 2011.</span><span class="sxs-lookup"><span data-stu-id="58835-322">Without knowing the conventions of the culture that was used to produce a date string, it is not possible to know whether 03/01/2011, 3/1/2011, and 01/03/2011 represent January 3, 2011 or March 1, 2011.</span></span>  
  
 [!code-cpp[System.String.Class#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.format1.cpp#8)]
 [!code-csharp[System.String.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/format1.cs#8)]
 [!code-vb[System.String.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/format1.vb#8)]  
  
 <span data-ttu-id="58835-323">Da mesma forma, como mostra o exemplo a seguir, uma única cadeia de caracteres pode produzir datas diferentes dependendo da cultura cujas convenções são usadas na operação de análise.</span><span class="sxs-lookup"><span data-stu-id="58835-323">Similarly, as the following example shows, a single string can produce different dates depending on the culture whose conventions are used in the parsing operation.</span></span>  
  
 [!code-cpp[System.String.Class#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.parse1.cpp#9)]
 [!code-csharp[System.String.Class#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/parse1.cs#9)]
 [!code-vb[System.String.Class#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/parse1.vb#9)]  
  
<a name="comparison"></a>   
### <a name="string-comparison-and-sorting"></a><span data-ttu-id="58835-324">Comparação da cadeia de caracteres e classificação</span><span class="sxs-lookup"><span data-stu-id="58835-324">String comparison and sorting</span></span>  
 <span data-ttu-id="58835-325">Convenções para comparar e classificar cadeias de caracteres variam de culturas.</span><span class="sxs-lookup"><span data-stu-id="58835-325">Conventions for comparing and sorting strings vary from culture to culture.</span></span> <span data-ttu-id="58835-326">Por exemplo, a ordem de classificação pode se basear em fonética ou na representação visual de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-326">For example, the sort order may be based on phonetics or on the visual representation of characters.</span></span> <span data-ttu-id="58835-327">Em idiomas do Leste Asiático, os caracteres são classificados pelo traço e radical de ideogramas.</span><span class="sxs-lookup"><span data-stu-id="58835-327">In East Asian languages, characters are sorted by the stroke and radical of ideographs.</span></span> <span data-ttu-id="58835-328">Também classificação depende das linguagens de ordem e culturas usam para o alfabeto.</span><span class="sxs-lookup"><span data-stu-id="58835-328">Sorting also depends on the order languages and cultures use for the alphabet.</span></span> <span data-ttu-id="58835-329">Por exemplo, o idioma dinamarquês tem um caractere de "Æ" que ele classifica após "Z" no alfabeto.</span><span class="sxs-lookup"><span data-stu-id="58835-329">For example, the Danish language has an "Æ" character that it sorts after "Z" in the alphabet.</span></span> <span data-ttu-id="58835-330">Além disso, as comparações podem ser maiusculas e minúsculas ou maiusculas de minúsculas, e em alguns casos as regras de maiusculas e minúsculas também diferem por cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-330">In addition, comparisons can be case-sensitive or case-insensitive, and in some cases casing rules also differ by culture.</span></span> <span data-ttu-id="58835-331">Comparação ordinal, por outro lado, usa os pontos de código Unicode dos caracteres individuais em uma cadeia de caracteres ao comparar e classificar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-331">Ordinal comparison, on the other hand, uses the Unicode code points of individual characters in a string when comparing and sorting strings.</span></span>  
  
 <span data-ttu-id="58835-332">Regras de classificação determinam que a ordem alfabética de caracteres Unicode e cadeias de caracteres como dois comparam entre si.</span><span class="sxs-lookup"><span data-stu-id="58835-332">Sort rules determine the alphabetic order of Unicode characters and how two strings compare to each other.</span></span> <span data-ttu-id="58835-333">Por exemplo, o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método compara duas cadeias de caracteres com base no <xref:System.StringComparison> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-333">For example, the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method compares two strings based on the <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="58835-334">Se o valor do parâmetro for <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, o método executa uma comparação linguística que usa as convenções da cultura atual; se o valor do parâmetro for <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, o método executa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-334">If the parameter value is <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, the method performs a linguistic comparison that uses the conventions of the current culture; if the parameter value is <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>, the method performs an ordinal comparison.</span></span> <span data-ttu-id="58835-335">Consequentemente, como mostra o exemplo seguinte, se a cultura atual é dos EUA Inglês, a primeira chamada para o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método (usando a comparação sensível à cultura) considera "a" menor que "A", mas considera a segunda chamada para o mesmo método (usando a comparação ordinal) "a" maior que "A".</span><span class="sxs-lookup"><span data-stu-id="58835-335">Consequently, as the following example shows, if the current culture is U.S. English, the first call to the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> method (using culture-sensitive comparison) considers "a" less than "A", but the second call to the same method (using ordinal comparison) considers "a" greater than "A".</span></span>  
  
 [!code-cpp[System.String.Class#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare1.cpp#10)]
 [!code-csharp[System.String.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare1.cs#10)]
 [!code-vb[System.String.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare1.vb#10)]  
  
 <span data-ttu-id="58835-336">O .NET Framework dá suporte a palavra, cadeia de caracteres e regras de classificação ordinal:</span><span class="sxs-lookup"><span data-stu-id="58835-336">The .NET Framework supports word, string, and ordinal sort rules:</span></span>  
  
-   <span data-ttu-id="58835-337">Uma classificação de palavra executa uma comparação de cadeias de caracteres sensível a cultura, em que determinados caracteres não alfanuméricos Unicode podem ter pesos especiais atribuídos a eles.</span><span class="sxs-lookup"><span data-stu-id="58835-337">A word sort performs a culture-sensitive comparison of strings in which certain nonalphanumeric Unicode characters might have special weights assigned to them.</span></span> <span data-ttu-id="58835-338">Por exemplo, o hífen (-) pode ter um peso muito pequeno atribuído a ele, de modo que "coop" e "co-op" apareçam próximos uns dos outros em uma lista classificada.</span><span class="sxs-lookup"><span data-stu-id="58835-338">For example, the hyphen (-) might have a very small weight assigned to it so that "coop" and "co-op" appear next to each other in a sorted list.</span></span> <span data-ttu-id="58835-339">Para obter uma lista da <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação do word, consulte a [operações de cadeia de caracteres por categoria](#ByCategory) seção.</span><span class="sxs-lookup"><span data-stu-id="58835-339">For a list of the <xref:System.String> methods that compare two strings using word sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
-   <span data-ttu-id="58835-340">Uma classificação de cadeia de caracteres também executa uma comparação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-340">A string sort also performs a culture-sensitive comparison.</span></span> <span data-ttu-id="58835-341">Ele é semelhante a uma classificação de palavra, exceto que há não há casos especiais, e todos os símbolos não alfanuméricos vêm antes de todos os caracteres Unicode de alfanumérico.</span><span class="sxs-lookup"><span data-stu-id="58835-341">It is similar to a word sort, except that there are no special cases, and all nonalphanumeric symbols come before all alphanumeric Unicode characters.</span></span> <span data-ttu-id="58835-342">Duas cadeias de caracteres podem ser comparadas usando regras de classificação de cadeia de caracteres chamando o <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> sobrecargas de método que tem um `options` parâmetro que é fornecido um valor de <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-342">Two strings can be compared using string sort rules by calling the <xref:System.Globalization.CompareInfo.Compare%2A?displayProperty=nameWithType> method overloads that have an `options` parameter that is supplied a value of <xref:System.Globalization.CompareOptions.StringSort?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-343">Observe que isso é o único método que o .NET Framework fornece para comparar duas cadeias de caracteres usando regras de classificação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-343">Note that this is the only method that the .NET Framework provides to compare two strings using string sort rules.</span></span>  
  
-   <span data-ttu-id="58835-344">Uma classificação ordinal compara as cadeias de caracteres com base no valor numérico de cada objeto <xref:System.Char> na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-344">An ordinal sort compares strings based on the numeric value of each <xref:System.Char> object in the string.</span></span> <span data-ttu-id="58835-345">Uma comparação ordinal é automaticamente diferencia maiusculas de minúsculas porque as versões maiusculas e minúsculas de um caractere têm pontos de código diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-345">An ordinal comparison is automatically case-sensitive because the lowercase and uppercase versions of a character have different code points.</span></span> <span data-ttu-id="58835-346">No entanto, se o caso não é importante, você pode especificar uma comparação ordinal que diferencia maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-346">However, if case is not important, you can specify an ordinal comparison that ignores case.</span></span> <span data-ttu-id="58835-347">Isso é equivalente a converter a cadeia de caracteres em maiusculas usando a cultura invariável e, em seguida, executar uma comparação ordinal no resultado.</span><span class="sxs-lookup"><span data-stu-id="58835-347">This is equivalent to converting the string to uppercase by using the invariant culture and then performing an ordinal comparison on the result.</span></span> <span data-ttu-id="58835-348">Para obter uma lista de <xref:System.String> métodos que comparam duas cadeias de caracteres usando regras de classificação ordinal, consulte a [operações de cadeia de caracteres por categoria](#ByCategory) seção.</span><span class="sxs-lookup"><span data-stu-id="58835-348">For a list of the <xref:System.String> methods that compare two strings using ordinal sort rules, see the [String operations by category](#ByCategory) section.</span></span>  
  
 <span data-ttu-id="58835-349">Uma comparação sensível à cultura é qualquer comparação que usa explicitamente ou implicitamente um <xref:System.Globalization.CultureInfo> objeto, incluindo a cultura invariável especificado pelo <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="58835-349">A culture-sensitive comparison is any comparison that explicitly or implicitly uses a <xref:System.Globalization.CultureInfo> object, including the invariant culture that is specified by the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="58835-350">A cultura implícita é a cultura atual, que é especificada pela <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> e <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedades.</span><span class="sxs-lookup"><span data-stu-id="58835-350">The implicit culture is the current culture, which is specified by the <xref:System.Threading.Thread.CurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="58835-351">Há uma variação considerável na ordem de classificação de caracteres alfabéticos (isto é, os caracteres para o qual o <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> propriedade retorna `true`) entre culturas.</span><span class="sxs-lookup"><span data-stu-id="58835-351">There is considerable variation in the sort order of alphabetic characters (that is, characters for which the <xref:System.Char.IsLetter%2A?displayProperty=nameWithType> property returns `true`) across cultures.</span></span> <span data-ttu-id="58835-352">Você pode especificar uma comparação sensível à cultura que usa as convenções de uma cultura específica, fornecendo uma <xref:System.Globalization.CultureInfo> de objeto para um método de comparação de cadeia de caracteres como <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span><span class="sxs-lookup"><span data-stu-id="58835-352">You can specify a culture-sensitive comparison that uses the conventions of a specific culture by supplying a <xref:System.Globalization.CultureInfo> object to a string comparison method such as <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29>.</span></span> <span data-ttu-id="58835-353">Você pode especificar uma comparação sensível à cultura que usa as convenções da cultura atual, fornecendo <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, ou qualquer membro do <xref:System.Globalization.CompareOptions> enumeração diferente de <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> ou <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> com um número apropriado sobrecarga da <xref:System.String.Compare%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-353">You can specify a culture-sensitive comparison that uses the conventions of the current culture by supplying <xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, or any member of the <xref:System.Globalization.CompareOptions> enumeration other than <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> or <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> to an appropriate overload of the <xref:System.String.Compare%2A> method.</span></span> <span data-ttu-id="58835-354">Uma comparação sensível à cultura é geralmente adequada para classificação, enquanto uma comparação ordinal não é.</span><span class="sxs-lookup"><span data-stu-id="58835-354">A culture-sensitive comparison is generally appropriate for sorting whereas an ordinal comparison is not.</span></span> <span data-ttu-id="58835-355">Uma comparação ordinal é geralmente adequada para determinar se duas cadeias de caracteres são iguais (isto é, para determinar a identidade), enquanto uma comparação sensível à cultura não é.</span><span class="sxs-lookup"><span data-stu-id="58835-355">An ordinal comparison is generally appropriate for determining whether two strings are equal (that is, for determining identity) whereas a culture-sensitive comparison is not.</span></span>  
  
 <span data-ttu-id="58835-356">O exemplo a seguir ilustra a diferença entre a comparação ordinal e de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-356">The following example illustrates the difference between culture-sensitive and ordinal comparison.</span></span> <span data-ttu-id="58835-357">O exemplo será avaliado três cadeias de caracteres, "Apple", "Æble" e "AEble", usando as convenções das culturas da-DK e en-US e comparação ordinal (cada um deles é a cultura padrão no momento o <xref:System.String.Compare%2A> método é chamado).</span><span class="sxs-lookup"><span data-stu-id="58835-357">The example evaluates three strings, "Apple", "Æble", and "AEble", using ordinal comparison and the conventions of the da-DK and en-US cultures (each of which is the default culture at the time the <xref:System.String.Compare%2A> method is called).</span></span> <span data-ttu-id="58835-358">Como o idioma dinamarquês trata o caractere "Æ" como uma letra individual e classifica-o após "Z" no alfabeto, a cadeia de caracteres "Æble" é maior que "Apple".</span><span class="sxs-lookup"><span data-stu-id="58835-358">Because the Danish language treats the character "Æ" as an individual letter and sorts it after "Z" in the alphabet, the string "Æble" is greater than "Apple".</span></span> <span data-ttu-id="58835-359">No entanto, "Æble" não é considerado equivalente a "AEble", "Æble" também é maior que "AEble".</span><span class="sxs-lookup"><span data-stu-id="58835-359">However, "Æble" is not considered equivalent to "AEble", so "Æble" is also greater than "AEble".</span></span> <span data-ttu-id="58835-360">A cultura en-US não inclui a letra "Æ", mas trata como equivalente a "AE", que explica por que "Æble" é menor que "Apple" mas igual a "AEble".</span><span class="sxs-lookup"><span data-stu-id="58835-360">The en-US culture doesn't include the letter"Æ" but treats it as equivalent to "AE", which explains why  "Æble" is less than "Apple" but equal to "AEble".</span></span> <span data-ttu-id="58835-361">Comparação ordinal, por outro lado, considera "Apple" para ser menor que "Æble" e "Æble" seja maior que "AEble".</span><span class="sxs-lookup"><span data-stu-id="58835-361">Ordinal comparison, on the other hand, considers "Apple" to be less than "Æble", and "Æble" to be greater than "AEble".</span></span>  
  
 [!code-csharp[System.String.Class#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare4.cs#21)]
 [!code-vb[System.String.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare4.vb#21)]  
  
 <span data-ttu-id="58835-362">Use as seguintes diretrizes gerais para escolher um método de comparação de classificação ou a cadeia de caracteres apropriado:</span><span class="sxs-lookup"><span data-stu-id="58835-362">Use the following general guidelines to choose an appropriate sorting or string comparison method:</span></span>  
  
-   <span data-ttu-id="58835-363">Se você quiser cadeias de caracteres a ser ordenadas com base na cultura do usuário, você deve pedi-las com base nas convenções da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-363">If you want the strings to be ordered based on the user's culture, you should order them based on the conventions of the current culture.</span></span> <span data-ttu-id="58835-364">Se a cultura do usuário for alterado, a ordem de cadeias de caracteres classificadas também serão alterados adequadamente.</span><span class="sxs-lookup"><span data-stu-id="58835-364">If the user's culture changes, the order of sorted strings will also change accordingly.</span></span> <span data-ttu-id="58835-365">Por exemplo, um aplicativo de dicionário de sinônimos deve sempre ser classificada palavras com base na cultura do usuário.</span><span class="sxs-lookup"><span data-stu-id="58835-365">For example, a thesaurus application should always sort words based on the user's culture.</span></span>  
  
-   <span data-ttu-id="58835-366">Se você quiser cadeias de caracteres a ser ordenadas com base nas convenções de uma cultura específica, ordene-as, fornecendo um <xref:System.Globalization.CultureInfo> objeto que representa aquela cultura para um método de comparação.</span><span class="sxs-lookup"><span data-stu-id="58835-366">If you want the strings to be ordered based on the conventions of a specific culture, you should order them by supplying a <xref:System.Globalization.CultureInfo> object that represents that culture to a comparison method.</span></span> <span data-ttu-id="58835-367">Por exemplo, em um aplicativo projetado para ensinar aos alunos um idioma específico, você deseja cadeias de caracteres a ser ordenadas com base nas convenções de uma das culturas que participa como palestrante nesse idioma.</span><span class="sxs-lookup"><span data-stu-id="58835-367">For example, in an application designed to teach students a particular language, you want strings to be ordered based on the conventions of one of the cultures that speaks that language.</span></span>  
  
-   <span data-ttu-id="58835-368">Se você deseja que a ordem de cadeias de caracteres permanecem inalterados entre culturas, você deve ordená-los com base nas convenções da cultura invariável ou usar uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-368">If you want the order of strings to remain unchanged across cultures, you should order them based on the conventions of the invariant culture or use an ordinal comparison.</span></span> <span data-ttu-id="58835-369">Por exemplo, você usaria uma classificação ordinal para organizar os nomes de arquivos, processos, mutexes, ou pipes nomeados.</span><span class="sxs-lookup"><span data-stu-id="58835-369">For example, you would use an ordinal sort to organize the names of files, processes, mutexes, or named pipes.</span></span>  
  
-   <span data-ttu-id="58835-370">Para obter uma comparação que envolve uma decisão de segurança (como se um nome de usuário é válido), você deve sempre executar um ordinal testar a igualdade chamando uma sobrecarga da <xref:System.String.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-370">For a comparison that involves a security decision (such as whether a username is valid), you should always perform an ordinal test for equality by calling an overload of the <xref:System.String.Equals%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-371">A classificação sensíveis à cultura e maiusculas e minúsculas usadas na comparação de cadeia de caracteres de regras dependem da versão do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="58835-371">The culture-sensitive sorting and casing rules used in string comparison depend on the version of the .NET Framework.</span></span> <span data-ttu-id="58835-372">No .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] em execução no [!INCLUDE[win8](~/includes/win8-md.md)] sistema operacional, classificação, maiusculas e minúsculas, normalização e informações de caractere Unicode em conformidade com o padrão Unicode 6.0.</span><span class="sxs-lookup"><span data-stu-id="58835-372">In the .NET Framework [!INCLUDE[net_v45](~/includes/net-v45-md.md)] running on the [!INCLUDE[win8](~/includes/win8-md.md)] operating system, sorting, casing, normalization, and Unicode character information conforms to the Unicode 6.0 standard.</span></span> <span data-ttu-id="58835-373">Em outros sistemas operacionais, ele está em conformidade com o padrão Unicode 5.0.</span><span class="sxs-lookup"><span data-stu-id="58835-373">On other operating systems, it conforms to the Unicode 5.0 standard.</span></span>  
  
 <span data-ttu-id="58835-374">Para obter mais informações sobre palavra, cadeia de caracteres e regras de classificação ordinal, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> tópico.</span><span class="sxs-lookup"><span data-stu-id="58835-374">For more information about word, string, and ordinal sort rules, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> topic.</span></span> <span data-ttu-id="58835-375">Para obter recomendações adicionais sobre quando usar cada regra, consulte [práticas recomendadas para usar cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-375">For additional recommendations on when to use each rule, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-376">Normalmente, você não chamar cadeia de caracteres de métodos de comparação como <xref:System.String.Compare%2A> diretamente para determinar a ordem de classificação de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-376">Ordinarily, you don't call string comparison methods such as <xref:System.String.Compare%2A> directly to determine the sort order of strings.</span></span> <span data-ttu-id="58835-377">Em vez disso, os métodos de comparação são chamados por métodos de classificação, como <xref:System.Array.Sort%2A?displayProperty=nameWithType> ou <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-377">Instead, comparison methods are called by sorting methods such as <xref:System.Array.Sort%2A?displayProperty=nameWithType> or <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-378">O exemplo a seguir executa quatro operações de classificação diferentes (classificação de palavra usando a cultura atual, classificação de palavra usando a cultura invariável, classificação ordinal e classificação de cadeia de caracteres usando a cultura invariável) sem chamar explicitamente um método de comparação de cadeia de caracteres Embora eles especificam o tipo de comparação a ser usado.</span><span class="sxs-lookup"><span data-stu-id="58835-378">The following example performs four different sorting operations (word sort using the current culture, word sort using the invariant culture, ordinal sort, and string sort using the invariant culture) without explicitly calling a string comparison method, although they do specify the type of comparison to use.</span></span> <span data-ttu-id="58835-379">Observe que cada tipo de classificação produz uma classificação exclusivo das cadeias de caracteres em sua matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-379">Note that each type of sort produces a unique ordering of strings in its array.</span></span>  
  
 [!code-cpp[System.String.Class#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare2.cpp#12)]
 [!code-csharp[System.String.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare2.cs#12)]
 [!code-vb[System.String.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare2.vb#12)]  
  
> [!TIP]
>  <span data-ttu-id="58835-380">Internamente, o.NET Framework usa chaves de classificação para dar suporte à comparação de cadeia de caracteres culturallysensitive.</span><span class="sxs-lookup"><span data-stu-id="58835-380">Internally, the.NET Framework uses sort keys to support culturallysensitive string comparison.</span></span> <span data-ttu-id="58835-381">Cada caractere em uma cadeia de caracteres é atribuída diversas categorias de pesos de classificação, incluindo alfabético, maiusculas e minúsculas e diacríticos.</span><span class="sxs-lookup"><span data-stu-id="58835-381">Each character in a string is given several categories of sort weights, including alphabetic, case, and diacritic.</span></span> <span data-ttu-id="58835-382">Uma chave de classificação, representado pelo <xref:System.Globalization.SortKey> de classe, fornece um repositório desses pesos para uma determinada cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-382">A sort key, represented by the <xref:System.Globalization.SortKey> class, provides a repository of these weights for a particular string.</span></span> <span data-ttu-id="58835-383">Se seu aplicativo executa um grande número de pesquisa ou operações no mesmo conjunto de cadeias de caracteres de classificação, você pode melhorar o desempenho gerando e armazenando chaves de classificação para todas as cadeias de caracteres que ele usa.</span><span class="sxs-lookup"><span data-stu-id="58835-383">If your app performs a large number of searching or sorting operations on the same set of strings, you can improve its performance by generating and storing sort keys for all the strings that it uses.</span></span> <span data-ttu-id="58835-384">Quando uma operação de classificação ou comparação é necessária, você use as chaves de classificação em vez de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-384">When a sort or comparison operation is required, you use the sort keys instead of the strings.</span></span> <span data-ttu-id="58835-385">Para obter mais informações, consulte a classe <xref:System.Globalization.SortKey>.</span><span class="sxs-lookup"><span data-stu-id="58835-385">For more information, see the <xref:System.Globalization.SortKey> class.</span></span>  
  
 <span data-ttu-id="58835-386">Se você não especificar uma convenção de comparação de cadeia de caracteres, métodos de classificação como <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> executar uma classificação sensível à cultura, diferencia maiusculas de minúsculas em cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-386">If you don't specify a string comparison convention, sorting methods such as <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> perform a culture-sensitive, case-sensitive sort on strings.</span></span> <span data-ttu-id="58835-387">O exemplo a seguir ilustra como mudar a cultura atual afeta a ordem das cadeias de caracteres classificadas em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-387">The following example illustrates how changing the current culture affects the order of sorted strings in an array.</span></span> <span data-ttu-id="58835-388">Ele cria uma matriz de três cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-388">It creates an array of three strings.</span></span> <span data-ttu-id="58835-389">Primeiro, ele define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade para en-US e chama o <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-389">First, it sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to en-US and calls the <xref:System.Array.Sort%28System.Array%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-390">A ordem de classificação resultante é com base em convenções de classificação para a cultura do inglês (Estados Unidos).</span><span class="sxs-lookup"><span data-stu-id="58835-390">The resulting sort order is based on sorting conventions for the English (United States) culture.</span></span> <span data-ttu-id="58835-391">Em seguida, o exemplo define o `System.Threading.Thread.CurrentThread.CurrentCulture` propriedade para da-DK e chama o <xref:System.Array.Sort%2A?displayProperty=nameWithType> método novamente.</span><span class="sxs-lookup"><span data-stu-id="58835-391">Next, the example sets the `System.Threading.Thread.CurrentThread.CurrentCulture` property to da-DK and calls the <xref:System.Array.Sort%2A?displayProperty=nameWithType> method again.</span></span> <span data-ttu-id="58835-392">Observe como a ordem de classificação resultante difere dos resultados en-US porque ele usa as convenções de classificação para dinamarquês (Dinamarca).</span><span class="sxs-lookup"><span data-stu-id="58835-392">Notice how the resulting sort order differs from the en-US results because it uses the sorting conventions for Danish (Denmark).</span></span>  
  
 [!code-csharp[Conceptual.Strings.Comparing#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.strings.comparing/cs/sort1.cs#3)]
 [!code-vb[Conceptual.Strings.Comparing#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.strings.comparing/vb/sort1.vb#3)]  
  
> [!WARNING]
>  <span data-ttu-id="58835-393">Se seu objetivo principal na comparação de cadeias de caracteres é determinar se eles forem iguais, você deve chamar o <xref:System.String.Equals%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-393">If your primary purpose in comparing strings is to determine whether they are equal, you should call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-394">Normalmente, você deve usar <xref:System.String.Equals%2A> para realizar uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-394">Typically, you should use <xref:System.String.Equals%2A> to perform an ordinal comparison.</span></span> <span data-ttu-id="58835-395">O <xref:System.String.Compare%2A?displayProperty=nameWithType> método destina-se principalmente para classificar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-395">The <xref:System.String.Compare%2A?displayProperty=nameWithType> method is intended primarily to sort strings.</span></span>  
  
 <span data-ttu-id="58835-396">Métodos de pesquisa de cadeia de caracteres, como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar comparações de cadeia de caracteres sensíveis à cultura ou ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-396">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons.</span></span> <span data-ttu-id="58835-397">O exemplo a seguir ilustra as diferenças entre as comparações ordinais e sensível à cultura usando o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-397">The following example illustrates the differences between ordinal and culture-sensitive comparisons using the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="58835-398">Uma pesquisa sensível à cultura em que a cultura atual é inglês (Estados Unidos) considera a subcadeia de caracteres "oe" para corresponder a Ligadura "œ".</span><span class="sxs-lookup"><span data-stu-id="58835-398">A culture-sensitive search in which the current culture is English (United States) considers the substring "oe" to match the ligature "œ".</span></span> <span data-ttu-id="58835-399">Como um hífen (U + 00AD) é um caractere de largura zero, a pesquisa trata o hífen como equivalente a <xref:System.String.Empty> e encontra uma correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-399">Because a soft hyphen (U+00AD) is a zero-width character, the search treats the soft hyphen as equivalent to <xref:System.String.Empty> and finds a match at the beginning of the string.</span></span> <span data-ttu-id="58835-400">Uma pesquisa ordinal, por outro lado, não encontra uma correspondência em ambos os casos.</span><span class="sxs-lookup"><span data-stu-id="58835-400">An ordinal search, on the other hand, does not find a match in either case.</span></span>  
  
 [!code-cpp[System.String.Class#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.compare3.cpp#13)]
 [!code-csharp[System.String.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/compare3.cs#13)]
 [!code-vb[System.String.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/compare3.vb#13)]  
  
### <a name="searching-strings"></a><span data-ttu-id="58835-401">Pesquisar cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-401">Searching Strings</span></span>  
 <span data-ttu-id="58835-402">Métodos de pesquisa de cadeia de caracteres, como <xref:System.String.StartsWith%2A?displayProperty=nameWithType> e <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, também pode executar sensíveis à cultura ou comparações de cadeia de caracteres ordinais para determinar se um caractere ou uma subcadeia de caracteres for encontrada em uma cadeia de caracteres especificada.</span><span class="sxs-lookup"><span data-stu-id="58835-402">String search methods, such as <xref:System.String.StartsWith%2A?displayProperty=nameWithType> and <xref:System.String.IndexOf%2A?displayProperty=nameWithType>, also can perform culture-sensitive or ordinal string comparisons to determine whether a character or substring is found in a specified string.</span></span>  
  
 <span data-ttu-id="58835-403">Os métodos de pesquisa na <xref:System.String> classe procurar por um caractere individual, como o <xref:System.String.IndexOf%2A> método ou um de um conjunto de caracteres, como o <xref:System.String.IndexOfAny%2A> método, realizam uma pesquisa ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-403">The search methods in the <xref:System.String> class that search for an individual character, such as the <xref:System.String.IndexOf%2A> method, or one of a set of characters,   such as the <xref:System.String.IndexOfAny%2A> method, all perform an ordinal search.</span></span> <span data-ttu-id="58835-404">Para executar uma pesquisa sensível à cultura por um caractere, você deve chamar um <xref:System.Globalization.CompareInfo> método, como <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> ou <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-404">To perform a culture-sensitive search for a character, you must call a <xref:System.Globalization.CompareInfo> method such as <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> or <xref:System.Globalization.CompareInfo.LastIndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-405">Observe que os resultados da pesquisa por um caractere usando a comparação ordinal e sensível à cultura podem ser muito diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-405">Note that the results of searching for a character using ordinal and culture-sensitive comparison can be very different.</span></span> <span data-ttu-id="58835-406">Por exemplo, uma pesquisa por um caractere pré-composto do Unicode, como a Ligadura "Æ" (U + 00 C 6) pode corresponder a qualquer ocorrência de seus componentes na sequência correta, como "AE" (U + 041U + 0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-406">For example, a search for a precomposed Unicode character such as the ligature "Æ" (U+00C6) might match any occurrence of its components in the correct sequence, such as "AE" (U+041U+0045), depending on the culture.</span></span> <span data-ttu-id="58835-407">O exemplo a seguir ilustra a diferença entre o <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> e <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> métodos ao procurar por um caractere individual.</span><span class="sxs-lookup"><span data-stu-id="58835-407">The following example illustrates the difference between the <xref:System.String.IndexOf%28System.Char%29?displayProperty=nameWithType> and <xref:System.Globalization.CompareInfo.IndexOf%28System.String%2CSystem.Char%29?displayProperty=nameWithType> methods when searching for an individual character.</span></span> <span data-ttu-id="58835-408">A Ligadura "æ" (U + 00E6) é encontrada na cadeia de caracteres "aérea" ao usar as convenções da cultura en-US, mas não ao usar as convenções da cultura da-DK ou ao executar uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-408">The ligature "æ" (U+00E6) is found in the string "aerial" when using the conventions of the en-US culture, but not when using the conventions of the da-DK culture or when performing an ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/search1.cs#22)]
 [!code-vb[System.String.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/search1.vb#22)]  
  
 <span data-ttu-id="58835-409">Por outro lado, <xref:System.String> métodos de pesquisa para uma cadeia de caracteres em vez de um caractere de realiza uma pesquisa sensível à cultura se opções de pesquisa não forem especificadas explicitamente por um parâmetro de tipo de classe <xref:System.StringComparison>.</span><span class="sxs-lookup"><span data-stu-id="58835-409">On the other hand, <xref:System.String> class methods that search for a string rather than a character perform a culture-sensitive search if search options are not explicitly specified by a parameter of type <xref:System.StringComparison>.</span></span> <span data-ttu-id="58835-410">A única exceção é <xref:System.String.Contains%2A>, que executa uma pesquisa ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-410">The sole exception is <xref:System.String.Contains%2A>, which performs an ordinal search.</span></span>  
  
<a name="equality"></a>   
### <a name="testing-for-equality"></a><span data-ttu-id="58835-411">Testando igualdade</span><span class="sxs-lookup"><span data-stu-id="58835-411">Testing for equality</span></span>  
 <span data-ttu-id="58835-412">Use o <xref:System.String.Compare%2A?displayProperty=nameWithType> método para determinar a relação entre duas cadeias de caracteres na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-412">Use the <xref:System.String.Compare%2A?displayProperty=nameWithType> method to determine the relationship of two strings in the sort order.</span></span> <span data-ttu-id="58835-413">Normalmente, isso é uma operação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-413">Typically, this is a culture-sensitive operation.</span></span> <span data-ttu-id="58835-414">Por outro lado, chame o <xref:System.String.Equals%2A?displayProperty=nameWithType> método para testar a igualdade.</span><span class="sxs-lookup"><span data-stu-id="58835-414">In contrast, call the <xref:System.String.Equals%2A?displayProperty=nameWithType> method to test for equality.</span></span> <span data-ttu-id="58835-415">Como o teste de igualdade normalmente compara a entrada do usuário com alguma cadeia de caracteres conhecida, como um nome de usuário válido, uma senha ou um caminho de sistema de arquivos, normalmente é uma operação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-415">Because the test for equality usually compares user input with some known string, such as a valid user name, a password, or a file system path, it is typically an ordinal operation.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-416">É possível testar a igualdade chamando o <xref:System.String.Compare%2A?displayProperty=nameWithType> método e determinar se o valor de retorno é zero.</span><span class="sxs-lookup"><span data-stu-id="58835-416">It is possible to test for equality by calling the <xref:System.String.Compare%2A?displayProperty=nameWithType> method and determining whether the return value is zero.</span></span> <span data-ttu-id="58835-417">No entanto, essa prática não é recomendada.</span><span class="sxs-lookup"><span data-stu-id="58835-417">However, this practice is not recommended.</span></span> <span data-ttu-id="58835-418">Para determinar se duas cadeias de caracteres são iguais, você deve chamar uma das sobrecargas do <xref:System.String.Equals%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-418">To determine whether two strings are equal, you should call one of the overloads of the <xref:System.String.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-419">A sobrecarga preferencial para chamar é a instância <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método ou estático <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, porque ambos os métodos incluem um <xref:System.StringComparison?displayProperty=nameWithType> parâmetro que especifica explicitamente o tipo de comparação.</span><span class="sxs-lookup"><span data-stu-id="58835-419">The preferred overload to call is either the instance <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method or the static <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, because both methods include a <xref:System.StringComparison?displayProperty=nameWithType> parameter that explicitly specifies the type of comparison.</span></span>  
  
 <span data-ttu-id="58835-420">O exemplo a seguir ilustra o perigo de realizar uma comparação sensível à cultura para igualdade quando um ordinal de um deve ser usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-420">The following example illustrates the danger of performing a culture-sensitive comparison for equality when an ordinal one should be used instead.</span></span> <span data-ttu-id="58835-421">Nesse caso, a intenção do código é proibir o acesso do sistema de arquivos de URLs que começam com "FILE://" ou "file://" ao executar uma comparação não diferencia maiusculas de início de uma URL com a cadeia de caracteres "FILE://".</span><span class="sxs-lookup"><span data-stu-id="58835-421">In this case, the intent of the code is to prohibit file system access from URLs that begin with "FILE://" or "file://" by performing a case-insensitive comparison of the beginning of a URL with the string "FILE://".</span></span> <span data-ttu-id="58835-422">No entanto, se uma comparação sensível à cultura é executada usando a cultura de turco (Turquia) em uma URL que começa com "file://", a comparação de igualdade falhará, porque o turco equivalente em maiusculas "i" minúsculo é "İ" em vez de "I".</span><span class="sxs-lookup"><span data-stu-id="58835-422">However, if a culture-sensitive comparison is performed using the Turkish (Turkey) culture on a URL that begins with "file://", the comparison for equality fails, because the Turkish uppercase equivalent of the lowercase "i" is "İ" instead of "I".</span></span> <span data-ttu-id="58835-423">Como resultado, o acesso do sistema de arquivos inadvertidamente é permitido.</span><span class="sxs-lookup"><span data-stu-id="58835-423">As a result, file system access is inadvertently permitted.</span></span> <span data-ttu-id="58835-424">Por outro lado, se uma comparação ordinal é executada, a comparação de igualdade for bem-sucedida, e acesso de sistema de arquivos será negado.</span><span class="sxs-lookup"><span data-stu-id="58835-424">On the other hand, if an ordinal comparison is performed, the comparison for equality succeeds, and file system access is denied.</span></span>  
  
 [!code-cpp[System.String.Class#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.equals.cpp#11)]
 [!code-csharp[System.String.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/equality1.cs#11)]
 [!code-vb[System.String.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/equality1.vb#11)]  
  
<a name="Normalization"></a>   
## <a name="normalization"></a><span data-ttu-id="58835-425">Normalização</span><span class="sxs-lookup"><span data-stu-id="58835-425">Normalization</span></span>  
 <span data-ttu-id="58835-426">Alguns caracteres Unicode têm várias representações.</span><span class="sxs-lookup"><span data-stu-id="58835-426">Some Unicode characters have multiple representations.</span></span> <span data-ttu-id="58835-427">Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":</span><span class="sxs-lookup"><span data-stu-id="58835-427">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="58835-428">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="58835-428">U+1EAF</span></span>  
  
-   <span data-ttu-id="58835-429">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="58835-429">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="58835-430">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="58835-430">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="58835-431">Várias representações para um único caractere complicam a pesquisa, classificação, correspondência e outras operações de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-431">Multiple representations for a single character complicate searching, sorting, matching, and other string operations.</span></span>  
  
 <span data-ttu-id="58835-432">O padrão Unicode define um processo chamado normalização que retorna uma representação binária de um caractere Unicode para qualquer uma das suas representações binárias equivalentes.</span><span class="sxs-lookup"><span data-stu-id="58835-432">The Unicode standard defines a process called normalization that returns one binary representation of a Unicode character for any of its equivalent binary representations.</span></span> <span data-ttu-id="58835-433">Normalização pode usar vários algoritmos, chamados de formulários de normalização que seguem regras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-433">Normalization can use several algorithms, called normalization forms, that follow different rules.</span></span> <span data-ttu-id="58835-434">O .NET Framework dá suporte a formulários de normalização Unicode C, D, KC e KD.</span><span class="sxs-lookup"><span data-stu-id="58835-434">The .NET Framework supports Unicode normalization forms C, D, KC, and KD.</span></span> <span data-ttu-id="58835-435">Cadeias de caracteres foram normalizadas para o mesmo formulário de normalização, eles podem ser comparados usando a comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-435">When strings have been normalized to the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="58835-436">Uma comparação ordinal é uma comparação binária do valor escalar Unicode correspondente <xref:System.Char> objetos em cada cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-436">An ordinal comparison is a binary comparison of the Unicode scalar value of corresponding <xref:System.Char> objects in each string.</span></span> <span data-ttu-id="58835-437">O <xref:System.String> classe inclui uma série de métodos que podem realizar uma comparação ordinal, incluindo o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-437">The <xref:System.String> class includes a number of methods that can perform an ordinal comparison, including the following:</span></span>  
  
-   <span data-ttu-id="58835-438">Nenhuma sobrecarga da <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>, <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, e <xref:System.String.LastIndexOf%2A> métodos que inclui um <xref:System.StringComparison> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-438">Any overload of the <xref:System.String.Compare%2A>, <xref:System.String.Equals%2A>, <xref:System.String.StartsWith%2A>,  <xref:System.String.EndsWith%2A>, <xref:System.String.IndexOf%2A>, and <xref:System.String.LastIndexOf%2A> methods that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="58835-439">O método executa uma comparação ordinal, se você fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase> para esse parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-439">The method performs an ordinal comparison if you supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase> for this parameter.</span></span>  
  
-   <span data-ttu-id="58835-440">As sobrecargas de <xref:System.String.CompareOrdinal%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-440">The overloads of the <xref:System.String.CompareOrdinal%2A> method.</span></span>  
  
-   <span data-ttu-id="58835-441">Métodos que utilizam a comparação ordinal por padrão, como <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, e <xref:System.String.Split%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-441">Methods that use ordinal comparison by default, such as <xref:System.String.Contains%2A>, <xref:System.String.Replace%2A>, and <xref:System.String.Split%2A>.</span></span>  
  
-   <span data-ttu-id="58835-442">Métodos de pesquisa para um <xref:System.Char> valor ou para os elementos em um <xref:System.Char> matriz em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-442">Methods that search for a <xref:System.Char> value or for the elements in a <xref:System.Char> array in a string instance.</span></span> <span data-ttu-id="58835-443">Esses métodos incluem <xref:System.String.IndexOf%28System.Char%29> e <xref:System.String.Split%28System.Char%5B%5D%29>.</span><span class="sxs-lookup"><span data-stu-id="58835-443">Such methods include <xref:System.String.IndexOf%28System.Char%29> and <xref:System.String.Split%28System.Char%5B%5D%29>.</span></span>  
  
 <span data-ttu-id="58835-444">Você pode determinar se uma cadeia de caracteres é normalizada para o formulário de normalização C chamando o <xref:System.String.IsNormalized?displayProperty=nameWithType> método, ou você pode chamar o <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para determinar se uma cadeia de caracteres é normalizada para um formulário de normalização especificado.</span><span class="sxs-lookup"><span data-stu-id="58835-444">You can determine whether a string is normalized to normalization form C by calling the <xref:System.String.IsNormalized?displayProperty=nameWithType> method, or you can call the <xref:System.String.IsNormalized%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to determine whether a string is normalized to a specified normalization form.</span></span> <span data-ttu-id="58835-445">Você também pode chamar o <xref:System.String.Normalize?displayProperty=nameWithType> método para converter uma cadeia de caracteres em formato de normalização C, ou você pode chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> método para converter uma cadeia de caracteres em um formato de normalização especificado.</span><span class="sxs-lookup"><span data-stu-id="58835-445">You can also call the <xref:System.String.Normalize?displayProperty=nameWithType> method to convert a string to normalization form C, or you can call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29?displayProperty=nameWithType> method to convert a string to a specified normalization form.</span></span> <span data-ttu-id="58835-446">Para obter informações passo a passo sobre a normalização e comparando cadeias de caracteres, consulte a <xref:System.String.Normalize> e <xref:System.String.Normalize%28System.Text.NormalizationForm%29> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-446">For step-by-step information about normalizing and comparing strings, see the <xref:System.String.Normalize> and <xref:System.String.Normalize%28System.Text.NormalizationForm%29> methods.</span></span>  
  
 <span data-ttu-id="58835-447">O exemplo simples a seguir ilustra a normalização de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-447">The following simple example illustrates string normalization.</span></span> <span data-ttu-id="58835-448">Ele define a letra "ố" de três maneiras diferentes em três cadeias de caracteres diferentes e usa uma comparação ordinal de igualdade para determinar o que cada cadeia de caracteres é diferente de outras duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-448">It defines the letter "ố" in three different ways in three different strings, and uses an ordinal comparison for equality to determine that each string differs from the other two strings.</span></span> <span data-ttu-id="58835-449">Ele converte cada cadeia de caracteres para os formulários de normalização com suporte e executa novamente uma comparação ordinal de cada cadeia de caracteres em um formulário de normalização especificada.</span><span class="sxs-lookup"><span data-stu-id="58835-449">It then converts each string to the supported normalization forms, and again performs an ordinal comparison of each string in a specified normalization form.</span></span> <span data-ttu-id="58835-450">Em cada caso, o segundo teste de igualdade mostra que as cadeias de caracteres são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-450">In each case, the second test for equality shows that the strings are equal.</span></span>  
  
 [!code-cpp[System.String.Class#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/string.normalize.cpp#14)]
 [!code-csharp[System.String.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/normalize1.cs#14)]
 [!code-vb[System.String.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/normalize1.vb#14)]  
  
 <span data-ttu-id="58835-451">Para obter mais informações sobre a normalização e formulários de normalização, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, bem como [Unicode Standard Annex #15: formulários de normalização Unicode](https://unicode.org/reports/tr15/) e o [perguntas Frequentes de normalização](https://www.unicode.org/faq/normalization.html) no site a site Unicode.org.</span><span class="sxs-lookup"><span data-stu-id="58835-451">For more information about normalization and normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>, as well as [Unicode Standard Annex #15: Unicode Normalization Forms](https://unicode.org/reports/tr15/) and the [Normalization FAQ](https://www.unicode.org/faq/normalization.html) on the unicode.org website.</span></span>  
  
<a name="ByCategory"></a>   
## <a name="string-operations-by-category"></a><span data-ttu-id="58835-452">Operações da cadeia de caracteres por categoria</span><span class="sxs-lookup"><span data-stu-id="58835-452">String operations by category</span></span>  
 <span data-ttu-id="58835-453">O <xref:System.String> classe fornece membros para comparar cadeias de caracteres, cadeias de caracteres para igualdade, localizando caracteres ou subcadeias de caracteres em uma cadeia de caracteres, modificando uma cadeia de caracteres, extraindo subcadeias de caracteres de uma cadeia de caracteres, combinar cadeias de caracteres, formatação de valores, uma cadeia de caracteres, a cópia de teste e Normalizando uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-453">The <xref:System.String> class provides members for comparing strings, testing strings for equality, finding characters or substrings in a string, modifying a string, extracting substrings from a string, combining strings, formatting values, copying a string, and normalizing a string.</span></span>  
  
### <a name="comparing-strings"></a><span data-ttu-id="58835-454">Comparando cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-454">Comparing strings</span></span>  
 <span data-ttu-id="58835-455">Você pode comparar cadeias de caracteres para determinar sua posição relativa na ordem de classificação usando os seguintes <xref:System.String> métodos:</span><span class="sxs-lookup"><span data-stu-id="58835-455">You can compare strings to determine their relative position in the sort order by using the following <xref:System.String> methods:</span></span>  
  
-   <span data-ttu-id="58835-456"><xref:System.String.Compare%2A> Retorna um inteiro que indica o relacionamento entre uma cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-456"><xref:System.String.Compare%2A> returns an integer that indicates the relationship of one string to a second string in the sort order.</span></span>  
  
-   <span data-ttu-id="58835-457"><xref:System.String.CompareOrdinal%2A> Retorna um inteiro que indica o relacionamento entre uma cadeia de caracteres para uma segunda cadeia de caracteres com base em uma comparação dos seus pontos de código.</span><span class="sxs-lookup"><span data-stu-id="58835-457"><xref:System.String.CompareOrdinal%2A> returns an integer that indicates the relationship of one string to a second string based on a comparison of their code points.</span></span>  
  
-   <span data-ttu-id="58835-458"><xref:System.String.CompareTo%2A> Retorna um inteiro que indica o relacionamento entre a instância atual da cadeia de caracteres para uma segunda cadeia de caracteres na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-458"><xref:System.String.CompareTo%2A> returns an integer that indicates the relationship of the current string instance to a second string in the sort order.</span></span> <span data-ttu-id="58835-459">O <xref:System.String.CompareTo%28System.String%29> método fornece a <xref:System.IComparable> e <xref:System.IComparable%601> implementações para o <xref:System.String> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-459">The <xref:System.String.CompareTo%28System.String%29> method provides the <xref:System.IComparable> and <xref:System.IComparable%601> implementations for the <xref:System.String> class.</span></span>  
  
### <a name="testing-strings-for-equality"></a><span data-ttu-id="58835-460">Testando igualdade das cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-460">Testing strings for equality</span></span>  
 <span data-ttu-id="58835-461">Você chama o <xref:System.String.Equals%2A> método para determinar se duas cadeias de caracteres são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-461">You call the <xref:System.String.Equals%2A> method to determine whether two strings are equal.</span></span> <span data-ttu-id="58835-462">A instância <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> e estático <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> sobrecargas permitem que você especifique se a comparação é ordinal ou sensível à cultura, e se o caso é considerado ou ignorado.</span><span class="sxs-lookup"><span data-stu-id="58835-462">The instance <xref:System.String.Equals%28System.String%2CSystem.String%2CSystem.StringComparison%29> and the static <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> overloads let you specify whether the comparison is culture-sensitive or ordinal, and whether case is considered or ignored.</span></span> <span data-ttu-id="58835-463">A maioria dos testes de igualdade são ordinais e comparações de igualdade que determinam o acesso a um recurso do sistema (como um objeto do sistema de arquivos) devem ser sempre ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-463">Most tests for equality are ordinal, and comparisons for equality that determine access to a system resource (such as a file system object) should always be ordinal.</span></span>  
  
### <a name="finding-characters-in-a-string"></a><span data-ttu-id="58835-464">Localizando caracteres em uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-464">Finding characters in a string</span></span>  
 <span data-ttu-id="58835-465">O <xref:System.String> classe inclui dois tipos de métodos de pesquisa:</span><span class="sxs-lookup"><span data-stu-id="58835-465">The <xref:System.String> class includes two kinds of search methods:</span></span>  
  
-   <span data-ttu-id="58835-466">Os métodos que retornam um <xref:System.Boolean> valor para indicar se uma subcadeia de caracteres específica está presente em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-466">Methods that return a <xref:System.Boolean> value to indicate whether a particular substring is present in a string instance.</span></span> <span data-ttu-id="58835-467">Isso inclui o <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, e <xref:System.String.StartsWith%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-467">These include the <xref:System.String.Contains%2A>, <xref:System.String.EndsWith%2A>, and <xref:System.String.StartsWith%2A> methods.</span></span>  
  
-   <span data-ttu-id="58835-468">Métodos que indicam a posição inicial de uma subcadeia de caracteres em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-468">Methods that indicate the starting position of a substring in a string instance.</span></span> <span data-ttu-id="58835-469">Isso inclui o <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, e <xref:System.String.LastIndexOfAny%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-469">These include the <xref:System.String.IndexOf%2A>, <xref:System.String.IndexOfAny%2A>, <xref:System.String.LastIndexOf%2A>, and <xref:System.String.LastIndexOfAny%2A> methods.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-470">Se você quiser pesquisar uma cadeia de caracteres para um determinado padrão em vez de uma subcadeia de caracteres específica, você deve usar expressões regulares.</span><span class="sxs-lookup"><span data-stu-id="58835-470">If you want to search a string for a particular pattern rather than a specific substring, you should use regular expressions.</span></span> <span data-ttu-id="58835-471">Para obter mais informações, consulte [Expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="58835-471">For more information, see [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
### <a name="modifying-a-string"></a><span data-ttu-id="58835-472">Modificando uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-472">Modifying a string</span></span>  
 <span data-ttu-id="58835-473">O <xref:System.String> classe inclui os seguintes métodos que aparecem para modificar o valor de uma cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="58835-473">The <xref:System.String> class includes the following methods that appear to modify the value of a string:</span></span>  
  
-   <span data-ttu-id="58835-474"><xref:System.String.Insert%2A> Insere uma cadeia de caracteres atual <xref:System.String> instância.</span><span class="sxs-lookup"><span data-stu-id="58835-474"><xref:System.String.Insert%2A> inserts a string into the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="58835-475"><xref:System.String.PadLeft%2A> Insere uma ou mais ocorrências de um caractere especificado no início de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-475"><xref:System.String.PadLeft%2A> inserts one or more occurrences of a specified character at the beginning of a string.</span></span>  
  
-   <span data-ttu-id="58835-476"><xref:System.String.PadRight%2A> Insere uma ou mais ocorrências de um caractere especificado no final de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-476"><xref:System.String.PadRight%2A> inserts one or more occurrences of a specified character at the end of a string.</span></span>  
  
-   <span data-ttu-id="58835-477"><xref:System.String.Remove%2A> Exclui uma subcadeia de caracteres de atual <xref:System.String> instância.</span><span class="sxs-lookup"><span data-stu-id="58835-477"><xref:System.String.Remove%2A> deletes a substring from the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="58835-478"><xref:System.String.Replace%2A> substitui uma subcadeia de caracteres por outra subcadeia de caracteres atual <xref:System.String> instância.</span><span class="sxs-lookup"><span data-stu-id="58835-478"><xref:System.String.Replace%2A> replaces a substring with another substring in the current <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="58835-479"><xref:System.String.ToLower%2A> e <xref:System.String.ToLowerInvariant%2A> converter todos os caracteres em uma cadeia de caracteres em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-479"><xref:System.String.ToLower%2A> and <xref:System.String.ToLowerInvariant%2A> convert all the characters in a string to lowercase.</span></span>  
  
-   <span data-ttu-id="58835-480"><xref:System.String.ToUpper%2A> e <xref:System.String.ToUpperInvariant%2A> converter todos os caracteres em uma cadeia de caracteres em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-480"><xref:System.String.ToUpper%2A> and <xref:System.String.ToUpperInvariant%2A> convert all the characters in a string to uppercase.</span></span>  
  
-   <span data-ttu-id="58835-481"><xref:System.String.Trim%2A> Remove todas as ocorrências de um caractere de início e no final de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-481"><xref:System.String.Trim%2A> removes all occurrences of a character from the beginning and end of a string.</span></span>  
  
-   <span data-ttu-id="58835-482"><xref:System.String.TrimEnd%2A> Remove todas as ocorrências de um caractere de final de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-482"><xref:System.String.TrimEnd%2A> removes all occurrences of a character from the end of a string.</span></span>  
  
-   <span data-ttu-id="58835-483"><xref:System.String.TrimStart%2A> Remove todas as ocorrências de um caractere do início de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-483"><xref:System.String.TrimStart%2A> removes all occurrences of a character from the beginning of a string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-484">Todos os métodos de modificação de cadeia de caracteres retornam um novo <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-484">All string modification methods return a new <xref:System.String> object.</span></span> <span data-ttu-id="58835-485">Eles não modificam o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-485">They don't modify the value of the current instance.</span></span>  
  
### <a name="extracting-substrings-from-a-string"></a><span data-ttu-id="58835-486">Extraindo subcadeias de caracteres de uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-486">Extracting substrings from a string</span></span>  
 <span data-ttu-id="58835-487">O <xref:System.String.Split%2A?displayProperty=nameWithType> método separa uma única cadeia de caracteres em várias cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-487">The <xref:System.String.Split%2A?displayProperty=nameWithType> method separates a single string into multiple strings.</span></span> <span data-ttu-id="58835-488">Sobrecargas do método permitem que você especifique vários delimitadores, para determinar o número máximo de subcadeias de caracteres que o método extrai e para determinar se as cadeias de caracteres vazias (que ocorrem quando os delimitadores sejam adjacentes) são incluídas entre as cadeias de caracteres retornadas.</span><span class="sxs-lookup"><span data-stu-id="58835-488">Overloads of the method allow you to specify multiple delimiters, to determine the maximum number of substrings that the method extracts, and to determine whether empty strings (which occur when delimiters are adjacent) are included among the returned strings.</span></span>  
  
### <a name="combining-strings"></a><span data-ttu-id="58835-489">Combinando cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-489">Combining strings</span></span>  
 <span data-ttu-id="58835-490">O seguinte <xref:System.String> métodos podem ser usados para concatenação de cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="58835-490">The following <xref:System.String> methods can be used for string concatenation:</span></span>  
  
-   <span data-ttu-id="58835-491"><xref:System.String.Concat%2A> combina as subcadeias de caracteres de um ou mais em uma única cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-491"><xref:System.String.Concat%2A> combines one or more substrings into a single string.</span></span>  
  
-   <span data-ttu-id="58835-492"><xref:System.String.Join%2A> Concatena uma ou mais subcadeias de caracteres em um único elemento e adiciona um separador entre cada subcadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-492"><xref:System.String.Join%2A> concatenates one or more substrings into a single element and adds a separator between each substring.</span></span>  
  
### <a name="formatting-values"></a><span data-ttu-id="58835-493">Formatando valores</span><span class="sxs-lookup"><span data-stu-id="58835-493">Formatting values</span></span>  
 <span data-ttu-id="58835-494">O <xref:System.String.Format%2A?displayProperty=nameWithType> método usa o recurso de formatação composta para substituir um ou mais espaços reservados para uma cadeia de caracteres com a representação de cadeia de caracteres de um objeto ou valor.</span><span class="sxs-lookup"><span data-stu-id="58835-494">The <xref:System.String.Format%2A?displayProperty=nameWithType> method uses the composite formatting feature to replace one or more placeholders in a string with the string representation of some object or value.</span></span> <span data-ttu-id="58835-495">O <xref:System.String.Format%2A> método geralmente é usado para fazer o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-495">The <xref:System.String.Format%2A> method is often used to do the following:</span></span>  
  
-   <span data-ttu-id="58835-496">Para inserir a representação de cadeia de caracteres de um valor numérico em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-496">To embed the string representation of a numeric value in a string.</span></span>  
  
-   <span data-ttu-id="58835-497">Para inserir a representação de cadeia de caracteres de um valor de data e hora em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-497">To embed the string representation of a date and time value in a string.</span></span>  
  
-   <span data-ttu-id="58835-498">Para inserir a representação de cadeia de caracteres de um valor de enumeração em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-498">To embed the string representation of an enumeration value in a string.</span></span>  
  
-   <span data-ttu-id="58835-499">Para inserir a representação de cadeia de caracteres de algum objeto que dá suporte a <xref:System.IFormattable> interface em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-499">To embed the string representation of some object that supports the <xref:System.IFormattable> interface in a string.</span></span>  
  
-   <span data-ttu-id="58835-500">Para justificar à direita ou justificar à esquerda de uma subcadeia de caracteres em um campo dentro de uma cadeia de caracteres maior.</span><span class="sxs-lookup"><span data-stu-id="58835-500">To right-justify or left-justify a substring in a field within a larger string.</span></span>  
  
 <span data-ttu-id="58835-501">Para obter informações detalhadas sobre a formatação de operações e exemplos, consulte o <xref:System.String.Format%2A> Resumo da sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58835-501">For detailed information about formatting operations and examples, see the <xref:System.String.Format%2A> overload summary.</span></span>  
  
### <a name="copying-a-string"></a><span data-ttu-id="58835-502">Copiando uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-502">Copying a string</span></span>  
 <span data-ttu-id="58835-503">Você pode chamar o seguinte <xref:System.String> métodos para fazer uma cópia de uma cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="58835-503">You can call the following <xref:System.String> methods to make a copy of a string:</span></span>  
  
-   <span data-ttu-id="58835-504"><xref:System.String.Clone%2A> Retorna uma referência a um existente <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-504"><xref:System.String.Clone%2A> returns a reference to an existing <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="58835-505"><xref:System.String.Copy%2A> cria uma cópia de uma cadeia de caracteres existente.</span><span class="sxs-lookup"><span data-stu-id="58835-505"><xref:System.String.Copy%2A> creates a copy of an existing string.</span></span>  
  
-   <span data-ttu-id="58835-506"><xref:System.String.CopyTo%2A> copia uma parte de uma cadeia de caracteres em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-506"><xref:System.String.CopyTo%2A> copies a portion of a string to a character array.</span></span>  
  
### <a name="normalizing-a-string"></a><span data-ttu-id="58835-507">Normalizando uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-507">Normalizing a string</span></span>  
 <span data-ttu-id="58835-508">Em Unicode, um único caractere pode ter vários pontos de código.</span><span class="sxs-lookup"><span data-stu-id="58835-508">In Unicode, a single character can have multiple code points.</span></span> <span data-ttu-id="58835-509">Normalização converte esses caracteres equivalentes na mesma representação binária.</span><span class="sxs-lookup"><span data-stu-id="58835-509">Normalization converts these equivalent characters into the same binary representation.</span></span> <span data-ttu-id="58835-510">O <xref:System.String.Normalize%2A?displayProperty=nameWithType> método executa a normalização e a <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> método determina se uma cadeia de caracteres é normalizada.</span><span class="sxs-lookup"><span data-stu-id="58835-510">The <xref:System.String.Normalize%2A?displayProperty=nameWithType> method performs the normalization, and the <xref:System.String.IsNormalized%2A?displayProperty=nameWithType> method determines whether a string is normalized.</span></span>  
  
 <span data-ttu-id="58835-511">Para obter mais informações e um exemplo, consulte o [normalização](#Normalization) seção neste tópico.</span><span class="sxs-lookup"><span data-stu-id="58835-511">For more information and an example, see the [Normalization](#Normalization) section earlier in this topic.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="58835-512">Este tipo é thread-safe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="58835-512">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.IComparable" />
    <altmember cref="T:System.ICloneable" />
    <altmember cref="T:System.IConvertible" />
    <altmember cref="T:System.Collections.IEnumerable" />
    <altmember cref="T:System.Text.StringBuilder" />
    <altmember cref="T:System.Globalization.CultureInfo" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-513">Inicializa uma nova instância da classe <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-513">Initializes a new instance of the <see cref="T:System.String" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-514">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="58835-514">In this section:</span></span>  
  
 <span data-ttu-id="58835-515">[Sintaxe de construtor sobrecarregada](#Syntax) </span><span class="sxs-lookup"><span data-stu-id="58835-515">[Overloaded constructor syntax](#Syntax) </span></span>  
 <span data-ttu-id="58835-516">[Parâmetros](#Params) </span><span class="sxs-lookup"><span data-stu-id="58835-516">[Parameters](#Params) </span></span>  
 <span data-ttu-id="58835-517">[Exceções](#Exceptions) </span><span class="sxs-lookup"><span data-stu-id="58835-517">[Exceptions](#Exceptions) </span></span>  
 <span data-ttu-id="58835-518">[Qual método chamar?](#Tasks) </span><span class="sxs-lookup"><span data-stu-id="58835-518">[Which method do I call?](#Tasks) </span></span>  
 <span data-ttu-id="58835-519">[Criando cadeias de caracteres](#Creating_Strings) </span><span class="sxs-lookup"><span data-stu-id="58835-519">[Creating strings](#Creating_Strings) </span></span>  
 <span data-ttu-id="58835-520">[Manipulação de cadeias de caracteres repetitivas](#Repetitive) </span><span class="sxs-lookup"><span data-stu-id="58835-520">[Handling repetitive strings](#Repetitive) </span></span>  
 <span data-ttu-id="58835-521">Exemplos de cadeias de caracteres ao instanciar:</span><span class="sxs-lookup"><span data-stu-id="58835-521">Examples of instantiating strings:</span></span>   
 [<span data-ttu-id="58835-522">Usar a atribuição de cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-522">Using string assignment</span></span>](#Ctor1_Example)  
 [<span data-ttu-id="58835-523">Usando uma matriz de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-523">Using a character array</span></span>](#Ctor2_Example)  
 [<span data-ttu-id="58835-524">Usando uma parte de uma matriz de caracteres e repetindo um único caractere</span><span class="sxs-lookup"><span data-stu-id="58835-524">Using a portion of a character array and repeating a single character</span></span>](#Ctor3_Example)  
 [<span data-ttu-id="58835-525">Usando um ponteiro para uma matriz de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-525">Using a pointer to a character array</span></span>](#Ctor4_Example)  
 [<span data-ttu-id="58835-526">Usando um ponteiro e um intervalo de uma matriz</span><span class="sxs-lookup"><span data-stu-id="58835-526">Using  a pointer and a range of an array</span></span>](#Ctor5_Example)  
 [<span data-ttu-id="58835-527">Usando um ponteiro para uma matriz de bytes com sinal</span><span class="sxs-lookup"><span data-stu-id="58835-527">Using a pointer to a signed byte array</span></span>](#Ctor6_Example)  
[<span data-ttu-id="58835-528">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58835-528">Version information</span></span>](#Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-constructor-syntax"></a><span data-ttu-id="58835-529">Sintaxe de construtor sobrecarregada</span><span class="sxs-lookup"><span data-stu-id="58835-529">Overloaded constructor syntax</span></span>  
 <span data-ttu-id="58835-530">Construtores de cadeia de caracteres se enquadram em duas categorias: aqueles sem parâmetros de ponteiro e aqueles com parâmetros de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-530">String constructors fall into two categories: those without pointer parameters, and those with pointer parameters.</span></span> <span data-ttu-id="58835-531">Os construtores que usam ponteiros não são compatíveis com CLS.</span><span class="sxs-lookup"><span data-stu-id="58835-531">The constructors that use pointers are not CLS-compliant.</span></span> <span data-ttu-id="58835-532">Além disso, o Visual Basic não suporta o uso de ponteiros e c# requer código que usa ponteiros para ser executado em um contexto inseguro.</span><span class="sxs-lookup"><span data-stu-id="58835-532">In addition, Visual Basic does not support the use of pointers, and C# requires code that uses pointers to run in an unsafe context.</span></span> <span data-ttu-id="58835-533">Para obter mais informações, consulte [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span><span class="sxs-lookup"><span data-stu-id="58835-533">For more information, see [unsafe](~/docs/csharp/language-reference/keywords/unsafe.md).</span></span>  
  
 <span data-ttu-id="58835-534">Para obter orientação adicional sobre como escolher uma sobrecarga, consulte [qual método devo chamar?](#Tasks)</span><span class="sxs-lookup"><span data-stu-id="58835-534">For additional guidance on choosing an overload, see [Which method do I call?](#Tasks)</span></span>  
  
 `String(Char[] value)`  
 <span data-ttu-id="58835-535">Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-535">Initializes the new instance to the value indicated by an array of Unicode characters.</span></span> <span data-ttu-id="58835-536">Este construtor copia caracteres Unicode ([exemplo](#Ctor2_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-536">This constructor copies Unicode characters([example](#Ctor2_Example)).</span></span>  
  
 `String(Char[] value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="58835-537">Inicializa a nova instância para o valor indicado por uma matriz de caracteres Unicode, uma posição do caractere inicial dentro dessa matriz e um comprimento ([exemplo](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-537">Initializes the new instance to the value indicated by an array of Unicode characters, a starting character position within that array, and a length ([example](#Ctor3_Example)).</span></span>  
  
 `String(Char c, Int32 count)`  
 <span data-ttu-id="58835-538">Inicializa a nova instância para o valor indicada por um caractere Unicode especificado repetido um número de vezes especificado ([exemplo](#Ctor3_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-538">Initializes the new instance to the value indicated by a specified Unicode character repeated a specified number of times ([example](#Ctor3_Example)).</span></span>  
  
 `String(char* value)`  
 <span data-ttu-id="58835-539">**(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode terminada por um caractere nulo (U + 0000 ou '\0').</span><span class="sxs-lookup"><span data-stu-id="58835-539">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters that is terminated by a null character (U+0000 or '\0').</span></span> <span data-ttu-id="58835-540">([exemplo](#Ctor4_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-540">([example](#Ctor4_Example)).</span></span>  
  
 <span data-ttu-id="58835-541">Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58835-541">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="58835-542">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58835-542">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(char* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="58835-543">**(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de caracteres Unicode, uma posição do caractere inicial dentro dessa matriz e um comprimento.</span><span class="sxs-lookup"><span data-stu-id="58835-543">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of Unicode characters, a starting character position within that array, and a length.</span></span> <span data-ttu-id="58835-544">O construtor copia os caracteres Unicode de `value` começando no índice `startIndex` e termina no índice `startIndex`  +  `length` – 1 ([exemplo](#Ctor5_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-544">The constructor copies the Unicode characters from `value` starting at index `startIndex` and ending at index `startIndex` + `length` – 1 ([example](#Ctor5_Example)).</span></span>  
  
 <span data-ttu-id="58835-545">Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58835-545">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="58835-546">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58835-546">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value)`  
 <span data-ttu-id="58835-547">**(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits.</span><span class="sxs-lookup"><span data-stu-id="58835-547">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers.</span></span> <span data-ttu-id="58835-548">A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="58835-548">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="58835-549">O construtor processa caracteres de `value` começando no local especificado pelo ponteiro até que um caractere nulo (0x00) seja atingido ([exemplo](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-549">The constructor processes characters from `value` starting from the location specified by the pointer until a null character (0x00) is reached ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="58835-550">Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58835-550">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="58835-551">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58835-551">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length)`  
 <span data-ttu-id="58835-552">**(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial dentro dessa matriz e um comprimento.</span><span class="sxs-lookup"><span data-stu-id="58835-552">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span></span>  <span data-ttu-id="58835-553">A matriz é assumida para representar uma cadeia de caracteres codificada usando a página de código atual do sistema (ou seja, a codificação especificada por <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="58835-553">The array is assumed to represent a string encoded using the current system code page (that is, the encoding specified by <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>).</span></span> <span data-ttu-id="58835-554">O construtor processa caracteres do valor começando `startIndex` e termina em `startIndex`  +  `length` – 1 ([exemplo](#Ctor6_Example)).</span><span class="sxs-lookup"><span data-stu-id="58835-554">The constructor processes characters from value starting at `startIndex` and ending at `startIndex` + `length` – 1 ([example](#Ctor6_Example)).</span></span>  
  
 <span data-ttu-id="58835-555">Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58835-555">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="58835-556">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58835-556">This member cannot be used by partially trusted or transparent code.</span></span>  
  
 `String(SByte* value, Int32 startIndex, Int32 length, Encoding enc)`  
 <span data-ttu-id="58835-557">**(Não compatível com CLS) ** Inicializa a nova instância para o valor indicado por um ponteiro para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz, um comprimento de e um <xref:System.Text.Encoding> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-557">**(Not CLS-compliant)** Initializes the new instance to the value indicated by a pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <xref:System.Text.Encoding> object.</span></span>  
  
 <span data-ttu-id="58835-558">Permissão: <xref:System.Security.SecurityCriticalAttribute>, requer confiança total para o chamador imediato.</span><span class="sxs-lookup"><span data-stu-id="58835-558">Permission: <xref:System.Security.SecurityCriticalAttribute>, requires full trust for the immediate caller.</span></span> <span data-ttu-id="58835-559">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span><span class="sxs-lookup"><span data-stu-id="58835-559">This member cannot be used by partially trusted or transparent code.</span></span>  
  
<a name="Params"></a>   
## <a name="parameters"></a><span data-ttu-id="58835-560">Parâmetros</span><span class="sxs-lookup"><span data-stu-id="58835-560">Parameters</span></span>  
 <span data-ttu-id="58835-561">Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que não incluem um parâmetro de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-561">Here is a complete list of parameters used by <xref:System.String> constructors that don't include a pointer parameter.</span></span> <span data-ttu-id="58835-562">Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.</span><span class="sxs-lookup"><span data-stu-id="58835-562">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="58835-563">Parâmetro</span><span class="sxs-lookup"><span data-stu-id="58835-563">Parameter</span></span>|<span data-ttu-id="58835-564">Tipo</span><span class="sxs-lookup"><span data-stu-id="58835-564">Type</span></span>|<span data-ttu-id="58835-565">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-565">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<span data-ttu-id="58835-566"><xref:System.Char>[]</span><span class="sxs-lookup"><span data-stu-id="58835-566"><xref:System.Char>[]</span></span>|<span data-ttu-id="58835-567">Uma matriz de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-567">An array of Unicode characters.</span></span>|  
|`c`|<xref:System.Char>|<span data-ttu-id="58835-568">Um caractere Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-568">A Unicode character.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="58835-569">A posição inicial no `value` do primeiro caractere na nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-569">The starting position in `value` of the first character in the new string.</span></span><br /><br /> <span data-ttu-id="58835-570">Valor padrão: 0</span><span class="sxs-lookup"><span data-stu-id="58835-570">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="58835-571">O número de caracteres em `value` para incluir na nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-571">The number of characters in `value` to include in the new string.</span></span><br /><br /> <span data-ttu-id="58835-572">Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="58835-572">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`count`|<xref:System.Int32>|<span data-ttu-id="58835-573">O número de vezes que o caractere `c` é repetido na nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-573">The number of times the character `c` is repeated in the new string.</span></span> <span data-ttu-id="58835-574">Se `count` for zero, o valor do novo objeto é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-574">If `count` is zero, the value of the new object is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
  
 <span data-ttu-id="58835-575">Aqui está uma lista completa dos parâmetros usados pelo <xref:System.String> construtores que incluem um parâmetro de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-575">Here is a complete list of parameters used by <xref:System.String> constructors that include a pointer parameter.</span></span> <span data-ttu-id="58835-576">Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.</span><span class="sxs-lookup"><span data-stu-id="58835-576">For the parameters used by each overload, see the overload syntax above.</span></span>  
  
|<span data-ttu-id="58835-577">Parâmetro</span><span class="sxs-lookup"><span data-stu-id="58835-577">Parameter</span></span>|<span data-ttu-id="58835-578">Tipo</span><span class="sxs-lookup"><span data-stu-id="58835-578">Type</span></span>|<span data-ttu-id="58835-579">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-579">Description</span></span>|  
|---------------|----------|-----------------|  
|`value`|<xref:System.Char>*<br /><br /> <span data-ttu-id="58835-580">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-580">-or-</span></span><br /><br /> <xref:System.SByte>\*|<span data-ttu-id="58835-581">Um ponteiro para uma matriz terminada em nulo de caracteres Unicode ou uma matriz de inteiros com sinal de 8 bits.</span><span class="sxs-lookup"><span data-stu-id="58835-581">A pointer to a null-terminated array of Unicode characters or an array of 8-bit signed integers.</span></span> <span data-ttu-id="58835-582">Se `value` está `null` ou uma matriz vazia, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-582">If `value` is `null` or an empty array, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>|  
|`startIndex`|<xref:System.Int32>|<span data-ttu-id="58835-583">O índice do elemento da matriz que define o primeiro caractere na nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-583">The index of the array element that defines the first character in the new string.</span></span><br /><br /> <span data-ttu-id="58835-584">Valor padrão: 0</span><span class="sxs-lookup"><span data-stu-id="58835-584">Default value: 0</span></span>|  
|`length`|<xref:System.Int32>|<span data-ttu-id="58835-585">O número de elementos da matriz para usar para criar a nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-585">The number of array elements to use to create the new string.</span></span> <span data-ttu-id="58835-586">Se o comprimento for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-586">If length is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span><br /><br /> <span data-ttu-id="58835-587">Valor padrão: <xref:System.Array.Length%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="58835-587">Default value: <xref:System.Array.Length%2A?displayProperty=nameWithType></span></span>|  
|`enc`|<xref:System.Text.Encoding>|<span data-ttu-id="58835-588">Um objeto que especifica como o `value` matriz é codificada.</span><span class="sxs-lookup"><span data-stu-id="58835-588">An object that specifies how the `value` array is encoded.</span></span><br /><br /> <span data-ttu-id="58835-589">Valor padrão: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, ou a página de código ANSI atual do sistema</span><span class="sxs-lookup"><span data-stu-id="58835-589">Default value: <xref:System.Text.Encoding.Default%2A?displayProperty=nameWithType>, or the system's current ANSI code page</span></span>|  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a><span data-ttu-id="58835-590">Exceções</span><span class="sxs-lookup"><span data-stu-id="58835-590">Exceptions</span></span>  
 <span data-ttu-id="58835-591">Aqui está uma lista de exceções geradas por construtores que não incluem os parâmetros de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-591">Here's a list of exceptions thrown by constructors that don't include pointer parameters.</span></span>  
  
|<span data-ttu-id="58835-592">Exceção</span><span class="sxs-lookup"><span data-stu-id="58835-592">Exception</span></span>|<span data-ttu-id="58835-593">Condição</span><span class="sxs-lookup"><span data-stu-id="58835-593">Condition</span></span>|<span data-ttu-id="58835-594">Lançado por</span><span class="sxs-lookup"><span data-stu-id="58835-594">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="58835-595">`value` é `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-595">`value` is `null`.</span></span>|<xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="58835-596">`startIndex`,`length`, ou `count` é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="58835-596">`startIndex`,`length`, or `count` is less than zero.</span></span><br /><br /> <span data-ttu-id="58835-597">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-597">-or-</span></span><br /><br /> <span data-ttu-id="58835-598">A soma de `startIndex` e `length` é maior que o número de elementos em `value`.</span><span class="sxs-lookup"><span data-stu-id="58835-598">The sum of `startIndex` and `length` is greater than the number of elements in `value`.</span></span><br /><br /> <span data-ttu-id="58835-599">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-599">-or-</span></span><br /><br /> <span data-ttu-id="58835-600">`count` é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="58835-600">`count` is less than zero.</span></span>|<xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29>|  
  
 <span data-ttu-id="58835-601">Aqui está uma lista de exceções geradas por construtores que incluem parâmetros de ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-601">Here's a list of exceptions thrown by constructors that include pointer parameters.</span></span>  
  
|<span data-ttu-id="58835-602">Exceção</span><span class="sxs-lookup"><span data-stu-id="58835-602">Exception</span></span>|<span data-ttu-id="58835-603">Condição</span><span class="sxs-lookup"><span data-stu-id="58835-603">Condition</span></span>|<span data-ttu-id="58835-604">Lançado por</span><span class="sxs-lookup"><span data-stu-id="58835-604">Thrown by</span></span>|  
|---------------|---------------|---------------|  
|<xref:System.ArgumentException>|<span data-ttu-id="58835-605">`value` Especifica uma matriz que contém um caractere Unicode inválido.</span><span class="sxs-lookup"><span data-stu-id="58835-605">`value` specifies an array that contains an invalid Unicode character.</span></span><br /><br /> <span data-ttu-id="58835-606">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-606">-or-</span></span><br /><br /> <span data-ttu-id="58835-607">`value` ou `value`  +  `startIndex` Especifica um endereço que é menor que 64K.</span><span class="sxs-lookup"><span data-stu-id="58835-607">`value` or `value` + `startIndex` specifies an address that is less than 64K.</span></span><br /><br /> <span data-ttu-id="58835-608">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-608">-or-</span></span><br /><br /> <span data-ttu-id="58835-609">Uma nova <xref:System.String> instância não pôde ser inicializada a partir de `value` porque a matriz de bytes `value` não usa a codificação de página de código padrão.</span><span class="sxs-lookup"><span data-stu-id="58835-609">A new <xref:System.String> instance could not be initialized from the `value` byte array because `value` does not use the default code page encoding.</span></span>|<span data-ttu-id="58835-610">Todos os construtores com ponteiros.</span><span class="sxs-lookup"><span data-stu-id="58835-610">All constructors with pointers.</span></span>|  
|<xref:System.ArgumentNullException>|<span data-ttu-id="58835-611">`value` é nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-611">`value` is null.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<xref:System.ArgumentOutOfRangeException>|<span data-ttu-id="58835-612">O processo atual não tem acesso de leitura a todos os caracteres endereçados.</span><span class="sxs-lookup"><span data-stu-id="58835-612">The current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="58835-613">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-613">-or-</span></span><br /><br /> <span data-ttu-id="58835-614">`startIndex` ou `length` é menor que zero, `value` + `startIndex` causa um estouro do ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.</span><span class="sxs-lookup"><span data-stu-id="58835-614">`startIndex` or `length` is less than zero, `value` + `startIndex` cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span></span><br /><br /> <span data-ttu-id="58835-615">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-615">-or-</span></span><br /><br /> <span data-ttu-id="58835-616">O comprimento da nova cadeia de caracteres é muito grande para alocar.</span><span class="sxs-lookup"><span data-stu-id="58835-616">The length of the new string is too large to allocate.</span></span>|<span data-ttu-id="58835-617">Todos os construtores com ponteiros.</span><span class="sxs-lookup"><span data-stu-id="58835-617">All constructors with pointers.</span></span>|  
|<xref:System.AccessViolationException>|<span data-ttu-id="58835-618">`value`, ou `value`  +  `startIndex`  +  `length` – 1, especifica um endereço inválido.</span><span class="sxs-lookup"><span data-stu-id="58835-618">`value`, or `value` + `startIndex` + `length` – 1, specifies an invalid address.</span></span>|<xref:System.String.%23ctor%28System.SByte%2A%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="58835-619">Qual método devo chamar?</span><span class="sxs-lookup"><span data-stu-id="58835-619">Which method do I call?</span></span>  
  
|<span data-ttu-id="58835-620">Para</span><span class="sxs-lookup"><span data-stu-id="58835-620">To</span></span>|<span data-ttu-id="58835-621">Chamada ou uso</span><span class="sxs-lookup"><span data-stu-id="58835-621">Call or use</span></span>|  
|--------|-----------------|  
|<span data-ttu-id="58835-622">Crie uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-622">Create a string.</span></span>|<span data-ttu-id="58835-623">Atribuição de uma cadeia de caracteres literal ou uma cadeia de caracteres existente ([exemplo](#Ctor1_Example))</span><span class="sxs-lookup"><span data-stu-id="58835-623">Assignment from a string literal or an existing string ([example](#Ctor1_Example))</span></span>|  
|<span data-ttu-id="58835-624">Crie uma cadeia de caracteres de uma matriz de caractere inteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-624">Create a string from an entire character array.</span></span>|<span data-ttu-id="58835-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([exemplo](#Ctor2_Example))</span><span class="sxs-lookup"><span data-stu-id="58835-625"><xref:System.String.%23ctor%28System.Char%5B%5D%29> ([example](#Ctor2_Example))</span></span>|  
|<span data-ttu-id="58835-626">Criar um cadeia de caracteres de uma parte de uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-626">Createa string from a portion of a character array.</span></span>|<span data-ttu-id="58835-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([exemplo](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="58835-627"><xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="58835-628">Crie uma cadeia de caracteres que se repete o mesmo caractere várias vezes.</span><span class="sxs-lookup"><span data-stu-id="58835-628">Create a string that repeats the same character multiple times.</span></span>|<span data-ttu-id="58835-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([exemplo](#Ctor3_Example))</span><span class="sxs-lookup"><span data-stu-id="58835-629"><xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> ([example](#Ctor3_Example))</span></span>|  
|<span data-ttu-id="58835-630">Crie uma cadeia de caracteres de um ponteiro para uma Unicode ou uma matriz de caractere largo.</span><span class="sxs-lookup"><span data-stu-id="58835-630">Create a string from a pointer to a Unicode or wide character array.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%29>|  
|<span data-ttu-id="58835-631">Crie uma cadeia de caracteres de uma parte de uma Unicode ou uma matriz de caractere largo usando seu ponteiro.</span><span class="sxs-lookup"><span data-stu-id="58835-631">Create a string from a portion of a Unicode or wide character array by using its pointer.</span></span>|<xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29>|  
|<span data-ttu-id="58835-632">Criar uma cadeia de caracteres de um C++ `char` matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-632">Create a string from a C++ `char` array.</span></span>|<span data-ttu-id="58835-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span><span class="sxs-lookup"><span data-stu-id="58835-633"><xref:System.String.%23ctor%28System.SByte%2A%29>, <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29></span></span><br /><br /> <span data-ttu-id="58835-634">- ou -</span><span class="sxs-lookup"><span data-stu-id="58835-634">-or-</span></span><br /><br /> <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%2CSystem.Text.Encoding%29>|  
|<span data-ttu-id="58835-635">Crie uma cadeia de caracteres ASCII.</span><span class="sxs-lookup"><span data-stu-id="58835-635">Create a string from ASCII characters.</span></span>|<xref:System.Text.ASCIIEncoding.GetString%2A?displayProperty=nameWithType>|  
  
<a name="Creating_Strings"></a>   
## <a name="creating-strings"></a><span data-ttu-id="58835-636">Criando cadeias de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-636">Creating strings</span></span>  
 <span data-ttu-id="58835-637">Usado com mais frequência técnica para criar cadeias de caracteres de forma programática é uma atribuição simples, conforme ilustrado na [Este exemplo](#Ctor1_Example).</span><span class="sxs-lookup"><span data-stu-id="58835-637">The most commonly used technique for creating strings programmatically is simple assignment, as illustrated in [this example](#Ctor1_Example).</span></span> <span data-ttu-id="58835-638">O <xref:System.String> classe também inclui quatro tipos de sobrecargas de construtor que permitem que você crie cadeias de caracteres entre os seguintes valores:</span><span class="sxs-lookup"><span data-stu-id="58835-638">The <xref:System.String> class also includes four types of constructor overloads that let you create strings from the following values:</span></span>  
  
-   <span data-ttu-id="58835-639">De uma matriz de caracteres (uma matriz de caracteres codificada em UTF-16).</span><span class="sxs-lookup"><span data-stu-id="58835-639">From a character array (an array of UTF-16-encoded characters).</span></span> <span data-ttu-id="58835-640">Você pode criar um novo <xref:System.String> objeto dos caracteres em toda a matriz ou uma parte dele.</span><span class="sxs-lookup"><span data-stu-id="58835-640">You can create a new <xref:System.String> object from the characters in the entire array or a portion of it.</span></span> <span data-ttu-id="58835-641">O <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor copia todos os caracteres na matriz para a nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-641">The <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor copies all the characters in the array to the new string.</span></span> <span data-ttu-id="58835-642">O <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor copia os caracteres de índice `startIndex` índice `startIndex`  +  `length` – 1 para a nova cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-642">The <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor copies the characters from index `startIndex` to index `startIndex` + `length` – 1 to the new string.</span></span> <span data-ttu-id="58835-643">Se `length` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-643">If `length` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
     <span data-ttu-id="58835-644">Se seu código instancia repetidamente cadeias de caracteres que têm o mesmo valor, você pode melhorar o desempenho do aplicativo por meio de um meio alternativo de criação de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-644">If your code repeatedly instantiates strings that have the same value, you can improve application performance by using an alternate means of creating strings.</span></span> <span data-ttu-id="58835-645">Para obter mais informações, consulte [tratando cadeias de caracteres repetitivas](#Repetitive).</span><span class="sxs-lookup"><span data-stu-id="58835-645">For more information, see [Handling repetitive strings](#Repetitive).</span></span>  
  
-   <span data-ttu-id="58835-646">De um único caractere que é zero duplicado, uma, ou mais vezes, usando o <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-646">From a single character that is duplicated zero, one, or more times, by using the <xref:System.String.%23ctor%28System.Char%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="58835-647">Se `count` for zero, o valor da nova cadeia de caracteres é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-647">If `count` is zero, the value of the new string is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="58835-648">De um ponteiro para uma matriz de caracteres terminada em nulo, usando o <xref:System.String.%23ctor%28System.Char%2A%29> ou <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-648">From a pointer to a null-terminated character array, by using the <xref:System.String.%23ctor%28System.Char%2A%29> or <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span> <span data-ttu-id="58835-649">A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-649">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="58835-650">O construtor copia uma sequência de caracteres Unicode começando a partir o ponteiro especificado ou o ponteiro especificado adição `startIndex` e continuando até o final da matriz ou para `length` caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-650">The constructor copies a sequence of Unicode characters starting from the specified pointer or from the specified pointer plus `startIndex` and continuing to the end of the array or for `length` characters.</span></span> <span data-ttu-id="58835-651">Se `value` for um ponteiro nulo ou `length` for zero, o construtor cria uma cadeia de caracteres cujo valor é <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-651">If `value` is a null pointer or `length` is zero, the constructor creates a string whose value is <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-652">Se a operação de cópia continua até o final da matriz e a matriz não é terminada em nulo, o comportamento do construtor é dependente do sistema.</span><span class="sxs-lookup"><span data-stu-id="58835-652">If the copy operation proceeds to the end of the array and the array is not null-terminated, the constructor behavior is system-dependent.</span></span> <span data-ttu-id="58835-653">Uma condição desse tipo pode causar uma violação de acesso.</span><span class="sxs-lookup"><span data-stu-id="58835-653">Such a condition might cause an access violation.</span></span>  
  
     <span data-ttu-id="58835-654">Se a matriz contiver quaisquer caracteres nulos inseridos (U + 0000 ou '\0') e o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos.</span><span class="sxs-lookup"><span data-stu-id="58835-654">If the array contains any embedded null characters (U+0000 or '\0') and the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="58835-655">O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos que inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-655">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="58835-656">Como o endereço é o início da matriz e todos os elementos na matriz devem ser adicionadas à cadeia de caracteres, o construtor cria uma instância de uma cadeia de caracteres com dez caracteres, incluindo dois nulos incorporados.</span><span class="sxs-lookup"><span data-stu-id="58835-656">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="58835-657">Por outro lado, se a mesma matriz é passada para o <xref:System.String.%23ctor%28System.Char%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclua o primeiro caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-657">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.Char%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/chptrctor_null.cpp#5)]
     [!code-csharp[System.String.ctor#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/chptrctor_null.cs#5)]  
  
     <span data-ttu-id="58835-658">A matriz deve conter caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-658">The array must contain Unicode characters.</span></span> <span data-ttu-id="58835-659">No C++, isso significa que a matriz de caracteres deve ser definido como o gerenciado <xref:System.Char>tipo [] ou não gerenciado`wchar_t`tipo [].</span><span class="sxs-lookup"><span data-stu-id="58835-659">In C++, this means that the character array must be defined either as the managed <xref:System.Char>[] type or the unmanaged`wchar_t`[] type.</span></span>  
  
     <span data-ttu-id="58835-660">Se o <xref:System.String.%23ctor%28System.Char%2A%29> sobrecarga é chamada e a matriz não é terminada em nulo, ou se o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada e `startIndex`  +  `length`-1 inclui um intervalo que ela fora da memória alocada para a sequência de caracteres, o comportamento do construtor é dependente do sistema e pode ocorrer uma violação de acesso.</span><span class="sxs-lookup"><span data-stu-id="58835-660">If the <xref:System.String.%23ctor%28System.Char%2A%29> overload is called and the array is not null-terminated, or if the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called and `startIndex` + `length`-1 includes a range that it outside the memory allocated for the sequence of characters, the behavior of the constructor is system-dependent, and an access violation may occur.</span></span> <span data-ttu-id="58835-661">Além disso, no processador Intel Itanium, chamadas para o <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> construtor pode lançar um <xref:System.DataMisalignedException> exceção.</span><span class="sxs-lookup"><span data-stu-id="58835-661">In addition, on the Intel Itanium processor, calls to the <xref:System.String.%23ctor%28System.Char%2A%2CSystem.Int32%2CSystem.Int32%29> constructor may throw a <xref:System.DataMisalignedException> exception.</span></span> <span data-ttu-id="58835-662">Se isso ocorrer, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-662">If this occurs, call the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> instead.</span></span>  
  
-   <span data-ttu-id="58835-663">De um ponteiro para uma matriz de bytes com sinal.</span><span class="sxs-lookup"><span data-stu-id="58835-663">From a pointer to a signed byte array.</span></span> <span data-ttu-id="58835-664">A matriz inteira ou um intervalo especificado pode ser usado para inicializar a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-664">Either the entire array or a specified range can be used to initialize the string.</span></span> <span data-ttu-id="58835-665">A sequência de bytes pode ser interpretada por meio da página de código padrão de codificação ou uma codificação pode ser especificada na chamada do construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-665">The sequence of bytes can be interpreted by using the default code page encoding, or an encoding can be specified in the constructor call.</span></span> <span data-ttu-id="58835-666">Se o construtor tenta criar uma instância de uma cadeia de caracteres de uma matriz de inteira que não é terminada em nulo, ou se o intervalo da matriz de `value`  +  `startIndex` à `value`  +  `startIndex`  +  `length` -1 está fora da memória alocada para a matriz, o comportamento desse construtor é dependente do sistema e pode ocorrer uma violação de acesso.</span><span class="sxs-lookup"><span data-stu-id="58835-666">If the constructor tries to instantiate a string from an entire array that is not null-terminated, or if the range of the array from `value` + `startIndex` to `value` + `startIndex` + `length` -1 is outside of the memory allocated for the array, the behavior of this constructor is system-dependent, and an access violation may occur.</span></span>  
  
     <span data-ttu-id="58835-667">Os três construtores que incluem uma matriz de bytes com sinal como um parâmetro são projetados principalmente para converter um C++ `char` de matriz para uma cadeia de caracteres, conforme mostrado neste exemplo:</span><span class="sxs-lookup"><span data-stu-id="58835-667">The three constructors that include a signed byte array as a parameter are designed primarily to convert a C++ `char` array to a string, as shown in this example:</span></span>  
  
     [!code-cpp[System.String.Ctor#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/sbyte_ctor1.cpp#4)]  
  
     <span data-ttu-id="58835-668">Se a matriz contiver quaisquer caracteres nulos ('\0') ou bytes cujo valor é 0 e o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> sobrecarga é chamada, a instância de cadeia de caracteres contém `length` caracteres, incluindo qualquer inseridos valores nulos.</span><span class="sxs-lookup"><span data-stu-id="58835-668">If the array contains any null characters ('\0') or bytes whose value is 0 and the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> overload is called, the string instance contains `length` characters including any embedded nulls.</span></span> <span data-ttu-id="58835-669">O exemplo a seguir mostra o que acontece quando um ponteiro para uma matriz de 10 elementos que inclui dois caracteres nulos é passado para o <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-669">The following example shows what happens when a pointer to an array of 10 elements that includes two null characters is passed to the <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="58835-670">Como o endereço é o início da matriz e todos os elementos na matriz devem ser adicionadas à cadeia de caracteres, o construtor cria uma instância de uma cadeia de caracteres com dez caracteres, incluindo dois nulos incorporados.</span><span class="sxs-lookup"><span data-stu-id="58835-670">Because the address is the beginning of the array and all elements in the array are to be added to the string, the constructor instantiates a string with ten characters, including two embedded nulls.</span></span> <span data-ttu-id="58835-671">Por outro lado, se a mesma matriz é passada para o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor, o resultado é uma cadeia de caracteres de quatro caracteres que não inclua o primeiro caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-671">On the other hand, if the same array is passed to the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor, the result is a four-character string that does not include the first null character.</span></span>  
  
     [!code-cpp[System.String.ctor#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/ptrctor_null.cpp#6)]
     [!code-csharp[System.String.ctor#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ptrctor_null.cs#6)]  
  
     <span data-ttu-id="58835-672">Porque o <xref:System.String.%23ctor%28System.SByte%2A%29> e <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> construtores interpretam `value` usando a página de código ANSI padrão, chamar esses construtores com matrizes de byte idênticos pode criar cadeias de caracteres que têm valores diferentes em sistemas diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-672">Because the <xref:System.String.%23ctor%28System.SByte%2A%29> and <xref:System.String.%23ctor%28System.SByte%2A%2CSystem.Int32%2CSystem.Int32%29> constructors interpret `value` by using the default ANSI code page, calling these constructors with identical byte arrays may create strings that have different values on different systems.</span></span>  
  
<a name="Repetitive"></a>   
## <a name="handling-repetitive-strings"></a><span data-ttu-id="58835-673">Identificando cadeias de caracteres repetitivas</span><span class="sxs-lookup"><span data-stu-id="58835-673">Handling repetitive strings</span></span>  
 <span data-ttu-id="58835-674">Os aplicativos que analisam ou decodificar fluxos de texto geralmente usam o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor ou o <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para converter as sequências de caracteres em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-674">Apps that parse or decode streams of text often use the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor or the <xref:System.Text.StringBuilder.Append%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to convert sequences of characters into a string.</span></span> <span data-ttu-id="58835-675">Repetidamente, criando novas cadeias de caracteres com o mesmo valor em vez de criar e reutilizar uma cadeia de caracteres desperdiça memória.</span><span class="sxs-lookup"><span data-stu-id="58835-675">Repeatedly creating new strings with the same value instead of creating and reusing one string wastes memory.</span></span> <span data-ttu-id="58835-676">Se você provavelmente criar o mesmo valor de cadeia de caracteres repetidamente chamando o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> de adiantamento de construtor, mesmo se você não souber em quais esses valores de cadeia de caracteres idênticos podem ser, você pode usar uma tabela de pesquisa em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-676">If you are likely to create the same string value repeatedly by calling the <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor, even if you don't know in advance what those identical string values may be, you can use a lookup table instead.</span></span>  
  
 <span data-ttu-id="58835-677">Por exemplo, suponha que você ler e analisar um fluxo de caracteres de um arquivo que contém as marcas XML e atributos.</span><span class="sxs-lookup"><span data-stu-id="58835-677">For example, suppose you read and parse a stream of characters from a file that contains XML tags and attributes.</span></span> <span data-ttu-id="58835-678">Quando você analisa o fluxo, você encontrar repetidamente determinados tokens (ou seja, sequências de caracteres que têm um significado simbólico).</span><span class="sxs-lookup"><span data-stu-id="58835-678">When you parse the stream, you repeatedly encounter certain tokens (that is, sequences of characters that have a symbolic meaning).</span></span> <span data-ttu-id="58835-679">Tokens equivalentes às cadeias de caracteres "0", "1", "true" e "false" têm probabilidade de ocorrer com frequência em um fluxo XML.</span><span class="sxs-lookup"><span data-stu-id="58835-679">Tokens equivalent to the strings "0", "1", "true", and "false" are likely to occur frequently in an XML stream.</span></span>  
  
 <span data-ttu-id="58835-680">Em vez de converter cada token em uma nova cadeia de caracteres, você pode criar um <xref:System.Xml.NameTable?displayProperty=nameWithType> objeto para armazenar cadeias de caracteres que ocorrem com frequência.</span><span class="sxs-lookup"><span data-stu-id="58835-680">Instead of converting each token into a new string, you can create a <xref:System.Xml.NameTable?displayProperty=nameWithType> object to hold commonly occurring strings.</span></span> <span data-ttu-id="58835-681">O <xref:System.Xml.NameTable> objeto melhora o desempenho, porque ele recupera cadeias de caracteres armazenadas sem alocação de memória temporária.</span><span class="sxs-lookup"><span data-stu-id="58835-681">The <xref:System.Xml.NameTable> object improves performance, because it retrieves stored strings without allocating temporary memory.</span></span> <span data-ttu-id="58835-682">Quando você encontrar um token, use o <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para recuperar o token da tabela.</span><span class="sxs-lookup"><span data-stu-id="58835-682">When you encounter a token, use the <xref:System.Xml.NameTable.Get%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to retrieve the token from the table.</span></span> <span data-ttu-id="58835-683">Se o token existir, o método retorna a cadeia de caracteres correspondente.</span><span class="sxs-lookup"><span data-stu-id="58835-683">If the token exists, the method returns the corresponding string.</span></span> <span data-ttu-id="58835-684">Se o token não existe, use o <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para inserir o token na tabela e obter a cadeia de caracteres correspondente.</span><span class="sxs-lookup"><span data-stu-id="58835-684">If the token does not exist, use the <xref:System.Xml.NameTable.Add%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to insert the token into the table and to get the corresponding string.</span></span>  
  
<a name="Ctor1_Example"></a>   
## <a name="example-1-using-string-assignment"></a><span data-ttu-id="58835-685">Exemplo 1: usando atribuição da cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-685">Example 1: Using string assignment</span></span>  
 <span data-ttu-id="58835-686">O exemplo a seguir cria uma nova cadeia de caracteres, atribuindo a ela um literal de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-686">The following example creates a new string by assigning it a string literal.</span></span> <span data-ttu-id="58835-687">Ele cria uma segunda cadeia de caracteres, atribuindo o valor da primeira cadeia de caracteres a ele.</span><span class="sxs-lookup"><span data-stu-id="58835-687">It creates a second string by assigning the value of the first string to it.</span></span> <span data-ttu-id="58835-688">Essas são as duas formas mais comuns para instanciar um novo <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-688">These are the two most common ways to instantiate a new <xref:System.String> object.</span></span>  
  
 [!code-cpp[System.String.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/assignment.cpp#1)]
 [!code-csharp[System.String.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.String.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.ctor/vb/ctor1.vb#1)]  
  
<a name="Ctor2_Example"></a>   
## <a name="example-2-using-a-character-array"></a><span data-ttu-id="58835-689">Exemplo 2: usando uma matriz de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-689">Example 2: Using a character array</span></span>  
 <span data-ttu-id="58835-690">O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-690">The following example demonstrates how to create a new <xref:System.String> object from a character array.</span></span>  
  
 [!code-cpp[stringexample1#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#1)]
 [!code-csharp[stringexample1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#1)]
 [!code-vb[stringexample1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#1)]  
  
<a name="Ctor3_Example"></a>   
## <a name="example-3-using-a-portion-of-a-character-array-and-repeating-a-single-character"></a><span data-ttu-id="58835-691">Exemplo 3: usando uma parte de uma matriz de caracteres e repetindo um único caractere</span><span class="sxs-lookup"><span data-stu-id="58835-691">Example 3: Using a portion of a character array and repeating a single character</span></span>  
 <span data-ttu-id="58835-692">O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto a partir de uma parte de uma matriz de caracteres e como criar um novo <xref:System.String> objeto que contém várias ocorrências de um único caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-692">The following example demonstrates how to create a new <xref:System.String> object from a portion of a character array, and how to create a new <xref:System.String> object that contains multiple occurrences of a single character.</span></span>  
  
 [!code-cpp[stringexample1#3](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#3)]
 [!code-csharp[stringexample1#3](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#3)]
 [!code-vb[stringexample1#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringexample1/VB/source.vb#3)]  
  
<a name="Ctor4_Example"></a>   
## <a name="example-4-using-a-pointer-to-a-character-array"></a><span data-ttu-id="58835-693">Exemplo 4: usando um ponteiro para uma matriz de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-693">Example 4: Using a pointer to a character array</span></span>  
 <span data-ttu-id="58835-694">O exemplo a seguir demonstra como criar um novo <xref:System.String> objeto de um ponteiro para uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-694">The following example demonstrates how to create a new <xref:System.String> object from a pointer to an array of characters.</span></span> <span data-ttu-id="58835-695">O exemplo c# deve ser compilado usando o `/unsafe` comutador de compilador.</span><span class="sxs-lookup"><span data-stu-id="58835-695">The C# example must be compiled by using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char1_ctor.cpp#2)]
 [!code-csharp[System.String.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/ctor2.cs#2)]  
  
<a name="Ctor5_Example"></a>   
## <a name="example-5-instantiating-a-string-from-a-pointer-and-a-range-of-an-array"></a><span data-ttu-id="58835-696">Exemplo 5: criando uma instância de uma cadeia de caracteres a partir de um ponteiro e um intervalo de uma matriz</span><span class="sxs-lookup"><span data-stu-id="58835-696">Example 5: Instantiating a string from a pointer and a range of an array</span></span>  
 <span data-ttu-id="58835-697">O exemplo a seguir examina os elementos de uma matriz de caracteres por um período ou um ponto de exclamação.</span><span class="sxs-lookup"><span data-stu-id="58835-697">The following example examines the elements of a character array for either a period or an exclamation point.</span></span> <span data-ttu-id="58835-698">Se um for encontrado, ele cria uma instância de uma cadeia de caracteres dos caracteres na matriz que precedem o símbolo de pontuação.</span><span class="sxs-lookup"><span data-stu-id="58835-698">If one is found, it instantiates a string from the characters in the array that precede the punctuation symbol.</span></span> <span data-ttu-id="58835-699">Caso contrário, ele cria uma instância de uma cadeia de caracteres com todo o conteúdo da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-699">If not, it instantiates a string with the entire contents of the array.</span></span> <span data-ttu-id="58835-700">O exemplo c# deve ser compilado usando o `/unsafe` comutador de compilador.</span><span class="sxs-lookup"><span data-stu-id="58835-700">The C# example must be compiled using the `/unsafe` compiler switch.</span></span>  
  
 [!code-cpp[System.String.Ctor#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.ctor/cpp/char2_ctor.cpp#3)]
 [!code-csharp[System.String.Ctor#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.ctor/cs/char2_ctor.cs#3)]  
  
<a name="Ctor6_Example"></a>   
## <a name="example-6-instantiating-a-string-from-a-pointer-to-a-signed-byte-array"></a><span data-ttu-id="58835-701">Exemplo 6: criando uma instância de uma cadeia de caracteres a partir de um ponteiro para uma matriz de bytes assinados</span><span class="sxs-lookup"><span data-stu-id="58835-701">Example 6: Instantiating a string from a pointer to a signed byte array</span></span>  
 <span data-ttu-id="58835-702">O exemplo a seguir demonstra como você pode criar uma instância das <xref:System.String> classe com o <xref:System.String.%23ctor%28System.SByte%2A%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-702">The following example demonstrates how you can create an instance of the <xref:System.String> class with the <xref:System.String.%23ctor%28System.SByte%2A%29> constructor.</span></span>  
  
 [!code-cpp[stringexample1#2](~/samples/snippets/cpp/VS_Snippets_CLR/stringexample1/CPP/source.cpp#2)]
 [!code-csharp[stringexample1#2](~/samples/snippets/csharp/VS_Snippets_CLR/stringexample1/CS/source.cs#2)]  
  
<a name="Versions"></a>   
## <a name="version-information"></a><span data-ttu-id="58835-703">Informações de versão</span><span class="sxs-lookup"><span data-stu-id="58835-703">Version information</span></span>  
 <span data-ttu-id="58835-704">.NET Framework</span><span class="sxs-lookup"><span data-stu-id="58835-704">.NET Framework</span></span>  
 <span data-ttu-id="58835-705">Todas as sobrecargas são suportadas em: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span><span class="sxs-lookup"><span data-stu-id="58835-705">All overloads are supported in: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0</span></span>  
  
 <span data-ttu-id="58835-706">.NET Framework Client Profile</span><span class="sxs-lookup"><span data-stu-id="58835-706">.NET Framework Client Profile</span></span>  
 <span data-ttu-id="58835-707">Todas as sobrecargas são suportadas em: 4, 3.5 SP1</span><span class="sxs-lookup"><span data-stu-id="58835-707">All overloads are supported in: 4, 3.5 SP1</span></span>  
  
 <span data-ttu-id="58835-708">Biblioteca de Classes Portátil</span><span class="sxs-lookup"><span data-stu-id="58835-708">Portable Class Library</span></span>  
 <span data-ttu-id="58835-709">Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte</span><span class="sxs-lookup"><span data-stu-id="58835-709">All overloads without an <xref:System.SByte>`*` parameter are supported</span></span>  
  
 <span data-ttu-id="58835-710">.NET para aplicativos da Windows Store</span><span class="sxs-lookup"><span data-stu-id="58835-710">.NET for Windows Store apps</span></span>  
 <span data-ttu-id="58835-711">Todas as sobrecargas sem um <xref:System.SByte> `*` parâmetro têm suporte em: Windows 8</span><span class="sxs-lookup"><span data-stu-id="58835-711">All overloads without an <xref:System.SByte>`*` parameter are supported in: Windows 8</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-712">Um ponteiro para uma matriz de caracteres Unicode terminada em nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-712">A pointer to a null-terminated array of Unicode characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-713">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-713">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-714">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-714">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-715">O processo atual não tem acesso de leitura a todos os caracteres endereçados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-715">The current process does not have read access to all the addressed characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-716">
            <paramref name="value" /> especifica uma matriz que contém um caractere Unicode inválido ou <paramref name="value" /> especifica um endereço menor que 64000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-716">
              <paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> specifies an address less than 64000.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="58835-717">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-717">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="58835-718">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-718">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new string : char[] -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-719">Uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-719">An array of Unicode characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-720">Inicializa uma nova instância de <see cref="T:System.String" /> classe para o valor indicado por uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-720">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-721">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-721">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;char&gt; value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.ReadOnlySpan{System.Char})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Char))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(ReadOnlySpan&lt;char&gt; value);" />
      <MemberSignature Language="F#" Value="new string : ReadOnlySpan&lt;char&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; -&gt; string" Usage="new System.string value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-722">Um ponteiro para uma matriz de inteiros de 8 bits com sinal com terminação nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-722">A pointer to a null-terminated array of 8-bit signed integers.</span>
          </span>
          <span data-ttu-id="58835-723">Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-723">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-724">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro para uma matriz de inteiros de 8 bits com sinal.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-724">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a pointer to an array of 8-bit signed integers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-725">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-725">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-726">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-726">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-727">Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo-se que <paramref name="value" /> está codificado em ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-727">A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-728">O comprimento da nova cadeia de caracteres a ser inicializada, que é determinado pelo caractere de terminação nula <paramref name="value" />, é muito grande para ser alocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-728">The length of the new string to initialize, which is determined by the null termination character of <paramref name="value" />, is too large to allocate.</span>
          </span>
        </exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="58835-729">
            <paramref name="value" /> especifica um endereço inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-729">
              <paramref name="value" /> specifies an invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="58835-730">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-730">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="58835-731">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-731">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char c, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char c, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (c As Char, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char c, int count);" />
      <MemberSignature Language="F#" Value="new string : char * int -&gt; string" Usage="new System.string (c, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="c" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="58835-732">Um caractere Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-732">A Unicode character.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-733">O número de vezes que <c>c</c> ocorre.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-733">The number of times <c>c</c> occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-734">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um caractere Unicode repetido um número de vezes especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-734">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified Unicode character repeated a specified number of times.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-735">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-735">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-736">
            <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-736">
              <paramref name="count" /> is less than zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(char* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;char&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-737">Um ponteiro para uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-737">A pointer to an array of Unicode characters.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-738">A posição inicial dentro de <c>valor</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-738">The starting position within <c>value</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-739">O número de caracteres em <c>valor</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-739">The number of characters within <c>value</c> to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-740">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um tamanho.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-740">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of Unicode characters, a starting character position within that array, and a length.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-741">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-741">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-742">
            <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero, <paramref name="value" /> + <paramref name="startIndex" /> causa um estouro do ponteiro ou o processo atual não tem acesso de leitura a todos os caracteres endereçados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-742">
              <paramref name="startIndex" /> or <paramref name="length" /> is less than zero, <paramref name="value" /> + <paramref name="startIndex" /> cause a pointer overflow, or the current process does not have read access to all the addressed characters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-743">
            <paramref name="value" /> especifica uma matriz que contém um caractere Unicode inválido ou <paramref name="value" /> + <paramref name="startIndex" /> especifica um endereço menor que 64000.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-743">
              <paramref name="value" /> specifies an array that contains an invalid Unicode character, or <paramref name="value" /> + <paramref name="startIndex" /> specifies an address less than 64000.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="58835-744">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-744">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="58835-745">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-745">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (char[] value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(char[] value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Char(), startIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(cli::array &lt;char&gt; ^ value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : char[] * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-746">Uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-746">An array of Unicode characters.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-747">A posição inicial dentro de <c>valor</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-747">The starting position within <c>value</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-748">O número de caracteres em <c>valor</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-748">The number of characters within <c>value</c> to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-749">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por uma matriz de caracteres Unicode, uma posição de caractere inicial dentro dessa matriz e um comprimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-749">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by an array of Unicode characters, a starting character position within that array, and a length.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-750">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-750">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-751">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-751">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-752">
            <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-752">
              <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-753">-ou- A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o número de elementos em <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-753">-or-  The sum of <paramref name="startIndex" /> and <paramref name="length" /> is greater than the number of elements in <paramref name="value" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int -&gt; string" Usage="new System.string (value, startIndex, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-754">Um ponteiro para uma matriz de inteiros com sinal de 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-754">A pointer to an array of 8-bit signed integers.</span>
          </span>
          <span data-ttu-id="58835-755">Os inteiros são interpretados usando a codificação da página de código do sistema atual (ou seja, a codificação especificada por <see cref="P:System.Text.Encoding.Default" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-755">The integers are interpreted using the current system code page encoding (that is, the encoding specified by <see cref="P:System.Text.Encoding.Default" />).</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-756">A posição inicial dentro de <c>valor</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-756">The starting position within <c>value</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-757">O número de caracteres em <c>valor</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-757">The number of characters within <c>value</c> to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-758">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz e um comprimento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-758">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, and a length.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-759">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-759">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-760">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-760">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-761">
            <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-761">
              <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-762">-ou- O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é muito grande para a plataforma atual; ou seja, o cálculo do endereço estourou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-762">-or-  The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span>
          </span>
          <span data-ttu-id="58835-763">-ou- O tamanho da nova cadeia de caracteres a ser inicializada é muito grande para ser alocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-763">-or-  The length of the new string to initialize is too large to allocate.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-764">O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é menor que 64K.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-764">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span>
          </span>
          <span data-ttu-id="58835-765">-ou- Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo que <paramref name="value" /> esteja codificado em ANSI.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-765">-or-  A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded in ANSI.</span>
          </span>
        </exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="58835-766">
            <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-766">
              <paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="58835-767">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-767">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="58835-768">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-768">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public String (sbyte* value, int startIndex, int length, System.Text.Encoding enc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int8* value, int32 startIndex, int32 length, class System.Text.Encoding enc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.#ctor(System.SByte*,System.Int32,System.Int32,System.Text.Encoding)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; String(System::SByte* value, int startIndex, int length, System::Text::Encoding ^ enc);" />
      <MemberSignature Language="F#" Value="new string : nativeptr&lt;sbyte&gt; * int * int * System.Text.Encoding -&gt; string" Usage="new System.string (value, startIndex, length, enc)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.SByte*" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="enc" Type="System.Text.Encoding" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-769">Um ponteiro para uma matriz de inteiros com sinal de 8 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-769">A pointer to an array of 8-bit signed integers.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-770">A posição inicial dentro de <c>valor</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-770">The starting position within <c>value</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-771">O número de caracteres em <c>valor</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-771">The number of characters within <c>value</c> to use.</span>
          </span>
        </param>
        <param name="enc">
          <span data-ttu-id="58835-772">Um objeto que especifica como a matriz referenciada por <c>value</c> é codificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-772">An object that specifies how the array referenced by <c>value</c> is encoded.</span>
          </span>
          <span data-ttu-id="58835-773">Se <c>enc</c> for <see langword="null" />, a codificação ANSI será pressuposta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-773">If <c>enc</c> is <see langword="null" />, ANSI encoding is assumed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-774">Inicializa uma nova instância da classe <see cref="T:System.String" /> para o valor indicado por um ponteiro especificado para uma matriz de inteiros com sinal de 8 bits, uma posição inicial na matriz, um comprimento e um objeto <see cref="T:System.Text.Encoding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-774">Initializes a new instance of the <see cref="T:System.String" /> class to the value indicated by a specified pointer to an array of 8-bit signed integers, a starting position within that array, a length, and an <see cref="T:System.Text.Encoding" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-775">Para exemplos e informações de uso abrangentes sobre este e outras sobrecargas do construtor `String`, consulte o resumo do construtor <xref:System.String.%23ctor%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-775">For examples and comprehensive usage information about this and other `String` constructor overloads, see the <xref:System.String.%23ctor%2A> constructor summary.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-776">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-776">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-777">
            <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-777">
              <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-778">-ou- O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é muito grande para a plataforma atual; ou seja, o cálculo do endereço estourou.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-778">-or-  The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is too large for the current platform; that is, the address calculation overflowed.</span>
          </span>
          <span data-ttu-id="58835-779">-ou- O tamanho da nova cadeia de caracteres a ser inicializada é muito grande para ser alocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-779">-or-  The length of the new string to initialize is too large to allocate.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-780">O endereço especificado por <paramref name="value" /> + <paramref name="startIndex" /> é menor que 64K.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-780">The address specified by <paramref name="value" /> + <paramref name="startIndex" /> is less than 64K.</span>
          </span>
          <span data-ttu-id="58835-781">-ou- Não foi possível inicializar uma nova instância de <see cref="T:System.String" /> usando <paramref name="value" />, supondo que <paramref name="value" /> esteja codificado conforme especificado por <paramref name="enc" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-781">-or-  A new instance of <see cref="T:System.String" /> could not be initialized using <paramref name="value" />, assuming <paramref name="value" /> is encoded as specified by <paramref name="enc" />.</span>
          </span>
        </exception>
        <exception cref="T:System.AccessViolationException">
          <span data-ttu-id="58835-782">
            <paramref name="value" />, <paramref name="startIndex" /> e <paramref name="length" /> coletivamente especificam um endereço inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-782">
              <paramref name="value" />, <paramref name="startIndex" />, and <paramref name="length" /> collectively specify an invalid address.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="58835-783">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-783">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="58835-784">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-784">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="Chars">
      <MemberSignature Language="C#" Value="public char this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Chars(int32)" />
      <MemberSignature Language="DocId" Value="P:System.String.Chars(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Chars(index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char default[int] { char get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Chars(int) : char" Usage="System.string.Chars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">
          <span data-ttu-id="58835-785">Uma posição na cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-785">A position in the current string.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-786">Obtém o objeto <see cref="T:System.Char" /> em uma posição especificada no atual objeto <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-786">Gets the <see cref="T:System.Char" /> object at a specified position in the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="58835-787">O objeto na posição <paramref name="index" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-787">The object at position <paramref name="index" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-788">O `index` parâmetro é baseado em zero.</span><span class="sxs-lookup"><span data-stu-id="58835-788">The `index` parameter is zero-based.</span></span>  
  
 <span data-ttu-id="58835-789">Essa propriedade retorna o <xref:System.Char> objeto na posição especificada pelo `index` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-789">This property returns the <xref:System.Char> object at the position specified by the `index` parameter.</span></span> <span data-ttu-id="58835-790">No entanto, um caractere Unicode pode ser representado por mais de um <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="58835-790">However, a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="58835-791">Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> caracteres de classe para trabalhar com o Unicode em vez de <xref:System.Char> objetos.</span><span class="sxs-lookup"><span data-stu-id="58835-791">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with Unicode characters instead of <xref:System.Char> objects.</span></span> <span data-ttu-id="58835-792">Para obter mais informações, consulte a seção "Char caracteres objetos e Unicode" o <xref:System.String> visão geral da classe.</span><span class="sxs-lookup"><span data-stu-id="58835-792">For more information, see the "Char Objects and Unicode Characters" section in the <xref:System.String> class overview.</span></span>  
  
 <span data-ttu-id="58835-793">No c#, o <xref:System.String.Chars%2A> propriedade é um indexador.</span><span class="sxs-lookup"><span data-stu-id="58835-793">In C#, the <xref:System.String.Chars%2A> property is an indexer.</span></span> <span data-ttu-id="58835-794">No Visual Basic, é a propriedade padrão do <xref:System.String> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-794">In Visual Basic, it is the default property of the <xref:System.String> class.</span></span> <span data-ttu-id="58835-795">Cada <xref:System.Char> objeto na cadeia de caracteres pode ser acessado por meio de código como o seguinte.</span><span class="sxs-lookup"><span data-stu-id="58835-795">Each <xref:System.Char> object in the string can be accessed by using code such as the following.</span></span>  
  
 [!code-csharp[System.String.Chars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.chars/cs/chars1.cs#1)]
 [!code-vb[System.String.Chars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.chars/vb/chars1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-796">O exemplo a seguir demonstra como você pode usar esse indexador em uma rotina para validar uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-796">The following example demonstrates how you can use this indexer in a routine to validate a string.</span></span>  
  
 [!code-cpp[Uri_IsHexDigit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Uri_IsHexDigit/CPP/uri_ishexdigit.cpp#1)]
 [!code-csharp[Uri_IsHexDigit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Uri_IsHexDigit/CS/uri_ishexdigit.cs#1)]
 [!code-vb[Uri_IsHexDigit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Uri_IsHexDigit/VB/uri_ishexdigit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="58835-797">
            <paramref name="index" /> é maior ou igual ao tamanho desse objeto ou menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-797">
              <paramref name="index" /> is greater than or equal to the length of this object or less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.GetEnumerator" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="string.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-798">Retorna uma referência a essa instância de <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-798">Returns a reference to this instance of <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-799">Esta instância de <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-799">This instance of <see cref="T:System.String" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-800">O valor retornado não é uma cópia independente dessa instância; ele é simplesmente outra exibição dos mesmos dados.</span><span class="sxs-lookup"><span data-stu-id="58835-800">The return value is not an independent copy of this instance; it is simply another view of the same data.</span></span> <span data-ttu-id="58835-801">Use o <xref:System.String.Copy%2A> ou <xref:System.String.CopyTo%2A> método para criar um separado <xref:System.String> objeto com o mesmo valor que esta instância.</span><span class="sxs-lookup"><span data-stu-id="58835-801">Use the <xref:System.String.Copy%2A> or <xref:System.String.CopyTo%2A> method to create a separate <xref:System.String> object with the same value as this instance.</span></span>  
  
 <span data-ttu-id="58835-802">Porque o <xref:System.String.Clone%2A> método simplesmente retorna a instância de cadeia de caracteres existente, há poucos motivos para chamá-lo diretamente.</span><span class="sxs-lookup"><span data-stu-id="58835-802">Because the <xref:System.String.Clone%2A> method simply returns the existing string instance, there is little reason to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Copy(System.String)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Compare">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-803">Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-803">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-804">Todas as sobrecargas do <xref:System.String.Compare%2A> método retornar um inteiro com sinal de 32 bits que indica a relação léxica entre os dois termos de comparação.</span><span class="sxs-lookup"><span data-stu-id="58835-804">All overloads of the <xref:System.String.Compare%2A> method return a 32-bit signed integer indicating the lexical relationship between the two comparands.</span></span>  
  
|<span data-ttu-id="58835-805">Valor</span><span class="sxs-lookup"><span data-stu-id="58835-805">Value</span></span>|<span data-ttu-id="58835-806">Condição</span><span class="sxs-lookup"><span data-stu-id="58835-806">Condition</span></span>|  
|-----------|---------------|  
|<span data-ttu-id="58835-807">Menor que zero</span><span class="sxs-lookup"><span data-stu-id="58835-807">Less than zero</span></span>|<span data-ttu-id="58835-808">A primeira subcadeia de caracteres precede a segunda subcadeia de caracteres na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-808">The first substring precedes the second substring in the sort order.</span></span>|  
|<span data-ttu-id="58835-809">Zero</span><span class="sxs-lookup"><span data-stu-id="58835-809">Zero</span></span>|<span data-ttu-id="58835-810">As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou `length` é zero.</span><span class="sxs-lookup"><span data-stu-id="58835-810">The substrings occur in the same position in the sort order, or `length` is zero.</span></span>|  
|<span data-ttu-id="58835-811">Maior que zero</span><span class="sxs-lookup"><span data-stu-id="58835-811">Greater than zero</span></span>|<span data-ttu-id="58835-812">A primeira subcadeia de caracteres segue a segunda subcadeia de caracteres na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-812">The first substring follows the second substring in the sort order.</span></span>|  
  
> [!WARNING]
>  <span data-ttu-id="58835-813">Sempre que possível, você deve chamar uma sobrecarga da <xref:System.String.Compare%2A> método inclui um <xref:System.StringComparison> parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-813">Whenever possible, you should call an overload of the <xref:System.String.Compare%2A> method that includes a <xref:System.StringComparison> parameter.</span></span> <span data-ttu-id="58835-814">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-814">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string -&gt; int" Usage="System.string.Compare (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-815">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-815">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-816">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-816">The second string to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-817">Compara dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-817">Compares two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-818">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-818">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-819">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description>
                  <paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <paramref name="strA" /> ocorre na mesma posição de <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description>
                  <paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-819">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description>
                    <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description>
                    <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-820">A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-820">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-821">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-821">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-822">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-822">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-823">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-823">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-824">Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método.</span><span class="sxs-lookup"><span data-stu-id="58835-824">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="58835-825">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-825">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-826">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-826">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-827">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-827">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-828">A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-828">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="58835-829">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-829">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-830">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-830">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-831">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-831">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-832">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-832">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#10)]
 [!code-csharp[System.String.Compare#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#10)]
 [!code-vb[System.String.Compare#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#10)]  
  
 <span data-ttu-id="58835-833">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-833">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-834">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-834">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#11)]
 [!code-csharp[System.String.Compare#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#11)]
 [!code-vb[System.String.Compare#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-835">A exemplo a seguir chama o <xref:System.String.Compare%28System.String%2CSystem.String%29> método para comparar os três conjuntos de cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-835">The following example calls the <xref:System.String.Compare%28System.String%2CSystem.String%29> method to compare three sets of strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 <span data-ttu-id="58835-836">No exemplo a seguir, o `ReverseStringComparer` classe demonstra como você pode avaliar duas cadeias de caracteres com o <xref:System.String.Compare%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-836">In the following example, the `ReverseStringComparer` class demonstrates how you can evaluate two strings with the <xref:System.String.Compare%2A> method.</span></span>  
  
 [!code-cpp[ArrayList#7](~/samples/snippets/cpp/VS_Snippets_CLR/ArrayList/CPP/ArrayListSample.cpp#7)]
 [!code-csharp[ArrayList#7](~/samples/snippets/csharp/VS_Snippets_CLR/ArrayList/CS/ArrayListSample.cs#7)]
 [!code-vb[ArrayList#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/ArrayList/VB/ArrayListSample.vb#7)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-837">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, uma comparação sensível à cultura de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  [! código csharp [System.String.Compare#21] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.Compare/cs/compare21.cs#21)] [! código vb [System.String.Compare#21] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.Compare/vb/compare21.vb#21)] para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, a chamada a <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o parâmetro 'comparisonType'.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-837">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  [!code-csharp[System.String.Compare#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare21.cs#21)] [!code-vb[System.String.Compare#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare21.vb#21)]  To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the `comparisonType` parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-838">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-838">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-839">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-839">The second string to compare.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-840">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-840">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-841">Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-841">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-842">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-842">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-843">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description>
                  <paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <paramref name="strA" /> ocorre na mesma posição de <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description>
                  <paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-843">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description>
                    <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description>
                    <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-844">A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-844">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-845">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-845">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-846">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-846">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-847">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-847">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-848">Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método.</span><span class="sxs-lookup"><span data-stu-id="58835-848">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="58835-849">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-849">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-850">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-850">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-851">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-851">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-852">A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-852">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="58835-853">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-853">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-854">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-854">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-855">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-855">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-856">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-856">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#12)]
 [!code-csharp[System.String.Compare#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#12)]
 [!code-vb[System.String.Compare#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#12)]  
  
 <span data-ttu-id="58835-857">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-857">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-858">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-858">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#13)]
 [!code-csharp[System.String.Compare#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#13)]
 [!code-vb[System.String.Compare#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#13)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-859">O exemplo a seguir demonstra que o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> método é equivalente a usar <xref:System.String.ToUpper%2A> ou <xref:System.String.ToLower%2A> ao comparar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-859">The following example demonstrates that the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Boolean%29> method is equivalent to using <xref:System.String.ToUpper%2A> or <xref:System.String.ToLower%2A> when comparing strings.</span></span>  
  
 [!code-cpp[System.String.Compare#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/compare02.cpp#18)]
 [!code-csharp[System.String.Compare#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare02.cs#18)]
 [!code-vb[System.String.Compare#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare02.vb#18)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-860">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, uma comparação sensível à cultura, não diferencia maiusculas de "animal" com "Ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  [! código csharp [System.String.Compare#22] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.Compare/cs/compare22.cs#22)] [! código vb [System.String.Compare#22] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.Compare/vb/compare22.vb#22)] para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, a chamada a <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-860">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a culture-sensitive, case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  [!code-csharp[System.String.Compare#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare22.cs#22)] [!code-vb[System.String.Compare#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare22.vb#22)]  To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * StringComparison -&gt; int" Usage="System.string.Compare (strA, strB, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-861">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-861">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-862">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-862">The second string to compare.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-863">Um dos valores de enumeração que especifica as regras a serem usadas na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-863">One of the enumeration values that specifies the rules to use in the comparison.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-864">Compara dois objetos <see cref="T:System.String" /> especificados usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-864">Compares two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-865">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-865">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-866">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description>
                  <paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <paramref name="strA" /> está na mesma posição de <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description>
                  <paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-866">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description>
                    <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <paramref name="strA" /> is in the same position as <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description>
                    <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-867">O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso dos termos de comparação ou usar o word (sensível à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-867">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="58835-868">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-868">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-869">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-869">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-870">A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-870">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="58835-871">No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-871">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-872">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-872">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-873">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-873">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-874">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-874">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#16)]
 [!code-csharp[System.String.Compare#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#16)]
 [!code-vb[System.String.Compare#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#16)]  
  
 <span data-ttu-id="58835-875">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-875">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-876">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-876">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#17)]
 [!code-csharp[System.String.Compare#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#17)]
 [!code-vb[System.String.Compare#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#17)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-877">O exemplo a seguir compara três versões da letra "I".</span><span class="sxs-lookup"><span data-stu-id="58835-877">The following example compares three versions of the letter "I".</span></span> <span data-ttu-id="58835-878">Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.</span><span class="sxs-lookup"><span data-stu-id="58835-878">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.CompareCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.CompareCmp/cpp/cmpcmp.cpp#1)]
 [!code-csharp[System.String.CompareCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.CompareCmp/cs/cmpcmp.cs#1)]
 [!code-vb[System.String.CompareCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.CompareCmp/vb/cmpcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-879">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-879">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="58835-880">
            <see cref="T:System.StringComparison" /> não é suportado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-880">
              <see cref="T:System.StringComparison" /> is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-881">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-881">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.StringComparison)" /> method does not consider such characters when it performs a culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Globalization.CultureInfo" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, strB, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-882">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-882">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-883">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-883">The second string to compare.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-884">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-884">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-885">Um objeto que fornece as informações de comparação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-885">An object that supplies culture-specific comparison information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-886">Compara dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, bem como usando informações culturais específicas para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-886">Compares two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-887">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-887">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-888">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description>
                  <paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <paramref name="strA" /> ocorre na mesma posição de <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description>
                  <paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-888">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description>
                    <paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description>
                    <paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-889">A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-889">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-890">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-890">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-891">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-891">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-892">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-892">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-893">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-893">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-894">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-894">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-895">A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-895">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="58835-896">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-896">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-897">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-897">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-898">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-898">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-899">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-899">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#14)]
 [!code-csharp[System.String.Compare#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#14)]
 [!code-vb[System.String.Compare#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#14)]  
  
 <span data-ttu-id="58835-900">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-900">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-901">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-901">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#15)]
 [!code-csharp[System.String.Compare#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#15)]
 [!code-vb[System.String.Compare#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#15)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-902">O exemplo a seguir demonstra como a cultura pode afetar uma comparação.</span><span class="sxs-lookup"><span data-stu-id="58835-902">The following example demonstrates how culture can affect a comparison.</span></span> <span data-ttu-id="58835-903">Em tcheco - cultura da República Tcheca, "ch" é um único caractere que é maior que "d".</span><span class="sxs-lookup"><span data-stu-id="58835-903">In Czech - Czech Republic culture, "ch" is a single character that is greater than "d".</span></span> <span data-ttu-id="58835-904">No entanto, em inglês - Estados Unidos cultura, "ch" consiste em dois caracteres e "c" é menor que "d".</span><span class="sxs-lookup"><span data-stu-id="58835-904">However, in English - United States culture, "ch" consists of two characters, and "c" is less than "d".</span></span>  
  
 [!code-cpp[string.comp4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.comp4/CPP/string.comp4.cpp#1)]
 [!code-csharp[string.comp4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.comp4/CS/string.comp4.cs#1)]
 [!code-vb[string.comp4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.comp4/VB/string.comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-905">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-905">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-906">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, uma comparação não diferencia maiusculas de "animal" com "Ani-sites perigosos" (usando um hífen ou U + 00AD) usando a invariável cultura indica que duas cadeias de caracteres são equivalentes.  [! código csharp [System.String.Compare#23] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.Compare/cs/compare23.cs#23)] [! código vb [System.String.Compare#23] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.Compare/vb/compare23.vb#23)] para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, a chamada a <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-906">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a case-insensitive comparison of "animal" with "Ani-mal" (using a soft hyphen, or U+00AD) using the invariant culture indicates that the two strings are equivalent.  [!code-csharp[System.String.Compare#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/compare23.cs#23)] [!code-vb[System.String.Compare#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/compare23.vb#23)]  To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of either <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="M:System.Globalization.CompareInfo.IsPrefix(System.String,System.String,System.Globalization.CompareOptions)" />
        <altmember cref="T:System.Boolean" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, string strB, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, string strB, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, strB As String, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, System::String ^ strB, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * string * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, strB, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-907">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-907">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-908">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-908">The second string to compare.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-909">A cultura que fornece as informações de comparação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-909">The culture that supplies culture-specific comparison information.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-910">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-910">Options to use when performing the comparison (such as ignoring case or symbols).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-911">Compara dois objetos <see cref="T:System.String" /> especificados usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas cadeias de caracteres na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-911">Compares two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two strings to each other in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-912">Um inteiro com sinal de 32 bits que indica a relação lexical entre <paramref name="strA" /> e <paramref name="strB" />, conforme mostrado na tabela a seguir <list type="table"><listheader><term> Valor </term><description> Condição </description></listheader><item><term> Menor que zero </term><description><paramref name="strA" /> precede <paramref name="strB" /> na ordem de classificação.  </description></item><item><term> Zero </term><description><paramref name="strA" /> ocorre na mesma posição de <paramref name="strB" /> na ordem de classificação.  </description></item><item><term> Maior que zero </term><description><paramref name="strA" /> segue <paramref name="strB" /> na ordem de classificação. </description></item></list></span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-912">A 32-bit signed integer that indicates the lexical relationship between <paramref name="strA" /> and <paramref name="strB" />, as shown in the following table  <list type="table"><listheader><term> Value  </term><description> Condition  </description></listheader><item><term> Less than zero  </term><description><paramref name="strA" /> precedes <paramref name="strB" /> in the sort order.  </description></item><item><term> Zero  </term><description><paramref name="strA" /> occurs in the same position as <paramref name="strB" /> in the sort order.  </description></item><item><term> Greater than zero  </term><description><paramref name="strA" /> follows <paramref name="strB" /> in the sort order.  </description></item></list></span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-913">A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética dos caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-913">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="58835-914">Por exemplo, uma determinada cultura poderia especificar que determinadas combinações de caracteres ser tratado como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que preceda ou segui-lo.</span><span class="sxs-lookup"><span data-stu-id="58835-914">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58835-915">O <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método é projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="58835-915">The <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="58835-916">Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar se um valor retornado de zero).</span><span class="sxs-lookup"><span data-stu-id="58835-916">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="58835-917">Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-917">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="58835-918">A comparação pode ser especificada por ainda mais a `options` parâmetro, que consiste em um ou mais membros do <xref:System.Globalization.CompareOptions> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-918">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions> enumeration.</span></span> <span data-ttu-id="58835-919">No entanto, pois a finalidade desse método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores não têm nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="58835-919">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="58835-920">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-920">Either or both comparands can be `null`.</span></span> <span data-ttu-id="58835-921">Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maiores do que uma referência nula e duas referências nulas forem comparados como iguais uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="58835-921">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-922">A comparação termina quando uma desigualdade é descoberta ou ambas as cadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-922">The comparison terminates when an inequality is discovered or both strings have been compared.</span></span> <span data-ttu-id="58835-923">No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-923">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-924">O exemplo a seguir compara duas cadeias de caracteres de três maneiras diferentes: usando comparação Linguística para a cultura en-US; usando a comparação diferencia maiusculas de minúsculas Linguística para a cultura en-US; e usando uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-924">The following example compares two strings in three different ways: using linguistic comparison for the en-US culture; using linguistic case-sensitive comparison for the en-US culture; and using an ordinal comparison.</span></span> <span data-ttu-id="58835-925">Ele ilustra como os três métodos de comparação produzem três resultados diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-925">It illustrates how the three methods of comparison produce three different results.</span></span>  
  
 [!code-cpp[System.String.Compare#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/example.cpp#1)]
 [!code-csharp[System.String.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/Example.cs#1)]
 [!code-vb[System.String.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-926">
            <paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-926">
              <paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-927">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-927">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-928">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. O <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-928">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. The <see cref="M:System.String.Compare(System.String,System.String,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider such characters when it performs a culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="Overload:System.String.CompareOrdinal" />
        <altmember cref="Overload:System.String.CompareTo" />
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-929">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-929">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-930">A posição da subcadeia de caracteres dentro de <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-930">The position of the substring within <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-931">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-931">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-932">A posição da subcadeia de caracteres dentro de <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-932">The position of the substring within <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-933">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-933">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-934">Compara subcadeias de dois objetos <see cref="T:System.String" /> especificados e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-934">Compares substrings of two specified <see cref="T:System.String" /> objects and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-935">Um inteiro com sinal de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-935">A 32-bit signed integer indicating the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-936">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-936">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-937">As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA` e, na `strB` em `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-937">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="58835-938">Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero.</span><span class="sxs-lookup"><span data-stu-id="58835-938">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="58835-939">O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-939">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="58835-940">O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-940">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="58835-941">O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-941">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="58835-942">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-942">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-943">A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-943">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-944">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-944">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-945">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-945">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-946">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-946">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-947">Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método.</span><span class="sxs-lookup"><span data-stu-id="58835-947">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="58835-948">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-948">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-949">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-949">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-950">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-950">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-951">A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-951">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="58835-952">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-952">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-953">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-953">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-954">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-954">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-955">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-955">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#2)]
 [!code-csharp[System.String.Compare#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#2)]
 [!code-vb[System.String.Compare#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#2)]  
  
 <span data-ttu-id="58835-956">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-956">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-957">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-957">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#3)]
 [!code-csharp[System.String.Compare#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#3)]
 [!code-vb[System.String.Compare#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-958">O exemplo a seguir compara duas subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-958">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-959">
            <paramref name="indexA" /> é maior que <paramref name="strA" /><see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-959">
              <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-960">-ou- <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-960">-or-  <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-961">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-961">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-962">-ou- <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" />, e <paramref name="length" /> é maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-962">-or-  Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-963">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-963">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-964">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-964">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-965">A posição da subcadeia de caracteres dentro de <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-965">The position of the substring within <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-966">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-966">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-967">A posição da subcadeia de caracteres dentro de <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-967">The position of the substring within <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-968">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-968">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-969">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-969">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-970">Compara as subcadeias de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas, e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-970">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-971">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-971">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-972">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-972">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-973">As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA`e, na `strB` em `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-973">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="58835-974">Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero.</span><span class="sxs-lookup"><span data-stu-id="58835-974">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero.</span></span> <span data-ttu-id="58835-975">O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-975">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="58835-976">O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-976">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="58835-977">O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-977">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="58835-978">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-978">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-979">A comparação usa a cultura atual para obter informações específicas da cultura, como regras de maiúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-979">The comparison uses the current culture to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-980">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-980">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-981">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-981">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-982">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-982">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="58835-983">Ao comparar cadeias de caracteres, você deve chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método, que exige que você especifique explicitamente o tipo de comparação de cadeia de caracteres que usa o método.</span><span class="sxs-lookup"><span data-stu-id="58835-983">When comparing strings, you should call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method, which requires that you explicitly specify the type of string comparison that the method uses.</span></span> <span data-ttu-id="58835-984">Para obter mais informações, consulte [Práticas recomendadas para o uso de cadeias de caracteres](~/docs/standard/base-types/best-practices-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-984">For more information, see [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md).</span></span>  
  
 <span data-ttu-id="58835-985">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-985">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-986">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-986">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-987">A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-987">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="58835-988">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-988">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-989">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-989">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-990">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-990">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-991">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-991">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#4)]
 [!code-csharp[System.String.Compare#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#4)]
 [!code-vb[System.String.Compare#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#4)]  
  
 <span data-ttu-id="58835-992">O nome do caminho precisa ser comparados de uma maneira invariável.</span><span class="sxs-lookup"><span data-stu-id="58835-992">The path name needs to be compared in an invariant manner.</span></span> <span data-ttu-id="58835-993">O código correto para fazer isso é o seguinte.</span><span class="sxs-lookup"><span data-stu-id="58835-993">The correct code to do this is as follows.</span></span>  
  
 [!code-cpp[System.String.Compare#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#5)]
 [!code-csharp[System.String.Compare#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#5)]
 [!code-vb[System.String.Compare#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-994">O exemplo a seguir executa duas comparações de duas subcadeias de caracteres que diferem apenas no caso.</span><span class="sxs-lookup"><span data-stu-id="58835-994">The following example performs two comparisons of two substrings that only differ in case.</span></span> <span data-ttu-id="58835-995">A primeira comparação diferencia maiusculas e minúsculas e a segunda comparação considera caso.</span><span class="sxs-lookup"><span data-stu-id="58835-995">The first comparison ignores case and the second comparison considers case.</span></span>  
  
 [!code-cpp[string.compare4#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare4/CPP/comp4.cpp#1)]
 [!code-csharp[string.compare4#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare4/CS/comp4.cs#1)]
 [!code-vb[string.compare4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare4/VB/comp4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-996">
            <paramref name="indexA" /> é maior que <paramref name="strA" /><see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-996">
              <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-997">-ou- <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-997">-or-  <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-998">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-998">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-999">-ou- <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" />, e <paramref name="length" /> é maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-999">-or-  Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1000">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1000">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * StringComparison -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-1001">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1001">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-1002">A posição da subcadeia de caracteres dentro de <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1002">The position of the substring within <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-1003">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1003">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-1004">A posição da subcadeia de caracteres dentro de <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1004">The position of the substring within <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-1005">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1005">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1006">Um dos valores de enumeração que especifica as regras a serem usadas na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1006">One of the enumeration values that specifies the rules to use in the comparison.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1007">Compara as subcadeias de caracteres de dois especificado <see cref="T:System.String" /> objetos usando as regras especificadas e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1007">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified rules, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1008">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1008">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-1009">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou o parâmetro <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1009">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings occur in the same position in the sort order, or the <paramref name="length" /> parameter is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> follllows the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1010">As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA` e, na `strB` em `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-1010">The substrings to compare start in `strA` at `indexA` and in `strB` at `indexB`.</span></span> <span data-ttu-id="58835-1011">Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero, não posicionar um.</span><span class="sxs-lookup"><span data-stu-id="58835-1011">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="58835-1012">O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-1012">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="58835-1013">O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-1013">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="58835-1014">O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-1014">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="58835-1015">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-1015">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-1016">O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso dos termos de comparação ou usar o word (sensível à cultura) ou regras de classificação (sem diferenciação de cultura) ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1016">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the comparands, or use word (culture-sensitive) or ordinal (culture-insensitive) sort rules.</span></span>  
  
 <span data-ttu-id="58835-1017">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-1017">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-1018">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1018">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-1019">A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1019">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="58835-1020">No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-1020">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-1021">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-1021">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-1022">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1022">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-1023">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-1023">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#8)]
 [!code-csharp[System.String.Compare#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#8)]
 [!code-vb[System.String.Compare#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#8)]  
  
 <span data-ttu-id="58835-1024">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1024">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-1025">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-1025">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#9)]
 [!code-csharp[System.String.Compare#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#9)]
 [!code-vb[System.String.Compare#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#9)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1026">O exemplo a seguir compara duas subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1026">The following example compares two substrings.</span></span>  
  
 [!code-cpp[string.compare3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare3/CPP/comp3.cpp#1)]
 [!code-csharp[string.compare3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare3/CS/comp3.cs#1)]
 [!code-vb[string.compare3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare3/VB/comp3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1027">
            <paramref name="indexA" /> é maior que <paramref name="strA" /><see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1027">
              <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1028">-ou- <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1028">-or-  <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1029">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1029">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1030">-ou- <paramref name="indexA" /> ou <paramref name="indexB" /> é <see langword="null" />, e <paramref name="length" /> é maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1030">-or-  Either <paramref name="indexA" /> or <paramref name="indexB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1031">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1031">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1032">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> para o <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1032">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.StringComparison)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" /> for the <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, ignoreCase As Boolean, culture As CultureInfo) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * bool * System.Globalization.CultureInfo -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-1033">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1033">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-1034">A posição da subcadeia de caracteres dentro de <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1034">The position of the substring within <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-1035">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1035">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-1036">A posição da subcadeia de caracteres dentro de <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1036">The position of the substring within <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-1037">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1037">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-1038">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1038">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-1039">Um objeto que fornece as informações de comparação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1039">An object that supplies culture-specific comparison information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1040">Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados, ignorando ou respeitando as maiúsculas e minúsculas e usando informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica sua posição relativa na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1040">Compares substrings of two specified <see cref="T:System.String" /> objects, ignoring or honoring their case and using culture-specific information to influence the comparison, and returns an integer that indicates their relative position in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1041">Um número inteiro que indica a relação lexical entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1041">An integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-1042">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1042">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1043">As subcadeias de caracteres a ser comparado Iniciar em `strA` na `indexA`e, na `strB` em `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-1043">The substrings to compare start in `strA` at `indexA`, and in `strB` at `indexB`.</span></span> <span data-ttu-id="58835-1044">Ambos `indexA` e `indexB` são com base em zero, ou seja, o primeiro caractere no `strA` e `strB` está na posição zero, não posicionar um.</span><span class="sxs-lookup"><span data-stu-id="58835-1044">Both `indexA` and `indexB` are zero-based; that is, the first character in `strA` and `strB` is at position zero, not position one.</span></span> <span data-ttu-id="58835-1045">O tamanho da primeira subcadeia de caracteres é igual ao tamanho de `strA` menos `indexA` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-1045">The length of the first substring is equal to the length of `strA` minus `indexA` plus one.</span></span> <span data-ttu-id="58835-1046">O tamanho da segunda subcadeia de caracteres é igual ao tamanho de `strB` menos `indexB` mais um.</span><span class="sxs-lookup"><span data-stu-id="58835-1046">The length of the second substring is equal to the length of `strB` minus `indexB` plus one.</span></span>  
  
 <span data-ttu-id="58835-1047">O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-1047">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="58835-1048">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-1048">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-1049">A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-1049">The comparison uses the `culture` parameter to obtain culture-specific information such as casing rules and the alphabetic order of individual characters.</span></span> <span data-ttu-id="58835-1050">Por exemplo, uma cultura poderia especificar que determinadas combinações de caracteres são tratadas como um caractere único ou caracteres em maiúsculas e minúsculas são comparados de uma determinada forma ou que a ordem de classificação de um caractere depende dos caracteres que precedem ou o seguem.</span><span class="sxs-lookup"><span data-stu-id="58835-1050">For example, a culture could specify that certain combinations of characters be treated as a single character, or uppercase and lowercase characters be compared in a particular way, or that the sorting order of a character depends on the characters that precede or follow it.</span></span>  
  
 <span data-ttu-id="58835-1051">A comparação é realizada usando-se regras de classificação de palavras.</span><span class="sxs-lookup"><span data-stu-id="58835-1051">The comparison is performed using word sort rules.</span></span> <span data-ttu-id="58835-1052">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1052">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1053">Um ou ambos os comparandos podem ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-1053">One or both comparands can be `null`.</span></span> <span data-ttu-id="58835-1054">Por definição, qualquer cadeia de caracteres, inclusive a cadeia de caracteres vazia (""), compara-se maior que uma referência nula e duas referências nulas comparam-se como iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1054">By definition, any string, including the empty string (""), compares greater than a null reference; and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-1055">A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1055">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="58835-1056">No entanto, caso as duas cadeias de caracteres comparem-se iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres com caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-1056">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, then the string with remaining characters is considered greater.</span></span> <span data-ttu-id="58835-1057">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-1057">The return value is the result of the last comparison performed.</span></span>  
  
 <span data-ttu-id="58835-1058">Os resultados inesperados podem ocorrer quando as comparações são afetadas por regras de maiúsculas específicas de cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1058">Unexpected results can occur when comparisons are affected by culture-specific casing rules.</span></span> <span data-ttu-id="58835-1059">Por exemplo, em turco, o exemplo a seguir produz os resultados errados porque o sistema de arquivos em turco não usa regras de maiúsculas linguísticas para a letra "i" em "file".</span><span class="sxs-lookup"><span data-stu-id="58835-1059">For example, in Turkish, the following example yields the wrong results because the file system in Turkish does not use linguistic casing rules for the letter "i" in "file".</span></span>  
  
 [!code-cpp[System.String.Compare#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#6)]
 [!code-csharp[System.String.Compare#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#6)]
 [!code-vb[System.String.Compare#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#6)]  
  
 <span data-ttu-id="58835-1060">Compare o nome do caminho para "file" que usa uma comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1060">Compare the path name to "file" using an ordinal comparison.</span></span> <span data-ttu-id="58835-1061">O código correto para fazer isso é o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-1061">The correct code to do this is as follows:</span></span>  
  
 [!code-cpp[System.String.Compare#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Compare/cpp/remarks.cpp#7)]
 [!code-csharp[System.String.Compare#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare/cs/remarks.cs#7)]
 [!code-vb[System.String.Compare#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare/vb/remarks.vb#7)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1062">O exemplo a seguir compara duas subcadeias de caracteres usando diferentes culturas e ignorando o caso de subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1062">The following example compares two substrings using different cultures and ignoring the case of the substrings.</span></span> <span data-ttu-id="58835-1063">A escolha da cultura afeta como a letra "I" é comparado.</span><span class="sxs-lookup"><span data-stu-id="58835-1063">The choice of culture affects how the letter "I" is compared.</span></span>  
  
 [!code-cpp[string.compare5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compare5/CPP/comp5.cpp#1)]
 [!code-csharp[string.compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compare5/CS/comp5.cs#1)]
 [!code-vb[string.compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compare5/VB/comp5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1064">
            <paramref name="indexA" /> é maior que <paramref name="strA" /><see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1064">
              <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1065">-ou- <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1065">-or-  <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1066">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1066">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1067">-ou- <paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" />, e <paramref name="length" /> é maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1067">-or-  Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1068">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1068">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1069">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, chame o <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método e fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1069">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Boolean,System.Globalization.CultureInfo)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, call the <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method and supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (string strA, int indexA, string strB, int indexB, int length, System.Globalization.CultureInfo culture, System.Globalization.CompareOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(string strA, int32 indexA, string strB, int32 indexB, int32 length, class System.Globalization.CultureInfo culture, valuetype System.Globalization.CompareOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer, culture As CultureInfo, options As CompareOptions) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length, System::Globalization::CultureInfo ^ culture, System::Globalization::CompareOptions options);" />
      <MemberSignature Language="F#" Value="static member Compare : string * int * string * int * int * System.Globalization.CultureInfo * System.Globalization.CompareOptions -&gt; int" Usage="System.string.Compare (strA, indexA, strB, indexB, length, culture, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="options" Type="System.Globalization.CompareOptions" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-1070">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1070">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-1071">A posição inicial da subcadeia de caracteres dentro de <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1071">The starting position of the substring within <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-1072">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1072">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-1073">A posição inicial da subcadeia de caracteres dentro de <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1073">The starting position of the substring within <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-1074">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1074">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-1075">Um objeto que fornece as informações de comparação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1075">An object that supplies culture-specific comparison information.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-1076">Opções a serem usadas ao executar a comparação (como ignorar maiúsculas e minúsculas ou símbolos).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1076">Options to use when performing the comparison (such as ignoring case or symbols).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1077">Compara duas subcadeias de caracteres <see cref="T:System.String" /> especificadas usando as opções de comparação especificadas e as informações específicas da cultura para influenciar a comparação e retorna um inteiro que indica o relacionamento entre as duas subcadeias de caracteres na ordem de classificação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1077">Compares substrings of two specified <see cref="T:System.String" /> objects using the specified comparison options and culture-specific information to influence the comparison, and returns an integer that indicates the relationship of the two substrings to each other in the sort order.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1078">Um número inteiro com relacionamento léxico entre as duas subcadeias de caracteres, como é mostrado na tabela a seguir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1078">An integer that indicates the lexical relationship between the two substrings, as shown in the following table.</span>
          </span>
          <span data-ttu-id="58835-1079">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> precede a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres ocorrem na mesma posição na ordem de classificação, ou <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> segue a subcadeia de caracteres em <paramref name="strB" /> na ordem de classificação. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1079">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> precedes the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings occur in the same position in the sort order, or <paramref name="length" /> is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> follows the substring in <paramref name="strB" /> in the sort order.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1080">As subcadeias de caracteres a ser comparado Iniciar em `strA` na posição `indexA` e, na `strB` na posição `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-1080">The substrings to compare start in `strA` at position `indexA` and in `strB` at position `indexB`.</span></span> <span data-ttu-id="58835-1081">O comprimento da primeira subcadeia de caracteres é o comprimento da `strA` menos `indexA`.</span><span class="sxs-lookup"><span data-stu-id="58835-1081">The length of the first substring is the length of `strA` minus `indexA`.</span></span> <span data-ttu-id="58835-1082">O comprimento da segunda subcadeia de caracteres é o comprimento da `strB` menos `indexB`.</span><span class="sxs-lookup"><span data-stu-id="58835-1082">The length of the second substring is the length of `strB` minus `indexB`.</span></span>  
  
 <span data-ttu-id="58835-1083">O número de caracteres a serem comparados é o menor dos tamanhos das subcadeias de caracteres e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-1083">The number of characters to compare is the lesser of the lengths of the two substrings, and `length`.</span></span> <span data-ttu-id="58835-1084">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-1084">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-1085">A comparação usa a `culture` parâmetro para obter informações específicas da cultura, como regras de maiusculas e minúsculas e a ordem alfabética dos caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-1085">The comparison uses the `culture` parameter to obtain culture-specific information, such as casing rules and the alphabetical order of individual characters.</span></span> <span data-ttu-id="58835-1086">Por exemplo, uma determinada cultura poderia especificar que determinadas combinações de caracteres ser tratado como um único caractere, que os caracteres maiusculos e minúsculos ser comparados de uma maneira específica ou que a ordem de classificação de um caractere depende dos caracteres que preceda ou segui-lo.</span><span class="sxs-lookup"><span data-stu-id="58835-1086">For example, a particular culture could specify that certain combinations of characters be treated as a single character, that uppercase and lowercase characters be compared in a particular way, or that the sort order of a character depends on the characters that precede or follow it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58835-1087">O <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método é projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="58835-1087">The <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method is designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="58835-1088">Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas subcadeias de caracteres são equivalentes (ou seja, quando a finalidade da chamada de método é testar se um valor retornado de zero).</span><span class="sxs-lookup"><span data-stu-id="58835-1088">It should not be used when the primary purpose of the method call is to determine whether two substrings are equivalent (that is, when the purpose of the method call is to test for a return value of zero).</span></span> <span data-ttu-id="58835-1089">Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-1089">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="58835-1090">Uma ou ambas `strA` e `strB` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-1090">One or both of `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="58835-1091">Por definição, qualquer cadeia de caracteres, incluindo <xref:System.String.Empty?displayProperty=nameWithType>, compara maiores do que uma referência nula e duas referências nulas forem comparados como iguais uns aos outros.</span><span class="sxs-lookup"><span data-stu-id="58835-1091">By definition, any string, including <xref:System.String.Empty?displayProperty=nameWithType>, compares greater than a null reference, and two null references compare equal to each other.</span></span>  
  
 <span data-ttu-id="58835-1092">A comparação pode ser especificada por ainda mais a `options` parâmetro, que consiste em um ou mais membros do <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1092">The comparison can be further specified by the `options` parameter, which consists of one or more members of the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="58835-1093">No entanto, pois a finalidade desse método é realizar uma comparação de cadeia de caracteres sensíveis à cultura, o <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> e <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> valores não têm nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="58835-1093">However, because the purpose of this method is to conduct a culture-sensitive string comparison, the <xref:System.Globalization.CompareOptions.Ordinal?displayProperty=nameWithType> and <xref:System.Globalization.CompareOptions.OrdinalIgnoreCase?displayProperty=nameWithType> values have no effect.</span></span>  
  
 <span data-ttu-id="58835-1094">A comparação termina quando uma desigualdade é descoberta ou ambas as subcadeias de caracteres são comparadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1094">The comparison terminates when an inequality is discovered or both substrings have been compared.</span></span> <span data-ttu-id="58835-1095">No entanto, se duas cadeias de caracteres forem comparados como iguais ao final de uma cadeia de caracteres e a outra cadeia de caracteres tenha caracteres restantes, a cadeia de caracteres restantes é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="58835-1095">However, if the two strings compare equal to the end of one string, and the other string has characters remaining, the string with the remaining characters is considered greater.</span></span> <span data-ttu-id="58835-1096">O valor de retorno é o resultado da última comparação realizada.</span><span class="sxs-lookup"><span data-stu-id="58835-1096">The return value is the result of the last comparison performed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1097">O exemplo a seguir usa o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> método para comparar os sobrenomes de duas pessoas.</span><span class="sxs-lookup"><span data-stu-id="58835-1097">The following example uses the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Globalization.CultureInfo%2CSystem.Globalization.CompareOptions%29> method to compare the last names of two people.</span></span> <span data-ttu-id="58835-1098">Ele, em seguida, as lista em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="58835-1098">It then lists them in alphabetical order.</span></span>  
  
 [!code-csharp[System.String.Compare5#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Compare5/cs/Example.cs#1)]
 [!code-vb[System.String.Compare5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Compare5/vb/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1099">
            <paramref name="options" /> não é um valor <see cref="T:System.Globalization.CompareOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1099">
              <paramref name="options" /> is not a <see cref="T:System.Globalization.CompareOptions" /> value.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1100">
            <paramref name="indexA" /> é maior que <paramref name="strA" /><see langword=".Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1100">
              <paramref name="indexA" /> is greater than <paramref name="strA" /><see langword=".Length" />.</span>
          </span>
          <span data-ttu-id="58835-1101">-ou- <paramref name="indexB" /> é maior que <paramref name="strB" /><see langword=".Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1101">-or-  <paramref name="indexB" /> is greater than <paramref name="strB" /><see langword=".Length" />.</span>
          </span>
          <span data-ttu-id="58835-1102">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1102">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1103">-ou- <paramref name="strA" /> ou <paramref name="strB" /> é <see langword="null" />, e <paramref name="length" /> é maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1103">-or-  Either <paramref name="strA" /> or <paramref name="strB" /> is <see langword="null" />, and <paramref name="length" /> is greater than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1104">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1104">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1105">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> método não considera esses caracteres quando ele executa uma comparação linguística ou sensível à cultura. Para reconhecer caracteres ignoráveis em sua comparação, fornecer um valor de <see cref="F:System.Globalization.CompareOptions.Ordinal" /> ou <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> para o <paramref name="options" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1105">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.Compare(System.String,System.Int32,System.String,System.Int32,System.Int32,System.Globalization.CultureInfo,System.Globalization.CompareOptions)" /> method does not consider these characters when it performs a linguistic or culture-sensitive comparison. To recognize ignorable characters in your comparison, supply a value of <see cref="F:System.Globalization.CompareOptions.Ordinal" /> or <see cref="F:System.Globalization.CompareOptions.OrdinalIgnoreCase" /> for the <paramref name="options" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="Overload:System.String.Equals" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareOrdinal">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1106">Compara dois objetos <see cref="T:System.String" /> avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1106">Compares two <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, System::String ^ strB);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * string -&gt; int" Usage="System.string.CompareOrdinal (strA, strB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-1107">A primeira cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1107">The first string to compare.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-1108">A segunda cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1108">The second string to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1109">Compara dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1109">Compares two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1110">Um número inteiro que indica a relação lexical entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1110">An integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-1111">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description>
                  <paramref name="strA" /> é menor que <paramref name="strB" />.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description>
                  <paramref name="strA" /> e <paramref name="strB" /> são iguais.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description>
                  <paramref name="strA" /> é maior que <paramref name="strB" />. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1111">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description>
                    <paramref name="strA" /> is less than <paramref name="strB" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description>
                    <paramref name="strA" /> and <paramref name="strB" /> are equal.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description>
                    <paramref name="strA" /> is greater than <paramref name="strB" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1112">Esse método executa uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1112">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="58835-1113">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1113">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-1114">Para executar uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal, chamar o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1114">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1115">Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-1115">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="58835-1116">Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1116">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="58835-1117">Se houver apenas um dos valores `null`, o método considera o valor não nulo seja maior.</span><span class="sxs-lookup"><span data-stu-id="58835-1117">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1118">O exemplo a seguir executa e comparação ordinal de duas cadeias de caracteres que diferem apenas no caso.</span><span class="sxs-lookup"><span data-stu-id="58835-1118">The following example performs and ordinal comparison of two strings that only differ in case.</span></span>  
  
 [!code-cpp[string.compareordinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.compareordinal/CPP/comp0.cpp#1)]
 [!code-csharp[string.compareordinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.compareordinal/CS/comp0.cs#1)]
 [!code-vb[string.compareordinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.compareordinal/VB/comp0.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareOrdinal">
      <MemberSignature Language="C#" Value="public static int CompareOrdinal (string strA, int indexA, string strB, int indexB, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CompareOrdinal(string strA, int32 indexA, string strB, int32 indexB, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareOrdinal(System.String,System.Int32,System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CompareOrdinal (strA As String, indexA As Integer, strB As String, indexB As Integer, length As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CompareOrdinal(System::String ^ strA, int indexA, System::String ^ strB, int indexB, int length);" />
      <MemberSignature Language="F#" Value="static member CompareOrdinal : string * int * string * int * int -&gt; int" Usage="System.string.CompareOrdinal (strA, indexA, strB, indexB, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strA" Type="System.String" />
        <Parameter Name="indexA" Type="System.Int32" />
        <Parameter Name="strB" Type="System.String" />
        <Parameter Name="indexB" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="strA">
          <span data-ttu-id="58835-1119">A primeira cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1119">The first string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexA">
          <span data-ttu-id="58835-1120">O índice inicial da subcadeia de caracteres em <c>strA</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1120">The starting index of the substring in <c>strA</c>.</span>
          </span>
        </param>
        <param name="strB">
          <span data-ttu-id="58835-1121">A segunda cadeia de caracteres a ser usada na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1121">The second string to use in the comparison.</span>
          </span>
        </param>
        <param name="indexB">
          <span data-ttu-id="58835-1122">O índice inicial da subcadeia de caracteres em <c>strB</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1122">The starting index of the substring in <c>strB</c>.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-1123">O número máximo de caracteres nas subcadeias de caracteres a serem comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1123">The maximum number of characters in the substrings to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1124">Compara subcadeias de caracteres de dois objetos <see cref="T:System.String" /> especificados avaliando os valores numéricos dos objetos <see cref="T:System.Char" /> correspondentes em cada subcadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1124">Compares substrings of two specified <see cref="T:System.String" /> objects by evaluating the numeric values of the corresponding <see cref="T:System.Char" /> objects in each substring.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1125">Um inteiro assinado de 32 bits que indica a relação léxica entre os dois termos de comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1125">A 32-bit signed integer that indicates the lexical relationship between the two comparands.</span>
          </span>
          <span data-ttu-id="58835-1126">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> é menor que a subcadeia de caracteres em <paramref name="strB" />.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> As subcadeias de caracteres são iguais, ou <paramref name="length" /> é zero.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> A subcadeia de caracteres em <paramref name="strA" /> é maior que a subcadeia de caracteres em <paramref name="strB" />. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1126">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> The substring in <paramref name="strA" /> is less than the substring in <paramref name="strB" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> The substrings are equal, or <paramref name="length" /> is zero.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> The substring in <paramref name="strA" /> is greater than the substring in <paramref name="strB" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1127">Os parâmetros `indexA`, `indexB` e `length` devem ser não negativos.</span><span class="sxs-lookup"><span data-stu-id="58835-1127">The `indexA`, `indexB`, and `length` parameters must be nonnegative.</span></span>  
  
 <span data-ttu-id="58835-1128">O número de caracteres em comparação é menor do que o comprimento da `strA` menos `indexA`, o comprimento de `strB` menos `indexB`, e `length`.</span><span class="sxs-lookup"><span data-stu-id="58835-1128">The number of characters compared is the lesser of the length of `strA` less `indexA`, the length of `strB` less `indexB`, and `length`.</span></span>  
  
 <span data-ttu-id="58835-1129">Esse método executa uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1129">This method performs a case-sensitive comparison using ordinal sort rules.</span></span> <span data-ttu-id="58835-1130">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1130">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-1131">Para executar uma comparação diferencia maiusculas de minúsculas usando as regras de classificação ordinal, chamar o <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> método com o `comparisonType` argumento definido como <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1131">To perform a case-insensitive comparison using ordinal sort rules, call the <xref:System.String.Compare%28System.String%2CSystem.Int32%2CSystem.String%2CSystem.Int32%2CSystem.Int32%2CSystem.StringComparison%29> method with the `comparisonType` argument set to <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1132">Porque <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> é um método estático, `strA` e `strB` pode ser `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-1132">Because <xref:System.String.CompareOrdinal%28System.String%2CSystem.String%29> is a static method, `strA` and `strB` can be `null`.</span></span> <span data-ttu-id="58835-1133">Se ambos os valores são `null`, o método retornará 0 (zero), que indica que `strA` e `strB` são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1133">If both values are `null`, the method returns 0 (zero), which indicates that `strA` and `strB` are equal.</span></span> <span data-ttu-id="58835-1134">Se houver apenas um dos valores `null`, o método considera o valor não nulo seja maior.</span><span class="sxs-lookup"><span data-stu-id="58835-1134">If only one of the values is `null`, the method considers the non-null value to be greater.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1135">O exemplo a seguir demonstra que <xref:System.String.CompareOrdinal%2A> e <xref:System.String.Compare%2A> usar diferentes ordens de classificação.</span><span class="sxs-lookup"><span data-stu-id="58835-1135">This following example demonstrates that <xref:System.String.CompareOrdinal%2A> and <xref:System.String.Compare%2A> use different sort orders.</span></span>  
  
 [!code-cpp[StringCompareOrdinal#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareOrdinal/CPP/stringcompareordinal.cpp#1)]
 [!code-csharp[StringCompareOrdinal#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareOrdinal/CS/stringcompareordinal.cs#1)]
 [!code-vb[StringCompareOrdinal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareOrdinal/VB/stringcompareordinal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1136">
            <paramref name="strA" /> não é <see langword="null" /> e <paramref name="indexA" /> é maior que <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1136">
              <paramref name="strA" /> is not <see langword="null" /> and <paramref name="indexA" /> is greater than <paramref name="strA" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1137">-ou- <paramref name="strB" /> não é <see langword="null" /> e <paramref name="indexB" /> é maior que <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1137">-or-  <paramref name="strB" /> is not <see langword="null" /> and <paramref name="indexB" /> is greater than <paramref name="strB" />.<see cref="P:System.String.Length" />.</span>
          </span>
          <span data-ttu-id="58835-1138">-ou- <paramref name="indexA" />, <paramref name="indexB" /> ou <paramref name="length" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1138">-or-  <paramref name="indexA" />, <paramref name="indexB" />, or <paramref name="length" /> is negative.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareTo(System.Object)" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1139">Compara esta instância com um objeto especificado ou com <see cref="T:System.String" /> e retorna um inteiro que indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação que o objeto especificado ou <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1139">Compares this instance with a specified object or <see cref="T:System.String" /> and returns an integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified object or <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1140">Ambas as sobrecargas do <xref:System.String.CompareTo%2A> método executar comparação sensível à cultura e maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-1140">Both overloads of the <xref:System.String.CompareTo%2A> method perform culture-sensitive and case-sensitive comparison.</span></span> <span data-ttu-id="58835-1141">Você não pode usar esse método para executar comparações insensíveis à cultura ou ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1141">You cannot use this method to perform culture-insensitive or ordinal comparisons.</span></span> <span data-ttu-id="58835-1142">Para maior clareza do código, é recomendável que você evite a <xref:System.String.CompareTo%2A> método e chamar o <xref:System.String.Compare%2A> método em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-1142">For code clarity, we recommend that you avoid the <xref:System.String.CompareTo%2A> method and call the <xref:System.String.Compare%2A> method instead.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="string.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1143">Um objeto avaliado como um <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1143">An object that evaluates to a <see cref="T:System.String" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1144">Compara essa instância com um <see cref="T:System.Object" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme o <see cref="T:System.Object" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1144">Compares this instance with a specified <see cref="T:System.Object" /> and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1145">Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1145">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="value" /> parameter.</span>
          </span>
          <span data-ttu-id="58835-1146">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> Essa instância precede <paramref name="value" />.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> Essa instância tem a mesma posição de <paramref name="value" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> Essa instância segue <paramref name="value" />. -ou- <paramref name="value" /> é <see langword="null" />. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1146">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> This instance precedes <paramref name="value" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> This instance has the same position in the sort order as <paramref name="value" />.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> This instance follows <paramref name="value" />.  -or-  <paramref name="value" /> is <see langword="null" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1147">`value` deve ser um <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-1147">`value` must be a <xref:System.String> object.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58835-1148">O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="58835-1148">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="58835-1149">Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1149">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="58835-1150">Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-1150">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="58835-1151">Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1151">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="58835-1152">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1152">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1153">Para obter mais informações sobre o comportamento desse método, consulte a seção comentários do <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1153">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1154">O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método com um <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="58835-1154">The following example uses the <xref:System.String.CompareTo%2A> method with an <xref:System.Object>.</span></span> <span data-ttu-id="58835-1155">Porque ele tenta comparar um <xref:System.String> da instância para uma `TestClass` do objeto, o método lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="58835-1155">Because it attempts to compare a <xref:System.String> instance to a `TestClass` object, the method throws an <xref:System.ArgumentException>.</span></span>  
  
 [!code-cpp[ExToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ExToString/CPP/extostring.cpp#1)]
 [!code-csharp[ExToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ExToString/CS/extostring.cs#1)]
 [!code-vb[ExToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ExToString/VB/extostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1156">
            <paramref name="value" /> não é um <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1156">
              <paramref name="value" /> is not a <see cref="T:System.String" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1157">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.Object)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, uma comparação de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  [! code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [! code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1157">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.CompareTo(System.Object)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  [!code-csharp[System.String.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto1.cs#1)] [!code-vb[System.String.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto1.vb#1)]  To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (string strB);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(string strB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CompareTo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (strB As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::String ^ strB);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : string -&gt; int&#xA;override this.CompareTo : string -&gt; int" Usage="string.CompareTo strB" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="strB" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="strB">
          <span data-ttu-id="58835-1158">A cadeia de caracteres a ser comparada com esta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1158">The string to compare with this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1159">Compara essa instância com um objeto <see cref="T:System.String" /> especificado e indica se esta instância precede, segue ou aparece na mesma posição na ordem de classificação, conforme a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1159">Compares this instance with a specified <see cref="T:System.String" /> object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1160">Um inteiro com sinal de 32 bits que indica se esta instância precede, segue ou é exibida na mesma posição da ordem de classificação que o parâmetro <paramref name="strB" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1160">A 32-bit signed integer that indicates whether this instance precedes, follows, or appears in the same position in the sort order as the <paramref name="strB" /> parameter.</span>
          </span>
          <span data-ttu-id="58835-1161">
            <list type="table">
              <listheader>
                <term> Valor </term>
                <description> Condição </description>
              </listheader>
              <item>
                <term> Menor que zero </term>
                <description> Essa instância precede <paramref name="strB" />.  </description>
              </item>
              <item>
                <term> Zero </term>
                <description> Essa instância tem a mesma posição de <paramref name="strB" /> na ordem de classificação.  </description>
              </item>
              <item>
                <term> Maior que zero </term>
                <description> Essa instância segue <paramref name="strB" />. -ou- <paramref name="strB" /> é <see langword="null" />. </description>
              </item>
            </list>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1161">
              <list type="table">
                <listheader>
                  <term> Value  </term>
                  <description> Condition  </description>
                </listheader>
                <item>
                  <term> Less than zero  </term>
                  <description> This instance precedes <paramref name="strB" />.  </description>
                </item>
                <item>
                  <term> Zero  </term>
                  <description> This instance has the same position in the sort order as <paramref name="strB" />.  </description>
                </item>
                <item>
                  <term> Greater than zero  </term>
                  <description> This instance follows <paramref name="strB" />.  -or-  <paramref name="strB" /> is <see langword="null" />.  </description>
                </item>
              </list>
            </span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1162">Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1162">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span> <span data-ttu-id="58835-1163">Para obter mais informações sobre a palavra, a cadeia de caracteres e os tipos ordinais, consulte <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1163">For more information about word, string, and ordinal sorts, see <xref:System.Globalization.CompareOptions?displayProperty=nameWithType>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="58835-1164">O <xref:System.String.CompareTo%2A> método foi projetado principalmente para uso em classificação ou operações de colocar em ordem alfabética.</span><span class="sxs-lookup"><span data-stu-id="58835-1164">The <xref:System.String.CompareTo%2A> method was designed primarily for use in sorting or alphabetizing operations.</span></span> <span data-ttu-id="58835-1165">Ele não deve ser usado quando o principal objetivo da chamada de método é determinar se duas cadeias de caracteres são equivalentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1165">It should not be used when the primary purpose of the method call is to determine whether two strings are equivalent.</span></span> <span data-ttu-id="58835-1166">Para determinar se duas cadeias de caracteres são equivalentes, chame o método <xref:System.String.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-1166">To determine whether two strings are equivalent, call the <xref:System.String.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="58835-1167">Para obter mais informações sobre o comportamento desse método, consulte a seção comentários do <xref:System.String.Compare%28System.String%2CSystem.String%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1167">For more information about the behavior of this method, see the Remarks section of the <xref:System.String.Compare%28System.String%2CSystem.String%29> method.</span></span>  
  
 <span data-ttu-id="58835-1168">Esse método implementa o <xref:System.IComparable%601?displayProperty=nameWithType> da interface e executa um pouco melhor do que o <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> método, porque ele não precisa determinar se o `strB` argumento é um tipo de valor mutável que deve ser boxed e tem que converter seu parâmetro de um <xref:System.Object> para um <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="58835-1168">This method implements the <xref:System.IComparable%601?displayProperty=nameWithType> interface and performs slightly better than the <xref:System.String.CompareTo%28System.Object%29?displayProperty=nameWithType> method, because it does not have to determine whether the `strB` argument is a mutable value type that must be boxed, and it does not have to cast its parameter from an <xref:System.Object> to a <xref:System.String>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1169">O exemplo a seguir usa o <xref:System.String.CompareTo%2A> método a ser comparado a instância atual da cadeia de caracteres com outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1169">The following example uses the <xref:System.String.CompareTo%2A> method to compare the current string instance with another string.</span></span>  
  
 [!code-cpp[stringcompareto#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringCompareTo/CPP/stringcompareto.cpp#1)]
 [!code-csharp[stringcompareto#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringCompareTo/CS/stringcompareto.cs#1)]
 [!code-vb[stringcompareto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringCompareTo/VB/stringcompareto.vb#1)]  
  
 <span data-ttu-id="58835-1170">O exemplo a seguir demonstra as versões genéricas e não genéricas do método CompareTo para vários tipos de valor e referência.</span><span class="sxs-lookup"><span data-stu-id="58835-1170">The following example demonstrates generic and non-generic versions of the CompareTo method for several value and reference types.</span></span>  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1171">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis. O <see cref="M:System.String.CompareTo(System.String)" /> método não considera esses caracteres quando ele executa uma comparação sensível à cultura. Por exemplo, se o código a seguir é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, uma comparação de "animal" com "ani-sites perigosos" (usando um hífen ou 00AD U +) indica que duas cadeias de caracteres são equivalentes.  [! code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [! code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  Para reconhecer caracteres ignoráveis em uma comparação de cadeia de caracteres, chame o <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1171">
              <para>Character sets include ignorable characters. The <see cref="M:System.String.CompareTo(System.String)" /> method does not consider such characters when it performs a culture-sensitive comparison. For example, if the following code is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, a comparison of "animal" with "ani-mal" (using a soft hyphen, or U+00AD) indicates that the two strings are equivalent.  [!code-csharp[System.String.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.compareto/cs/compareto2.cs#2)] [!code-vb[System.String.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.compareto/vb/compareto2.vb#2)]  To recognize ignorable characters in a string comparison, call the <see cref="M:System.String.CompareOrdinal(System.String,System.String)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Concat">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1172">Concatena uma ou mais instâncias de <see cref="T:System.String" /> ou as representações <see cref="T:System.String" /> dos valores de uma ou mais instâncias de <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1172">Concatenates one or more instances of <see cref="T:System.String" />, or the <see cref="T:System.String" /> representations of the values of one or more instances of <see cref="T:System.Object" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;string&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="values">
          <span data-ttu-id="58835-1173">Um objeto de coleção que implementa <see cref="T:System.Collections.Generic.IEnumerable`1" /> e cujo argumento de tipo genérico é <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1173">A collection object that implements <see cref="T:System.Collections.Generic.IEnumerable`1" /> and whose generic type argument is <see cref="T:System.String" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1174">Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1174">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1175">As cadeias de caracteres concatenadas em <paramref name="values" /> ou <see cref="F:System.String.Empty" /> se <paramref name="values" /> for um <see langword="IEnumerable(Of String)" /> vazio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1175">The concatenated strings in <paramref name="values" />, or <see cref="F:System.String.Empty" /> if <paramref name="values" /> is an empty <see langword="IEnumerable(Of String)" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1176">O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1176">The method concatenates each object in `values`; it does not add any delimiters.</span></span> <span data-ttu-id="58835-1177">Para especificar um delimitador entre cada membro do `values`, chame o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1177">To specify a delimiter between each member of `values`, call the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 <span data-ttu-id="58835-1178">Uma <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer elemento nulo em `values`.</span><span class="sxs-lookup"><span data-stu-id="58835-1178">An <xref:System.String.Empty> string is used in place of any null element in `values`.</span></span>  
  
 <span data-ttu-id="58835-1179">Se `values` está vazio `IEnumerable(Of String)`, o método retorna <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1179">If `values` is an empty `IEnumerable(Of String)`, the method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-1180">Se `values` está `null`, o método lança um <xref:System.ArgumentNullException> exceção.</span><span class="sxs-lookup"><span data-stu-id="58835-1180">If `values` is `null`, the method throws an <xref:System.ArgumentNullException> exception.</span></span>  
  
 <span data-ttu-id="58835-1181"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1181"><xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="58835-1182">Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta).</span><span class="sxs-lookup"><span data-stu-id="58835-1182">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="58835-1183">O exemplo a seguir passa um `List(Of String)` objeto que contém as letras maiusculas ou minúsculas do alfabeto para uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M").</span><span class="sxs-lookup"><span data-stu-id="58835-1183">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="58835-1184">O `IEnumerable(Of String)` coleção retornada pela <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1184">The `IEnumerable(Of String)` collection that is returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Concat#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat2.cs#3)]
 [!code-vb[System.String.Concat#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat2.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1185">O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100.</span><span class="sxs-lookup"><span data-stu-id="58835-1185">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="58835-1186">Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1186">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Concat%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Concat#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat1.cs#2)]
 [!code-vb[System.String.Concat#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1187">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1187">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Concat : obj -&gt; string" Usage="System.string.Concat arg0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="58835-1188">O objeto a ser representado ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1188">The object to represent, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1189">Cria a representação de cadeia de caracteres de um objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1189">Creates the string  representation of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1190">A representação da cadeia de caracteres do valor de <paramref name="arg0" /> ou <see cref="F:System.String.Empty" /> se <paramref name="arg0" /> for <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1190">The string representation of the value of <paramref name="arg0" />, or <see cref="F:System.String.Empty" /> if <paramref name="arg0" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1191">O <xref:System.String.Concat%28System.Object%29> método representa `arg0` como uma cadeia de caracteres chamando seu sem parâmetros `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="58835-1191">The <xref:System.String.Concat%28System.Object%29> method represents `arg0` as a string by calling its parameterless `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1192">O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1192">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Concat : obj[] -&gt; string" Usage="System.string.Concat args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="58835-1193">Uma matriz de objeto que contém os elementos a serem concatenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1193">An object array that contains the elements to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1194">Concatena as representações de cadeia de caracteres dos elementos em uma matriz <see cref="T:System.Object" /> especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1194">Concatenates the string representations of the elements in a specified <see cref="T:System.Object" /> array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1195">As representações de cadeia de caracteres concatenadas dos valores dos elementos em <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1195">The concatenated string representations of the values of the elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1196">O método concatena cada objeto na `args` chamando o Next sem parâmetros `ToString` método desse objeto; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1196">The method concatenates each object in `args` by calling the parameterless `ToString` method of that object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1197"><xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer objeto nulo na matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1197"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1198">O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.Object> matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1198">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with an <xref:System.Object> array.</span></span>  
  
 [!code-csharp[stringconcat1#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat1/CS/stringconcat1.cs#1)]
 [!code-vb[stringconcat1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat1/VB/stringconcat1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1199">
            <paramref name="args" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1199">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="58835-1200">Sem memória.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1200">Out of memory.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1201">
            <para>Esse método não é chamado pelo código C++. O compilador C++ resolve chamadas para <see cref="Overload:System.String.Concat" /> que tem quatro ou mais parâmetros de objeto como uma chamada para <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1201">
              <para>This method is not called by C++ code. The C++ compiler resolves calls to <see cref="Overload:System.String.Concat" /> that have four or more object parameters as a call to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (params string[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (ParamArray values As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(... cli::array &lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : string[] -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="values" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="values">
          <span data-ttu-id="58835-1202">Uma matriz de instâncias de cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1202">An array of string instances.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1203">Concatena os elementos de uma matriz <see cref="T:System.String" /> especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1203">Concatenates the elements of a specified <see cref="T:System.String" /> array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1204">Os elementos concatenados de <paramref name="values" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1204">The concatenated elements of <paramref name="values" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1205">O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1205">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1206">Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1206">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1207">O exemplo a seguir demonstra o uso do <xref:System.String.Concat%2A> método com um <xref:System.String> matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1207">The following example demonstrates the use of the <xref:System.String.Concat%2A> method with a <xref:System.String> array.</span></span>  
  
 [!code-cpp[stringconcat3#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat3/CPP/stringconcat3.cpp#1)]
 [!code-csharp[stringconcat3#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat3/CS/stringconcat3.cs#1)]
 [!code-vb[stringconcat3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat3/VB/stringconcat3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1208">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1208">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="58835-1209">Sem memória.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1209">Out of memory.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="58835-1210">O primeiro objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1210">The first object to concatenate.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1211">O segundo objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1211">The second object to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1212">Concatena as representações de cadeia de caracteres de dois objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1212">Concatenates the string representations of two specified objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1213">As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" /> e <paramref name="arg1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1213">The concatenated string representations of the values of <paramref name="arg0" /> and <paramref name="arg1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1214">O método concatena `arg0` e `arg1` chamando o Next sem parâmetros `ToString` método de `arg0` e `arg1`; não adiciona qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1214">The method concatenates `arg0` and `arg1` by calling the parameterless `ToString` method of `arg0` and `arg1`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1215"><xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1215"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="58835-1216">Se um dos argumentos é uma referência de matriz, o método concatena uma cadeia de caracteres que representa essa matriz, em vez de seus membros (por exemplo, "System.String[]").</span><span class="sxs-lookup"><span data-stu-id="58835-1216">If either of the arguments is an array reference, the method concatenates a string representing that array, instead of its members (for example, "System.String[]").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1217">O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1217">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string -&gt; string" Usage="System.string.Concat (str0, str1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">
          <span data-ttu-id="58835-1218">A primeira sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1218">The first string to concatenate.</span>
          </span>
        </param>
        <param name="str1">
          <span data-ttu-id="58835-1219">A segunda sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1219">The second string to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1220">Concatena duas instâncias especificadas de <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1220">Concatenates two specified instances of <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1221">A concatenação de <paramref name="str0" /> e <paramref name="str1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1221">The concatenation of <paramref name="str0" /> and <paramref name="str1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1222">O método concatena `str0` e `str1`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1222">The method concatenates `str0` and `str1`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-1223">Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-1223">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="58835-1224">, para concatenar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1224">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="58835-1225">Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1225">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1226">O exemplo a seguir concatena, o meio e o último nome de uma pessoa.</span><span class="sxs-lookup"><span data-stu-id="58835-1226">The following example concatenates a person's first, middle, and last name.</span></span>  
  
 [!code-cpp[stringconcat4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringconcat4/CPP/stringconcat4.cpp#1)]
 [!code-csharp[stringconcat4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringconcat4/CS/stringconcat4.cs#1)]
 [!code-vb[stringconcat4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringconcat4/VB/stringconcat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="58835-1227">O primeiro objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1227">The first object to concatenate.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1228">O segundo objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1228">The second object to concatenate.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="58835-1229">O terceiro objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1229">The third object to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1230">Concatena as representações de cadeia de caracteres de três objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1230">Concatenates the string representations of three specified objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1231">As representações de cadeia de caracteres concatenadas dos valores de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1231">The concatenated string representations of the values of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1232">O método concatena `arg0`, `arg1`, e `arg2` chamando sem parâmetro `ToString` método de cada objeto; não adiciona qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1232">The method concatenates `arg0`, `arg1`, and `arg2` by calling the parameterless `ToString` method of each object; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1233"><xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1233"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1234">O exemplo a seguir demonstra o <xref:System.String.Concat%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1234">The following example demonstrates the <xref:System.String.Concat%2A> method.</span></span>  
  
 [!code-cpp[string.concat5#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.concat5/CPP/string.concat5.cpp#1)]
 [!code-csharp[string.concat5#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.concat5/CS/string.concat5.cs#1)]
 [!code-vb[string.concat5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.concat5/VB/string.concat5.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">
          <span data-ttu-id="58835-1235">A primeira sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1235">The first string to concatenate.</span>
          </span>
        </param>
        <param name="str1">
          <span data-ttu-id="58835-1236">A segunda sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1236">The second string to concatenate.</span>
          </span>
        </param>
        <param name="str2">
          <span data-ttu-id="58835-1237">A terceira cadeia de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1237">The third string to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1238">Concatena três instâncias especificadas de <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1238">Concatenates three specified instances of <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1239">A concatenação de <paramref name="str0" />, <paramref name="str1" /> e <paramref name="str2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1239">The concatenation of <paramref name="str0" />, <paramref name="str1" />, and <paramref name="str2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1240">O método concatena `str0`, `str1`, e `str2`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1240">The method concatenates `str0`, `str1`, and `str2`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-1241">Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-1241">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="58835-1242">, para concatenar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1242">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="58835-1243">Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1243">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1244">O exemplo a seguir usa o <xref:System.String.Concat%2A> método para concatenar três cadeias de caracteres e exibe o resultado.</span><span class="sxs-lookup"><span data-stu-id="58835-1244">The following example uses the <xref:System.String.Concat%2A> method to concatenate three strings and displays the result.</span></span>  
  
 [!code-cpp[System.String.Concat#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.concat/cpp/Concat6.cpp#6)]
 [!code-csharp[System.String.Concat#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/Concat6.cs#6)]
 [!code-vb[System.String.Concat#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/Concat6.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberSignature Language="F#" Value="static member Concat : obj * obj * obj * obj -&gt; string" Usage="System.string.Concat (arg0, arg1, arg2, arg3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="arg0">
          <span data-ttu-id="58835-1245">O primeiro objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1245">The first object to concatenate.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1246">O segundo objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1246">The second object to concatenate.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="58835-1247">O terceiro objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1247">The third object to concatenate.</span>
          </span>
        </param>
        <param name="arg3">
          <span data-ttu-id="58835-1248">O quarto objeto a ser concatenado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1248">The fourth object to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1249">Concatena as representações de cadeia de caracteres de quatro objetos especificados e quaisquer objetos especificados em uma lista de parâmetros opcionais de tamanho variável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1249">Concatenates the string representations of four specified objects and any objects specified in an optional variable length parameter list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1250">A representação de cadeia de caracteres concatenada de cada valor na lista de parâmetros.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1250">The concatenated string representation of each value in the parameter list.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="58835-1251">Esta API não compatível com CLS.</span><span class="sxs-lookup"><span data-stu-id="58835-1251">This API is not CLS-compliant.</span></span> <span data-ttu-id="58835-1252">A alternativa compatível com CLS é <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1252">The CLS-compliant alternative is <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-1253">Os compiladores c# e Visual Basic resolver automaticamente uma chamada para esse método como uma chamada para <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1253">The C# and Visual Basic compilers automatically resolve a call to this method as a call to <xref:System.String.Concat%28System.Object%5B%5D%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1254">O método concatena a cada objeto na lista de parâmetros ao chamar seu sem parâmetros `ToString` método; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1254">The method concatenates each object in the parameter list by calling its parameterless `ToString` method; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1255"><xref:System.String.Empty?displayProperty=nameWithType> é usado no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1255"><xref:System.String.Empty?displayProperty=nameWithType> is used in place of any null argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-1256">O último parâmetro do <xref:System.String.Concat%2A> método é uma lista delimitada por vírgulas opcional de um ou mais objetos adicionais a serem concatenados.</span><span class="sxs-lookup"><span data-stu-id="58835-1256">The last parameter of the  <xref:System.String.Concat%2A> method is an optional comma-delimited list of one or more additional objects to concatenate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1257">O exemplo a seguir ilustra o uso do <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para concatenar uma lista de parâmetros variáveis.</span><span class="sxs-lookup"><span data-stu-id="58835-1257">The following example illustrates the use of the <xref:System.String.Concat%28System.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to concatenate a list of variable parameters.</span></span> <span data-ttu-id="58835-1258">Nesse caso, o método é chamado com nove parâmetros.</span><span class="sxs-lookup"><span data-stu-id="58835-1258">In this case, the method is called with nine parameters.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1259">
            <para>Esse método é marcado com o <see langword="vararg" /> palavra-chave, o que significa que ele oferece suporte a um número variável de parâmetros. O método pode ser chamado de Visual C++, mas ele não pode ser chamado de código c# ou Visual Basic. Os compiladores c# e Visual Basic resolver chamadas a <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> como chamadas para <see cref="M:System.String.Concat(System.Object[])" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1259">
              <para>This method is marked with the <see langword="vararg" /> keyword, which means that it supports a variable number of parameters. The method can be called from Visual C++, but it cannot be called from C# or Visual Basic code. The C# and Visual Basic compilers resolve calls to <see cref="M:System.String.Concat(System.Object,System.Object,System.Object,System.Object)" /> as calls to <see cref="M:System.String.Concat(System.Object[])" />.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Concat">
      <MemberSignature Language="C#" Value="public static string Concat (string str0, string str1, string str2, string str3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat(string str0, string str1, string str2, string str3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat(System.String,System.String,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat (str0 As String, str1 As String, str2 As String, str3 As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Concat(System::String ^ str0, System::String ^ str1, System::String ^ str2, System::String ^ str3);" />
      <MemberSignature Language="F#" Value="static member Concat : string * string * string * string -&gt; string" Usage="System.string.Concat (str0, str1, str2, str3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str0" Type="System.String" />
        <Parameter Name="str1" Type="System.String" />
        <Parameter Name="str2" Type="System.String" />
        <Parameter Name="str3" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str0">
          <span data-ttu-id="58835-1260">A primeira sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1260">The first string to concatenate.</span>
          </span>
        </param>
        <param name="str1">
          <span data-ttu-id="58835-1261">A segunda sequência de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1261">The second string to concatenate.</span>
          </span>
        </param>
        <param name="str2">
          <span data-ttu-id="58835-1262">A terceira cadeia de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1262">The third string to concatenate.</span>
          </span>
        </param>
        <param name="str3">
          <span data-ttu-id="58835-1263">A quarta cadeia de caracteres a ser concatenada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1263">The fourth string to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1264">Concatena quatro instâncias especificadas de <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1264">Concatenates four specified instances of <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1265">A concatenação de <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" /> e <paramref name="str3" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1265">The concatenation of <paramref name="str0" />, <paramref name="str1" />, <paramref name="str2" />, and <paramref name="str3" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1266">O método concatena `str0`, `str1`, `str2`, e `str3`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1266">The method concatenates `str0`, `str1`, `str2`, and `str3`; it does not add any delimiters.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-1267">Você também pode usar o operador de concatenação de cadeia de caracteres da sua linguagem, tais como `+` em c#, ou `&` e `+` no Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-1267">You can also use your language's string concatenation operator, such as `+` in C#, or `&` and `+` in Visual Basic)</span></span>  
>   
>  <span data-ttu-id="58835-1268">, para concatenar cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1268">, to concatenate strings.</span></span>  
  
 <span data-ttu-id="58835-1269">Um <xref:System.String.Empty> cadeia de caracteres é usada no lugar de qualquer objeto nulo na matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1269">An <xref:System.String.Empty> string is used in place of any null object in the array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1270">O exemplo a seguir define uma matriz de quatro – letra de palavras e armazena suas letras individuais em uma matriz de cadeia de caracteres para embaralhá-los.</span><span class="sxs-lookup"><span data-stu-id="58835-1270">The following example defines an array of four-letter words and stores their individual letters to a string array in order to scramble them.</span></span> <span data-ttu-id="58835-1271">Em seguida, ele chama o <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> método remontar as palavras embaralhadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1271">It then calls the <xref:System.String.Concat%28System.String%2CSystem.String%2CSystem.String%2CSystem.String%29> method to reassemble the scrambled words.</span></span>  
  
 [!code-csharp[System.String.Concat#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat4.cs#1)]
 [!code-vb[System.String.Concat#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat4.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
      </Docs>
    </Member>
    <Member MemberName="Concat&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Concat&lt;T&gt; (System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Concat&lt;T&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Concat``1(System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Concat(Of T) (values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Concat(System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Concat : seq&lt;'T&gt; -&gt; string" Usage="System.string.Concat values" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="58835-1272">O tipo dos membros da <c>valores</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1272">The type of the members of <c>values</c>.</span>
          </span>
        </typeparam>
        <param name="values">
          <span data-ttu-id="58835-1273">Um objeto de coleção que implementa a interface do <see cref="T:System.Collections.Generic.IEnumerable`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1273">A collection object that implements the <see cref="T:System.Collections.Generic.IEnumerable`1" /> interface.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1274">Concatena os membros de uma implementação <see cref="T:System.Collections.Generic.IEnumerable`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1274">Concatenates the members of an <see cref="T:System.Collections.Generic.IEnumerable`1" /> implementation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1275">Os membros concatenados em <paramref name="values" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1275">The concatenated members in <paramref name="values" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1276">O método concatena cada objeto em `values`; ele não adicione qualquer delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-1276">The method concatenates each object in `values`; it does not add any delimiters.</span></span>  
  
 <span data-ttu-id="58835-1277">Uma cadeia de caracteres <xref:System.String.Empty> é usada no lugar de qualquer argumento nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-1277">An <xref:System.String.Empty> string is used in place of any null argument.</span></span>  
  
 <span data-ttu-id="58835-1278"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um <xref:System.Collections.Generic.IEnumerable%601> coleção sem primeiro converter os elementos nas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1278"><xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each element in an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting the elements to strings.</span></span> <span data-ttu-id="58835-1279">Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta), como mostra o exemplo.</span><span class="sxs-lookup"><span data-stu-id="58835-1279">It is particularly useful with Language-Integrated Query (LINQ) query expressions, as the example illustrates.</span></span> <span data-ttu-id="58835-1280">A representação de cadeia de caracteres de cada objeto na <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada por meio da chamada do objeto `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="58835-1280">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1281">O exemplo a seguir define um muito simples `Animal` classe que contém o nome do animal e a ordem ao qual ele pertence.</span><span class="sxs-lookup"><span data-stu-id="58835-1281">The following example defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="58835-1282">Em seguida, ele define uma <xref:System.Collections.Generic.List%601> objeto para conter um número de `Animal` objetos.</span><span class="sxs-lookup"><span data-stu-id="58835-1282">It then defines a <xref:System.Collections.Generic.List%601> object to contain a number of `Animal` objects.</span></span> <span data-ttu-id="58835-1283">O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método de extensão é chamado para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Roedor".</span><span class="sxs-lookup"><span data-stu-id="58835-1283">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="58835-1284">O resultado é passado para o <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> método e exibidos no console.</span><span class="sxs-lookup"><span data-stu-id="58835-1284">The result is passed to the <xref:System.String.Concat%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> method and displayed to the console.</span></span>  
  
 [!code-csharp[System.String.Concat#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.concat/cs/concat3.cs#4)]
 [!code-vb[System.String.Concat#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.concat/vb/concat3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1285">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1285">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value);" />
      <MemberSignature Language="F#" Value="member this.Contains : char -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Contains : string -&gt; bool" Usage="string.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1286">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1286">The string to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1287">Retorna um valor que indica se uma subcadeia especificada ocorre nesta cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1287">Returns a value indicating whether a specified substring occurs within this string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1288">
            <see langword="true" /> se o parâmetro <paramref name="value" /> ocorrer nesta cadeia de caracteres, ou se <paramref name="value" /> for a cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1288">
              <see langword="true" /> if the <paramref name="value" /> parameter occurs within this string, or if <paramref name="value" /> is the empty string (""); otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1289">Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-1289">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span> <span data-ttu-id="58835-1290">A pesquisa começa na posição do primeiro caractere da cadeia de caracteres e continua até a última posição de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-1290">The search begins at the first character position of this string and continues through the last character position.</span></span>  
  
 <span data-ttu-id="58835-1291">Para determinar se uma cadeia de caracteres contém uma subcadeia de caracteres especificada, usando algo diferente de uma comparação ordinal (como comparação sensível à cultura, ou a comparação diferencia maiusculas de minúsculas ordinal), você pode criar um método personalizado.</span><span class="sxs-lookup"><span data-stu-id="58835-1291">To determine whether a string contains a specified substring by using something other than ordinal comparison (such as culture-sensitive comparison, or ordinal case-insensitive comparison), you can create a custom method.</span></span> <span data-ttu-id="58835-1292">O exemplo a seguir ilustra um exemplo dessa abordagem.</span><span class="sxs-lookup"><span data-stu-id="58835-1292">The following example illustrates one such approach.</span></span> <span data-ttu-id="58835-1293">Ele define uma <xref:System.String> método de extensão que inclui um <xref:System.StringComparison> parâmetro e indica se uma cadeia de caracteres contém uma subcadeia de caracteres ao usar o formulário especificado de comparação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1293">It defines a <xref:System.String> extension method  that includes a <xref:System.StringComparison> parameter and indicates whether a string contains a substring when using the specified form of string comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#1)]
 [!code-vb[System.String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#1)]  
  
 <span data-ttu-id="58835-1294">O exemplo a seguir, em seguida, chama o `Contains` método de extensão para determinar se uma subcadeia de caracteres é encontrada em uma cadeia de caracteres ao usar comparação ordinal e diferencia maiusculas de minúsculas comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1294">The following example then calls the `Contains` extension method to determine whether a substring is found in a string when using ordinal comparison and case-insensitive ordinal comparison.</span></span>  
  
 [!code-csharp[System.String.Contains#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Contains/cs/ContainsExt1.cs#2)]
 [!code-vb[System.String.Contains#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Contains/vb/ContainsExt1.vb#2)]  
  
 <span data-ttu-id="58835-1295">Se você estiver interessado na posição da subcadeia de caracteres `value` na instância atual, você pode chamar o <xref:System.String.IndexOf%2A> método para obter a posição inicial da primeira ocorrência, ou você pode chamar o <xref:System.String.LastIndexOf%2A> posição do método a ser obtido a partir do seu última ocorrência.</span><span class="sxs-lookup"><span data-stu-id="58835-1295">If you are interested in the position of the substring `value` in the current instance, you can call the <xref:System.String.IndexOf%2A> method to get the starting position of its first occurrence, or you can call the <xref:System.String.LastIndexOf%2A> method to get the starting position of its last occurrence.</span></span> <span data-ttu-id="58835-1296">O exemplo inclui uma chamada para o <xref:System.String.IndexOf%28System.String%29> método se uma subcadeia de caracteres for encontrada em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1296">The example includes a call to the <xref:System.String.IndexOf%28System.String%29> method if a substring is found in a string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1297">O exemplo a seguir determina se a cadeia de caracteres "raposa" é uma subcadeia de caracteres de aspas uma familiar.</span><span class="sxs-lookup"><span data-stu-id="58835-1297">The following example determines whether the string "fox" is a substring of a familiar quotation.</span></span> <span data-ttu-id="58835-1298">Se "raposa" for encontrado na cadeia de caracteres, ele também exibe sua posição inicial.</span><span class="sxs-lookup"><span data-stu-id="58835-1298">If "fox" is found in the string, it also displays its starting position.</span></span>  
  
 [!code-cpp[String.Contains#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.contains/CPP/cont.cpp#1)]
 [!code-csharp[String.Contains#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.contains/CS/cont.cs#1)]
 [!code-vb[String.Contains#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.contains/VB/cont.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1299">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1299">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As Char, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : char * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Contains(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Contains(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Contains : string * StringComparison -&gt; bool" Usage="string.Contains (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static string Copy (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Copy(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Copy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Copy (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Copy(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Copy : string -&gt; string" Usage="System.string.Copy str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">
          <span data-ttu-id="58835-1300">A cadeia de caracteres a ser copiada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1300">The string to copy.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1301">Cria uma nova instância de <see cref="T:System.String" /> com o mesmo valor que um <see cref="T:System.String" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1301">Creates a new instance of <see cref="T:System.String" /> with the same value as a specified <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1302">Uma nova cadeia de caracteres com o mesmo valor que <paramref name="str" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1302">A new string with the same value as <paramref name="str" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1303">O <xref:System.String.Copy%2A> método retorna um <xref:System.String> objeto que tem o mesmo valor de cadeia de caracteres original, mas representa uma referência de objeto diferente.</span><span class="sxs-lookup"><span data-stu-id="58835-1303">The <xref:System.String.Copy%2A> method returns a <xref:System.String> object that has the same value as the original string but represents a different object reference.</span></span> <span data-ttu-id="58835-1304">Ele é diferente de uma operação de atribuição, que atribui uma referência de cadeia de caracteres existente a uma variável de objeto adicionais.</span><span class="sxs-lookup"><span data-stu-id="58835-1304">It differs from an assignment operation, which assigns an existing string reference to an additional object variable.</span></span> <span data-ttu-id="58835-1305">O exemplo ilustra a diferença.</span><span class="sxs-lookup"><span data-stu-id="58835-1305">The example illustrates the difference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1306">O exemplo a seguir cria dois objetos de cadeia de caracteres com valores diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1306">The following example creates two string objects with different values.</span></span> <span data-ttu-id="58835-1307">Quando ele chama o <xref:System.String.Copy%2A> método para atribuir o primeiro valor para a segunda cadeia de caracteres, a saída indica que as cadeias de caracteres representam as referências de objeto diferentes, embora seus valores agora são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1307">When it calls the <xref:System.String.Copy%2A> method to assign the first value to the second string, the output indicates that the strings represent different object references although their values are now equal.</span></span> <span data-ttu-id="58835-1308">Por outro lado, quando a primeira cadeia de caracteres é atribuída à segunda cadeia de caracteres, duas cadeias de caracteres tiverem valores idênticos, porque eles representam a mesma referência de objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-1308">On the other hand, when the first string is assigned to the second string, the two strings have identical values because they represent the same object reference.</span></span>  
  
 [!code-csharp[System.String.Copy#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.copy/cs/copy1.cs#1)]
 [!code-vb[System.String.Copy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.copy/vb/copy1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1309">
            <paramref name="str" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1309">
              <paramref name="str" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (int sourceIndex, char[] destination, int destinationIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(int32 sourceIndex, char[] destination, int32 destinationIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (sourceIndex As Integer, destination As Char(), destinationIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(int sourceIndex, cli::array &lt;char&gt; ^ destination, int destinationIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : int * char[] * int * int -&gt; unit" Usage="string.CopyTo (sourceIndex, destination, destinationIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destination" Type="System.Char[]" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceIndex">
          <span data-ttu-id="58835-1310">O índice do primeiro caractere nessa instância a ser copiada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1310">The index of the first character in this instance to copy.</span>
          </span>
        </param>
        <param name="destination">
          <span data-ttu-id="58835-1311">Uma matriz de caracteres Unicode para a qual caracteres nessa instância são copiados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1311">An array of Unicode characters to which characters in this instance are copied.</span>
          </span>
        </param>
        <param name="destinationIndex">
          <span data-ttu-id="58835-1312">O índice em <c>destination</c> no qual a operação de cópia é iniciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1312">The index in <c>destination</c> at which the copy operation begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-1313">O número de caracteres nesta instância a serem copiados para <c>destination</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1313">The number of characters in this instance to copy to <c>destination</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1314">Copia um número especificado de caracteres de uma posição especificada nesta instância para uma posição especificada em uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1314">Copies a specified number of characters from a specified position in this instance to a specified position in an array of Unicode characters.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1315">Esse método copia `count` caracteres da `sourceIndex` posição dessa instância para o `destinationIndex` posição do `destination` matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1315">This method copies `count` characters from the `sourceIndex` position of this instance to the `destinationIndex` position of `destination` character array.</span></span> <span data-ttu-id="58835-1316">Esse método não redimensiona o `destination` matriz de caracteres; ele deve ter um número suficiente de elementos para acomodar os caracteres copiados ou o método lança um <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="58835-1316">This method does not resize the `destination` character array; it must have a sufficient number of elements to accommodate the copied characters or the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="58835-1317">`sourceIndex` e `destinationIndex` são baseados em zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1317">`sourceIndex` and `destinationIndex` are zero-based.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1318">O exemplo a seguir demonstra o <xref:System.String.CopyTo%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1318">The following example demonstrates the <xref:System.String.CopyTo%2A> method.</span></span>  
  
 [!code-cpp[stringcopyto#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringcopyto/CPP/stringcopyto.cpp#1)]
 [!code-csharp[stringcopyto#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringcopyto/CS/stringcopyto.cs#1)]
 [!code-vb[stringcopyto#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringcopyto/VB/stringcopyto.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1319">
            <paramref name="destination" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1319">
              <paramref name="destination" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1320">
            <paramref name="sourceIndex" />, <paramref name="destinationIndex" /> ou <paramref name="count" /> é negativo -ou- <paramref name="sourceIndex" /> não identifica uma posição na instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1320">
              <paramref name="sourceIndex" />, <paramref name="destinationIndex" />, or <paramref name="count" /> is negative  -or-  <paramref name="sourceIndex" /> does not identify a position in the current instance.</span>
          </span>
          <span data-ttu-id="58835-1321">-ou- <paramref name="destinationIndex" /> não identifica um índice válido na matriz <paramref name="destination" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1321">-or-  <paramref name="destinationIndex" /> does not identify a valid index in the <paramref name="destination" /> array.</span>
          </span>
          <span data-ttu-id="58835-1322">-ou- <paramref name="count" /> é maior que o tamanho da subcadeia de caracteres de <paramref name="sourceIndex" /> até o final dessa instância -ou- <paramref name="count" /> é maior que o tamanho da submatriz de <paramref name="destinationIndex" /> até o final da matriz <paramref name="destination" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1322">-or-  <paramref name="count" /> is greater than the length of the substring from <paramref name="sourceIndex" /> to the end of this instance  -or-  <paramref name="count" /> is greater than the length of the subarray from <paramref name="destinationIndex" /> to the end of the <paramref name="destination" /> array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Create&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static string Create&lt;TState&gt; (int length, TState state, System.Buffers.SpanAction&lt;char,TState&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Create&lt;TState&gt;(int32 length, !!TState state, class System.Buffers.SpanAction`2&lt;char, !!TState&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Create``1(System.Int32,``0,System.Buffers.SpanAction{System.Char,``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create(Of TState) (length As Integer, state As TState, action As SpanAction(Of Char, TState)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static System::String ^ Create(int length, TState state, System::Buffers::SpanAction&lt;char, TState&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member Create : int * 'State * System.Buffers.SpanAction&lt;char, 'State&gt; -&gt; string" Usage="System.string.Create (length, state, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="action" Type="System.Buffers.SpanAction&lt;System.Char,TState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="length">To be added.</param>
        <param name="state">To be added.</param>
        <param name="action">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static readonly string Empty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string Empty" />
      <MemberSignature Language="DocId" Value="F:System.String.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Empty As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ Empty;" />
      <MemberSignature Language="F#" Value=" staticval mutable Empty : string" Usage="System.string.Empty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1323">Representa a cadeia de caracteres vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1323">Represents the empty string.</span>
          </span>
          <span data-ttu-id="58835-1324">Este campo é somente leitura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1324">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1325">O valor desse campo é a cadeia de caracteres de comprimento zero, "".</span><span class="sxs-lookup"><span data-stu-id="58835-1325">The value of this field is the zero-length string, "".</span></span>  
  
 <span data-ttu-id="58835-1326">No código do aplicativo, esse campo é mais comumente usado em atribuições para inicializar uma variável de cadeia de caracteres em uma cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="58835-1326">In application code, this field is most commonly used in assignments to initialize a string variable to an empty string.</span></span> <span data-ttu-id="58835-1327">Para testar se o valor de uma cadeia de caracteres é `null` ou <xref:System.String.Empty?displayProperty=nameWithType>, use o <xref:System.String.IsNullOrEmpty%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1327">To test whether the value of a string is either `null` or <xref:System.String.Empty?displayProperty=nameWithType>, use the <xref:System.String.IsNullOrEmpty%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="EndsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1328">Determina se o fim desta instância de cadeia de caracteres corresponde a uma cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1328">Determines whether the end of this string instance matches a specified string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : char -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string -&gt; bool" Usage="string.EndsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1329">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1329">The string to compare to the substring at the end of this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1330">Determina se o final desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1330">Determines whether the end of this string instance matches the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1331">
            <see langword="true" /> se <paramref name="value" /> corresponder ao final dessa instância; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1331">
              <see langword="true" /> if <paramref name="value" /> matches the end of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1332">Esse método compara `value` à subcadeia de caracteres no final desta instância que é o mesmo tamanho que `value`e retorna uma indicação se eles forem iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1332">This method compares `value` to the substring at the end of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="58835-1333">Para que seja igual, `value` deve ser uma referência a essa mesma instância ou corresponde ao final dessa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-1333">To be equal, `value` must be a reference to this same instance or match the end of this instance.</span></span>  
  
 <span data-ttu-id="58835-1334">Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1334">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1335">O exemplo a seguir indica se cada cadeia de caracteres em uma matriz termina com um ponto (".").</span><span class="sxs-lookup"><span data-stu-id="58835-1335">The following example indicates whether each string in an array ends with a period (".").</span></span>  
  
 [!code-csharp[System.String.EndsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.EndsWith/cs/EndsWith1.cs#1)]
 [!code-vb[System.String.EndsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.EndsWith/vb/EndsWith1.vb#1)]  
  
 <span data-ttu-id="58835-1336">O exemplo a seguir define uma `StripEndTags` método que usa o <xref:System.String.EndsWith%28System.String%29> método para remover as marcas de fim HTML do final de uma linha.</span><span class="sxs-lookup"><span data-stu-id="58835-1336">The following example defines a `StripEndTags` method that uses the <xref:System.String.EndsWith%28System.String%29> method to remove HTML end tags from the end of a line.</span></span> <span data-ttu-id="58835-1337">Observe que o `StripEndTags` método é chamado recursivamente para garantir que as várias marcas de fim HTML no final da linha são removidas.</span><span class="sxs-lookup"><span data-stu-id="58835-1337">Note that the  `StripEndTags` method is called recursively to ensure that multiple HTML end tags at the end of the line are removed.</span></span>  
  
 [!code-cpp[stringendswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringendswith/CPP/stringendswith.cpp#1)]
 [!code-csharp[stringendswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringendswith/CS/stringendswith.cs#1)]
 [!code-vb[stringendswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringendswith/VB/stringendswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1338">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1338">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1339">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para determinar se uma cadeia de caracteres termina com uma subcadeia de caracteres específica usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1339">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To determine whether a string ends with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.EndsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.StartsWith(System.String)" />
        <altmember cref="M:System.String.Compare(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * StringComparison -&gt; bool" Usage="string.EndsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1340">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1340">The string to compare to the substring at the end of this instance.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1341">Um dos valores de enumeração que determina como essa cadeia de caracteres e o <c>valor</c> são comparados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1341">One of the enumeration values that determines how this string and <c>value</c> are compared.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1342">Determina se o fim dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado ao uso da opção de comparação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1342">Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1343">
            <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1343">
              <see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1344">O <xref:System.String.EndsWith%2A> método compara o `value` parâmetro à subcadeia de caracteres no final dessa cadeia de caracteres e retorna um valor que indica se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1344">The <xref:System.String.EndsWith%2A> method compares the `value` parameter to the substring at the end of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="58835-1345">Para que seja igual, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve corresponder ao final dessa cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1345">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the end of this string.</span></span> <span data-ttu-id="58835-1346">O tipo de comparação executada pelo <xref:System.String.EndsWith%2A> método depende do valor da `comparisonType` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-1346">The type of comparison performed by the <xref:System.String.EndsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1347">O exemplo a seguir determina se uma cadeia de caracteres termina com uma subcadeia de caracteres específica.</span><span class="sxs-lookup"><span data-stu-id="58835-1347">The following example determines whether a string ends with a particular substring.</span></span> <span data-ttu-id="58835-1348">Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.</span><span class="sxs-lookup"><span data-stu-id="58835-1348">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span>  
  
 [!code-cpp[System.String.EndsWithCmp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cpp/ewcmp.cpp#1)]
 [!code-csharp[System.String.EndsWithCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.EndsWithCmp/cs/ewcmp.cs#1)]
 [!code-vb[System.String.EndsWithCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.EndsWithCmp/vb/ewcmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1349">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1349">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1350">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1350">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="EndsWith">
      <MemberSignature Language="C#" Value="public bool EndsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool EndsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.EndsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool EndsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.EndsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.EndsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1351">A cadeia de caracteres a ser comparada com a subcadeia de caracteres no final desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1351">The string to compare to the substring at the end of this instance.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-1352">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1352">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-1353">As informações culturais que determinam como essa instância e <c>value</c> são comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1353">Cultural information that determines how this instance and <c>value</c> are compared.</span>
          </span>
          <span data-ttu-id="58835-1354">Se <c>culture</c> for <see langword="null" />, a cultura atual será usada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1354">If <c>culture</c> is <see langword="null" />, the current culture is used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1355">Determina se o final dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1355">Determines whether the end of this string instance matches the specified string when compared using the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1356">
            <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao final dessa cadeia de caracteres; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1356">
              <see langword="true" /> if the <paramref name="value" /> parameter matches the end of this string; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1357">Esse método compara os `value` parâmetro para a subcadeia de caracteres no final dessa cadeia de caracteres que é o mesmo tamanho que `value`e retorna um valor que indica se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-1357">This method compares the `value` parameter to the substring at the end of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="58835-1358">Para que seja igual, `value` deve ser uma referência a essa mesma instância ou corresponde ao final dessa cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1358">To be equal, `value` must be a reference to this same instance or match the end of this string.</span></span>  
  
 <span data-ttu-id="58835-1359">Esse método executa uma comparação de (sensível à cultura) do word usando a cultura e maiusculas e minúsculas especificada.</span><span class="sxs-lookup"><span data-stu-id="58835-1359">This method performs a word (culture-sensitive) comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1360">O exemplo a seguir determina se uma cadeia de caracteres ocorre no final da outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1360">The following example determines whether a string occurs at the end of another string.</span></span> <span data-ttu-id="58835-1361">O <xref:System.String.EndsWith%2A> método é chamado várias vezes com diferenciação de maiusculas e minúsculas e diferentes culturas que influenciam os resultados da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1361">The <xref:System.String.EndsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.EndsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.EndsWithCI/cs/ewci.cs#1)]
 [!code-vb[system.string.EndsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.EndsWithCI/vb/ewci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1362">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1362">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1363">Determina se dois objetos <see cref="T:System.String" /> têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1363">Determines whether two <see cref="T:System.String" /> objects have the same value.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="string.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="58835-1364">A cadeia de caracteres a ser comparada com esta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1364">The string to compare to this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1365">Determina se essa instância e um objeto especificado, que também deve ser um objeto <see cref="T:System.String" />, têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1365">Determines whether this instance and a specified object, which must also be a <see cref="T:System.String" /> object, have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1366">
            <see langword="true" /> se <paramref name="obj" /> for um <see cref="T:System.String" /> e seu valor for o mesmo que o dessa instância; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1366">
              <see langword="true" /> if <paramref name="obj" /> is a <see cref="T:System.String" /> and its value is the same as this instance; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="58835-1367">Se <paramref name="obj" /> for <see langword="null" />, o método retornará <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1367">If <paramref name="obj" /> is <see langword="null" />, the method returns <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1368">Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-1368">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1369">O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1369">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::String ^ value);" />
      <MemberSignature Language="F#" Value="override this.Equals : string -&gt; bool" Usage="string.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1370">A cadeia de caracteres a ser comparada com esta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1370">The string to compare to this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1371">Determina se essa instância e outro objeto <see cref="T:System.String" /> especificado têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1371">Determines whether this instance and another specified <see cref="T:System.String" /> object have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1372">
            <see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual ao valor dessa instância; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1372">
              <see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as the value of this instance; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="58835-1373">Se <paramref name="value" /> for <see langword="null" />, o método retornará <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1373">If <paramref name="value" /> is <see langword="null" />, the method returns <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1374">Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-1374">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1375">O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método. Ele compara a palavra concatenada título "File" com uma palavra equivalente, seu equivalente em minúsculas, seu equivalente em maiusculas e uma palavra que contém LATINO pequeno LETRA i sem PINGO I (U + 0131) em vez de LATINO pequeno LETRA I (u+0069).</span><span class="sxs-lookup"><span data-stu-id="58835-1375">The following example demonstrates the <xref:System.String.Equals%2A> method.It compares the title-cased word "File" with an equivalent word, its lowercase equivalent, its uppercase equivalent, and a word that contains LATIN SMALL LETTER DOTLESS I (U+0131) instead of LATIN SMALL LETTER I (U+0069).</span></span> <span data-ttu-id="58835-1376">Porque o <xref:System.String.Equals%28System.String%29> método executa uma comparação ordinal, somente a comparação com uma palavra idêntica retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="58835-1376">Because the <xref:System.String.Equals%28System.String%29> method performs an ordinal comparison, only the comparison with an identical word returns `true`.</span></span>  
  
 [!code-csharp[System.String.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equalsex1.cs#2)]
 [!code-vb[System.String.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equalsex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string -&gt; bool" Usage="System.string.Equals (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="58835-1377">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1377">The first string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="58835-1378">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1378">The second string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1379">Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1379">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1380">
            <see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1380">
              <see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="58835-1381">Se tanto <paramref name="a" /> quanto <paramref name="b" /> forem <see langword="null" />, o método retornará <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1381">If both <paramref name="a" /> and <paramref name="b" /> are <see langword="null" />, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1382">Este método executa uma comparação ordinal (diferencia maiúsculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-1382">This method performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1383">O exemplo a seguir demonstra o <xref:System.String.Equals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1383">The following example demonstrates the <xref:System.String.Equals%2A> method.</span></span>  
  
 [!code-cpp[string.equals#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.equals/CPP/equals.cpp#1)]
 [!code-csharp[string.equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.equals/CS/equals.cs#1)]
 [!code-vb[string.equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.equals/VB/equals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.Equals : string * StringComparison -&gt; bool" Usage="string.Equals (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1384">A cadeia de caracteres a ser comparada com esta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1384">The string to compare to this instance.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1385">Um dos valores de enumeração que especifica como as cadeias de caracteres serão comparadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1385">One of the enumeration values that specifies how the strings will be compared.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1386">Determina se essa cadeia de caracteres e um objeto <see cref="T:System.String" /> especificado têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1386">Determines whether this string and a specified <see cref="T:System.String" /> object have the same value.</span>
          </span>
          <span data-ttu-id="58835-1387">Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1387">A parameter specifies the culture, case, and sort rules used in the comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1388">
            <see langword="true" /> se o valor do parâmetro <paramref name="value" /> for igual a essa cadeia de caracteres; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1388">
              <see langword="true" /> if the value of the <paramref name="value" /> parameter is the same as this string; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1389">O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso de duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1389">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1390">O exemplo a seguir cria uma matriz de cadeia de caracteres que consiste em letras maiusculas "I", "i" em letras minúsculas e "ı" sem pingo.</span><span class="sxs-lookup"><span data-stu-id="58835-1390">The following example creates a string array that consists of an uppercase "I", a lowercase "i", and a dotless "ı".</span></span> <span data-ttu-id="58835-1391">Em seguida, ele chama o <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> método para compará-los por meio de cada possível <xref:System.StringComparison> valor de enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1391">It then calls the <xref:System.String.Equals%28System.String%2CSystem.StringComparison%29> method to compare them by using each possible <xref:System.StringComparison> enumeration value.</span></span>  
  
 [!code-csharp[System.String.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/eqcmp.cs#1)]
 [!code-vb[System.String.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/eqcmp.vb#1)]  
  
 <span data-ttu-id="58835-1392">O exemplo a seguir compara os quatro conjuntos de palavras por meio de cada membro do <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1392">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="58835-1393">As comparações usam as convenções das culturas Sami (Suécia superior) e inglês (Estados Unidos).</span><span class="sxs-lookup"><span data-stu-id="58835-1393">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="58835-1394">Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalente na cultura en-US, mas não na cultura Sami (Norte Suécia).</span><span class="sxs-lookup"><span data-stu-id="58835-1394">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex4.cs#4)]
 [!code-vb[System.String.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1395">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1395">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (string a, string b, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(string a, string b, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Equals(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (a As String, b As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::String ^ a, System::String ^ b, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="static member Equals : string * string * StringComparison -&gt; bool" Usage="System.string.Equals (a, b, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="58835-1396">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1396">The first string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="58835-1397">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1397">The second string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1398">Um dos valores de enumeração que especifica as regras para a comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1398">One of the enumeration values that specifies the rules for the comparison.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1399">Determina se dois objetos <see cref="T:System.String" /> especificados têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1399">Determines whether two specified <see cref="T:System.String" /> objects have the same value.</span>
          </span>
          <span data-ttu-id="58835-1400">Um parâmetro especifica a cultura, as maiúsculas e minúsculas e as regras de classificação usadas na comparação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1400">A parameter specifies the culture, case, and sort rules used in the comparison.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1401">
            <see langword="true" /> se o valor do parâmetro <paramref name="a" /> for igual ao valor do parâmetro <paramref name="b" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1401">
              <see langword="true" /> if the value of the <paramref name="a" /> parameter is equal to the value of the <paramref name="b" /> parameter; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1402">O `comparisonType` parâmetro indica se a comparação deve usar a cultura atual ou invariável, honrar ou ignorar o caso de duas cadeias de caracteres que estão sendo comparados ou usar o word ou regras de classificação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-1402">The `comparisonType` parameter indicates whether the comparison should use the current or invariant culture, honor or ignore the case of the two strings being compared, or use word or ordinal sort rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1403">O exemplo a seguir compara os quatro conjuntos de palavras por meio de cada membro do <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1403">The following example compares four sets of words by using each member of the <xref:System.StringComparison> enumeration.</span></span>  <span data-ttu-id="58835-1404">As comparações usam as convenções das culturas Sami (Suécia superior) e inglês (Estados Unidos).</span><span class="sxs-lookup"><span data-stu-id="58835-1404">The comparisons use the conventions of the English (United States) and Sami (Upper Sweden) cultures.</span></span> <span data-ttu-id="58835-1405">Observe que as cadeias de caracteres "encyclopædia" e "enciclopédia" são consideradas equivalente na cultura en-US, mas não na cultura Sami (Norte Suécia).</span><span class="sxs-lookup"><span data-stu-id="58835-1405">Note that the strings "encyclopædia" and "encyclopedia" are considered equivalent in the en-US culture but not in the Sami (Northern Sweden) culture.</span></span>  
  
 [!code-csharp[System.String.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.equals/cs/equals_ex3.cs#3)]
 [!code-vb[System.String.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.equals/vb/equals_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1406">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1406">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.CompareOrdinal(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Format">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1407">Converte o valor de objetos em cadeias de caracteres com base nos formatos especificados e os insere em outra cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1407">Converts the value of objects to strings based on the formats specified and inserts them into another string.</span>
          </span>
          <span data-ttu-id="58835-1408">Caso não esteja familiarizado com o método `String.Format`, confira a seção [Introdução ao método String.Format](#Starting) para obter uma visão geral rápida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1408">If you are new to the `String.Format` method, see the [Get started with the String.Format method](#Starting) section for a quick overview.</span>
          </span>
          <span data-ttu-id="58835-1409">Confira a seção [Comentários](#remarks-top) para obter a documentação geral do método `String.Format`.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1409">See the [Remarks](#remarks-top) section for general documentation for the `String.Format` method.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
<a name="remarks-top"></a>   
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
 
 <span data-ttu-id="58835-1410">Nesta seção:</span><span class="sxs-lookup"><span data-stu-id="58835-1410">In this section:</span></span>  
  
 <span data-ttu-id="58835-1411">[Comece com o método String. Format](#Starting) </span><span class="sxs-lookup"><span data-stu-id="58835-1411">[Get started with the String.Format method](#Starting) </span></span>  
 <span data-ttu-id="58835-1412">[Qual método chamar?](#FTaskList) </span><span class="sxs-lookup"><span data-stu-id="58835-1412">[Which method do I call?](#FTaskList) </span></span>  
 <span data-ttu-id="58835-1413">[O método Format resumido](#Format_Brief) </span><span class="sxs-lookup"><span data-stu-id="58835-1413">[The Format method in brief](#Format_Brief) </span></span>  
 <span data-ttu-id="58835-1414">[O item de formato](#FormatItem) </span><span class="sxs-lookup"><span data-stu-id="58835-1414">[The Format item](#FormatItem) </span></span>  
 <span data-ttu-id="58835-1415">[Como os argumentos são formatados](#HowFormatted) </span><span class="sxs-lookup"><span data-stu-id="58835-1415">[How arguments are formatted](#HowFormatted) </span></span>  
 <span data-ttu-id="58835-1416">[Itens de formato que têm o mesmo índice](#SameIndex) </span><span class="sxs-lookup"><span data-stu-id="58835-1416">[Format items that have the same index](#SameIndex) </span></span>  
 <span data-ttu-id="58835-1417">[Formatação e cultura](#Format_Culture) </span><span class="sxs-lookup"><span data-stu-id="58835-1417">[Formatting and culture](#Format_Culture) </span></span>  
 <span data-ttu-id="58835-1418">[Operações de formatação personalizadas](#Format_Custom) </span><span class="sxs-lookup"><span data-stu-id="58835-1418">[Custom formatting operations](#Format_Custom) </span></span>  
 [<span data-ttu-id="58835-1419">String. Format p e r</span><span class="sxs-lookup"><span data-stu-id="58835-1419">String.Format Q & A</span></span>](#QA)  
  
<a name="Starting"></a>   
## <a name="get-started-with-the-stringformat-method"></a><span data-ttu-id="58835-1420">Comece com o método String. Format</span><span class="sxs-lookup"><span data-stu-id="58835-1420">Get started with the String.Format method</span></span>  
 <span data-ttu-id="58835-1421">Use <xref:System.String.Format%2A?displayProperty=nameWithType> se você precisar inserir o valor de um objeto, variável ou expressão em outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1421">Use <xref:System.String.Format%2A?displayProperty=nameWithType> if you need to insert the value of an object, variable, or expression into another string.</span></span> <span data-ttu-id="58835-1422">Por exemplo, você pode inserir o valor de uma <xref:System.Decimal> valor em uma cadeia de caracteres para exibi-lo ao usuário como uma única cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="58835-1422">For example, you can insert the value of a <xref:System.Decimal> value into a string to display it to the user as a single string:</span></span>  
  
 [!code-cpp[System.String.Format#35](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#35)]
 [!code-csharp-interactive[System.String.Format#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#35)]
 [!code-vb[System.String.Format#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#35)]  
  
 <span data-ttu-id="58835-1423">E você pode controlar esse valor de formatação:</span><span class="sxs-lookup"><span data-stu-id="58835-1423">And you can control that value's formatting:</span></span>  
  
 [!code-cpp[System.String.Format#36](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting2.cpp#36)]
 [!code-csharp-interactive[System.String.Format#36](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting2.cs#36)]
 [!code-vb[System.String.Format#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting2.vb#36)]  
  
 <span data-ttu-id="58835-1424">Além de formatação, você também pode controlar espaçamento e alinhamento.</span><span class="sxs-lookup"><span data-stu-id="58835-1424">Besides formatting, you can also control alignment and spacing.</span></span>  
  
 ### <a name="inserting-a-string"></a><span data-ttu-id="58835-1425">Inserindo uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-1425">Inserting a string</span></span>  

 <span data-ttu-id="58835-1426"><xref:System.String.Format%2A?displayProperty=nameWithType> começa com uma cadeia de caracteres de formato, seguida por um ou mais objetos ou expressões que serão convertidas em cadeias de caracteres e inseridas em um local especificado na cadeia de caracteres de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1426"><xref:System.String.Format%2A?displayProperty=nameWithType> starts with a format string, followed by one or more objects or expressions that will be converted to strings and inserted at a specified place in the format string.</span></span> <span data-ttu-id="58835-1427">Por exemplo:</span><span class="sxs-lookup"><span data-stu-id="58835-1427">For example:</span></span>  
  
 [!code-cpp[System.String.Format#30](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#30)]
 [!code-csharp-interactive[System.String.Format#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#30)]
 [!code-vb[System.String.Format#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#30)]  
  
 <span data-ttu-id="58835-1428">O `{0}` no formato de cadeia de caracteres é um item de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1428">The `{0}` in the format string is a format item.</span></span> <span data-ttu-id="58835-1429">`0` é o índice do objeto cujo valor de cadeia de caracteres será inserido nessa posição.</span><span class="sxs-lookup"><span data-stu-id="58835-1429">`0` is the index of the object whose string value will be inserted at that position.</span></span> <span data-ttu-id="58835-1430">(Os índices começam com 0). Se o objeto a ser inserido não é uma cadeia de caracteres, seu `ToString` método é chamado para convertê-lo em um antes de inseri-lo na cadeia de caracteres resultante.</span><span class="sxs-lookup"><span data-stu-id="58835-1430">(Indexes start at 0.) If the object to be inserted is not a string, its `ToString` method is called to convert it to one before inserting it in the result string.</span></span>  
  
 <span data-ttu-id="58835-1431">Aqui está outro exemplo que usa dois itens de formato e dois objetos na lista de objetos:</span><span class="sxs-lookup"><span data-stu-id="58835-1431">Here's another example that uses two format items and two objects in the object list:</span></span>  
  
 [!code-cpp[System.String.Format#31](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#31)]
 [!code-csharp-interactive[System.String.Format#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#31)]
 [!code-vb[System.String.Format#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#31)]  
  
 <span data-ttu-id="58835-1432">Você pode ter quantos itens de formato e a quantidade de objetos na lista de objetos que você deseja, desde que o índice de cada item de formato tem um objeto correspondente na lista de objetos.</span><span class="sxs-lookup"><span data-stu-id="58835-1432">You can have as many format items and as many objects in the object list as you want, as long as the index of every format item has a matching object in the object list.</span></span> <span data-ttu-id="58835-1433">Você também não precisa se preocupar sobre qual sobrecarga você chamar; o compilador irá selecionar aquela que for apropriada para você.</span><span class="sxs-lookup"><span data-stu-id="58835-1433">You also don't have to worry about which overload you call; the compiler will select the appropriate one for you.</span></span>  
  
 ### <a name="controlling-formatting"></a><span data-ttu-id="58835-1434">Controlando a formatação</span><span class="sxs-lookup"><span data-stu-id="58835-1434">Controlling formatting</span></span>  
 <span data-ttu-id="58835-1435">Você pode seguir o índice de um item de formato com uma cadeia de caracteres de formato para controlar como um objeto é formatado.</span><span class="sxs-lookup"><span data-stu-id="58835-1435">You can follow the index in a format item with a format string to control how an object is formatted.</span></span> <span data-ttu-id="58835-1436">Por exemplo, `{0:d}` aplica-se a cadeia de caracteres de formato "d" para o primeiro objeto na lista de objetos.</span><span class="sxs-lookup"><span data-stu-id="58835-1436">For example, `{0:d}` applies the "d" format string to the first object in the object list.</span></span> <span data-ttu-id="58835-1437">Aqui está um exemplo com um único objeto e dois itens de formato:</span><span class="sxs-lookup"><span data-stu-id="58835-1437">Here is an example with a single object and two format items:</span></span>  
  
 [!code-cpp[System.String.Format#32](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#32)]
 [!code-csharp-interactive[System.String.Format#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#32)]
 [!code-vb[System.String.Format#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#32)]  
  
 <span data-ttu-id="58835-1438">Um número de suporte de tipos de formato de cadeias de caracteres, incluindo todos os tipos numéricos (ambos [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md) Formatar cadeias de caracteres), todas as datas e horas (tanto [padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md) Formatar cadeias de caracteres) e intervalos de tempo (ambos [padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md) Formatar cadeias de caracteres), todos os tipos de enumeração [tipos de enumeração ](~/docs/standard/base-types/enumeration-format-strings.md), e [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span><span class="sxs-lookup"><span data-stu-id="58835-1438">A number of types support format strings, including all numeric types (both [standard](~/docs/standard/base-types/standard-numeric-format-strings.md) and [custom](~/docs/standard/base-types/custom-numeric-format-strings.md) format strings), all dates and times (both [standard](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [custom](~/docs/standard/base-types/custom-date-and-time-format-strings.md) format strings) and time intervals (both [standard](~/docs/standard/base-types/standard-timespan-format-strings.md) and [custom](~/docs/standard/base-types/custom-timespan-format-strings.md) format strings), all enumeration types [enumeration types](~/docs/standard/base-types/enumeration-format-strings.md), and [GUIDs](https://msdn.microsoft.com/library/97af8hh4.aspx).</span></span> <span data-ttu-id="58835-1439">Você também pode adicionar suporte para cadeias de caracteres de formato para seus próprios tipos.</span><span class="sxs-lookup"><span data-stu-id="58835-1439">You can also add support for format strings to your own types.</span></span>  
  
 ### <a name="controlling-spacing"></a><span data-ttu-id="58835-1440">Controlar o espaçamento</span><span class="sxs-lookup"><span data-stu-id="58835-1440">Controlling spacing</span></span>  
 <span data-ttu-id="58835-1441">Você pode definir a largura da cadeia de caracteres que é inserida na cadeia de caracteres de resultado usando sintaxe como `{0,12}`, que insere uma cadeia de caracteres de 12 caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1441">You can define the width of the string that is inserted into the result string by using syntax such as `{0,12}`, which inserts a 12-character string.</span></span> <span data-ttu-id="58835-1442">Nesse caso, a representação de cadeia de caracteres do primeiro objeto é alinhado à direita no campo de 12 caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1442">In this case, the string representation of the first object is right-aligned in the 12-character field.</span></span>  <span data-ttu-id="58835-1443">(Se a representação de cadeia de caracteres do primeiro objeto é mais de 12 caracteres de comprimento, no entanto, a largura preferencial do campo será ignorada e a cadeia de caracteres inteira é inserida na cadeia de caracteres de resultado.)</span><span class="sxs-lookup"><span data-stu-id="58835-1443">(If the string representation of the first object is more than 12 characters in length, though, the preferred field width is ignored, and the entire string is inserted into the result string.)</span></span>  
  
 <span data-ttu-id="58835-1444">O exemplo a seguir define um campo de 6 caracteres para conter a cadeia de caracteres "Ano" e algumas cadeias de caracteres do ano, bem como um campo de 15 caracteres para conter a cadeia de caracteres "População" e alguns dados de população.</span><span class="sxs-lookup"><span data-stu-id="58835-1444">The following example defines a 6-character field to hold the string "Year" and some year strings, as well as an 15-character field to hold the string "Population" and some population data.</span></span> <span data-ttu-id="58835-1445">Observe que os caracteres são alinhados à direita no campo.</span><span class="sxs-lookup"><span data-stu-id="58835-1445">Note that the characters are right-aligned in the field.</span></span>  
  
 [!code-cpp[System.String.Format#33](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#33)]
 [!code-csharp-interactive[System.String.Format#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting3.cs)]
 [!code-vb[System.String.Format#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#33)]  
  
 ### <a name="controlling-alignment"></a><span data-ttu-id="58835-1446">Controlar o alinhamento</span><span class="sxs-lookup"><span data-stu-id="58835-1446">Controlling alignment</span></span>  
 <span data-ttu-id="58835-1447">Por padrão, cadeias de caracteres são alinhados à direita em seu campo se você especificar uma largura de campo.</span><span class="sxs-lookup"><span data-stu-id="58835-1447">By default, strings are right-aligned within their field if you specify a field width.</span></span> <span data-ttu-id="58835-1448">Para alinhar à esquerda cadeias de caracteres em um campo, você preceda a largura do campo com um sinal negativo, tais como `{0,-12}` para definir um campo de 12 caracteres alinhada à direita.</span><span class="sxs-lookup"><span data-stu-id="58835-1448">To left-align strings in a field, you preface the field width with a negative sign, such as `{0,-12}` to define a 12-character right-aligned field.</span></span>  
  
 <span data-ttu-id="58835-1449">O exemplo a seguir é semelhante ao anterior, exceto pelo fato de ele alinha à esquerda os rótulos e os dados.</span><span class="sxs-lookup"><span data-stu-id="58835-1449">The following example is similar to the previous one, except that it left-aligns both labels and data.</span></span>  
  
 [!code-cpp[System.String.Format#34](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/starting1.cpp#34)]
 [!code-csharp-interactive[System.String.Format#34](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/starting1.cs#34)]
 [!code-vb[System.String.Format#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/starting1.vb#34)]  
  
 <span data-ttu-id="58835-1450"><xref:System.String.Format%2A?displayProperty=nameWithType> faz uso de recurso de formatação composta.</span><span class="sxs-lookup"><span data-stu-id="58835-1450"><xref:System.String.Format%2A?displayProperty=nameWithType> makes use of the composite formatting feature.</span></span> <span data-ttu-id="58835-1451">Para obter mais informações, veja [Formatação de composição](~/docs/standard/base-types/composite-formatting.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1451">For more information, see [Composite Formatting](~/docs/standard/base-types/composite-formatting.md).</span></span>  
  
<a name="FTaskList"></a>   
## <a name="which-method-do-i-call"></a><span data-ttu-id="58835-1452">Qual método devo chamar?</span><span class="sxs-lookup"><span data-stu-id="58835-1452">Which method do I call?</span></span>  
  
|<span data-ttu-id="58835-1453">Para</span><span class="sxs-lookup"><span data-stu-id="58835-1453">To</span></span>|<span data-ttu-id="58835-1454">Call</span><span class="sxs-lookup"><span data-stu-id="58835-1454">Call</span></span>|  
|--------|----------|  
|<span data-ttu-id="58835-1455">Formate um ou mais objetos usando as convenções da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1455">Format one or more objects by using the conventions of the current culture.</span></span>|<span data-ttu-id="58835-1456">Exceto para as sobrecargas que incluem uma `provider` parâmetro, o restante <xref:System.String.Format%2A> sobrecargas incluem um <xref:System.String> parâmetro seguido por um ou mais parâmetros de objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-1456">Except for the overloads that include a `provider` parameter, the remaining <xref:System.String.Format%2A> overloads include a <xref:System.String> parameter followed by one or more object parameters.</span></span> <span data-ttu-id="58835-1457">Por isso, você não precisa determinar qual <xref:System.String.Format%2A> sobrecarga que você pretende chamar.</span><span class="sxs-lookup"><span data-stu-id="58835-1457">Because of this, you don't have to determine which <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="58835-1458">O compilador de linguagem seleciona a sobrecarga apropriada dentre as sobrecargas que não têm um `provider` parâmetro, com base em sua lista de argumentos.</span><span class="sxs-lookup"><span data-stu-id="58835-1458">Your language compiler selects the appropriate overload from among the overloads that don't have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="58835-1459">Por exemplo, se sua lista de argumentos tiver cinco argumentos, o compilador chama o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1459">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="58835-1460">Formate um ou mais objetos usando as convenções de uma cultura específica.</span><span class="sxs-lookup"><span data-stu-id="58835-1460">Format one or more objects by using the conventions of a specific culture.</span></span>|<span data-ttu-id="58835-1461">Cada <xref:System.String.Format%2A> sobrecarga que começa com um `provider` parâmetro é seguido por um <xref:System.String> parâmetro e um ou mais parâmetros do objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-1461">Each <xref:System.String.Format%2A> overload that begins with a `provider` parameter is followed by a <xref:System.String> parameter and one or more object parameters.</span></span> <span data-ttu-id="58835-1462">Por isso, você não precisa determinar qual específicas <xref:System.String.Format%2A> sobrecarga que você pretende chamar.</span><span class="sxs-lookup"><span data-stu-id="58835-1462">Because of this, you don't have to determine which specific <xref:System.String.Format%2A> overload you intend to call.</span></span> <span data-ttu-id="58835-1463">O compilador de linguagem seleciona a sobrecarga apropriada dentre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos.</span><span class="sxs-lookup"><span data-stu-id="58835-1463">Your language compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span> <span data-ttu-id="58835-1464">Por exemplo, se sua lista de argumentos tiver cinco argumentos, o compilador chama o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1464">For example, if your argument list has five arguments, the compiler calls the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method.</span></span>|  
|<span data-ttu-id="58835-1465">Executar uma operação de formatação personalizada com uma <xref:System.ICustomFormatter> implementação ou um <xref:System.IFormattable> implementação.</span><span class="sxs-lookup"><span data-stu-id="58835-1465">Perform a custom formatting operation either with an <xref:System.ICustomFormatter> implementation or an <xref:System.IFormattable> implementation.</span></span>|<span data-ttu-id="58835-1466">Qualquer um dos quatro sobrecargas com um `provider` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-1466">Any of the four overloads with a `provider` parameter.</span></span> <span data-ttu-id="58835-1467">O compilador seleciona a sobrecarga apropriada dentre as sobrecargas que têm um `provider` parâmetro, com base em sua lista de argumentos.</span><span class="sxs-lookup"><span data-stu-id="58835-1467">The compiler selects the appropriate overload from among the overloads that have a `provider` parameter, based on your argument list.</span></span>|  
  
<a name="Format_Brief"></a>   
## <a name="the-format-method-in-brief"></a><span data-ttu-id="58835-1468">O método Format resumido</span><span class="sxs-lookup"><span data-stu-id="58835-1468">The Format method in brief</span></span> 

 <span data-ttu-id="58835-1469">Cada sobrecarga da <xref:System.String.Format%2A> usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para incluir com base em zero espaços reservados indexados, chamados *formatar itens*, em uma cadeia de caracteres de formato composto.</span><span class="sxs-lookup"><span data-stu-id="58835-1469">Each overload of the <xref:System.String.Format%2A> method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to include zero-based indexed placeholders, called *format items*, in a composite format string.</span></span> <span data-ttu-id="58835-1470">Em tempo de execução, cada item de formato é substituído pela representação de cadeia de caracteres do argumento correspondente em uma lista de parâmetros.</span><span class="sxs-lookup"><span data-stu-id="58835-1470">At run time, each format item is replaced with the string representation of the corresponding argument in a parameter list.</span></span> <span data-ttu-id="58835-1471">Se o valor do argumento for `null`, o item de formato é substituído pelo <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1471">If the value of the argument is `null`, the format item is replaced with <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-1472">Por exemplo, a seguinte chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método inclui uma cadeia de caracteres de formato com três itens de formato {0}, {1}, e {2}e uma lista de argumentos com três itens.</span><span class="sxs-lookup"><span data-stu-id="58835-1472">For example, the following call to the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method includes a format string with three format items, {0}, {1}, and {2}, and an argument list with three items.</span></span>  
  
 [!code-cpp[System.String.Format#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload1.cpp#8)]
 [!code-csharp-interactive[System.String.Format#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload1.cs#8)]
 [!code-vb[System.String.Format#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload1.vb#8)]  
  
<a name="FormatItem"></a>   
## <a name="the-format-item"></a><span data-ttu-id="58835-1473">O item de formato</span><span class="sxs-lookup"><span data-stu-id="58835-1473">The format item</span></span>  
 <span data-ttu-id="58835-1474">Um item de formato tem a seguinte sintaxe:</span><span class="sxs-lookup"><span data-stu-id="58835-1474">A format item has this syntax:</span></span>  
  
```  
{index[,alignment][:formatString]}  
```  
 
 <span data-ttu-id="58835-1475">Colchetes indicam elementos opcionais.</span><span class="sxs-lookup"><span data-stu-id="58835-1475">Brackets denote optional elements.</span></span> <span data-ttu-id="58835-1476">As chaves de abertura e fechamento são necessárias.</span><span class="sxs-lookup"><span data-stu-id="58835-1476">The opening and closing braces are required.</span></span> <span data-ttu-id="58835-1477">(Para incluir uma literal abertura ou fechamento na cadeia de caracteres de formato, consulte o [chaves de escape](~/docs/standard/base-types/composite-formatting.md#escaping-braces) seção o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) artigo.)</span><span class="sxs-lookup"><span data-stu-id="58835-1477">(To include a literal opening or closing brace in the format string, see the [Escaping Braces](~/docs/standard/base-types/composite-formatting.md#escaping-braces) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.)</span></span>  
  
 <span data-ttu-id="58835-1478">Por exemplo, um item de formato para formatar um valor de moeda pode aparecer como este:</span><span class="sxs-lookup"><span data-stu-id="58835-1478">For example, a format item to format a currency value might appear like this:</span></span>  
  
 [!code-cpp[System.String.Format#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatsyntax1.cpp#12)]
 [!code-csharp-interactive[System.String.Format#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatsyntax1.cs#12)]  
 [!code-vb[System.String.Format#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatsyntax1.vb#12)]  

 <span data-ttu-id="58835-1479">Um item de formato tem os seguintes elementos:</span><span class="sxs-lookup"><span data-stu-id="58835-1479">A format item has the following elements:</span></span>  
  
 <span data-ttu-id="58835-1480">*index*</span><span class="sxs-lookup"><span data-stu-id="58835-1480">*index*</span></span>  
 <span data-ttu-id="58835-1481">O índice baseado em zero do argumento cuja representação de cadeia de caracteres deve ser incluído nessa posição na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1481">The zero-based index of the argument whose string representation is to be included at this position in the string.</span></span> <span data-ttu-id="58835-1482">Se esse argumento for `null`, uma cadeia de caracteres vazia será incluída nessa posição na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1482">If this argument is `null`, an empty string will be included at this position in the string.</span></span>  
  
 <span data-ttu-id="58835-1483">*alignment*</span><span class="sxs-lookup"><span data-stu-id="58835-1483">*alignment*</span></span>  
 <span data-ttu-id="58835-1484">Opcional.</span><span class="sxs-lookup"><span data-stu-id="58835-1484">Optional.</span></span> <span data-ttu-id="58835-1485">Um inteiro com sinal que indica o comprimento total do campo em que o argumento é inserido e se ele estiver alinhado à direita (um inteiro positivo) ou alinhado à esquerda (um inteiro negativo).</span><span class="sxs-lookup"><span data-stu-id="58835-1485">A signed integer that indicates the total length of the field into which the argument is inserted and whether it is right-aligned (a positive integer) or left-aligned (a negative integer).</span></span> <span data-ttu-id="58835-1486">Se você omitir *alinhamento*, a representação de cadeia de caracteres do argumento correspondente é inserida em um campo sem espaços à esquerda ou direita.</span><span class="sxs-lookup"><span data-stu-id="58835-1486">If you omit *alignment*, the string representation of the corresponding argument is inserted in a field with no leading or trailing spaces.</span></span>  
  
 <span data-ttu-id="58835-1487">Se o valor de *alinhamento* é menor que o comprimento do argumento a ser inserido, *alinhamento* será ignorado e o comprimento da representação de cadeia de caracteres do argumento é usado como a largura do campo.</span><span class="sxs-lookup"><span data-stu-id="58835-1487">If the value of *alignment* is less than the length of the argument to be inserted, *alignment* is ignored and the length of the string representation of the argument is used as the field width.</span></span>  
  
 <span data-ttu-id="58835-1488">*formatString*</span><span class="sxs-lookup"><span data-stu-id="58835-1488">*formatString*</span></span>  
 <span data-ttu-id="58835-1489">Opcional.</span><span class="sxs-lookup"><span data-stu-id="58835-1489">Optional.</span></span> <span data-ttu-id="58835-1490">Uma cadeia de caracteres que especifica o formato de cadeia de caracteres de resultado do argumento correspondente.</span><span class="sxs-lookup"><span data-stu-id="58835-1490">A string that specifies the format of the corresponding argument's result string.</span></span> <span data-ttu-id="58835-1491">Se você omitir *formatString*, o argumento correspondente sem parâmetros `ToString` método é chamado para produzir sua representação de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1491">If you omit *formatString*, the corresponding argument's parameterless `ToString` method is called to produce its string representation.</span></span> <span data-ttu-id="58835-1492">Se você especificar *formatString*, o argumento referenciado pelo item de formato deve implementar o <xref:System.IFormattable> interface.</span><span class="sxs-lookup"><span data-stu-id="58835-1492">If you specify *formatString*, the argument referenced by the format item must implement the <xref:System.IFormattable> interface.</span></span> <span data-ttu-id="58835-1493">Os tipos que oferecem suporte a cadeias de caracteres de formato incluem:</span><span class="sxs-lookup"><span data-stu-id="58835-1493">Types that support format strings include:</span></span>  
  
-   <span data-ttu-id="58835-1494">Todos os tipos de ponto flutuante e integrais.</span><span class="sxs-lookup"><span data-stu-id="58835-1494">All integral and floating-point types.</span></span> <span data-ttu-id="58835-1495">(Consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="58835-1495">(See [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="58835-1496"><xref:System.DateTime> e <xref:System.DateTimeOffset>.</span><span class="sxs-lookup"><span data-stu-id="58835-1496"><xref:System.DateTime> and <xref:System.DateTimeOffset>.</span></span> <span data-ttu-id="58835-1497">(Consulte [cadeias de caracteres de formato de data e hora padrão](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [cadeias de caracteres de formato de data e hora personalizado](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="58835-1497">(See [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="58835-1498">Todos os tipos de enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1498">All enumeration types.</span></span> <span data-ttu-id="58835-1499">(Consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="58835-1499">(See [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="58835-1500">valores <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="58835-1500"><xref:System.TimeSpan> values.</span></span> <span data-ttu-id="58835-1501">(Consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de caracteres de formato TimeSpan personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="58835-1501">(See [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).)</span></span>  
  
-   <span data-ttu-id="58835-1502">GUIDs.</span><span class="sxs-lookup"><span data-stu-id="58835-1502">GUIDs.</span></span> <span data-ttu-id="58835-1503">(Consulte o <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> método.)</span><span class="sxs-lookup"><span data-stu-id="58835-1503">(See the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> method.)</span></span>  
  
 <span data-ttu-id="58835-1504">No entanto, observe que qualquer tipo personalizado pode implementar <xref:System.IFormattable> ou estender um tipo existente <xref:System.IFormattable> implementação.</span><span class="sxs-lookup"><span data-stu-id="58835-1504">However, note that any custom type can implement <xref:System.IFormattable> or extend an existing type's <xref:System.IFormattable> implementation.</span></span>  
  
 <span data-ttu-id="58835-1505">O exemplo a seguir usa o `alignment` e `formatString` argumentos para produzir saída formatada.</span><span class="sxs-lookup"><span data-stu-id="58835-1505">The following example uses the `alignment` and `formatString` arguments to produce formatted output.</span></span>  
  
 [!code-cpp[System.String.Format#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatoverload2.cpp#9)]
 [!code-csharp-interactive[System.String.Format#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatoverload2.cs#9)]
 [!code-vb[System.String.Format#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatoverload2.vb#9)]  
  
<a name="HowFormatted"></a>   
## <a name="how-arguments-are-formatted"></a><span data-ttu-id="58835-1506">Como os argumentos são formatados</span><span class="sxs-lookup"><span data-stu-id="58835-1506">How arguments are formatted</span></span>  
 <span data-ttu-id="58835-1507">Itens de formato são processados em sequência, desde o início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1507">Format items are processed sequentially from the beginning of the string.</span></span> <span data-ttu-id="58835-1508">Cada item de formato tem um índice que corresponde a um objeto na lista de argumentos do método.</span><span class="sxs-lookup"><span data-stu-id="58835-1508">Each format item has an index that corresponds to an object in the method's argument list.</span></span> <span data-ttu-id="58835-1509">O <xref:System.String.Format%2A> recupera o argumento de método e sua representação de cadeia de caracteres é derivado da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="58835-1509">The <xref:System.String.Format%2A> method retrieves the argument and derives its string representation as follows:</span></span>  
  
-   <span data-ttu-id="58835-1510">Se o argumento for `null`, o método insere <xref:System.String.Empty?displayProperty=nameWithType> na cadeia de caracteres de resultado.</span><span class="sxs-lookup"><span data-stu-id="58835-1510">If the argument is `null`, the method inserts <xref:System.String.Empty?displayProperty=nameWithType> into the result string.</span></span> <span data-ttu-id="58835-1511">Você não precisa se preocupar com a manipulação de um <xref:System.NullReferenceException> para argumentos nulos.</span><span class="sxs-lookup"><span data-stu-id="58835-1511">You don't have to be concerned with handling a <xref:System.NullReferenceException> for null arguments.</span></span> 
  
-   <span data-ttu-id="58835-1512">Se você chamar o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> sobrecarga e a `provider` do objeto <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementação retorna não nulo <xref:System.ICustomFormatter> implementação, o argumento é passado para sua <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1512">If you call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> overload and the `provider` object's <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation returns a non-null <xref:System.ICustomFormatter> implementation, the argument is passed to its <xref:System.ICustomFormatter.Format%28System.String%2CSystem.Object%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-1513">Se o item de formato inclui um *formatString* argumento, ele é passado como o primeiro argumento para o método.</span><span class="sxs-lookup"><span data-stu-id="58835-1513">If the format item includes a *formatString* argument, it is passed as the first argument to the method.</span></span> <span data-ttu-id="58835-1514">Se o <xref:System.ICustomFormatter> implementação está disponível e produz uma cadeia de caracteres não-nulo, cadeia de caracteres é retornada como a representação de cadeia de caracteres do argumento; caso contrário, a próxima etapa é executada.</span><span class="sxs-lookup"><span data-stu-id="58835-1514">If the <xref:System.ICustomFormatter> implementation is available and produces a non-null string, that string is returned as the string representation of the argument; otherwise, the next step executes.</span></span>  
  
-   <span data-ttu-id="58835-1515">Se o argumento implementa o <xref:System.IFormattable> interface, seu <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementação é chamada.</span><span class="sxs-lookup"><span data-stu-id="58835-1515">If the argument implements the <xref:System.IFormattable> interface, its <xref:System.IFormattable.ToString%2A?displayProperty=nameWithType> implementation is called.</span></span>  
  
-   <span data-ttu-id="58835-1516">O argumento sem parâmetros `ToString` método, que substitui ou herda de uma implementação da classe base, é chamado.</span><span class="sxs-lookup"><span data-stu-id="58835-1516">The argument's parameterless `ToString` method, which either overrides or inherits from a base class implementation, is called.</span></span>  
  
 <span data-ttu-id="58835-1517">Para obter um exemplo que intercepta as chamadas para o <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> método e permite que você veja quais informações o <xref:System.String.Format%2A> passes de método para um método de formatação para cada item de formato em uma cadeia de caracteres de formato de composição, consulte [exemplo: um provedor de interceptação e Formatador de algarismo romano](#Format7_Example).</span><span class="sxs-lookup"><span data-stu-id="58835-1517">For an example that intercepts calls to the <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> method and allows you to see what information the <xref:System.String.Format%2A> method passes to a formatting method for each format item in a composite format string, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  

 <span data-ttu-id="58835-1518">Para obter mais informações, consulte o [ordem de processamento](~/docs/standard/base-types/composite-formatting.md##processing-order) seção o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) artigo.</span><span class="sxs-lookup"><span data-stu-id="58835-1518">For more information, see the [Processing Order](~/docs/standard/base-types/composite-formatting.md##processing-order) section in the [Composite Formatting](~/docs/standard/base-types/composite-formatting.md) article.</span></span>  
  
<a name="SameIndex"></a>   
## <a name="format-items-that-have-the-same-index"></a><span data-ttu-id="58835-1519">Itens de formato que têm o mesmo índice</span><span class="sxs-lookup"><span data-stu-id="58835-1519">Format items that have the same index</span></span>  
 <span data-ttu-id="58835-1520">O <xref:System.String.Format%2A> método lança um <xref:System.FormatException> exceção se o índice de um item do índice é maior que ou igual ao número de argumentos na lista de argumentos.</span><span class="sxs-lookup"><span data-stu-id="58835-1520">The <xref:System.String.Format%2A> method throws a <xref:System.FormatException> exception if the index of an index item is greater than or equal to the number of arguments in the argument list.</span></span> <span data-ttu-id="58835-1521">No entanto, `format` pode incluir mais itens de formato que o número de argumentos, desde que vários itens de formato têm o mesmo índice.</span><span class="sxs-lookup"><span data-stu-id="58835-1521">However, `format` can include more format items than there are arguments, as long as multiple format items have the same index.</span></span> <span data-ttu-id="58835-1522">Na chamada para o <xref:System.String.Format%28System.String%2CSystem.Object%29> método no exemplo a seguir, a lista de argumentos tem um único argumento, mas a cadeia de caracteres de formato inclui dois itens de formato: um exibe o valor decimal de um número e o outro exibe seu valor hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="58835-1522">In the call to the <xref:System.String.Format%28System.String%2CSystem.Object%29> method in following example, the argument list has a single argument, but the format string includes two format items: one displays the decimal value of a number, and the other displays its hexadecimal value.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example1.cs#1)]
 [!code-vb[System.String.Format2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example1.vb#1)]  
  
<a name="Format_Culture"></a>   
## <a name="formatting-and-culture"></a><span data-ttu-id="58835-1523">Formatação e cultura</span><span class="sxs-lookup"><span data-stu-id="58835-1523">Formatting and culture</span></span>  
 <span data-ttu-id="58835-1524">Em geral, os objetos na lista de argumentos são convertidos em suas representações de cadeia de caracteres usando as convenções da cultura atual, que é retornado pelo <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propriedade.</span><span class="sxs-lookup"><span data-stu-id="58835-1524">Generally, objects in the argument list are converted to their string representations by using the conventions of the current culture, which is returned by the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="58835-1525">Você pode controlar esse comportamento, chamando uma das sobrecargas de <xref:System.String.Format%2A> que inclui um `provider` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-1525">You can control this behavior by calling one of the overloads of <xref:System.String.Format%2A> that includes a `provider` parameter.</span></span> <span data-ttu-id="58835-1526">O `provider` parâmetro é um <xref:System.IFormatProvider> o processo de implementação que fornece informações de formatação específicas da cultura e personalizadas que são usadas para moderar a formatação.</span><span class="sxs-lookup"><span data-stu-id="58835-1526">The `provider` parameter is an <xref:System.IFormatProvider> implementation that supplies custom and culture-specific formatting information that is used to moderate the formatting process.</span></span>  
  
 <span data-ttu-id="58835-1527">O <xref:System.IFormatProvider> interface tem um único membro, <xref:System.IFormatProvider.GetFormat%2A>, que é responsável por retornar o objeto que fornece informações de formatação.</span><span class="sxs-lookup"><span data-stu-id="58835-1527">The <xref:System.IFormatProvider> interface has a single member, <xref:System.IFormatProvider.GetFormat%2A>, which is responsible for returning the object that provides formatting information.</span></span> <span data-ttu-id="58835-1528">O .NET Framework tem três <xref:System.IFormatProvider> implementações que fornecem a formatação de cultura específica:</span><span class="sxs-lookup"><span data-stu-id="58835-1528">The .NET Framework has three <xref:System.IFormatProvider> implementations that provide culture-specific formatting:</span></span>  
  
-   <span data-ttu-id="58835-1529"><xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="58835-1529"><xref:System.Globalization.CultureInfo>.</span></span> <span data-ttu-id="58835-1530">Sua <xref:System.Globalization.CultureInfo.GetFormat%2A> método retorna uma cultura específica <xref:System.Globalization.NumberFormatInfo> objeto para a formatação de valores numéricos e uma cultura específica <xref:System.Globalization.DateTimeFormatInfo> objeto para a formatação de valores de data e hora.</span><span class="sxs-lookup"><span data-stu-id="58835-1530">Its <xref:System.Globalization.CultureInfo.GetFormat%2A> method returns a culture-specific <xref:System.Globalization.NumberFormatInfo> object for formatting numeric values and a culture-specific <xref:System.Globalization.DateTimeFormatInfo> object for formatting date and time values.</span></span>  
  
-   <span data-ttu-id="58835-1531"><xref:System.Globalization.DateTimeFormatInfo>, que é usado para formatação de cultura específica de valores de data e hora.</span><span class="sxs-lookup"><span data-stu-id="58835-1531"><xref:System.Globalization.DateTimeFormatInfo>, which is used for culture-specific formatting of date and time values.</span></span> <span data-ttu-id="58835-1532">Seu <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> método retorna ele próprio.</span><span class="sxs-lookup"><span data-stu-id="58835-1532">Its <xref:System.Globalization.DateTimeFormatInfo.GetFormat%2A> method returns itself.</span></span>  
  
-   <span data-ttu-id="58835-1533"><xref:System.Globalization.NumberFormatInfo>, que é usado para formatação de cultura específica de valores numéricos.</span><span class="sxs-lookup"><span data-stu-id="58835-1533"><xref:System.Globalization.NumberFormatInfo>, which is used for culture-specific formatting of numeric values.</span></span> <span data-ttu-id="58835-1534">Seu <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> propriedade retorna ele próprio.</span><span class="sxs-lookup"><span data-stu-id="58835-1534">Its <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> property returns itself.</span></span> 

<a name="Format_Custom"></a>   
## <a name="custom-formatting-operations"></a><span data-ttu-id="58835-1535">Operações de formatação personalizadas</span><span class="sxs-lookup"><span data-stu-id="58835-1535">Custom formatting operations</span></span>  
 <span data-ttu-id="58835-1536">Você também pode chamar qualquer uma das sobrecargas do <xref:System.String.Format%2A> método que tem um `provider` parâmetro do tipo <xref:System.IFormatProvider> para executar operações de formatação personalizadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1536">You can also call the any of the overloads of the <xref:System.String.Format%2A> method that have a `provider` parameter of type <xref:System.IFormatProvider> to perform custom formatting operations.</span></span> <span data-ttu-id="58835-1537">Por exemplo, você pode formatar um número inteiro como um número de identificação ou como um número de telefone.</span><span class="sxs-lookup"><span data-stu-id="58835-1537">For example, you could format an integer as an identification number or as a telephone number.</span></span> <span data-ttu-id="58835-1538">Para executar a formatação personalizada, sua `provider` argumento deve implementar ambas as <xref:System.IFormatProvider> e <xref:System.ICustomFormatter> interfaces.</span><span class="sxs-lookup"><span data-stu-id="58835-1538">To perform custom formatting, your `provider` argument must implement both the <xref:System.IFormatProvider> and <xref:System.ICustomFormatter> interfaces.</span></span> <span data-ttu-id="58835-1539">Quando o <xref:System.String.Format%2A> método recebe um <xref:System.ICustomFormatter> implementação como o `provider` argumento, o <xref:System.String.Format%2A> chamadas de método seu <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementação e solicita um objeto do tipo <xref:System.ICustomFormatter>.</span><span class="sxs-lookup"><span data-stu-id="58835-1539">When the <xref:System.String.Format%2A> method is passed an <xref:System.ICustomFormatter> implementation as the `provider` argument, the <xref:System.String.Format%2A> method calls its   <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> implementation and requests an object of type <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="58835-1540">Em seguida, chama retornado <xref:System.ICustomFormatter> do objeto <xref:System.ICustomFormatter.Format%2A> método para cada item de formato na cadeia de caracteres composta de formato passado para ele.</span><span class="sxs-lookup"><span data-stu-id="58835-1540">It then calls the returned <xref:System.ICustomFormatter> object's <xref:System.ICustomFormatter.Format%2A> method to format each format item in the composite string passed to it.</span></span>  
  
 <span data-ttu-id="58835-1541">Para obter mais informações sobre como fornecer soluções personalizadas de formatação, consulte [como: definir e usar provedores de formato de numérico personalizado](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) e <xref:System.ICustomFormatter>.</span><span class="sxs-lookup"><span data-stu-id="58835-1541">For more information about providing custom formatting solutions, see [How to: Define and Use Custom Numeric Format Providers](~/docs/standard/base-types/how-to-define-and-use-custom-numeric-format-providers.md) and <xref:System.ICustomFormatter>.</span></span> <span data-ttu-id="58835-1542">Para obter um exemplo que converte números inteiros em números formatados de personalizado, consulte [exemplo: uma operação de formatação personalizada](#Format6_Example).</span><span class="sxs-lookup"><span data-stu-id="58835-1542">For an example that converts integers to formatted custom numbers, see [Example: A custom formatting operation](#Format6_Example).</span></span> <span data-ttu-id="58835-1543">Para obter um exemplo que converte bytes sem sinal em numerais romanos, consulte [exemplo: um provedor de interceptação e formatador de algarismo romano](#Format7_Example).</span><span class="sxs-lookup"><span data-stu-id="58835-1543">For an example that converts unsigned bytes to Roman numerals, see [Example: An intercept provider and Roman numeral formatter](#Format7_Example).</span></span>  
  
<a name="Format6_Example" />  
### <a name="example-a-custom-formatting-operation"></a><span data-ttu-id="58835-1544">Exemplo: Uma operação de formatação personalizada</span><span class="sxs-lookup"><span data-stu-id="58835-1544">Example: A custom formatting operation</span></span>  
 <span data-ttu-id="58835-1545">Este exemplo define um provedor de formato que formata um valor inteiro como um número de conta do cliente no formato x-xxxxx-xx.</span><span class="sxs-lookup"><span data-stu-id="58835-1545">This example defines a format provider that formats an integer value as a customer account number in the form x-xxxxx-xx.</span></span>  
  
 [!code-cpp[System.String.Format#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample2.cpp#2)]
 [!code-csharp-interactive[System.String.Format#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/FormatExample2.cs#2)]
 [!code-vb[System.String.Format#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/FormatExample2.vb#2)]  
  
<a name="Format7_Example" />  
### <a name="example-an-intercept-provider-and-roman-numeral-formatter"></a><span data-ttu-id="58835-1546">Exemplo: Um provedor de interceptação e formatador de algarismo romano</span><span class="sxs-lookup"><span data-stu-id="58835-1546">Example: An intercept provider and Roman numeral formatter</span></span>  
 <span data-ttu-id="58835-1547">Este exemplo define um provedor de formato personalizado que implementa o <xref:System.ICustomFormatter> e <xref:System.IFormatProvider> interfaces fazer duas coisas:</span><span class="sxs-lookup"><span data-stu-id="58835-1547">This example defines a custom format provider that implements the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces to do two things:</span></span>  
  
-   <span data-ttu-id="58835-1548">Ele exibe os parâmetros passados para seus <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementação.</span><span class="sxs-lookup"><span data-stu-id="58835-1548">It displays the parameters passed to its <xref:System.ICustomFormatter.Format%2A?displayProperty=nameWithType> implementation.</span></span> <span data-ttu-id="58835-1549">Isso nos permite ver quais parâmetros a <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método está passando para a implementação de formatação personalizada para cada objeto que ele tenta formatar.</span><span class="sxs-lookup"><span data-stu-id="58835-1549">This enables us to see what parameters the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is passing to the custom formatting implementation for each object that it tries to format.</span></span> <span data-ttu-id="58835-1550">Isso pode ser útil quando você estiver depurando seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1550">This can be useful when you're debugging your application.</span></span>  
  
-   <span data-ttu-id="58835-1551">Se o objeto a ser formatado for um valor de byte sem sinal que deve ser formatada usando a cadeia de caracteres de formato padrão "R", o formatador personalizado formata o valor numérico como um numeral romano.</span><span class="sxs-lookup"><span data-stu-id="58835-1551">If the object to be formatted is an unsigned byte value that is to be formatted by using the "R" standard format string, the custom formatter formats the numeric value as a Roman numeral.</span></span>  
  
 [!code-cpp[System.String.Format#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/interceptor2.cpp#11)]
 [!code-csharp-interactive[System.String.Format#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/interceptor2.cs#11)]
 [!code-vb[System.String.Format#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/interceptor2.vb#11)]  
  
<a name="QA"></a>   
## <a name="stringformat-q--a"></a><span data-ttu-id="58835-1552">String. Format p e r</span><span class="sxs-lookup"><span data-stu-id="58835-1552">String.Format Q & A</span></span>  
  
### <a name="why-do-you-recommend-string-interpolation-over-calls-to-the-stringformat-method"></a><span data-ttu-id="58835-1553">Por que você recomenda interpolação de cadeia de caracteres em chamadas para o `String.Format` método?</span><span class="sxs-lookup"><span data-stu-id="58835-1553">Why do you recommend string interpolation over calls to the `String.Format` method?</span></span>

<span data-ttu-id="58835-1554">Interpolação de cadeia de caracteres é:</span><span class="sxs-lookup"><span data-stu-id="58835-1554">String interpolation is:</span></span>

- <span data-ttu-id="58835-1555">Mais flexível.</span><span class="sxs-lookup"><span data-stu-id="58835-1555">More flexible.</span></span> <span data-ttu-id="58835-1556">Ele pode ser usado em qualquer cadeia de caracteres sem a necessidade de uma chamada para um método que dá suporte à formatação de composição.</span><span class="sxs-lookup"><span data-stu-id="58835-1556">It can be used in any string without requiring a call to a method that supports composite formatting.</span></span> <span data-ttu-id="58835-1557">Caso contrário, você precisará chamar o <xref:System.String.Format%2A> método ou outro método que oferece suporte a formatação de composição, como <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> ou <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1557">Otherwise, you have to call the <xref:System.String.Format%2A> method or another method that supports composite formatting, such as <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Text.StringBuilder.AppendFormat%2A?displayProperty=nameWithType>.</span></span> 

- <span data-ttu-id="58835-1558">Mais legível.</span><span class="sxs-lookup"><span data-stu-id="58835-1558">More readable.</span></span> <span data-ttu-id="58835-1559">Como a expressão a ser inserido em uma cadeia de caracteres aparece na expressão interpolada em vez de em uma lista de argumentos, cadeias de caracteres interpoladas são muito mais fácil para o código e ler.</span><span class="sxs-lookup"><span data-stu-id="58835-1559">Because the expression to insert into a string appears in the interpolated expression rather than in a argument list, interpolated strings are far easier to code and to read.</span></span> <span data-ttu-id="58835-1560">Devido a sua maior legibilidade, cadeias de caracteres interpoladas podem substituir não apenas as chamadas para métodos de formato composto, mas eles também podem ser usados em operações de concatenação de cadeia de caracteres para produzir um código mais conciso e mais claro.</span><span class="sxs-lookup"><span data-stu-id="58835-1560">Because of their greater readability, interpolated strings can replace not only calls to composite format methods, but they can also be used in string concatenation operations to produce more concise, clearer code.</span></span> 

<span data-ttu-id="58835-1561">Uma comparação dos seguintes exemplos de código ilustra a superioridade do cadeias de caracteres interpoladas ao longo de concatenação de cadeia de caracteres e chamadas para métodos de formatação de composição.</span><span class="sxs-lookup"><span data-stu-id="58835-1561">A comparison of the following two code examples illustrates the superiority of interpolated strings over string concatenation and calls to composite formatting methods.</span></span> <span data-ttu-id="58835-1562">O uso de várias operações de concatenação de cadeia de caracteres no exemplo a seguir produz código detalhado e difícil de ler.</span><span class="sxs-lookup"><span data-stu-id="58835-1562">The use of multiple string concatenation operations in the following example produces verbose and hard-to-read code.</span></span>

[!code-csharp-interactive[non-interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated1.cs)]
[!code-vb[non-interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated1.vb)]  

<span data-ttu-id="58835-1563">Em contraste, o uso de cadeias de caracteres interpoladas no exemplo a seguir produz código mais conciso e bem mais claro que a instrução de concatenação de cadeia de caracteres e a chamada para o <xref:System.String.Format%2A> método no exemplo anterior.</span><span class="sxs-lookup"><span data-stu-id="58835-1563">In contrast, the use of interpolated strings in the following example produce much clearer, more concise code than the string concatenation statement and the call to the <xref:System.String.Format%2A> method in the previous example.</span></span>

[!code-csharp-interactive[interpolated string operations](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa-interpolated2.cs)]
[!code-vb[interpolated string operations](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa-interpolated2.vb)]  

### <a name="where-can-i-find-a-list-of-the-predefined-format-strings-that-can-be-used-with-format-items"></a><span data-ttu-id="58835-1564">Onde posso encontrar uma lista de cadeias de caracteres de formato predefinido que pode ser usado com itens de formato?</span><span class="sxs-lookup"><span data-stu-id="58835-1564">Where can I find a list of the predefined format strings that can be used with format items?</span></span>  
  
-   <span data-ttu-id="58835-1565">Para todos os tipos de ponto flutuante e integrais, consulte [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) e [às cadeias de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1565">For all integral and floating-point types, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="58835-1566">Para obter valores de data e hora, consulte [padrão de data e cadeias de caracteres de formato de hora](~/docs/standard/base-types/standard-date-and-time-format-strings.md) e [Data personalizada e cadeias de caracteres de formato de hora](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1566">For date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
-   <span data-ttu-id="58835-1567">Para obter valores de enumeração, consulte [cadeias de caracteres de formato de enumeração](~/docs/standard/base-types/enumeration-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1567">For enumeration values, see [Enumeration Format Strings](~/docs/standard/base-types/enumeration-format-strings.md).</span></span>  
  
-   <span data-ttu-id="58835-1568">Para <xref:System.TimeSpan> valores, consulte [cadeias de caracteres de formato TimeSpan padrão](~/docs/standard/base-types/standard-timespan-format-strings.md) e [cadeias de caracteres de formato de intervalo de tempo personalizado](~/docs/standard/base-types/custom-timespan-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1568">For <xref:System.TimeSpan> values, see  [Standard TimeSpan Format Strings](~/docs/standard/base-types/standard-timespan-format-strings.md) and [Custom TimeSpan Format Strings](~/docs/standard/base-types/custom-timespan-format-strings.md).</span></span>  
  
-   <span data-ttu-id="58835-1569">Para <xref:System.Guid> valores, consulte a seção de comentários do <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> página de referência.</span><span class="sxs-lookup"><span data-stu-id="58835-1569">For <xref:System.Guid> values, see the Remarks section of the <xref:System.Guid.ToString%28System.String%29?displayProperty=nameWithType> reference page.</span></span>  
  
### <a name="how-do-i-control-the-alignment-of-the-result-strings-that-replace-format-items"></a><span data-ttu-id="58835-1570">Como controlar o alinhamento das cadeias de caracteres resultado substituir itens de formato?</span><span class="sxs-lookup"><span data-stu-id="58835-1570">How do I control the alignment of the result strings that replace format items?</span></span>  
 <span data-ttu-id="58835-1571">A sintaxe geral de um item de formato é:</span><span class="sxs-lookup"><span data-stu-id="58835-1571">The general syntax of a format item is:</span></span>  
  
```  
{index[,alignment][: formatString]}  
```  
  
 <span data-ttu-id="58835-1572">em que *alinhamento* é um inteiro com sinal que define a largura do campo.</span><span class="sxs-lookup"><span data-stu-id="58835-1572">where *alignment* is a signed integer that defines the field width.</span></span> <span data-ttu-id="58835-1573">Se esse valor for negativo, o texto do campo é alinhado à esquerda.</span><span class="sxs-lookup"><span data-stu-id="58835-1573">If this value is negative, text in the field is left-aligned.</span></span> <span data-ttu-id="58835-1574">Se ele for positivo, o texto é alinhado à direita.</span><span class="sxs-lookup"><span data-stu-id="58835-1574">If it is positive, text is right-aligned.</span></span>  
  
### <a name="how-do-i-control-the-number-of-digits-after-the-decimal-separator"></a><span data-ttu-id="58835-1575">Como controlar o número de dígitos após o separador decimal?</span><span class="sxs-lookup"><span data-stu-id="58835-1575">How do I control the number of digits after the decimal separator?</span></span>  
 <span data-ttu-id="58835-1576">Todos os [cadeias de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) exceto "D" (que é usado com apenas números inteiros), "G", "R" e "X" permitir que um especificador de precisão que define o número de dígitos decimais na cadeia de caracteres de resultado.</span><span class="sxs-lookup"><span data-stu-id="58835-1576">All [standard numeric format strings](~/docs/standard/base-types/standard-numeric-format-strings.md) except "D" (which is used with integers only), "G", "R", and "X" allow a precision specifier that defines the number of decimal digits in the result string.</span></span> <span data-ttu-id="58835-1577">O exemplo a seguir usa cadeias de caracteres de formato numérico padrão para controlar o número de dígitos decimais na cadeia de caracteres de resultado.</span><span class="sxs-lookup"><span data-stu-id="58835-1577">The following example uses standard numeric format strings to control the number of decimal digits in the result string.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa26.cs#26)]
 [!code-vb[System.String.Format#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa26.vb#26)]  
  
 <span data-ttu-id="58835-1578">Se você estiver usando um [cadeia de caracteres de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), use o especificador de formato "0" para controlar o número de dígitos decimais na cadeia de caracteres resultante, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-1578">If you're using a [custom numeric format string](~/docs/standard/base-types/custom-numeric-format-strings.md), use the "0" format specifier to control the number of decimal digits in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa27.cs#27)]
 [!code-vb[System.String.Format#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa27.vb#27)]  
  
### <a name="how-do-i-control-the-number-of-integral-digits"></a><span data-ttu-id="58835-1579">Como controlar o número de dígitos integrais?</span><span class="sxs-lookup"><span data-stu-id="58835-1579">How do I control the number of integral digits?</span></span>  
 <span data-ttu-id="58835-1580">Por padrão, operações de formatação exibem somente os dígitos integrais de diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1580">By default, formatting operations only display non-zero integral digits.</span></span> <span data-ttu-id="58835-1581">Se você estiver formatando números inteiros, você pode usar um especificador de precisão com "D" e "X" cadeias de caracteres de formato padrão para controlar o número de dígitos.</span><span class="sxs-lookup"><span data-stu-id="58835-1581">If you are formatting integers, you can use a precision specifier with the "D" and "X" standard format strings to control the number of digits.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa29.cs#29)]
 [!code-vb[System.String.Format#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa29.vb#29)]  
  
 <span data-ttu-id="58835-1582">Você pode preencher um inteiro ou um número de ponto flutuante com zeros à esquerda para produzir uma cadeia de caracteres de resultado com um número especificado de dígitos integrais usando o "0" [especificador de formato numérico personalizado](~/docs/standard/base-types/custom-numeric-format-strings.md), como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-1582">You can pad an integer or floating-point number with leading zeros to produce a result string with a specified number of integral digits by using the "0" [custom numeric format specifier](~/docs/standard/base-types/custom-numeric-format-strings.md), as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa28.cs#28)]
 [!code-vb[System.String.Format#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa28.vb#28)]  
  
### <a name="how-many-items-can-i-include-in-the-format-list"></a><span data-ttu-id="58835-1583">Quantos itens podem incluir na lista formato?</span><span class="sxs-lookup"><span data-stu-id="58835-1583">How many items can I include in the format list?</span></span>  
 <span data-ttu-id="58835-1584">Não há nenhum limite prático.</span><span class="sxs-lookup"><span data-stu-id="58835-1584">There is no practical limit.</span></span> <span data-ttu-id="58835-1585">O segundo parâmetro do <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método é marcado com o <xref:System.ParamArrayAttribute> atributo, que permite que você inclua uma lista delimitada por ponto ou uma matriz de objetos como sua lista de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1585">The second parameter of the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method is tagged with the <xref:System.ParamArrayAttribute> attribute, which allows you to include either a delimited list or an object array as your format list.</span></span>  
  
<a name="braces" />
### <a name="how-do-i-include-literal-braces--and--in-the-result-string"></a><span data-ttu-id="58835-1586">Como incluir a chaves literais ("{" e "}") na cadeia de caracteres de resultado?</span><span class="sxs-lookup"><span data-stu-id="58835-1586">How do I include literal braces ("{" and "}") in the result string?</span></span>  
 <span data-ttu-id="58835-1587">Por exemplo, como evitar a seguinte chamada de método, gere um <xref:System.FormatException> exceção?</span><span class="sxs-lookup"><span data-stu-id="58835-1587">For example, how do you prevent the following method call from throwing a <xref:System.FormatException> exception?</span></span>  
  
 [!code-csharp[System.String.Format#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#23)]
 [!code-vb[System.String.Format#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#23)]  
  
 <span data-ttu-id="58835-1588">Um simples de abertura ou fechamento é sempre interpretado como o início ou final de um item de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1588">A single opening or closing brace is always interpreted as the beginning or end of a format item.</span></span> <span data-ttu-id="58835-1589">Para ser interpretado literalmente, ela deverá ser substituída.</span><span class="sxs-lookup"><span data-stu-id="58835-1589">To be interpreted literally, it must be escaped.</span></span> <span data-ttu-id="58835-1590">Você fazer o escape de uma chave com a adição de outra chave ("{{" e "}}" em vez de "{" e "}"), conforme mostrado no seguinte chamada de método:</span><span class="sxs-lookup"><span data-stu-id="58835-1590">You escape a brace by adding another brace ("{{" and "}}" instead of "{" and "}"), as in the following method call:</span></span>  
  
 [!code-csharp-interactive[System.String.Format#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#24)]
 [!code-vb[System.String.Format#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#24)]  
  
 <span data-ttu-id="58835-1591">No entanto, as chaves de escape ainda são facilmente mal interpretadas.</span><span class="sxs-lookup"><span data-stu-id="58835-1591">However, even escaped braces are easily misinterpreted.</span></span> <span data-ttu-id="58835-1592">É recomendável que você inclua chaves na lista de formato e usa itens de formato para inseri-los na cadeia de caracteres de resultado, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-1592">We recommend that you include braces in the format list and use format items to insert them in the result string, as the following example shows.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa3.cs#25)]
 [!code-vb[System.String.Format#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa3.vb#25)]  
  
### <a name="why-does-my-call-to-the-stringformat-method-throw-a-formatexception"></a><span data-ttu-id="58835-1593">Por que minha chamada ao método String. Format lança uma FormatException?</span><span class="sxs-lookup"><span data-stu-id="58835-1593">Why does my call to the String.Format method throw a FormatException?</span></span>  
 <span data-ttu-id="58835-1594">A causa mais comum da exceção é que o índice de um item de formato não corresponde a um objeto na lista de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1594">The most common cause of the exception is that the index of a format item doesn't correspond to an object in the format list.</span></span> <span data-ttu-id="58835-1595">Normalmente, isso indica que você já misnumbered os índices dos itens de formato ou você esqueceu de incluir um objeto na lista de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1595">Usually this indicates that you've misnumbered the indexes of format items or you've forgotten to include an object in the format list.</span></span> <span data-ttu-id="58835-1596">A tentativa de incluir uma chave esquerda ou direita sem escape caractere também gera um <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="58835-1596">Attempting to include an unescaped left or right brace character also throws a <xref:System.FormatException>.</span></span> <span data-ttu-id="58835-1597">Ocasionalmente, a exceção é o resultado de um erro de digitação; Por exemplo, um erro típico é incorretamente "[" (o colchete esquerdo), em vez de "{" (a chave à esquerda).</span><span class="sxs-lookup"><span data-stu-id="58835-1597">Occasionally, the exception is the result of a typo; for example, a typical mistake is to mistype "[" (the left bracket) instead of "{" (the left brace).</span></span>  
  
### <a name="if-the-formatsystemiformatprovidersystemstringsystemobject-method-supports-parameter-arrays-why-does-my-code-throw-an-exception-when-i-use-an-array"></a><span data-ttu-id="58835-1598">Se o método Format(System.IFormatProvider,System.String,System.Object[]) dá suporte a matrizes de parâmetro, por que meu código lançar uma exceção quando eu uso uma matriz?</span><span class="sxs-lookup"><span data-stu-id="58835-1598">If the Format(System.IFormatProvider,System.String,System.Object[]) method supports parameter arrays, why does my code throw an exception when I use an array?</span></span>  
 <span data-ttu-id="58835-1599">Por exemplo, o código a seguir gera um <xref:System.FormatException> exceção:</span><span class="sxs-lookup"><span data-stu-id="58835-1599">For example, the following code throws a <xref:System.FormatException> exception:</span></span>  
  
 [!code-csharp[System.String.Format#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa1.cs#21)]
 [!code-vb[System.String.Format#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa1.vb#21)]  
  
 <span data-ttu-id="58835-1600">Este é um problema de resolução de sobrecarga do compilador.</span><span class="sxs-lookup"><span data-stu-id="58835-1600">This is a problem of compiler overload resolution.</span></span> <span data-ttu-id="58835-1601">Porque o compilador não pode converter uma matriz de inteiros em uma matriz de objetos, ele trata a matriz de inteiros como um único argumento, para que ele chama o <xref:System.String.Format%28System.String%2CSystem.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1601">Because the compiler cannot convert an array of integers to an object array, it treats the integer array as a single argument, so it calls the <xref:System.String.Format%28System.String%2CSystem.Object%29> method.</span></span> <span data-ttu-id="58835-1602">A exceção é gerada porque há quatro itens de formato, mas apenas um único item na lista de formato.</span><span class="sxs-lookup"><span data-stu-id="58835-1602">The exception is thrown because there are four format items but only a single item in the format list.</span></span>  
  
 <span data-ttu-id="58835-1603">Como o Visual Basic nem c# pode converter uma matriz de inteiros para uma matriz de objetos, você precisa executar a conversão antes de chamar o <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1603">Because neither Visual Basic nor C# can convert an integer array to an object array, you have to perform the conversion yourself before calling the <xref:System.String.Format%28System.String%2CSystem.Object%5B%5D%29> method.</span></span> <span data-ttu-id="58835-1604">O exemplo a seguir fornece uma implementação.</span><span class="sxs-lookup"><span data-stu-id="58835-1604">The following example provides one implementation.</span></span>  
  
 [!code-csharp-interactive[System.String.Format#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/qa2.cs#22)]
 [!code-vb[System.String.Format#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/qa2.vb#22)]  

## Examples

<span data-ttu-id="58835-1605">Ver vários exemplos que chamam a <xref:System.String.Format%2A> método são intercalados por meio de [comentários](#remarks) seção deste artigo.</span><span class="sxs-lookup"><span data-stu-id="58835-1605">Numerous examples that call the <xref:System.String.Format%2A> method are interspersed through the [Remarks](#remarks) section of this article.</span></span>  

[!INCLUDE[interactive-note](~/includes/csharp-interactive-note.md)]

<span data-ttu-id="58835-1606">Você também pode baixar um conjunto completo de `String.Format` exemplos, que são incluídos uma [projeto .NET Core 2.0 para c#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) e uma [projeto .NET Core 2.0 para o Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), da [dotnet / repositório GitHub de exemplos](https://github.com/dotnet/samples).</span><span class="sxs-lookup"><span data-stu-id="58835-1606">You can also download a complete set of `String.Format` examples, which are included a [.NET Core 2.0 project for C#](https://github.com/dotnet/samples/raw/master/snippets/csharp/downloads/api/System/String.Format.zip) and a [.NET Core 2.0 project for Visual Basic](https://github.com/dotnet/samples/raw/master/snippets/visualbasic/downloads/api/System/String.Format.zip), from the [dotnet/samples GitHub repository](https://github.com/dotnet/samples).</span></span>

<span data-ttu-id="58835-1607">Seguem alguns exemplos incluídos neste artigo:</span><span class="sxs-lookup"><span data-stu-id="58835-1607">The following are some of the examples included in the article:</span></span>

### <a name="create-a-format-string"></a><span data-ttu-id="58835-1608">Criar uma cadeia de caracteres de formato</span><span class="sxs-lookup"><span data-stu-id="58835-1608">Create a format string</span></span>

[<span data-ttu-id="58835-1609">Inserindo uma cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-1609">Inserting a string</span></span>](#inserting-a-string)  
[<span data-ttu-id="58835-1610">O item de formato</span><span class="sxs-lookup"><span data-stu-id="58835-1610">The format item</span></span>](#the-format-item)  
[<span data-ttu-id="58835-1611">Itens de formato que têm o mesmo índice</span><span class="sxs-lookup"><span data-stu-id="58835-1611">Format items that have the same index</span></span>](#format-items-that-have-the-same-index)

### <a name="control-formatted-output"></a><span data-ttu-id="58835-1612">Controlar a saída formatada</span><span class="sxs-lookup"><span data-stu-id="58835-1612">Control formatted output</span></span>

[<span data-ttu-id="58835-1613">Controlando a formatação</span><span class="sxs-lookup"><span data-stu-id="58835-1613">Controlling formatting</span></span>](#controlling-formatting)  
[<span data-ttu-id="58835-1614">Controlar o espaçamento</span><span class="sxs-lookup"><span data-stu-id="58835-1614">Controlling spacing</span></span>](#controlling-spacing)  
[<span data-ttu-id="58835-1615">Controlar o alinhamento</span><span class="sxs-lookup"><span data-stu-id="58835-1615">Controlling alignment</span></span>](#controlling-alignment)  
[<span data-ttu-id="58835-1616">Controlar o número de dígitos integrais</span><span class="sxs-lookup"><span data-stu-id="58835-1616">Controlling the number of integral digits</span></span>](#how-do-i-control-the-number-of-integral-digits)  
[<span data-ttu-id="58835-1617">Controlando o número de dígitos após o separador decimal</span><span class="sxs-lookup"><span data-stu-id="58835-1617">Controlling the number of digits after the decimal separator</span></span>](#how-do-i-control-the-number-of-digits-after-the-decimal-separator)  
[<span data-ttu-id="58835-1618">Incluindo chaves literais em uma cadeia de caracteres de resultado</span><span class="sxs-lookup"><span data-stu-id="58835-1618">Including literal braces in a result string</span></span>](#braces)  

### <a name="make-format-strings-culture-sensitive"></a><span data-ttu-id="58835-1619">Tornar sensível à cultura de cadeias de caracteres de formato</span><span class="sxs-lookup"><span data-stu-id="58835-1619">Make format strings culture-sensitive</span></span>

[<span data-ttu-id="58835-1620">Formatação sensível à cultura</span><span class="sxs-lookup"><span data-stu-id="58835-1620">Culture-sensitive formatting</span></span>](#culture-sensitive-formatting)  

### <a name="customize-the-formatting-operation"></a><span data-ttu-id="58835-1621">Personalizar a operação de formatação</span><span class="sxs-lookup"><span data-stu-id="58835-1621">Customize the formatting operation</span></span>

[<span data-ttu-id="58835-1622">Uma operação de formatação personalizada</span><span class="sxs-lookup"><span data-stu-id="58835-1622">A custom formatting operation</span></span>](#example-a-custom-formatting-operation)  
[<span data-ttu-id="58835-1623">Um provedor de interceptação e formatador de algarismo romano</span><span class="sxs-lookup"><span data-stu-id="58835-1623">An intercept provider and Roman numeral formatter</span></span>](#example-an-intercept-provider-and-roman-numeral-formatter)  

 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj -&gt; string" Usage="System.string.Format (format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="58835-1624">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1624">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1625">O objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1625">The object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1626">Substitui um ou mais itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de um objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1626">Replaces one or more format items in a string with the string representation of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1627">Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1627">A copy of <paramref name="format" /> in which any format items are replaced by the string representation of <paramref name="arg0" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1628">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de uma expressão em sua representação de cadeia de caracteres e inserir essa representação em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1628">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-a-single-argument"></a><span data-ttu-id="58835-1629">Exemplo: Formatando um único argumento</span><span class="sxs-lookup"><span data-stu-id="58835-1629">Example: Formatting a single argument</span></span>  
 
 <span data-ttu-id="58835-1630">O exemplo a seguir usa o <xref:System.String.Format%28System.String%2CSystem.Object%29> método para inserir a idade de um indivíduo no meio de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1630">The following example uses the <xref:System.String.Format%28System.String%2CSystem.Object%29> method to embed an individual's age in the middle of a string.</span></span>  
  
 [!code-cpp[System.String.Format#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format7.cpp#7)]
 [!code-csharp-interactive[System.String.Format#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format7.cs#7)]
 [!code-vb[System.String.Format#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format7.vb#7)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1631">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1631">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1632">O item de formato em <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1632">The format item in <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1633">-ou- O índice de um item de formato não é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1633">-or-  The index of a format item is not zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj[] -&gt; string" Usage="System.string.Format (format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="58835-1634">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1634">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="58835-1635">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1635">An object array that contains zero or more objects to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1636">Substitui o item de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres de um objeto correspondente em uma matriz especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1636">Replaces the format item in a specified string with the string representation of a corresponding object in a specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1637">Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1637">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1638">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de quatro ou mais expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1638">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="58835-1639">Uma vez que o `args` parâmetro é marcado com o <xref:System.ParamArrayAttribute?displayProperty=nameWithType> atributo, você pode passar os objetos para o método como argumentos individuais ou como um <xref:System.Object> matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-1639">Since the `args` parameter is marked with the <xref:System.ParamArrayAttribute?displayProperty=nameWithType> attribute, you can pass the objects to the method as individual arguments or as an <xref:System.Object> array.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-more-than-three-arguments"></a><span data-ttu-id="58835-1640">Exemplo: Formatando mais de três argumentos</span><span class="sxs-lookup"><span data-stu-id="58835-1640">Example: Formatting more than three arguments</span></span>  
 
 <span data-ttu-id="58835-1641">Este exemplo cria uma cadeia de caracteres que contém dados sobre a temperatura alta e baixa em uma determinada data.</span><span class="sxs-lookup"><span data-stu-id="58835-1641">This example creates a string that contains data on the high and low temperature on a particular date.</span></span> <span data-ttu-id="58835-1642">A cadeia de caracteres de formato de composição tem cinco itens de formato no exemplo de c# e seis no exemplo do Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="58835-1642">The composite format string has five format items in the C# example and six in the Visual Basic example.</span></span> <span data-ttu-id="58835-1643">Dois dos itens de formato definem a largura da representação de cadeia de caracteres do valor de seu correspondente e o primeiro item de formato também inclui um padrão de data e a cadeia de caracteres de formato de hora.</span><span class="sxs-lookup"><span data-stu-id="58835-1643">Two of the format items define the width of their corresponding value's string representation, and the first format item also includes a standard date and time format string.</span></span>  
  
 [!code-cpp[System.String.Format#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format5.cpp#5)]
 [!code-csharp-interactive[System.String.Format#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format5.cs#5)]
 [!code-vb[System.String.Format#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format5.vb#5)]  
  
 <span data-ttu-id="58835-1644">Você também pode passar os objetos a serem formatados como uma matriz em vez de uma lista de argumentos.</span><span class="sxs-lookup"><span data-stu-id="58835-1644">You can also pass the objects to be formatted as an array rather than a an argument list.</span></span>  
  
 [!code-cpp[System.String.Format#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format_paramarray1.cpp#10)]
 [!code-csharp-interactive[System.String.Format#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format_paramarray1.cs#10)]
 [!code-vb[System.String.Format#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format_paramarray1.vb#10)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1645">
            <paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1645">
              <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1646">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1646">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1647">-ou- O índice de um item de formato é menor que zero ou superior ou igual ao tamanho da matriz <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1647">-or-  The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj -&gt; string" Usage="System.string.Format (provider, format, arg0)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-1648">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1648">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <param name="format">
          <span data-ttu-id="58835-1649">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1649">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1650">O objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1650">The object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1651">Substitui o item ou itens de formato em uma cadeia de caracteres especificada pela representação de cadeia de caracteres do objeto correspondente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1651">Replaces the format item or items in a specified string with the string representation of the corresponding object.</span>
          </span>
          <span data-ttu-id="58835-1652">Um parâmetro fornece informações de formatação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1652">A parameter supplies culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1653">Uma cópia do <paramref name="format" /> na qual o item ou itens de formato foram substituídos pela representação de cadeia de caracteres do <paramref name="arg0" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1653">A copy of <paramref name="format" /> in which the format item or items have been replaced by the string representation of <paramref name="arg0" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1654">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de uma expressão em sua representação de cadeia de caracteres e inserir essa representação em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1654">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of an expression to its string representation and to embed that representation in a string.</span></span> <span data-ttu-id="58835-1655">Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado.</span><span class="sxs-lookup"><span data-stu-id="58835-1655">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="58835-1656">O método converte `arg0` em sua representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString ( String, IFormatProvider)** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1656">The method converts `arg0` to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="58835-1657">Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1657">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1658">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1658">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1659">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1659">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1660">-ou- O índice de um item de formato não é zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1660">-or-  The index of a format item is not zero.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, ParamArray args As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj[] -&gt; string" Usage="System.string.Format (provider, format, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-1661">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1661">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <param name="format">
          <span data-ttu-id="58835-1662">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1662">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="58835-1663">Uma matriz de objetos que contém zero ou mais objetos a serem formatados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1663">An object array that contains zero or more objects to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1664">Substitui os itens de formato em uma cadeia de caracteres pelas representações cadeia de caracteres de objetos correspondentes em uma matriz especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1664">Replaces the format items in a string with the string representations of corresponding objects in a specified array.</span>
          </span>
          <span data-ttu-id="58835-1665">Um parâmetro fornece informações de formatação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1665">A parameter supplies culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1666">Uma cópia do <paramref name="format" /> na qual os itens de formato foram substituídos pela representação de cadeia de caracteres dos objetos correspondentes no <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1666">A copy of <paramref name="format" /> in which the format items have been replaced by the string representation of the corresponding objects in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1667">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter quatro ou mais expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1667">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert four or more expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="58835-1668">Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado.</span><span class="sxs-lookup"><span data-stu-id="58835-1668">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="58835-1669">O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1669">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="58835-1670">Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1670">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
  
## <a name="example-culture-sensitive-formatting"></a><span data-ttu-id="58835-1671">Exemplo: Cultura de formatação</span><span class="sxs-lookup"><span data-stu-id="58835-1671">Example: Culture-sensitive formatting</span></span>  
 <span data-ttu-id="58835-1672">Este exemplo usa o <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> método para exibir a representação de cadeia de caracteres de alguns valores de data e hora e valores numéricos usando várias culturas diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1672">This example uses the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29> method to display the string representation of some date and time values and numeric values by using several different cultures.</span></span>  
  
 [!code-csharp-interactive[System.String.Format2#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format2/cs/Example2.cs#2)]
 [!code-vb[System.String.Format2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format2/vb/Example2.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1673">
            <paramref name="format" /> ou <paramref name="args" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1673">
              <paramref name="format" /> or <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1674">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1674">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1675">-ou- O índice de um item de formato é menor que zero ou superior ou igual ao tamanho da matriz <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1675">-or-  The index of a format item is less than zero, or greater than or equal to the length of the <paramref name="args" /> array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Globalization.DateTimeFormatInfo" />
        <altmember cref="T:System.ICustomFormatter" />
        <altmember cref="T:System.IFormatProvider" />
        <altmember cref="T:System.Globalization.NumberFormatInfo" />
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="58835-1676">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1676">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1677">O primeiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1677">The first object to format.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1678">O segundo objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1678">The second object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1679">Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de dois objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1679">Replaces the format items in a string with the string representation of two specified objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1680">Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1680">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1681">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor de duas expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1681">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of two expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-two-arguments"></a><span data-ttu-id="58835-1682">Exemplo: Formatando dois argumentos</span><span class="sxs-lookup"><span data-stu-id="58835-1682">Example: Formatting two arguments</span></span>  
 
 <span data-ttu-id="58835-1683">Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> método para exibir dados de tempo e a temperatura armazenados em um genérico <xref:System.Collections.Generic.Dictionary%602> objeto.</span><span class="sxs-lookup"><span data-stu-id="58835-1683">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%29> method to display time and temperature data stored in a generic <xref:System.Collections.Generic.Dictionary%602> object.</span></span> <span data-ttu-id="58835-1684">Observe que a cadeia de caracteres de formato tem três itens de formato, embora existam apenas dois objetos a serem formatados.</span><span class="sxs-lookup"><span data-stu-id="58835-1684">Note that the format string has three format items, although there are only two objects to format.</span></span> <span data-ttu-id="58835-1685">Isso ocorre porque o primeiro objeto na lista (um valor de data e hora) é usado por dois itens de formato: O primeiro exibe de item de formato a hora e a segunda exibe a data.</span><span class="sxs-lookup"><span data-stu-id="58835-1685">This is because the first object in the list (a date and time value) is used by two format items: The first format item displays the time, and the second displays the date.</span></span>  
  
 [!code-cpp[System.String.Format#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/formatexample4.cpp#6)]
 [!code-csharp-interactive[System.String.Format#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/formatexample4.cs#6)]
 [!code-vb[System.String.Format#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/formatexample4.vb#6)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1686">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1686">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1687">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1687">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1688">-ou- O índice de um item de formato não é zero nem um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1688">-or-  The index of a format item is not zero or one.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-1689">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1689">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <param name="format">
          <span data-ttu-id="58835-1690">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1690">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1691">O primeiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1691">The first object to format.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1692">O segundo objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1692">The second object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1693">Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de dois objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1693">Replaces the format items in a string with the string representation of two specified objects.</span>
          </span>
          <span data-ttu-id="58835-1694">Um parâmetro fornece informações de formatação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1694">A parameter supplies culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1695">Uma cópia do <paramref name="format" /> na qual os itens de formato são substituídos pelas representações da cadeia de caracteres de <paramref name="arg0" /> e <paramref name="arg1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1695">A copy of <paramref name="format" /> in which format items are replaced by the string representations of <paramref name="arg0" /> and <paramref name="arg1" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1696">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) converter duas expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1696">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert two expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="58835-1697">Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado.</span><span class="sxs-lookup"><span data-stu-id="58835-1697">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="58835-1698">O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1698">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="58835-1699">Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1699">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1700">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1700">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1701">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1701">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1702">-ou- O índice de um item de formato não é zero nem um.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1702">-or-  The index of a format item is not zero or one.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : string * obj * obj * obj -&gt; string" Usage="System.string.Format (format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="58835-1703">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1703">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1704">O primeiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1704">The first object to format.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1705">O segundo objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1705">The second object to format.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="58835-1706">O terceiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1706">The third object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1707">Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de três objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1707">Replaces the format items in a string with the string representation of three specified objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1708">Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1708">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1709">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) para converter o valor das três expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1709">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert the value of three expressions to their string representations and to embed those representations in a string.</span></span> 

[!INCLUDE[simple-string-format](~/includes/simple-string-format.md)]

## <a name="example-formatting-three-arguments"></a><span data-ttu-id="58835-1710">Exemplo: Formatando três argumentos</span><span class="sxs-lookup"><span data-stu-id="58835-1710">Example: Formatting three arguments</span></span>  
 
 <span data-ttu-id="58835-1711">Este exemplo usa o <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> método para criar uma cadeia de caracteres que ilustra o resultado de um valor booliano `And` operação com dois valores inteiros.</span><span class="sxs-lookup"><span data-stu-id="58835-1711">This example uses the <xref:System.String.Format%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> method to create a string that illustrates the result of a Boolean `And` operation with two integer values.</span></span> <span data-ttu-id="58835-1712">Observe que a cadeia de caracteres de formato inclui seis itens de formato, mas o método tem apenas três itens na lista de parâmetros, porque cada item é formatada de duas maneiras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1712">Note that the format string includes six format items, but the method has only three items in its parameter list, because each item is formatted in two different ways.</span></span>  
  
 [!code-cpp[System.String.Format#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Format/cpp/format4.cpp#4)]
 [!code-csharp-interactive[System.String.Format#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Format/cs/format4.cs#4)]
 [!code-vb[System.String.Format#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Format/vb/format4.vb#4)]  
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1713">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1713">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1714">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1714">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1715">-ou- O índice de um item de formato é menor que zero ou maior que dois.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1715">-or-  The index of a format item is less than zero, or greater than two.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Format">
      <MemberSignature Language="C#" Value="public static string Format (IFormatProvider provider, string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Format(class System.IFormatProvider provider, string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Format(System.IFormatProvider,System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Format (provider As IFormatProvider, format As String, arg0 As Object, arg1 As Object, arg2 As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Format(IFormatProvider ^ provider, System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberSignature Language="F#" Value="static member Format : IFormatProvider * string * obj * obj * obj -&gt; string" Usage="System.string.Format (provider, format, arg0, arg1, arg2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-1716">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1716">An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <param name="format">
          <span data-ttu-id="58835-1717">Uma [cadeia de caracteres de formato composto](~/docs/standard/base-types/composite-formatting.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1717">A [composite format string](~/docs/standard/base-types/composite-formatting.md).</span>
          </span>
        </param>
        <param name="arg0">
          <span data-ttu-id="58835-1718">O primeiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1718">The first object to format.</span>
          </span>
        </param>
        <param name="arg1">
          <span data-ttu-id="58835-1719">O segundo objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1719">The second object to format.</span>
          </span>
        </param>
        <param name="arg2">
          <span data-ttu-id="58835-1720">O terceiro objeto a ser formatado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1720">The third object to format.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1721">Substitui os itens de formato em uma cadeia de caracteres pela representação de cadeia de caracteres de três objetos especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1721">Replaces the format items in a string with the string representation of three specified objects.</span>
          </span>
          <span data-ttu-id="58835-1722">Um parâmetro fornece informações de formatação específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1722">An parameter supplies culture-specific formatting information.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1723">Uma cópia do <paramref name="format" /> na qual ou itens de formato foram substituídos pela representação de cadeia de caracteres de <paramref name="arg0" />, <paramref name="arg1" /> e <paramref name="arg2" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1723">A copy of <paramref name="format" /> in which the format items have been replaced by the string representations of <paramref name="arg0" />, <paramref name="arg1" />, and <paramref name="arg2" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

[!INCLUDE[interpolated-strings](~/includes/interpolated-strings.md)] 
  
<span data-ttu-id="58835-1724">Esse método usa o [recurso de formatação composta](~/docs/standard/base-types/composite-formatting.md) converter três expressões em suas representações de cadeia de caracteres e incorporar essas representações em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1724">This method uses the [composite formatting feature](~/docs/standard/base-types/composite-formatting.md) to convert three expressions to their string representations and to embed those representations in a string.</span></span> <span data-ttu-id="58835-1725">Na execução da conversão, o método usa formatação sensível à cultura ou um formatador personalizado.</span><span class="sxs-lookup"><span data-stu-id="58835-1725">In performing the conversion, the method uses culture-sensitive formatting or a custom formatter.</span></span> <span data-ttu-id="58835-1726">O método converte cada <xref:System.Object> argumento para a representação de cadeia de caracteres chamando seus **ToString(IFormatProvider)** método ou, se o objeto a correspondente do item de formato inclui uma cadeia de caracteres de formato, chamando seu **ToString(String,IFormatProvider)** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1726">The method converts each <xref:System.Object> argument to its string representation by calling its **ToString(IFormatProvider)** method or, if the object's corresponding format item includes a format string, by calling its **ToString(String,IFormatProvider)** method.</span></span> <span data-ttu-id="58835-1727">Se esses métodos não existirem, ele chama o objeto sem parâmetros **ToString** método.</span><span class="sxs-lookup"><span data-stu-id="58835-1727">If these methods don't exist, it calls the object's parameterless **ToString** method.</span></span>  

[!INCLUDE[provider-string-format](~/includes/provider-string-format.md)]
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1728">
            <paramref name="format" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1728">
              <paramref name="format" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-1729">
            <paramref name="format" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1729">
              <paramref name="format" /> is invalid.</span>
          </span>
          <span data-ttu-id="58835-1730">-ou- O índice de um item de formato é menor que zero ou maior que dois.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1730">-or-  The index of a format item is less than zero, or greater than two.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public CharEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.CharEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As CharEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CharEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; CharEnumerator" Usage="string.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CharEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-1731">Recupera um objeto que pode iterar os caracteres individuais nessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1731">Retrieves an object that can iterate through the individual characters in this string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1732">Um objeto enumerador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1732">An enumerator object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!TIP]
> <span data-ttu-id="58835-1733">Em vez de chamar o <xref:System.String.GetEnumerator%2A> método para recuperar um <xref:System.CharEnumerator> do objeto que você usar para enumerar uma cadeia de caracteres, em vez disso, use o constructo de iteração da sua linguagem (em c#, no C + + c++ /CLI CLR e no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="58835-1733">Rather than calling the <xref:System.String.GetEnumerator%2A> method to retrieve a <xref:System.CharEnumerator> object that you then use to enumerate a string, you should instead use your language's iteration construct (in C#, in C++/CLR, and in Visual Basic).</span></span> <span data-ttu-id="58835-1734">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) em c#, [para cada](/cpp/dotnet/for-each-in) no C + + c++ /CLI CLR, e [para cada](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="58835-1734">[foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) in C#, [for each](/cpp/dotnet/for-each-in) in C++/CLR, and [For Each](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) in Visual Basic).</span></span>
  
 <span data-ttu-id="58835-1735">Esse método permite que você iterar os caracteres individuais em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1735">This method enables you to iterate the individual characters in a string.</span></span> <span data-ttu-id="58835-1736">Por exemplo, o Visual Basic `For Each` e c# `foreach` instruções invocar esse método para retornar um <xref:System.CharEnumerator> objeto que pode fornecer acesso somente leitura aos caracteres nesta instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1736">For example, the Visual Basic `For Each` and C# `foreach` statements invoke this method to return a <xref:System.CharEnumerator> object that can provide read-only access to the characters in this string instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1737">O exemplo a seguir itera os caracteres em várias cadeias de caracteres e exibe informações sobre seus caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-1737">The following example iterates the characters in several strings and displays information about their individual characters.</span></span> <span data-ttu-id="58835-1738">Ele usa a construção de iteração de linguagem em vez de uma chamada para o <xref:System.String.GetEnumerator%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1738">It uses the language iteration construct rather than a call to the <xref:System.String.GetEnumerator%2A> method.</span></span>  
  
 [!code-cpp[system.string.getenumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetEnumerator/CPP/getenumerator.cpp#1)]
 [!code-csharp[system.string.getenumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetEnumerator/CS/getenumerator.cs#1)]
 [!code-vb[system.string.getenumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetEnumerator/VB/getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
        <altmember cref="T:System.Collections.IEnumerable" />
        <altmember cref="P:System.String.Chars(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="string.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-1739">Retorna o código hash desta cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1739">Returns the hash code for this string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1740">Um código de hash do inteiro assinado de 32 bits.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1740">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1741">O comportamento de <xref:System.String.GetHashCode%2A> depende de sua implementação, o que pode ser alterado de uma versão do common language runtime para outro.</span><span class="sxs-lookup"><span data-stu-id="58835-1741">The behavior of <xref:System.String.GetHashCode%2A> is dependent on its implementation, which might change from one version of the common language runtime to another.</span></span> <span data-ttu-id="58835-1742">Um motivo por que isso pode acontecer é melhorar o desempenho de <xref:System.String.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-1742">A reason why this might happen is to improve the performance of <xref:System.String.GetHashCode%2A>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-1743">Se dois objetos de cadeia de caracteres são iguais, o <xref:System.String.GetHashCode%2A> método retorna valores idênticos.</span><span class="sxs-lookup"><span data-stu-id="58835-1743">If two string objects are equal, the <xref:System.String.GetHashCode%2A> method returns identical values.</span></span> <span data-ttu-id="58835-1744">No entanto, não há um valor de código hash exclusivo para cada valor de cadeia de caracteres exclusiva.</span><span class="sxs-lookup"><span data-stu-id="58835-1744">However, there is not a unique hash code value for each unique string value.</span></span> <span data-ttu-id="58835-1745">Cadeias de caracteres diferentes podem retornar o mesmo código hash.</span><span class="sxs-lookup"><span data-stu-id="58835-1745">Different strings can return the same hash code.</span></span>  
>   
>  <span data-ttu-id="58835-1746">O código de hash em si não é garantido para ser estável.</span><span class="sxs-lookup"><span data-stu-id="58835-1746">The hash code itself is not guaranteed to be stable.</span></span> <span data-ttu-id="58835-1747">Códigos de hash para cadeias de caracteres idênticas podem ser diferentes entre versões do .NET Framework e entre plataformas (como 32 bits e 64 bits) para uma única versão do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="58835-1747">Hash codes for identical strings can differ across versions of the .NET Framework and across platforms (such as 32-bit and 64-bit) for a single version of the .NET Framework.</span></span> <span data-ttu-id="58835-1748">Em alguns casos, pode até mesmo diferem por domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1748">In some cases, they can even differ by application domain.</span></span> <span data-ttu-id="58835-1749">Isso significa que duas execuções subsequentes do mesmo programa podem retornar códigos de hash diferente.</span><span class="sxs-lookup"><span data-stu-id="58835-1749">This implies two subsequent runs of the same program may return different hash codes.</span></span>  
>   
>  <span data-ttu-id="58835-1750">Como resultado, hash códigos nunca devem ser usados fora do domínio de aplicativo no qual eles foram criados, eles nunca devem ser usados como campos de chave em uma coleção e nunca deve ser mantidos.</span><span class="sxs-lookup"><span data-stu-id="58835-1750">As a result, hash codes should never be used outside of the application domain in which they were created, they should never be used as key fields in a collection, and they should never be persisted.</span></span>  
>   
>  <span data-ttu-id="58835-1751">Por fim, não use o código de hash em vez de um valor retornado por uma função de hash criptográfica, se você precisar de um hash criptograficamente forte.</span><span class="sxs-lookup"><span data-stu-id="58835-1751">Finally, don't use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="58835-1752">Para hashes criptográficos, use uma classe derivada de <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> ou <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-1752">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
>   
>  <span data-ttu-id="58835-1753">Para obter mais informações sobre códigos de hash, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1753">For more information about hash codes, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="58835-1754">Em aplicativos da área de trabalho, você pode usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) para gerar códigos de hash exclusivo em uma base domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1754">In desktop apps, you can use the             [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md) to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="58835-1755">Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash.</span><span class="sxs-lookup"><span data-stu-id="58835-1755">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="58835-1756">O exemplo a seguir mostra como usar o [ \<UseRandomizedStringHashAlgorithm > elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span><span class="sxs-lookup"><span data-stu-id="58835-1756">The following example shows how to use the                [\<UseRandomizedStringHashAlgorithm> element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span> <span data-ttu-id="58835-1757">Ele define uma gerar códigos de hash exclusivo em uma base domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1757">It defines a  to generate unique hash codes on a per application domain basis.</span></span> <span data-ttu-id="58835-1758">Isso pode reduzir o número de colisões e melhorar o desempenho geral de inserções e pesquisas que usam tabelas de hash.</span><span class="sxs-lookup"><span data-stu-id="58835-1758">This can reduce the number of collisions and improve the overall performance of insertions and lookups that use hash tables.</span></span> <span data-ttu-id="58835-1759">O exemplo a seguir mostra como usar o.</span><span class="sxs-lookup"><span data-stu-id="58835-1759">The following example shows how to use the .</span></span> <span data-ttu-id="58835-1760">Ele define uma `DisplayString` classe que inclui uma constante de cadeia de caracteres privados, `s`, cujo valor é "Esta é uma cadeia de caracteres."</span><span class="sxs-lookup"><span data-stu-id="58835-1760">It defines a `DisplayString` class that includes a private string constant, `s`, whose value is "This is a string."</span></span> <span data-ttu-id="58835-1761">Também inclui um método `ShowStringHashCode` que exibe o valor de cadeia de caracteres e seu código de hash com o nome do domínio do aplicativo no qual o método está sendo executado.</span><span class="sxs-lookup"><span data-stu-id="58835-1761">It also includes a `ShowStringHashCode` method that displays the string value and its hash code along with the name of the application domain in which the method is executing.</span></span>  
  
 [!code-csharp[System.String.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/perdomain.cs#2)]
 [!code-vb[System.String.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/perdomain.vb#2)]  
  
 <span data-ttu-id="58835-1762">Quando você executa o exemplo sem fornecer um arquivo de configuração, ele exibe uma saída semelhante à seguinte.</span><span class="sxs-lookup"><span data-stu-id="58835-1762">When you run the example without supplying a configuration file, it displays output similar to the following.</span></span> <span data-ttu-id="58835-1763">Observe que os códigos hash para a cadeia de caracteres são idênticos nos dois domínios de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1763">Note that the hash codes for the string are identical in the two application domains.</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 941BCEAC  
String 'This is a string.' in domain 'NewDomain': 941BCEAC  
  
```  
  
 <span data-ttu-id="58835-1764">Entretanto, se você adicionar o seguinte arquivo de configuração ao diretório de exemplo e, então, executar o exemplo, os códigos hash da mesma cadeia de caracteres diferirão de acordo com o domínio de aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1764">However, if you add the following configuration file to the example's directory and then run the example, the hash codes for the same string will differ by application domain.</span></span>  
  
```xml  
  
<?xml version ="1.0"?>  
<configuration>  
   <runtime>  
      <UseRandomizedStringHashAlgorithm enabled="1" />  
   </runtime>  
</configuration>  
  
```  
  
 <span data-ttu-id="58835-1765">Quando o arquivo de configuração estiver presente, o exemplo exibe a saída a seguir:</span><span class="sxs-lookup"><span data-stu-id="58835-1765">When the configuration file is present, the example displays the following output:</span></span>  
  
```  
  
String 'This is a string.' in domain 'PerDomain.exe': 5435776D  
String 'This is a string.' in domain 'NewDomain': 75CC8236  
  
```  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-1766">Códigos de hash são usados para inserir e recuperar objetos com chave das tabelas de hash com eficiência.</span><span class="sxs-lookup"><span data-stu-id="58835-1766">Hash codes are used to insert and retrieve keyed objects from hash tables efficiently.</span></span> <span data-ttu-id="58835-1767">No entanto, os códigos de hash não identificam exclusivamente as cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1767">However, hash codes don't uniquely identify strings.</span></span> <span data-ttu-id="58835-1768">Cadeias de caracteres idênticas têm códigos hash igual, mas o common language runtime também pode atribuir o mesmo código hash para cadeias de caracteres diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-1768">Identical strings have  equal hash codes, but the common language runtime can also assign the same hash code to different strings.</span></span> <span data-ttu-id="58835-1769">Além disso, os códigos hash podem variar por versão do .NET Framework, por plataforma dentro de uma única versão e pelo domínio do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="58835-1769">In addition, hash codes can vary by version of the .NET Framework, by platform within a single version, and by application domain.</span></span> <span data-ttu-id="58835-1770">Por isso, você não deve serializar ou manter valores de hash de código, nem deve você usá-los como chaves em uma tabela de hash ou dicionário.</span><span class="sxs-lookup"><span data-stu-id="58835-1770">Because of this, you should not serialize or persist hash code values, nor should you use them as keys in a hash table or dictionary.</span></span>  
  
 <span data-ttu-id="58835-1771">Para obter informações adicionais sobre o uso dos códigos de hash e o `GetHashCode` método, consulte <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-1771">For additional information about the use of hash codes and the `GetHashCode` method, see <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1772">O exemplo a seguir demonstra o <xref:System.String.GetHashCode%2A> método usando várias cadeias de caracteres de entrada.</span><span class="sxs-lookup"><span data-stu-id="58835-1772">The following example demonstrates the <xref:System.String.GetHashCode%2A> method using various input strings.</span></span>  
  
 [!code-cpp[system.string.gethashcode#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.GetHashCode/CPP/gethashcode.cpp#1)]
 [!code-csharp[system.string.gethashcode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.GetHashCode/CS/gethashcode.cs#1)]
 [!code-vb[system.string.gethashcode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.GetHashCode/VB/gethashcode.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1773">
            <para>O valor retornado por <see cref="M:System.String.GetHashCode" /> é dependente de plataforma. Ele é diferente nas versões de 32 bits e 64 bits do .NET Framework. Ele também pode ser diferente entre as versões do .NET Framework.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1773">
              <para>The value returned by <see cref="M:System.String.GetHashCode" /> is platform-dependent. It differs on the 32-bit and 64-bit versions of the .NET Framework. It also can differ between versions of the .NET Framework.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public int GetHashCode (StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetHashCode(valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetHashCode(System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetHashCode (comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetHashCode(StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : StringComparison -&gt; int" Usage="string.GetHashCode comparisonType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="string.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-1774">Retorna o <see cref="T:System.TypeCode" /> para a classe <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1774">Returns the <see cref="T:System.TypeCode" /> for class <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1775">A constante enumerada, <see cref="F:System.TypeCode.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1775">The enumerated constant, <see cref="F:System.TypeCode.String" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="58835-1776">O exemplo a seguir exibe a <xref:System.TypeCode> constante enumerada para o <xref:System.String> tipo.</span><span class="sxs-lookup"><span data-stu-id="58835-1776">The following example displays the <xref:System.TypeCode> enumerated constant for the <xref:System.String> type.</span></span>  
  
 [!code-cpp[string.gettypecode#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.gettypecode/CPP/gtc.cpp#1)]
 [!code-csharp[string.gettypecode#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.gettypecode/CS/gtc.cs#1)]
 [!code-vb[string.gettypecode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.gettypecode/VB/gtc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1777">Relata o índice de base zero da primeira ocorrência de uma cadeia de caracteres ou um caractere Unicode especificado nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1777">Reports the zero-based index of the first occurrence of a specified Unicode character or string within this instance.</span>
          </span>
          <span data-ttu-id="58835-1778">O método retorna -1 caso o caractere ou a cadeia de caracteres não seja encontrado nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1778">The method returns -1 if the character or string is not found in this instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1779">Um caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1779">A Unicode character to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1780">Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1780">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1781">A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1781">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1782">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1782">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-1783">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-1783">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-1784">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1784">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1785">O exemplo a seguir demonstra como você pode pesquisar um <xref:System.String> para um caractere usando o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1785">The following example demonstrates how you can search a <xref:System.String> for a character using the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[System.String.IndexOf#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexof_c.cpp#5)]
 [!code-csharp[System.String.IndexOf#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexof_c.cs#5)]
 [!code-vb[System.String.IndexOf#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexof_c.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string -&gt; int" Usage="string.IndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1786">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1786">The string to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1787">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1787">Reports the zero-based index of the first occurrence of the specified string in this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1788">A posição do índice com base em zero de <paramref name="value" /> caso essa cadeia de caracteres seja encontrada ou -1 caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1788">The zero-based index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1789">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1789">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1790">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1790">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-1791">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1791">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="58835-1792">A pesquisa começa na posição do primeiro caractere dessa instância e continua até que a última posição de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-1792">The search begins at the first character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="58835-1793">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1793">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-1794">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-1794">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-1795">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%29> método sempre retorna 0 (zero) para indicar que a correspondência for encontrada no início da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1795">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%29> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.</span></span> <span data-ttu-id="58835-1796">No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%29> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1796">In the following example, the <xref:System.String.IndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="58835-1797">Apenas uma das cadeias de caracteres contém um hífen condicional.</span><span class="sxs-lookup"><span data-stu-id="58835-1797">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="58835-1798">Se o exemplo é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen condicional é um caractere ignorável, o resultado é o mesmo como se o hífen não havia sido incluído no `value`.</span><span class="sxs-lookup"><span data-stu-id="58835-1798">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="58835-1799">Ao procurar por um hífen somente, o método retorna 0 (zero) para indicar que encontrou uma correspondência no início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1799">When searching for a soft hyphen only, the method returns 0 (zero) to indicate that it has found a match at the beginning of the string.</span></span>  
  
 [!code-csharp[System.String.IndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable21.cs#21)]
 [!code-vb[System.String.IndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1800">O exemplo a seguir procura "n" em "animal".</span><span class="sxs-lookup"><span data-stu-id="58835-1800">The following example searches for the "n" in "animal".</span></span> <span data-ttu-id="58835-1801">Porque os índices de cadeia de caracteres começam em zero em vez de um, o <xref:System.String.IndexOf%28System.String%29> método indica que o "n" na posição 1.</span><span class="sxs-lookup"><span data-stu-id="58835-1801">Because string indexes begin at zero rather than one, the <xref:System.String.IndexOf%28System.String%29> method indicates that the "n" is at position 1.</span></span>  
  
 [!code-cpp[System.String.IndexOf#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/simple1.cpp#12)]
 [!code-csharp[System.String.IndexOf#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/simple1.cs#12)]
 [!code-vb[System.String.IndexOf#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/simple1.vb#12)]  
  
 <span data-ttu-id="58835-1802">O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para determinar a posição inicial de um nome do animal em uma sentença.</span><span class="sxs-lookup"><span data-stu-id="58835-1802">The following example uses the <xref:System.String.IndexOf%2A> method to determine the starting position of an animal name in a sentence.</span></span> <span data-ttu-id="58835-1803">Ele usa essa posição para inserir um adjetivo que descreve o animal em sentença.</span><span class="sxs-lookup"><span data-stu-id="58835-1803">It then uses this position to insert an adjective that describes the animal into the sentence.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1804">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1804">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1805">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para o parâmetro 'comparisonType'.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1805">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the first index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1806">Um caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1806">A Unicode character to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1807">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1807">The search starting position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1808">Relata o índice baseado em zero da primeira ocorrência do caractere Unicode especificado na cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1808">Reports the zero-based index of the first occurrence of the specified Unicode character in this string.</span>
          </span>
          <span data-ttu-id="58835-1809">A pesquisa é iniciada em uma posição de caractere especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1809">The search starts at a specified character position.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1810">A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1810">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1811">Índice de numeração começa em 0.</span><span class="sxs-lookup"><span data-stu-id="58835-1811">Index numbering starts from 0.</span></span> <span data-ttu-id="58835-1812">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1812">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="58835-1813">Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1813">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="58835-1814">A pesquisa varia de `startIndex` até o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1814">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="58835-1815">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-1815">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-1816">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1816">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1817">O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1817">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[string.indexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof1/CPP/ixof1.cpp#1)]
 [!code-csharp[string.indexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof1/CS/ixof1.cs#1)]
 [!code-vb[string.indexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof1/VB/ixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1818">
            <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1818">
              <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of the string.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int -&gt; int" Usage="string.IndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1819">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1819">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1820">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1820">The search starting position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1821">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1821">Reports the zero-based index of the first occurrence of the specified string in this instance.</span>
          </span>
          <span data-ttu-id="58835-1822">A pesquisa é iniciada em uma posição de caractere especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1822">The search starts at a specified character position.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1823">A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1823">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1824">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1824">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1825">Índice de numeração começa em 0.</span><span class="sxs-lookup"><span data-stu-id="58835-1825">Index numbering starts from 0.</span></span> <span data-ttu-id="58835-1826">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1826">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="58835-1827">Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1827">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="58835-1828">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1828">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="58835-1829">A pesquisa começa no `startIndex` caractere posição dessa instância e continua até que a última posição de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-1829">The search begins at the `startIndex` character position of this instance and continues until the last character position.</span></span>  
  
 <span data-ttu-id="58835-1830">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1830">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-1831">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-1831">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-1832">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="58835-1832">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="58835-1833">No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" em duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1833">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in two strings.</span></span> <span data-ttu-id="58835-1834">Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária.</span><span class="sxs-lookup"><span data-stu-id="58835-1834">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="58835-1835">Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1835">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string.</span></span> <span data-ttu-id="58835-1836">No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".</span><span class="sxs-lookup"><span data-stu-id="58835-1836">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable22.cs#22)]
 [!code-vb[System.String.IndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1837">O exemplo a seguir procura todas as ocorrências de uma cadeia de caracteres especificada dentro de uma cadeia de caracteres de destino.</span><span class="sxs-lookup"><span data-stu-id="58835-1837">The following example searches for all occurrences of a specified string within a target string.</span></span>  
  
 [!code-cpp[stringindexof4#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringindexof4/CPP/stringindexof4.cpp#1)]
 [!code-csharp[stringindexof4#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringindexof4/CS/stringindexof4.cs#1)]
 [!code-vb[stringindexof4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringindexof4/VB/stringindexof4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1838">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1838">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1839">
            <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1839">
              <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1840">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para localizar o primeiro índice de uma subcadeia de caracteres que ocorre após uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para o parâmetro 'comparisonType'.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1840">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the first index of a substring that occurs after a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * StringComparison -&gt; int" Usage="string.IndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1841">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1841">The string to seek.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1842">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1842">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1843">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1843">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span>
          </span>
          <span data-ttu-id="58835-1844">Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1844">A parameter specifies the type of search to use for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1845">A posição do índice do parâmetro <paramref name="value" /> caso essa cadeia de caracteres seja encontrada, ou -1 caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1845">The index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1846">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1846">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is 0.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1847">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1847">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-1848">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-1848">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1849">A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1849">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1850">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1850">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1851">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1851">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1852">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método sempre retorna 0 (zero) para indicar que a correspondência for encontrada no início da instância atual.  No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, como o hífen é um caractere ignorável, uma pesquisa sensível à cultura retorna o mesmo valor que será retornado se o hífen não foram incluídos na cadeia de caracteres de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen em uma cadeia de caracteres com êxito e relata que está ausente da segunda cadeia de caracteres.  [! código csharp [System.String.IndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.IndexOf/CS/ignorable26.cs#26)] [! código vb [System.String.IndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.IndexOf/VB/ignorable26.vb#26)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1852">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method always returns 0 (zero) to indicate that the match is found at the beginning of the current instance.  In the following example, the <see cref="M:System.String.IndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string. An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.  [!code-csharp[System.String.IndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable26.cs#26)] [!code-vb[System.String.IndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable26.vb#26)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : char * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1853">Um caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1853">A Unicode character to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1854">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1854">The search starting position.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-1855">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1855">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1856">Relata o índice baseado em zero da primeira ocorrência do caractere especificado nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1856">Reports the zero-based index of the first occurrence of the specified character in this instance.</span>
          </span>
          <span data-ttu-id="58835-1857">A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1857">The search starts at a specified character position and examines a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1858">A posição de índice baseado em zero de <paramref name="value" /> do início da cadeia de caracteres se esse caractere for encontrado ou -1 se não for.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1858">The zero-based index position of <paramref name="value" /> from the start of the string if that character is found, or -1 if it is not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1859">A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1859">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="58835-1860">O caractere na `startIndex`  +  `count` não está incluído na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1860">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="58835-1861">Índice de numeração começa em 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="58835-1861">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="58835-1862">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1862">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="58835-1863">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-1863">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-1864">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1864">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1865">O exemplo a seguir demonstra o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-1865">The following example demonstrates the <xref:System.String.IndexOf%2A> method.</span></span>  
  
 [!code-cpp[system.string.indexof#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.IndexOf/CPP/indexofcii.cpp#1)]
 [!code-csharp[system.string.indexof#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/indexofcii.cs#1)]
 [!code-vb[system.string.indexof#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/indexofcii.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1866">
            <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1866">
              <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1867">-ou- <paramref name="startIndex" /> é maior que o tamanho dessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1867">-or-  <paramref name="startIndex" /> is greater than the length of this string.</span>
          </span>
          <span data-ttu-id="58835-1868">-ou- <paramref name="count" /> é maior que o tamanho dessa cadeia de caracteres menos <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1868">-or-  <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int -&gt; int" Usage="string.IndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1869">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1869">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1870">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1870">The search starting position.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-1871">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1871">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1872">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1872">Reports the zero-based index of the first occurrence of the specified string in this instance.</span>
          </span>
          <span data-ttu-id="58835-1873">A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1873">The search starts at a specified character position and examines a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1874">A posição de índice baseado em zero do <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1874">The zero-based index position of <paramref name="value" /> from the start of the current instance if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1875">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1875">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1876">Índice de numeração começa em 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="58835-1876">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="58835-1877">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1877">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="58835-1878">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1878">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span> <span data-ttu-id="58835-1879">A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1879">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="58835-1880">O caractere na `startIndex`  +  `count` não está incluído na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1880">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="58835-1881">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1881">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-1882">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-1882">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-1883">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="58835-1883">If `value` consists only of one or more ignorable characters, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="58835-1884">No exemplo a seguir, o <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir do terceiro ao sexto posições de caractere em duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1884">In the following example, the <xref:System.String.IndexOf%28System.String%2CSystem.Int32%2CSystem.Int32%29> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings.</span></span> <span data-ttu-id="58835-1885">Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária.</span><span class="sxs-lookup"><span data-stu-id="58835-1885">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="58835-1886">Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1886">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="58835-1887">No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".</span><span class="sxs-lookup"><span data-stu-id="58835-1887">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.IndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable23.cs#23)]
 [!code-vb[System.String.IndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-1888">O exemplo a seguir localiza o índice de todas as ocorrências da cadeia de caracteres "OL" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1888">The following example finds the index of all occurrences of the string "he" within a substring of another string.</span></span> <span data-ttu-id="58835-1889">Observe que o número de caracteres a serem pesquisadas deve ser recalculado para cada iteração de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1889">Note that the number of characters to be searched must be recalculated for each search iteration.</span></span>  
  
 [!code-cpp[string.indexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexof8/CPP/ixof8.cpp#1)]
 [!code-csharp[string.indexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexof8/CS/ixof8.cs#1)]
 [!code-vb[string.indexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexof8/VB/ixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1890">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1890">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1891">
            <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1891">
              <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1892">-ou- <paramref name="startIndex" /> é maior que o tamanho dessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1892">-or-  <paramref name="startIndex" /> is greater than the length of this string.</span>
          </span>
          <span data-ttu-id="58835-1893">-ou- <paramref name="count" /> é maior que o tamanho dessa cadeia de caracteres menos <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1893">-or-  <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1894">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para usar as regras de comparação da cultura atual para executar esta operação, chame o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para o parâmetro 'comparisonType'.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1894">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To use the comparison rules of the current culture to perform this operation, call the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its `comparisonType` parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1895">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1895">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1896">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1896">The search starting position.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1897">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1897">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1898">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1898">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span>
          </span>
          <span data-ttu-id="58835-1899">Os parâmetros especificam a posição de pesquisa inicial na cadeia de caracteres atual e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1899">Parameters specify the starting search position in the current string and the type of search to use for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1900">A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1900">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1901">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1901">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1902">Índice de numeração começa em 0.</span><span class="sxs-lookup"><span data-stu-id="58835-1902">Index numbering starts from 0.</span></span> <span data-ttu-id="58835-1903">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1903">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span> <span data-ttu-id="58835-1904">Se `startIndex` for igual ao comprimento da instância de cadeia de caracteres, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1904">If `startIndex` equals the length of the string instance, the method returns -1.</span></span>  
  
 <span data-ttu-id="58835-1905">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-1905">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1906">A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1906">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1907">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1907">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1908">
            <paramref name="startIndex" /> é menor que 0 (zero) ou maior que o tamanho dessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1908">
              <paramref name="startIndex" /> is less than 0 (zero) or greater than the length of this string.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1909">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1909">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1910">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir da posição do terceiro caractere duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método retorna o índice do hífen na primeira cadeia de caracteres somente quando ele executa uma comparação ordinal.  [! código csharp [System.String.IndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.IndexOf/CS/ignorable25.cs#25)] [! código vb [System.String.IndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.IndexOf/VB/ignorable25.vb#25)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1910">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting with the third character position in two strings. Only one of the strings contains the required substring.If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m". The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  [!code-csharp[System.String.IndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable25.cs#25)] [!code-vb[System.String.IndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable25.vb#25)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public int IndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.IndexOf : string * int * int * StringComparison -&gt; int" Usage="string.IndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-1911">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1911">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1912">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1912">The search starting position.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-1913">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1913">The number of character positions to examine.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-1914">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1914">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1915">Relata o índice baseado em zero da primeira ocorrência da cadeia de caracteres especificada no objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1915">Reports the zero-based index of the first occurrence of the specified string in the current <see cref="T:System.String" /> object.</span>
          </span>
          <span data-ttu-id="58835-1916">Parâmetros especificam a posição inicial de pesquisa na cadeia de caracteres de atual, o número de caracteres na cadeia de caracteres atual para pesquisar e o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1916">Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1917">A posição de índice baseado em zero do parâmetro <paramref name="value" /> do início da instância atual se essa cadeia de caracteres for encontrada; caso contrário, -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1917">The zero-based index position of the <paramref name="value" /> parameter from the start of the current instance if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-1918">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1918">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1919">Índice de numeração começa em 0 (zero).</span><span class="sxs-lookup"><span data-stu-id="58835-1919">Index numbering starts from 0 (zero).</span></span> <span data-ttu-id="58835-1920">O parâmetro `startIndex` pode variar de 0 ao tamanho da instância da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1920">The `startIndex` parameter can range from 0 to the length of the string instance.</span></span>  
  
 <span data-ttu-id="58835-1921">A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1921">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="58835-1922">O caractere na `startIndex`  +  `count` não está incluído na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1922">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="58835-1923">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-1923">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1924">A seguir exampledemonstrates três sobrecargas do <xref:System.String.IndexOf%2A> método de localizar a primeira ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-1924">The following exampledemonstrates three overloads of the <xref:System.String.IndexOf%2A> method that find the first occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.IndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.IndexOfCmp/cs/iocmp.cs#1)]
 [!code-vb[system.string.IndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.IndexOfCmp/vb/iocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1925">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1925">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1926">
            <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1926">
              <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1927">-ou- <paramref name="startIndex" /> é maior que o tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1927">-or-  <paramref name="startIndex" /> is greater than the length of this instance.</span>
          </span>
          <span data-ttu-id="58835-1928">-ou- <paramref name="count" /> é maior que o tamanho dessa cadeia de caracteres menos <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1928">-or-  <paramref name="count" /> is greater than the length of this string minus <paramref name="startIndex" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-1929">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1929">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-1930">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  No exemplo a seguir, o <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m" a partir do terceiro ao sexto posições de caractere em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen, seguido por um "m", o método não retorna o índice do hífen virtual, mas em vez disso, retorna o índice do "m", quando ele executa uma comparação sensível à cultura. O método retorna o índice do hífen na primeira cadeia de caracteres somente quando ele executa uma comparação ordinal.  [! código csharp [System.String.IndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.IndexOf/CS/ignorable24.cs#24)] [! código vb [System.String.IndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.IndexOf/VB/ignorable24.vb#24)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1930">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  In the following example, the <see cref="M:System.String.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" starting in the third through sixth character positions in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. When it performs an ordinal comparison, however, it finds the substring only in the first string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison. The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  [!code-csharp[System.String.IndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.IndexOf/CS/ignorable24.cs#24)] [!code-vb[System.String.IndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.IndexOf/VB/ignorable24.vb#24)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-1931">Relata o índice da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1931">Reports the index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span>
          </span>
          <span data-ttu-id="58835-1932">O método retorna -1 caso os caracteres na matriz não sejam encontrados nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1932">The method returns -1 if the characters in the array are not found in this instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] -&gt; int" Usage="string.IndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-1933">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1933">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1934">Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1934">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1935">A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1935">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1936">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1936">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-1937">A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-1937">The search for `anyOf` is case-sensitive.</span></span> <span data-ttu-id="58835-1938">Se `anyOf` é uma matriz vazia, localiza o método uma correspondência no início da cadeia de caracteres (ou seja, no índice zero).</span><span class="sxs-lookup"><span data-stu-id="58835-1938">If `anyOf` is an empty array, the method finds a match at the beginning of the string (that  is, at index zero).</span></span>  
  
 <span data-ttu-id="58835-1939">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-1939">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-1940">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1940">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1941">O exemplo a seguir localiza a primeira vogal em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1941">The following example finds the first vowel in a string.</span></span>  
  
 [!code-csharp[System.String.IndexOfAny#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.IndexOfAny/cs/IndexOfAny1.cs#1)]
 [!code-vb[System.String.IndexOfAny#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.IndexOfAny/vb/IndexOfAny1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1942">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1942">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-1943">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1943">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1944">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1944">The search starting position.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1945">Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1945">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span>
          </span>
          <span data-ttu-id="58835-1946">A pesquisa é iniciada em uma posição de caractere especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1946">The search starts at a specified character position.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1947">A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1947">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1948">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1948">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-1949">O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1949">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="58835-1950">A pesquisa varia de `startIndex` até o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1950">The search ranges from `startIndex` to the end of the string.</span></span>  
  
 <span data-ttu-id="58835-1951">A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-1951">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-1952">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo.</span><span class="sxs-lookup"><span data-stu-id="58835-1952">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="58835-1953">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1953">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1954">O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1954">The following example finds the index of the occurrence of any character of the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany2/CPP/ixany2.cpp#1)]
 [!code-csharp[string.indexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany2/CS/ixany2.cs#1)]
 [!code-vb[string.indexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany2/VB/ixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1955">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1955">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1956">
            <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1956">
              <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1957">-ou- <paramref name="startIndex" /> é maior que o número de caracteres dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1957">-or-  <paramref name="startIndex" /> is greater than the number of characters in this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="IndexOfAny">
      <MemberSignature Language="C#" Value="public int IndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function IndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.IndexOfAny : char[] * int * int -&gt; int" Usage="string.IndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-1958">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1958">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-1959">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1959">The search starting position.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-1960">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1960">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1961">Relata o índice baseado em zero da primeira ocorrência nessa instância de qualquer caractere em uma matriz especificada de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1961">Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.</span>
          </span>
          <span data-ttu-id="58835-1962">A pesquisa é iniciada em uma posição de caractere especificada e examina um número especificado de posições de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1962">The search starts at a specified character position and examines a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1963">A posição do índice baseado em zero da primeira ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1963">The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1964">A pesquisa começa em `startIndex` e continua `startIndex`  +  `count` -1.</span><span class="sxs-lookup"><span data-stu-id="58835-1964">The search begins at `startIndex` and continues to `startIndex` + `count` -1.</span></span> <span data-ttu-id="58835-1965">O caractere na `startIndex`  +  `count` não está incluído na pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-1965">The character at `startIndex` + `count` is not included in the search.</span></span>  
  
 <span data-ttu-id="58835-1966">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-1966">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-1967">O `startIndex` parâmetro pode variar de 0 a menos que o comprimento da instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1967">The `startIndex` parameter can range from 0 to one less than the length of the string instance.</span></span>  
  
 <span data-ttu-id="58835-1968">A pesquisa de `anyOf` diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-1968">The search for `anyOf` is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-1969">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo.</span><span class="sxs-lookup"><span data-stu-id="58835-1969">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="58835-1970">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-1970">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.IndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1971">O exemplo a seguir localiza o índice da ocorrência de qualquer caractere da "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1971">The following example finds the index of the occurrence of any character of the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.indexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.indexofany3/CPP/ixany3.cpp#1)]
 [!code-csharp[string.indexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.indexofany3/CS/ixany3.cs#1)]
 [!code-vb[string.indexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.indexofany3/VB/ixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1972">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1972">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1973">
            <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1973">
              <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-1974">-ou- <paramref name="count" /> + <paramref name="startIndex" /> é maior que o número de caracteres dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1974">-or-  <paramref name="count" /> + <paramref name="startIndex" /> is greater than the number of characters in this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Insert">
      <MemberSignature Language="C#" Value="public string Insert (int startIndex, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Insert(int32 startIndex, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Insert(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Insert (startIndex As Integer, value As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Insert(int startIndex, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.Insert : int * string -&gt; string" Usage="string.Insert (startIndex, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-1975">A posição de índice baseado em zero da inserção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1975">The zero-based index position of the insertion.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="58835-1976">A cadeia de caracteres a ser inserida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1976">The string to insert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1977">Retorna uma nova cadeia de caracteres na qual uma cadeia de caracteres especificada é inserida em uma posição de índice especificada nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1977">Returns a new string in which a specified string is inserted at a specified index position in this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1978">Uma nova cadeia de caracteres equivalente a esta instância, mas com <paramref name="value" /> inserido na posição <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1978">A new string that is equivalent to this instance, but with <paramref name="value" /> inserted at position <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1979">Se `startIndex` é igual ao comprimento dessa instância, `value` é acrescentado ao final dessa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-1979">If `startIndex` is equal to the length of this instance, `value` is appended to the end of this instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-1980">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1980">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-1981">Em vez disso, ele retorna uma nova cadeia de caracteres na qual `value` é inserida na instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-1981">Instead, it returns a new string in which `value` is inserted into the current instance.</span></span>  
  
 <span data-ttu-id="58835-1982">Por exemplo, o valor de retorno `"abc".Insert(2, "XYZ")` é "abXYZc".</span><span class="sxs-lookup"><span data-stu-id="58835-1982">For example, the return value of `"abc".Insert(2, "XYZ")` is "abXYZc".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-1983">O exemplo a seguir insere um caractere de espaço em que a quarta posição de caractere (o caractere no índice 3) de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1983">The following example inserts a space character in the fourth character position (the character at index 3) of a string.</span></span>  
  
 [!code-csharp[System.String.Insert#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Insert/cs/Insert1.cs#1)]
 [!code-vb[System.String.Insert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Insert/vb/Insert1.vb#1)]  
  
 <span data-ttu-id="58835-1984">O aplicativo de console a seguir solicita que os usuários insiram um ou mais adjetivos para descrever dois animais.</span><span class="sxs-lookup"><span data-stu-id="58835-1984">The following console application prompts the users to enter one or more adjectives to describe two animals.</span></span> <span data-ttu-id="58835-1985">Em seguida, ele chama o <xref:System.String.Insert%2A> método para inserir o texto inserido pelo usuário em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-1985">It then calls the <xref:System.String.Insert%2A> method to insert the text entered by the user into a string.</span></span>  
  
 [!code-cpp[stringinsert#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringinsert/CPP/stringinsert.cpp#1)]
 [!code-csharp[stringinsert#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringinsert/CS/stringinsert.cs#1)]
 [!code-vb[stringinsert#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringinsert/VB/stringinsert.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-1986">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1986">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-1987">
            <paramref name="startIndex" /> é negativo ou maior que o comprimento dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1987">
              <paramref name="startIndex" /> is negative or greater than the length of this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.CopyTo(System.Int32,System.Char[],System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Intern">
      <MemberSignature Language="C#" Value="public static string Intern (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Intern(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Intern(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Intern (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Intern(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member Intern : string -&gt; string" Usage="System.string.Intern str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">
          <span data-ttu-id="58835-1988">Uma cadeia de caracteres para pesquisar no pool interno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1988">A string to search for in the intern pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-1989">Recupera a referência do sistema para o <see cref="T:System.String" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1989">Retrieves the system's reference to the specified <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-1990">A referência do sistema para <paramref name="str" />, se interno; caso contrário, uma nova referência para uma cadeia de caracteres com o valor de <paramref name="str" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-1990">The system's reference to <paramref name="str" />, if it is interned; otherwise, a new reference to a string with the value of <paramref name="str" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-1991">O common language runtime preserva o armazenamento de cadeia de caracteres por manter uma tabela, o pool interno, que contém uma única referência para cada literal cadeia de caracteres exclusiva declarados ou criado por meio de programação em seu programa de chamada.</span><span class="sxs-lookup"><span data-stu-id="58835-1991">The common language runtime conserves string storage by maintaining a table, called the intern pool, that contains a single reference to each unique literal string declared or created programmatically in your program.</span></span> <span data-ttu-id="58835-1992">Consequentemente, uma instância de uma cadeia de caracteres literal com um valor específico existe somente uma vez no sistema.</span><span class="sxs-lookup"><span data-stu-id="58835-1992">Consequently, an instance of a literal string with a particular value only exists once in the system.</span></span>  
  
 <span data-ttu-id="58835-1993">Por exemplo, se você atribuir a mesma cadeia de caracteres literal a diversas variáveis, o tempo de execução recupera a mesma referência para a cadeia de caracteres literal do pool interno e atribui a cada variável.</span><span class="sxs-lookup"><span data-stu-id="58835-1993">For example, if you assign the same literal string to several variables, the runtime retrieves the same reference to the literal string from the intern pool and assigns it to each variable.</span></span>  
  
 <span data-ttu-id="58835-1994">O <xref:System.String.Intern%2A> método usa o pool interno para pesquisar uma cadeia de caracteres igual ao valor de `str`.</span><span class="sxs-lookup"><span data-stu-id="58835-1994">The <xref:System.String.Intern%2A> method uses the intern pool to search for a string equal to the value of `str`.</span></span> <span data-ttu-id="58835-1995">Se existir uma cadeia de caracteres, sua referência no pool interno é retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-1995">If such a string exists, its reference in the intern pool is returned.</span></span> <span data-ttu-id="58835-1996">Se a cadeia de caracteres não existir, uma referência a `str` é adicionado ao pool interno, em seguida, essa referência é retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-1996">If the string does not exist, a reference to `str` is added to the intern pool, then that reference is returned.</span></span>  
  
 <span data-ttu-id="58835-1997">No exemplo a seguir, a cadeia de caracteres s1, que tem um valor de "MyTest", já é internalizadas porque ele é um literal no programa.</span><span class="sxs-lookup"><span data-stu-id="58835-1997">In the following example, the string s1, which has a value of "MyTest", is already interned because it is a literal in the program.</span></span> <span data-ttu-id="58835-1998">O <xref:System.Text.StringBuilder?displayProperty=nameWithType> classe gera um novo objeto de cadeia de caracteres que tem o mesmo valor de s1.</span><span class="sxs-lookup"><span data-stu-id="58835-1998">The <xref:System.Text.StringBuilder?displayProperty=nameWithType> class generates a new string object that has the same value as s1.</span></span> <span data-ttu-id="58835-1999">Uma referência a essa cadeia de caracteres é atribuída para s2.</span><span class="sxs-lookup"><span data-stu-id="58835-1999">A reference to that string is assigned to s2.</span></span> <span data-ttu-id="58835-2000">O <xref:System.String.Intern%2A> método procura uma cadeia de caracteres que tem o mesmo valor de s2.</span><span class="sxs-lookup"><span data-stu-id="58835-2000">The <xref:System.String.Intern%2A> method searches for a string that has the same value as s2.</span></span> <span data-ttu-id="58835-2001">Como existe uma cadeia de caracteres, o método retorna a mesma referência é atribuída ao s1.</span><span class="sxs-lookup"><span data-stu-id="58835-2001">Because such a string exists, the method returns the same reference that is assigned to s1.</span></span> <span data-ttu-id="58835-2002">Essa referência, em seguida, é atribuída ao s3.</span><span class="sxs-lookup"><span data-stu-id="58835-2002">That reference is then assigned to s3.</span></span> <span data-ttu-id="58835-2003">Referências s1 e S2 comparam diferentes porque elas se referem a objetos diferentes; referências de s1 e s3 comparam como iguais porque elas se referem à mesma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2003">References s1 and s2 compare unequal because they refer to different objects; references s1 and s3 compare equal because they refer to the same string.</span></span>  
  
 [!code-csharp[System.String.Intern#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern1.cs#1)]
 [!code-vb[System.String.Intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern1.vb#1)]  
  
 <span data-ttu-id="58835-2004">Compare este método para o <xref:System.String.IsInterned%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2004">Compare this method to the <xref:System.String.IsInterned%2A> method.</span></span>  
  
## <a name="version-considerations"></a><span data-ttu-id="58835-2005">Considerações da versão</span><span class="sxs-lookup"><span data-stu-id="58835-2005">Version Considerations</span></span>  
 <span data-ttu-id="58835-2006">No [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], o <xref:System.String.Intern%2A> método será revertido para seu comportamento no .NET Framework 1.0 e 1.1 em relação à centralização da cadeia de caracteres vazia.</span><span class="sxs-lookup"><span data-stu-id="58835-2006">In the [!INCLUDE[net_v35SP1_long](~/includes/net-v35sp1-long-md.md)], the <xref:System.String.Intern%2A> method reverts to its behavior in the .NET Framework 1.0 and 1.1 with regard to interning the empty string.</span></span> <span data-ttu-id="58835-2007">No exemplo a seguir, a variável `str1` for atribuído a uma referência ao <xref:System.String.Empty>e a variável `str2` é atribuído a referência ao <xref:System.String.Empty> que é retornado ao chamar o <xref:System.String.Intern%2A> método depois de converter um <xref:System.Text.StringBuilder>objeto cujo valor é <xref:System.String.Empty> para uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2007">In the following example, the variable `str1` is assigned a reference to <xref:System.String.Empty>, and the variable `str2` is assigned the reference to <xref:System.String.Empty> that is returned by calling the <xref:System.String.Intern%2A> method after converting a <xref:System.Text.StringBuilder> object whose value is <xref:System.String.Empty> to a string.</span></span> <span data-ttu-id="58835-2008">Em seguida, as referências contidas `str1` e `str2` são comparadas quanto à igualdade.</span><span class="sxs-lookup"><span data-stu-id="58835-2008">Then the references contained in `str1` and `str2` are compared for equality.</span></span>  
  
 [!code-csharp[System.String.Intern#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Intern/cs/Intern2.cs#2)]
 [!code-vb[System.String.Intern#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Intern/vb/Intern2.vb#2)]  
  
 <span data-ttu-id="58835-2009">No [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], e [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` e `str2` são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2009">In the [!INCLUDE[net_v10_short](~/includes/net-v10-short-md.md)], [!INCLUDE[net_v11_short](~/includes/net-v11-short-md.md)], and [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)], `str1` and `str2` are equal.</span></span> <span data-ttu-id="58835-2010">No [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] e [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` e `str2` não são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2010">In the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)] and [!INCLUDE[net_v30_long](~/includes/net-v30-long-md.md)], `str1` and `str2` are not equal.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2011">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2011">Performance Considerations</span></span>  
 <span data-ttu-id="58835-2012">Se você estiver tentando reduzir a quantidade total de memória aloca de seu aplicativo, tenha em mente que a centralização de uma cadeia de caracteres tem dois efeitos colaterais indesejados.</span><span class="sxs-lookup"><span data-stu-id="58835-2012">If you are trying to reduce the total amount of memory your application allocates, keep in mind that interning a string has two unwanted side effects.</span></span> <span data-ttu-id="58835-2013">Em primeiro lugar, a memória alocada para internalizadas <xref:System.String> objetos não é provavelmente ser liberado até que o common language runtime (CLR) seja encerrado.</span><span class="sxs-lookup"><span data-stu-id="58835-2013">First, the memory allocated for interned <xref:System.String> objects is not likely be released until the common language runtime (CLR) terminates.</span></span> <span data-ttu-id="58835-2014">A razão é que a referência do CLR para o interno <xref:System.String> object pode persistir após seu aplicativo ou até mesmo seu domínio de aplicativo, será encerrado.</span><span class="sxs-lookup"><span data-stu-id="58835-2014">The reason is that the CLR's reference to the interned <xref:System.String> object can persist after your application, or even your application domain, terminates.</span></span> <span data-ttu-id="58835-2015">Em segundo lugar, para o estágio de uma cadeia de caracteres, você deve primeiro criar a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2015">Second, to intern a string, you must first create the string.</span></span> <span data-ttu-id="58835-2016">A memória usada pelo <xref:System.String> objeto ainda deve ser alocado, mesmo que a memória eventualmente será coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="58835-2016">The memory used by the <xref:System.String> object must still be allocated, even though the memory will eventually be garbage collected.</span></span>  
  
 <span data-ttu-id="58835-2017">O .NET Framework versão 2.0 introduz o <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> membro de enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2017">The .NET Framework version 2.0 introduces the <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning?displayProperty=nameWithType> enumeration member.</span></span> <span data-ttu-id="58835-2018">O <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> membro marca um assembly como não exigindo centralização da cadeia de caracteres literal.</span><span class="sxs-lookup"><span data-stu-id="58835-2018">The <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> member marks an assembly as not requiring string-literal interning.</span></span> <span data-ttu-id="58835-2019">Você pode aplicar <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> a um assembly usando o <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="58835-2019">You can apply <xref:System.Runtime.CompilerServices.CompilationRelaxations.NoStringInterning> to an assembly using the <xref:System.Runtime.CompilerServices.CompilationRelaxationsAttribute> attribute.</span></span> <span data-ttu-id="58835-2020">Além disso, quando você usa o [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para compilar um assembly com antecedência sobre o tempo de execução, cadeias de caracteres não são internalizadas nos módulos.</span><span class="sxs-lookup"><span data-stu-id="58835-2020">Also, when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to compile an assembly in advance of run time, strings are not interned across modules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2021">O exemplo a seguir usa três cadeias de caracteres são iguais em valor para determinar se uma cadeia de caracteres criada recentemente e uma cadeia de caracteres interno são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2021">The following example uses three strings that are equal in value to determine whether a newly created string and an interned string are equal.</span></span>  
  
 [!code-cpp[string.intern#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.intern/CPP/string_intern.cpp#1)]
 [!code-csharp[string.intern#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.intern/CS/string_intern.cs#1)]
 [!code-vb[string.intern#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.intern/VB/string_intern.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2022">
            <paramref name="str" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2022">
              <paramref name="str" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.IsInterned(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsInterned">
      <MemberSignature Language="C#" Value="public static string IsInterned (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string IsInterned(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsInterned(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInterned (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ IsInterned(System::String ^ str);" />
      <MemberSignature Language="F#" Value="static member IsInterned : string -&gt; string" Usage="System.string.IsInterned str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">
          <span data-ttu-id="58835-2023">A cadeia de caracteres para pesquisar no pool interno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2023">The string to search for in the intern pool.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2024">Recupera uma referência a um <see cref="T:System.String" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2024">Retrieves a reference to a specified <see cref="T:System.String" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2025">Uma referência a <paramref name="str" /> se ele estiver no pool interno de Common Language Runtime; caso contrário, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2025">A reference to <paramref name="str" /> if it is in the common language runtime intern pool; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2026">O common language runtime mantém automaticamente uma tabela, chamada pool interno, que contém uma única instância de cada constante de literal de cadeia de caracteres exclusiva declarado em um programa, bem como qualquer instância exclusiva do <xref:System.String> você adicionar programaticamente chamando o <xref:System.String.Intern%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2026">The common language runtime automatically maintains a table, called the intern pool, which contains a single instance of each unique literal string constant declared in a program, as well as any unique instance of <xref:System.String> you add programmatically by calling the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="58835-2027">Armazenamento de cadeia de caracteres preserva a pool interno.</span><span class="sxs-lookup"><span data-stu-id="58835-2027">The intern pool conserves string storage.</span></span> <span data-ttu-id="58835-2028">Se você atribuir uma constante de cadeia de caracteres literal a diversas variáveis, cada variável é definida para referenciar a mesma constante no pool interno em vez de referenciar várias instâncias diferentes do <xref:System.String> que têm valores idênticos.</span><span class="sxs-lookup"><span data-stu-id="58835-2028">If you assign a literal string constant to several variables, each variable is set to reference the same constant in the intern pool instead of referencing several different instances of <xref:System.String> that have identical values.</span></span>  
  
 <span data-ttu-id="58835-2029">Este método pesquisa `str` no pool interno.</span><span class="sxs-lookup"><span data-stu-id="58835-2029">This method looks up `str` in the intern pool.</span></span> <span data-ttu-id="58835-2030">Se `str` já foi internalizadas, uma referência a essa instância é retornado; caso contrário, `null` será retornado.</span><span class="sxs-lookup"><span data-stu-id="58835-2030">If `str` has already been interned, a reference to that instance is returned; otherwise, `null` is returned.</span></span>  
  
 <span data-ttu-id="58835-2031">Compare este método para o <xref:System.String.Intern%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2031">Compare this method to the <xref:System.String.Intern%2A> method.</span></span>  
  
 <span data-ttu-id="58835-2032">Esse método não retorna um valor booliano.</span><span class="sxs-lookup"><span data-stu-id="58835-2032">This method does not return a Boolean value.</span></span> <span data-ttu-id="58835-2033">Se você chamar o método porque você deseja que um valor booliano que indica se uma determinada cadeia de caracteres é internalizada, você pode usar código como o seguinte.</span><span class="sxs-lookup"><span data-stu-id="58835-2033">If you call the method because you want a Boolean value that indicates whether a particular string is interned, you can use code such as the following.</span></span>  
  
 [!code-csharp[System.String.IsInterned#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isinterned/cs/isinternedex1.cs#1)]
 [!code-vb[System.String.IsInterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isinterned/vb/isinternedex1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="58835-2034">Começando com o .NET Framework versão 2.0, você pode substituir o uso do pool interno de quando você usa o [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) para instalar um assembly no cache de imagem nativa em um computador local.</span><span class="sxs-lookup"><span data-stu-id="58835-2034">Starting with the .NET Framework version 2.0, you can override the use of the intern pool when you use the [Ngen.exe (Native Image Generator)](~/docs/framework/tools/ngen-exe-native-image-generator.md) to install an assembly to the native image cache on a local computer.</span></span> <span data-ttu-id="58835-2035">Para obter mais informações, consulte Considerações de desempenho na seção comentários para o <xref:System.String.Intern%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="58835-2035">For more information, see Performance Considerations in the Remarks section for the <xref:System.String.Intern%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2036">O exemplo a seguir demonstra que as cadeias de caracteres literais sejam internalizadas automaticamente pelo compilador.</span><span class="sxs-lookup"><span data-stu-id="58835-2036">The following example demonstrates that literal strings are interned automatically by the compiler.</span></span>  
  
 [!code-cpp[string.isinterned#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isinterned/CPP/isin.cpp#1)]
 [!code-csharp[string.isinterned#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isinterned/CS/isin.cs#1)]
 [!code-vb[string.isinterned#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isinterned/VB/isin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2037">
            <paramref name="str" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2037">
              <paramref name="str" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Intern(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IsNormalized">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2038">Indica se esta cadeia de caracteres está em um formulário de normalização Unicode específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2038">Indicates whether this string is in a particular Unicode normalization form.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized" />
      <MemberSignature Language="VB.NET" Value="Public Function IsNormalized () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized();" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : unit -&gt; bool" Usage="string.IsNormalized " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-2039">Indica se essa cadeia de caracteres está no formulário C de normalização Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2039">Indicates whether this string is in Unicode normalization form C.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2040">
            <see langword="true" /> se essa cadeia de caracteres estiver no formulário C de normalização; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2040">
              <see langword="true" /> if this string is in normalization form C; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2041">Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos.</span><span class="sxs-lookup"><span data-stu-id="58835-2041">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="58835-2042">A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.</span><span class="sxs-lookup"><span data-stu-id="58835-2042">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="58835-2043">O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2043">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="58835-2044">A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-2044">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="58835-2045">O .NET Framework dá suporte aos formulários de normalização C, D, KC e KD no momento.</span><span class="sxs-lookup"><span data-stu-id="58835-2045">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="58835-2046">Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2046">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2047">O exemplo a seguir determina se uma cadeia de caracteres com êxito é normalizada para várias formas de normalização.</span><span class="sxs-lookup"><span data-stu-id="58835-2047">The following example determines whether a string is successfully normalized to various normalization forms.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2048">A instância atual contém caracteres Unicode inválidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2048">The current instance contains invalid Unicode characters.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2049">
            <para>O <see cref="Overload:System.String.IsNormalized" /> método retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2049">
              <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNormalized">
      <MemberSignature Language="C#" Value="public bool IsNormalized (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsNormalized(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNormalized(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsNormalized(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.IsNormalized : System.Text.NormalizationForm -&gt; bool" Usage="string.IsNormalized normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">
          <span data-ttu-id="58835-2050">Um formato de normalização Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2050">A Unicode normalization form.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2051">Indica se esta cadeia de caracteres está no formulário de normalização Unicode especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2051">Indicates whether this string is in the specified Unicode normalization form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2052">
            <see langword="true" /> se esta cadeia de caracteres estiver no formulário de normalização especificado pelo parâmetro <paramref name="normalizationForm" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2052">
              <see langword="true" /> if this string is in the normalization form specified by the <paramref name="normalizationForm" /> parameter; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2053">Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos.</span><span class="sxs-lookup"><span data-stu-id="58835-2053">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="58835-2054">A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.</span><span class="sxs-lookup"><span data-stu-id="58835-2054">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="58835-2055">O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2055">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="58835-2056">A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-2056">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="58835-2057">O .NET Framework dá suporte aos formulários de normalização C, D, KC e KD no momento.</span><span class="sxs-lookup"><span data-stu-id="58835-2057">The .NET Framework currently supports normalization forms C, D, KC, and KD.</span></span>  
  
 <span data-ttu-id="58835-2058">Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2058">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2059">O exemplo a seguir demonstra a <xref:System.String.IsNormalized%2A> e <xref:System.String.Normalize%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-2059">The following example demonstrates the <xref:System.String.IsNormalized%2A> and <xref:System.String.Normalize%2A> methods.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2060">A instância atual contém caracteres Unicode inválidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2060">The current instance contains invalid Unicode characters.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2061">
            <para>O <see cref="Overload:System.String.IsNormalized" /> método retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2061">
              <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.Normalize" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrEmpty">
      <MemberSignature Language="C#" Value="public static bool IsNullOrEmpty (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrEmpty(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrEmpty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrEmpty (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrEmpty(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrEmpty : string -&gt; bool" Usage="System.string.IsNullOrEmpty value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2062">A cadeia de caracteres a ser testada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2062">The string to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2063">Indica se a cadeia de caracteres especificada é <see langword="null" /> ou uma cadeia de caracteres <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2063">Indicates whether the specified string is <see langword="null" /> or an <see cref="F:System.String.Empty" /> string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2064">
            <see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou uma cadeia de caracteres vazia (""); caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2064">
              <see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or an empty string (""); otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2065"><xref:System.String.IsNullOrEmpty%2A> é um método de conveniência que permite que você teste simultaneamente se um <xref:System.String> está `null` ou seu valor é <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-2065"><xref:System.String.IsNullOrEmpty%2A> is a convenience method that enables you to simultaneously test whether a <xref:System.String> is `null` or its value is <xref:System.String.Empty>.</span></span> <span data-ttu-id="58835-2066">É equivalente ao seguinte código:</span><span class="sxs-lookup"><span data-stu-id="58835-2066">It is equivalent to the following code:</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/isnullorempty1.cpp#1)]
 [!code-csharp[System.String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/isnullorempty1.cs#1)]
 [!code-vb[System.String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/isnullorempty1.vb#1)]  
  
 <span data-ttu-id="58835-2067">Você pode usar o <xref:System.String.IsNullOrWhiteSpace%2A> método para testar se é uma cadeia de caracteres `null`, seu valor é <xref:System.String.Empty?displayProperty=nameWithType>, ou consiste apenas em caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2067">You can use the <xref:System.String.IsNullOrWhiteSpace%2A> method to test whether a string is `null`, its value is <xref:System.String.Empty?displayProperty=nameWithType>,  or it consists only of white-space characters.</span></span>  
  
## <a name="what-is-a-null-string"></a><span data-ttu-id="58835-2068">O que é uma cadeia de caracteres nula?</span><span class="sxs-lookup"><span data-stu-id="58835-2068">What is a null string?</span></span>  
 <span data-ttu-id="58835-2069">É uma cadeia de caracteres `null` se ele não tiver sido atribuído um valor (em C++ e Visual Basic) ou se tiver sido atribuído explicitamente um valor de `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2069">A string is `null` if it has not been assigned a value (in C++ and Visual Basic) or if has explicitly been assigned a value of `null`.</span></span> <span data-ttu-id="58835-2070">Embora o [formatação composta](~/docs/standard/base-types/composite-formatting.md) recurso tratar normalmente uma cadeia de caracteres nula, como mostra o exemplo abaixo, tentar chame um se seus membros lança um <xref:System.NullReferenceException>.</span><span class="sxs-lookup"><span data-stu-id="58835-2070">Although the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature can gracefully handle a null string, as the following example shows, attempting to call one if its members throws a <xref:System.NullReferenceException>.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#2)]
 [!code-csharp[System.String.IsNullOrEmpty#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#2)]
 [!code-vb[System.String.IsNullOrEmpty#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#2)]  
  
## <a name="what-is-an-empty-string"></a><span data-ttu-id="58835-2071">O que é uma cadeia de caracteres vazia?</span><span class="sxs-lookup"><span data-stu-id="58835-2071">What is an empty string?</span></span>  
 <span data-ttu-id="58835-2072">Uma cadeia de caracteres estará vazia se ele for explicitamente atribuído a uma cadeia de caracteres vazia ("") ou <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2072">A string is empty if it  is explicitly assigned an empty string ("") or <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-2073">Uma cadeia de caracteres vazia tem um <xref:System.String.Length%2A> igual a 0.</span><span class="sxs-lookup"><span data-stu-id="58835-2073">An empty string has a <xref:System.String.Length%2A> of 0.</span></span>  <span data-ttu-id="58835-2074">O exemplo a seguir cria uma cadeia de caracteres vazia e exibe seu valor e seu comprimento.</span><span class="sxs-lookup"><span data-stu-id="58835-2074">The following example creates an empty string and displays its value and its length.</span></span>  
  
 [!code-cpp[System.String.IsNullOrEmpty#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.isnullorempty/cpp/NullString1.cpp#3)]
 [!code-csharp[System.String.IsNullOrEmpty#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorempty/cs/NullString1.cs#3)]
 [!code-vb[System.String.IsNullOrEmpty#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorempty/vb/NullString1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2075">O exemplo a seguir examina três cadeias de caracteres e determina se cada cadeia de caracteres tem um valor, é uma cadeia de caracteres vazia ou é `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2075">The following example examines three strings and determines whether each string has a value, is an empty string, or is `null`.</span></span>  
  
 [!code-cpp[String.IsNullOrEmpty#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.isNullOrEmpty/CPP/inoe.cpp#1)]
 [!code-csharp[String.IsNullOrEmpty#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.isNullOrEmpty/CS/inoe.cs#1)]
 [!code-vb[String.IsNullOrEmpty#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.isNullOrEmpty/VB/inoe.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrWhiteSpace(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="IsNullOrWhiteSpace">
      <MemberSignature Language="C#" Value="public static bool IsNullOrWhiteSpace (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNullOrWhiteSpace(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.IsNullOrWhiteSpace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNullOrWhiteSpace (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNullOrWhiteSpace(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member IsNullOrWhiteSpace : string -&gt; bool" Usage="System.string.IsNullOrWhiteSpace value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2076">A cadeia de caracteres a ser testada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2076">The string to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2077">Indica se uma cadeia de caracteres especificada é <see langword="null" />, vazia ou consiste apenas em caracteres de espaço em branco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2077">Indicates whether a specified string is <see langword="null" />, empty, or consists only of white-space characters.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2078">
            <see langword="true" /> se o parâmetro <paramref name="value" /> for <see langword="null" /> ou <see cref="F:System.String.Empty" />, ou se <paramref name="value" /> consistir exclusivamente em caracteres de espaço em branco.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2078">
              <see langword="true" /> if the <paramref name="value" /> parameter is <see langword="null" /> or <see cref="F:System.String.Empty" />, or if <paramref name="value" /> consists exclusively of white-space characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2079"><xref:System.String.IsNullOrWhiteSpace%2A> é um método de conveniência que é semelhante ao código a seguir, exceto que ele oferece desempenho superior:</span><span class="sxs-lookup"><span data-stu-id="58835-2079"><xref:System.String.IsNullOrWhiteSpace%2A> is a convenience method that is similar to the following  code, except that it offers superior performance:</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhitespace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace.cs#2)]
 [!code-vb[System.String.IsNullOrWhitespace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace.vb#2)]  
  
 <span data-ttu-id="58835-2080">Os caracteres de espaço em branco são definidos pelo padrão Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-2080">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="58835-2081">O <xref:System.String.IsNullOrWhiteSpace%2A> método interpreta qualquer caractere que retorna um valor de `true` quando ele é passado para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método como um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2081">The <xref:System.String.IsNullOrWhiteSpace%2A> method interprets any character that returns a value of `true` when it is passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method as a white-space character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2082">O exemplo a seguir cria uma matriz de cadeia de caracteres e, em seguida, passa cada elemento da matriz para o <xref:System.String.IsNullOrWhiteSpace%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2082">The following example creates a string array, and then passes each element of the array to the <xref:System.String.IsNullOrWhiteSpace%2A> method.</span></span>  
  
 [!code-csharp[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.isnullorwhitespace/cs/isnullorwhitespace1.cs#1)]
 [!code-vb[System.String.IsNullOrWhiteSpace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.isnullorwhitespace/vb/isnullorwhitespace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.IsNullOrEmpty(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2083">Concatena os elementos de uma matriz especificada ou os membros de uma coleção, usando o separador especificado entre cada elemento ou membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2083">Concatenates the elements of a specified array or the members of a collection, using the specified separator between each element or member.</span>
          </span>
        </summary>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, System.Collections.Generic.IEnumerable&lt;string&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, class System.Collections.Generic.IEnumerable`1&lt;string&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Collections.Generic.IEnumerable{System.String})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, values As IEnumerable(Of String)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;System::String ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;string&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2084">A cadeia de caracteres a ser usada como um separador.<c>separator</c> estará incluída na cadeia de caracteres retornada somente se <c>values</c> tiver mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2084">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span>
          </span>
        </param>
        <param name="values">
          <span data-ttu-id="58835-2085">Uma coleção que contém as cadeias de caracteres a serem concatenadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2085">A collection that contains the strings to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2086">Concatena os membros de uma coleção de <see cref="T:System.Collections.Generic.IEnumerable`1" /> construída do tipo <see cref="T:System.String" />, usando o separador especificado entre cada membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2086">Concatenates the members of a constructed <see cref="T:System.Collections.Generic.IEnumerable`1" /> collection of type <see cref="T:System.String" />, using the specified separator between each member.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2087">Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2087">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span>
          </span>
          <span data-ttu-id="58835-2088">Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2088">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2089">Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="58835-2089">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="58835-2090">Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-2090">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="58835-2091"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> é um método de conveniência que permite a concatenação de cada elemento em um `IEnumerable(Of String)` coleção sem primeiro converter os elementos em uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2091"><xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> is a convenience method that lets you concatenate each element in an `IEnumerable(Of String)` collection without first converting the elements to a string array.</span></span> <span data-ttu-id="58835-2092">Ele é especialmente útil com expressões de consulta integrada à linguagem LINQ (consulta).</span><span class="sxs-lookup"><span data-stu-id="58835-2092">It is particularly useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="58835-2093">O exemplo a seguir passa um `List(Of String)` objeto que contém as letras maiusculas ou minúsculas do alfabeto para uma expressão lambda que seleciona letras serão igual a ou maior que uma determinada letra (que, no exemplo, é o "M").</span><span class="sxs-lookup"><span data-stu-id="58835-2093">The following example passes a `List(Of String)` object that contains either the uppercase or lowercase letters of the alphabet to a lambda expression that selects letters that are equal to or greater than a particular letter (which, in the example, is "M").</span></span> <span data-ttu-id="58835-2094">O `IEnumerable(Of String)` coleção retornada pela <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método é passado para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método para exibir o resultado como uma única cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2094">The `IEnumerable(Of String)` collection returned by the <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> method is passed to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method to display the result as a single string.</span></span>  
  
 [!code-csharp[System.String.Join#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join4.cs#4)]
 [!code-vb[System.String.Join#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join4.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2095">O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100.</span><span class="sxs-lookup"><span data-stu-id="58835-2095">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="58835-2096">Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo <xref:System.String>, que, em seguida, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2096">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type <xref:System.String>, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Collections.Generic.IEnumerable%7BSystem.String%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join3.cs#3)]
 [!code-vb[System.String.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2097">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2097">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params object[] values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, object[] values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray values As Object()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::Object ^&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * obj[] -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2098">A cadeia de caracteres a ser usada como um separador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2098">The string to use as a separator.</span>
          </span>
          <span data-ttu-id="58835-2099">
            <c>separator</c> estará incluído na cadeia de caracteres retornada apenas se <c>values</c> tiver mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2099">
              <c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span>
          </span>
        </param>
        <param name="values">
          <span data-ttu-id="58835-2100">Uma matriz que contém os elementos a concatenar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2100">An array that contains the elements to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2101">Concatena os elementos de uma matriz de objetos, usando o separador especificado entre cada elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2101">Concatenates the elements of an object array, using the specified separator between each element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2102">Uma cadeia de caracteres composta pelos elementos de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2102">A string that consists of the elements of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span>
          </span>
          <span data-ttu-id="58835-2103">Se <paramref name="values" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2103">If <paramref name="values" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2104">Se `separator` está `null` ou se qualquer elemento de `values` diferente do primeiro elemento é `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usado em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-2104">If `separator` is `null` or if any element of `values` other than the first element is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="58835-2105">Consulte as notas de seção chamadores, se o primeiro elemento da `values` é `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2105">See the Notes for Callers section if the first element of `values` is `null`.</span></span>  
  
 <span data-ttu-id="58835-2106"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> é um método de conveniência que permite a concatenação de cada elemento em uma matriz de objetos sem uma conversão explícita de seus elementos em cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2106"><xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> is a convenience method that lets you concatenate each element in an object array without explicitly converting its elements to strings.</span></span> <span data-ttu-id="58835-2107">A representação de cadeia de caracteres de cada objeto na matriz é derivada por meio da chamada do objeto `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="58835-2107">The string representation of each object in the array is derived by calling that object's `ToString` method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2108">O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100.</span><span class="sxs-lookup"><span data-stu-id="58835-2108">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="58835-2109">Ele atribui o resultado em uma matriz de inteiro, que, em seguida, ele passa para o <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2109">It assigns the result to a integer array, which it then passes to the <xref:System.String.Join%28System.String%2CSystem.Object%5B%5D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join1.cs#1)]
 [!code-vb[System.String.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2110">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2110">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2111">
            <para>Se o primeiro elemento da <paramref name="values" /> está <see langword="null" />, o <see cref="M:System.String.Join(System.String,System.Object[])" /> método concatene os elementos na <paramref name="values" /> , mas retorna <see cref="F:System.String.Empty" />. Um número de soluções alternativas para esse problema está disponível. É a maneira mais fácil atribuir um valor de <see cref="F:System.String.Empty" /> para o primeiro elemento da matriz, como o exemplo a seguir mostra.  [! code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [! code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2111">
              <para>If the first element of <paramref name="values" /> is <see langword="null" />, the <see cref="M:System.String.Join(System.String,System.Object[])" /> method does not concatenate the elements in <paramref name="values" /> but instead returns <see cref="F:System.String.Empty" />. A number of workarounds for this issue are available. The easiest is to assign a value of <see cref="F:System.String.Empty" /> to the first element of the array, as the following example shows.  [!code-csharp[System.String.Join#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/joinfix1.cs#6)] [!code-vb[System.String.Join#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/joinfix1.vb#6)]</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, params string[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, ParamArray value As String()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, ... cli::array &lt;System::String ^&gt; ^ value);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] -&gt; string" Usage="System.string.Join (separator, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2112">A cadeia de caracteres a ser usada como um separador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2112">The string to use as a separator.</span>
          </span>
          <span data-ttu-id="58835-2113">
            <c>separator</c> estará incluído na cadeia de caracteres retornada apenas se <c>value</c> tiver mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2113">
              <c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="58835-2114">Uma matriz que contém os elementos a concatenar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2114">An array that contains the elements to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2115">Concatena todos os elementos de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2115">Concatenates all the elements of a string array, using the specified separator between each element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2116">Uma cadeia de caracteres que consiste nos elementos em <paramref name="value" /> delimitados pela cadeia de caracteres <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2116">A string that consists of the elements in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span>
          </span>
          <span data-ttu-id="58835-2117">Se <paramref name="value" /> for uma matriz vazia, o método retornará <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2117">If <paramref name="value" /> is an empty array, the method returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2118">Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "grape" e "pear" `Join(separator, value)` retorna "apple, laranja, grape, pear".</span><span class="sxs-lookup"><span data-stu-id="58835-2118">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value)` returns "apple, orange, grape, pear".</span></span>  
  
 <span data-ttu-id="58835-2119">Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="58835-2119">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="58835-2120">Se qualquer elemento em `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-2120">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2121">O exemplo a seguir demonstra o <xref:System.String.Join%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2121">The following example demonstrates the <xref:System.String.Join%2A> method.</span></span>  
  
 [!code-cpp[stringjoin#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringjoin/CPP/stringjoin.cpp#1)]
 [!code-csharp[stringjoin#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringjoin/CS/stringjoin.cs#1)]
 [!code-vb[stringjoin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringjoin/VB/stringjoin.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2122">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2122">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (char separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(char separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.Char,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As Char, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(char separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : char * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public static string Join (string separator, string[] value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join(string separator, string[] value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join(System.String,System.String[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join (separator As String, value As String(), startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Join(System::String ^ separator, cli::array &lt;System::String ^&gt; ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Join : string * string[] * int * int -&gt; string" Usage="System.string.Join (separator, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="value" Type="System.String[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2123">A cadeia de caracteres a ser usada como um separador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2123">The string to use as a separator.</span>
          </span>
          <span data-ttu-id="58835-2124">
            <c>separator</c> estará incluído na cadeia de caracteres retornada apenas se <c>value</c> tiver mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2124">
              <c>separator</c> is included in the returned string only if <c>value</c> has more than one element.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="58835-2125">Uma matriz que contém os elementos a concatenar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2125">An array that contains the elements to concatenate.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2126">O primeiro elemento em <c>value</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2126">The first element in <c>value</c> to use.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2127">O número de elementos de <c>value</c> a ser usado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2127">The number of elements of <c>value</c> to use.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2128">Concatena os elementos especificados de uma matriz de cadeia de caracteres usando o separador especificado entre cada elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2128">Concatenates the specified elements of a string array, using the specified separator between each element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2129">Uma cadeia de caracteres que consiste em cadeias de caracteres em <paramref name="value" /> delimitada pela cadeia de caracteres <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2129">A string that consists of the strings in <paramref name="value" /> delimited by the <paramref name="separator" /> string.</span>
          </span>
          <span data-ttu-id="58835-2130">-ou- <see cref="F:System.String.Empty" /> se <paramref name="count" /> for zero, <paramref name="value" /> não tiver elementos ou <paramref name="separator" /> e todos os elementos de <paramref name="value" /> forem <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2130">-or-  <see cref="F:System.String.Empty" /> if <paramref name="count" /> is zero, <paramref name="value" /> has no elements, or <paramref name="separator" /> and all the elements of <paramref name="value" /> are <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2131">Por exemplo, se `separator` é "," e os elementos de `value` são "apple", "laranja", "grape" e "pear" `Join(separator, value, 1, 2)` retorna "laranja, grape".</span><span class="sxs-lookup"><span data-stu-id="58835-2131">For example, if `separator` is ", " and the elements of `value` are "apple", "orange", "grape", and "pear", `Join(separator, value, 1, 2)` returns "orange, grape".</span></span>  
  
 <span data-ttu-id="58835-2132">Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="58835-2132">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="58835-2133">Se qualquer elemento em `value` é `null`, uma cadeia de caracteres vazia é usada em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-2133">If any element in `value` is `null`, an empty string is used instead.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2134">O exemplo a seguir concatena dois elementos de uma matriz de nomes de frutas.</span><span class="sxs-lookup"><span data-stu-id="58835-2134">The following example concatenates two elements from an array of names of fruit.</span></span>  
  
 [!code-cpp[string.join2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.join2/CPP/join2.cpp#1)]
 [!code-csharp[string.join2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.join2/CS/join2.cs#1)]
 [!code-vb[string.join2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.join2/VB/join2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2135">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2135">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2136">
            <paramref name="startIndex" /> ou <paramref name="count" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2136">
              <paramref name="startIndex" /> or <paramref name="count" /> is less than 0.</span>
          </span>
          <span data-ttu-id="58835-2137">-ou- A soma de <paramref name="startIndex" /> e <paramref name="count" /> é maior que o número de elementos em <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2137">-or-  <paramref name="startIndex" /> plus <paramref name="count" /> is greater than the number of elements in <paramref name="value" />.</span>
          </span>
        </exception>
        <exception cref="T:System.OutOfMemoryException">
          <span data-ttu-id="58835-2138">Sem memória.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2138">Out of memory.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (char separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(char separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.Char,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As Char, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(char separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : char * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="separator">To be added.</param>
        <param name="values">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Join&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static string Join&lt;T&gt; (string separator, System.Collections.Generic.IEnumerable&lt;T&gt; values);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Join&lt;T&gt;(string separator, class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; values) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Join``1(System.String,System.Collections.Generic.IEnumerable{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Join(Of T) (separator As String, values As IEnumerable(Of T)) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::String ^ Join(System::String ^ separator, System::Collections::Generic::IEnumerable&lt;T&gt; ^ values);" />
      <MemberSignature Language="F#" Value="static member Join : string * seq&lt;'T&gt; -&gt; string" Usage="System.string.Join (separator, values)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="values" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">
          <span data-ttu-id="58835-2139">O tipo dos membros da <c>valores</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2139">The type of the members of <c>values</c>.</span>
          </span>
        </typeparam>
        <param name="separator">
          <span data-ttu-id="58835-2140">A cadeia de caracteres a ser usada como um separador.<c>separator</c> estará incluída na cadeia de caracteres retornada somente se <c>values</c> tiver mais de um elemento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2140">The string to use as a separator.<c>separator</c> is included in the returned string only if <c>values</c> has more than one element.</span>
          </span>
        </param>
        <param name="values">
          <span data-ttu-id="58835-2141">Uma coleção que contém os objetos a serem concatenados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2141">A collection that contains the objects to concatenate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2142">Concatena os membros de uma coleção, usando o separador especificado entre cada membro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2142">Concatenates the members of a collection, using the specified separator between each member.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2143">Uma cadeia de caracteres que consiste em membros de <paramref name="values" /> delimitados pela cadeia de caracteres <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2143">A string that consists of the members of <paramref name="values" /> delimited by the <paramref name="separator" /> string.</span>
          </span>
          <span data-ttu-id="58835-2144">Se <paramref name="values" /> não tiver nenhum membro, o método retornará <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2144">If <paramref name="values" /> has no members, the method returns <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2145">Caso `separator` seja `null`, uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>) é usada em seu lugar.</span><span class="sxs-lookup"><span data-stu-id="58835-2145">If `separator` is `null`, an empty string (<xref:System.String.Empty?displayProperty=nameWithType>) is used instead.</span></span> <span data-ttu-id="58835-2146">Se qualquer membro do `values` é `null`, uma cadeia de caracteres vazia é usada em vez disso.</span><span class="sxs-lookup"><span data-stu-id="58835-2146">If any member of `values` is `null`, an empty string is used instead.</span></span>  
  
 <span data-ttu-id="58835-2147"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> é um método de conveniência que permite a concatenação de cada membro de um <xref:System.Collections.Generic.IEnumerable%601> coleção sem primeiro convertê-las em cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2147"><xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> is a convenience method that lets you concatenate each member of an <xref:System.Collections.Generic.IEnumerable%601> collection without first converting them to strings.</span></span> <span data-ttu-id="58835-2148">A representação de cadeia de caracteres de cada objeto na <xref:System.Collections.Generic.IEnumerable%601> coleção é derivada por meio da chamada do objeto `ToString` método.</span><span class="sxs-lookup"><span data-stu-id="58835-2148">The string representation of each object in the <xref:System.Collections.Generic.IEnumerable%601> collection is derived by calling that object's `ToString` method.</span></span>  
  
 <span data-ttu-id="58835-2149">Esse método é determinado útil com expressões de consulta integrada à linguagem LINQ (consulta).</span><span class="sxs-lookup"><span data-stu-id="58835-2149">This method is particular useful with Language-Integrated Query (LINQ) query expressions.</span></span> <span data-ttu-id="58835-2150">Por exemplo, o código a seguir define um muito simples `Animal` classe que contém o nome do animal e a ordem ao qual ele pertence.</span><span class="sxs-lookup"><span data-stu-id="58835-2150">For example, the following code defines a very simple `Animal` class that contains the name of an animal and the order to which it belongs.</span></span> <span data-ttu-id="58835-2151">Em seguida, ele define uma <xref:System.Collections.Generic.List%601> objeto que contém um número de `Animal` objetos.</span><span class="sxs-lookup"><span data-stu-id="58835-2151">It then defines a <xref:System.Collections.Generic.List%601> object that contains a number of `Animal` objects.</span></span> <span data-ttu-id="58835-2152">O <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> método de extensão é chamado para extrair o `Animal` objetos cujo `Order` propriedade é igual a "Roedor".</span><span class="sxs-lookup"><span data-stu-id="58835-2152">The <xref:System.Linq.Enumerable.Where%2A?displayProperty=nameWithType> extension method is called to extract the `Animal` objects whose `Order` property equals "Rodent".</span></span> <span data-ttu-id="58835-2153">O resultado é passado para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2153">The result is passed to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join5.cs#5)]
 [!code-vb[System.String.Join#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join5.vb#5)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2154">O exemplo a seguir usa o algoritmo Sieve of Eratosthenes para calcular os números principais menores que ou iguais a 100.</span><span class="sxs-lookup"><span data-stu-id="58835-2154">The following example uses the Sieve of Eratosthenes algorithm to calculate the prime numbers that are less than or equal to 100.</span></span> <span data-ttu-id="58835-2155">Ele atribui o resultado para um <xref:System.Collections.Generic.List%601> objeto do tipo inteiro, que, em seguida, ele passa para o <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2155">It assigns the result to a <xref:System.Collections.Generic.List%601> object of type integer, which it then passes to the <xref:System.String.Join%60%601%28System.String%2CSystem.Collections.Generic.IEnumerable%7B%60%600%7D%29> method.</span></span>  
  
 [!code-csharp[System.String.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.join/cs/join2.cs#2)]
 [!code-vb[System.String.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.join/vb/join2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2156">
            <paramref name="values" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2156">
              <paramref name="values" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Split(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2157">Relata a posição de índice de base zero da última ocorrência de uma cadeia de caracteres ou um caractere Unicode especificado nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2157">Reports the zero-based index position of the last occurrence of a specified Unicode character or string within this instance.</span>
          </span>
          <span data-ttu-id="58835-2158">O método retorna -1 caso o caractere ou a cadeia de caracteres não seja encontrado nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2158">The method returns -1 if the character or string is not found in this instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2159">O caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2159">The Unicode character to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2160">Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2160">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2161">A posição do índice com base em zero de <paramref name="value" /> caso o caractere seja encontrado -1 caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2161">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2162">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2162">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2163">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2163">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2164">Esse método começa a procurar na última posição de caracteres dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2164">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2165">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2165">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2166">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-2166">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-2167">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2167">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2168">O exemplo a seguir define uma `ExtractFilename` método que usa o <xref:System.String.LastIndexOf%28System.Char%29> método para localizar o último caractere de separador de diretório em uma cadeia de caracteres e extrair o nome do arquivo da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2168">The following example defines an `ExtractFilename` method that uses the <xref:System.String.LastIndexOf%28System.Char%29> method to find the last directory separator character in a string and to extract the string's file name.</span></span> <span data-ttu-id="58835-2169">Se o arquivo existir, o método retorna o nome do arquivo sem o caminho.</span><span class="sxs-lookup"><span data-stu-id="58835-2169">If the file exists, the method returns the file name without its path.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/LastIndexOf_Example.cs#1)]
 [!code-vb[System.String.LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/LastIndexOf_Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string -&gt; int" Usage="string.LastIndexOf value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2170">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2170">The string to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2171">Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2171">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2172">A posição do índice inicial com base em zero de <paramref name="value" />, se a cadeia de caracteres for encontrada, ou -1, caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2172">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-2173">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2173">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2174">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2174">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2175">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2175">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2176">A pesquisa começa na posição do último caractere dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2176">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
 <span data-ttu-id="58835-2177">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2177">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="58835-2178">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2178">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-2179">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-2179">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-2180">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%28System.String%29> método sempre retorna <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, que representa a última posição de índice na instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2180">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%29> method always returns <xref:System.String.Length%2A?displayProperty=nameWithType> – 1, which represents the last index position in the current instance.</span></span> <span data-ttu-id="58835-2181">No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%29> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2181">In the following example, the <xref:System.String.LastIndexOf%28System.String%29> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings.</span></span> <span data-ttu-id="58835-2182">Apenas uma das cadeias de caracteres contém um hífen condicional.</span><span class="sxs-lookup"><span data-stu-id="58835-2182">Only one of the strings contains a soft hyphen.</span></span> <span data-ttu-id="58835-2183">Se o exemplo é executado o [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em cada caso, como o hífen condicional é um caractere ignorável, o resultado é o mesmo como se o hífen não havia sido incluído no `value`.</span><span class="sxs-lookup"><span data-stu-id="58835-2183">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in each case, because the soft hyphen is an ignorable character, the result is the same as if the soft hyphen had not been included in `value`.</span></span> <span data-ttu-id="58835-2184">Ao procurar por um hífen somente, o método retorna 6 e 5.</span><span class="sxs-lookup"><span data-stu-id="58835-2184">When searching for a soft hyphen only, the method returns 6 and 5.</span></span> <span data-ttu-id="58835-2185">Esses valores correspondem ao índice do último caractere em duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2185">These values correspond to the index of the last character in the two strings.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof21.cs#21)]
 [!code-vb[System.String.LastIndexOf#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof21.vb#21)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2186">O exemplo a seguir remove a abertura e fechamento de marcas HTML de uma cadeia de caracteres se as marcas begin e end a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2186">The following example removes opening and closing HTML tags from a string if the tags begin and end the string.</span></span> <span data-ttu-id="58835-2187">Se uma cadeia de caracteres termina com um fechamento caractere de colchete (">"), o exemplo usa o <xref:System.String.LastIndexOf%2A> método para localizar o início da marca de fim.</span><span class="sxs-lookup"><span data-stu-id="58835-2187">If a string ends with a closing bracket character (">"), the example uses the <xref:System.String.LastIndexOf%2A> method to locate the start of the end tag.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof_example2.cs#2)]
 [!code-vb[System.String.LastIndexOf#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof_example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2188">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2188">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2189">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para localizar o último índice de uma subcadeia de caracteres dentro de uma instância de cadeia de caracteres usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2189">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the last index of a substring within a string instance by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2190">O caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2190">The Unicode character to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2191">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2191">The starting position of the search.</span>
          </span>
          <span data-ttu-id="58835-2192">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2192">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2193">Relata a posição de índice com base em zero da última ocorrência de um caractere Unicode especificado nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2193">Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.</span>
          </span>
          <span data-ttu-id="58835-2194">A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2194">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2195">A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2195">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2196">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2196">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2197">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> -1. esse método inicia a pesquisa no `startIndex` posição dessa instância e continua para trás até o início da instância atual até que de caracteres `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2197">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning of the current instance until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2198">Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início.</span><span class="sxs-lookup"><span data-stu-id="58835-2198">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span> <span data-ttu-id="58835-2199">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2199">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2200">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-2200">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-2201">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2201">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2202">O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma cadeia de caracteres, trabalhando no final da cadeia de caracteres para o início da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2202">The following example finds the index of all occurrences of a character in a string, working from the end of the string to the start of the string.</span></span>  
  
 [!code-cpp[string.lastindexof1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof1/CPP/lastixof1.cpp#1)]
 [!code-csharp[string.lastindexof1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof1/CS/lastixof1.cs#1)]
 [!code-vb[string.lastindexof1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof1/VB/lastixof1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2203">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2203">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int -&gt; int" Usage="string.LastIndexOf (value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2204">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2204">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2205">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2205">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2206">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2206">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2207">Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2207">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span>
          </span>
          <span data-ttu-id="58835-2208">A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2208">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2209">A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2209">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="58835-2210">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2210">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2211">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2211">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2212">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2212">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2213">A pesquisa começa na `startIndex` caracteres a posição dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2213">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2214">Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início.</span><span class="sxs-lookup"><span data-stu-id="58835-2214">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="58835-2215">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2215">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="58835-2216">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2216">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-2217">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-2217">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-2218">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="58835-2218">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="58835-2219">No exemplo a seguir, o <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> método é usado para localizar uma subcadeia de caracteres que inclui um hífen (U + 00AD) e que precede ou inclui o "m" final em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2219">In the following example, the <xref:System.String.LastIndexOf%28System.String%2CSystem.Int32%29> method is used to find a substring that includes a soft hyphen (U+00AD) and that precedes or includes the final "m" in a string.</span></span> <span data-ttu-id="58835-2220">Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, pois o hífen na cadeia de caracteres de pesquisa é ignorado, chamando o método para localizar uma subcadeia de caracteres que consiste o hífen e o "m" retorna a posição do "m" na cadeia de caracteres, enquanto que chamá-lo para localizar um substrin g que consiste o hífen e "n" retorna a posição de "n".</span><span class="sxs-lookup"><span data-stu-id="58835-2220">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen in the search string is ignored, calling the method to find a substring that consists of the soft hyphen and "m" returns the position of the "m" in the string, whereas calling it to find a substring that consists of the soft hyphen and "n" returns the position of the "n".</span></span> <span data-ttu-id="58835-2221">Quando a cadeia de caracteres de pesquisa contém apenas o hífen, o método retorna o índice do "m", que representa o valor de `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="58835-2221">When the search string contains only the soft hyphen, the method returns the index of the "m", which represents the value of `startIndex`.</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof22.cs#22)]
 [!code-vb[System.String.LastIndexOf#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof22.vb#22)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2222">O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na cadeia de caracteres de destino, trabalhando no final da cadeia de caracteres de destino para o início da cadeia de caracteres de destino.</span><span class="sxs-lookup"><span data-stu-id="58835-2222">The following example finds the index of all occurrences of a string in target string, working from the end of the target string to the start of the target string.</span></span>  
  
 [!code-cpp[string.lastindexof7#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf7/CPP/lastixof7.cpp#1)]
 [!code-csharp[string.lastindexof7#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf7/CS/lastixof7.cs#1)]
 [!code-vb[string.lastindexof7#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf7/VB/lastixof7.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2223">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2223">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2224">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2224">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span>
          </span>
          <span data-ttu-id="58835-2225">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2225">-or-  The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2226">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para localizar o índice de uma subcadeia de caracteres que precede uma posição de caractere específico usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2226">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To find the index of a substring that precedes a particular character position by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * StringComparison -&gt; int" Usage="string.LastIndexOf (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2227">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2227">The string to seek.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-2228">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2228">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2229">Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2229">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span>
          </span>
          <span data-ttu-id="58835-2230">Um parâmetro especifica o tipo de pesquisa a ser usado para a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2230">A parameter specifies the type of search to use for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2231">A posição do índice inicial com base em zero do parâmetro <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 caso não seja.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2231">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not.</span>
          </span>
          <span data-ttu-id="58835-2232">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2232">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2233">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2233">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2234">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2234">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2235">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-2235">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
 <span data-ttu-id="58835-2236">A pesquisa começa na posição do último caractere dessa instância e continua para trás até o início até que `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2236">The search begins at the last character position of this instance and proceeds backward toward the beginning until either `value` is found or the first character position has been examined.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2237">A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2237">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2238">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2238">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2239">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2239">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2240">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="options" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método sempre retorna <see cref="P:System.String.Length" /> – 1, que representa a última posição de índice na instância atual.  No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> método é usado para encontrar subcadeias de três caracteres (um hífen (U + 00AD), um hífen seguido por "n" e um hífen seguido por "m") em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém um hífen condicional. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, como o hífen é um caractere ignorável, uma pesquisa sensível à cultura retorna o mesmo valor que será retornado se o hífen não foram incluídos na cadeia de caracteres de pesquisa. Uma pesquisa ordinal, no entanto, localiza o hífen em uma cadeia de caracteres com êxito e relata que está ausente da segunda cadeia de caracteres.  [! código csharp [System.String.LastIndexOf#26] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.LastIndexOf/cs/lastindexof26.cs#26)] [! código vb [System.String.LastIndexOf#26] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2240">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="options" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method always returns <see cref="P:System.String.Length" /> – 1, which represents the last index position in the current instance.  In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.StringComparison)" /> method is used to find three substrings (a soft hyphen (U+00AD), a soft hyphen followed by "n", and a soft hyphen followed by "m") in two strings. Only one of the strings contains a soft hyphen. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, because the soft hyphen is an ignorable character, a culture-sensitive search returns the same value that it would return if the soft hyphen were not included in the search string. An ordinal search, however, successfully finds the soft hyphen in one string and reports that it is absent from the second string.  [!code-csharp[System.String.LastIndexOf#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof26.cs#26)] [!code-vb[System.String.LastIndexOf#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof26.vb#26)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (char value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(char value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.Char,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As Char, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(char value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : char * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2241">O caractere Unicode a ser buscado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2241">The Unicode character to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2242">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2242">The starting position of the search.</span>
          </span>
          <span data-ttu-id="58835-2243">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2243">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2244">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2244">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2245">Relata a posição de índice que começa com zero da última ocorrência do caractere Unicode especificado em uma subcadeia de caracteres dentro dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2245">Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance.</span>
          </span>
          <span data-ttu-id="58835-2246">A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2246">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2247">A posição do índice baseado em zero de <paramref name="value" /> se esse caractere for encontrado ou -1 se ele não for encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2247">The zero-based index position of <paramref name="value" /> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2248">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2248">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2249">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2249">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2250">Esse método começa a procurar na `startIndex` caracteres de posição e continua para trás até o início dessa instância até que `value` for encontrado ou `count` foram examinadas posições de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2250">This method begins searching at the `startIndex` character position and proceeds backward toward the beginning of this instance until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="58835-2251">Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2251">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span> <span data-ttu-id="58835-2252">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2252">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2253">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso o valor escalar Unicode seja o mesmo.</span><span class="sxs-lookup"><span data-stu-id="58835-2253">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar value are the same.</span></span> <span data-ttu-id="58835-2254">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2254">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2255">O exemplo a seguir localiza o índice de todas as ocorrências de um caractere em uma subcadeia de caracteres, trabalhando no final da subcadeia de caracteres para o início da subcadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2255">The following example finds the index of all occurrences of a character in a substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.lastindexof2/CPP/lastixof2.cpp#1)]
 [!code-csharp[string.lastindexof2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.lastindexof2/CS/lastixof2.cs#1)]
 [!code-vb[string.lastindexof2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.lastindexof2/VB/lastixof2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2256">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> é menor que zero ou maior ou igual ao tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2256">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than or equal to the length of this instance.</span>
          </span>
          <span data-ttu-id="58835-2257">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> - <paramref name="count" /> + 1 é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2257">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" /> + 1 is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int -&gt; int" Usage="string.LastIndexOf (value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2258">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2258">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2259">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2259">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2260">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2260">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2261">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2261">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2262">Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2262">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span>
          </span>
          <span data-ttu-id="58835-2263">A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2263">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2264">A posição do índice inicial baseado em zero de <paramref name="value" /> se essa cadeia de caracteres for encontrada ou -1 se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2264">The zero-based starting index position of <paramref name="value" /> if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="58835-2265">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2265">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2266">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2266">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2267">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2267">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2268">A pesquisa começa na `startIndex` caracteres a posição dessa instância e continua para trás até o início até que `value` for encontrado ou `count` foram examinadas posições de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2268">The search begins at the `startIndex` character position of this instance and proceeds backward toward the beginning until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="58835-2269">Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2269">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="58835-2270">Este método executa uma pesquisa de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2270">This method performs a word (case-sensitive and culture-sensitive) search using the current culture.</span></span>  
  
 <span data-ttu-id="58835-2271">Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao durante a realização de uma comparação linguística ou sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2271">Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison.</span></span> <span data-ttu-id="58835-2272">Em uma pesquisa sensível à cultura, caso `value` contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido.</span><span class="sxs-lookup"><span data-stu-id="58835-2272">In a culture-sensitive search, if `value` contains an ignorable character, the result is equivalent to searching with that character removed.</span></span> <span data-ttu-id="58835-2273">Se `value` consiste apenas em um ou mais caracteres ignoráveis, o <xref:System.String.LastIndexOf%2A> método sempre retorna `startIndex`, que é a posição do caractere no qual a pesquisa começa.</span><span class="sxs-lookup"><span data-stu-id="58835-2273">If `value` consists only of one or more ignorable characters, the <xref:System.String.LastIndexOf%2A> method always returns `startIndex`, which is the character position at which the search begins.</span></span> <span data-ttu-id="58835-2274">No exemplo a seguir, o <xref:System.String.LastIndexOf%2A> método é usado para localizar a posição de um hífen (U + 00AD) em dois caracteres que precedem o último "m" de duas cadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2274">In the following example, the <xref:System.String.LastIndexOf%2A> method is used to find the position of a soft hyphen (U+00AD) in the two characters that precede the final "m" of two strings.</span></span> <span data-ttu-id="58835-2275">Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária.</span><span class="sxs-lookup"><span data-stu-id="58835-2275">Only one of the strings contains the required substring.</span></span> <span data-ttu-id="58835-2276">Se o exemplo é executado no [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2276">If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison.</span></span> <span data-ttu-id="58835-2277">No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m".</span><span class="sxs-lookup"><span data-stu-id="58835-2277">Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m".</span></span>  
  
 [!code-csharp[System.String.LastIndexOf#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof23.cs#23)]
 [!code-vb[System.String.LastIndexOf#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof23.vb#23)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2278">O exemplo a seguir localiza o índice de todas as ocorrências de uma cadeia de caracteres na subcadeia de caracteres, trabalhando no final da subcadeia de caracteres para o início da subcadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2278">The following example finds the index of all occurrences of a string in substring, working from the end of the substring to the start of the substring.</span></span>  
  
 [!code-cpp[string.lastindexof8#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOf8/CPP/lastixof8.cpp#1)]
 [!code-csharp[string.lastindexof8#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOf8/CS/lastixof8.cs#1)]
 [!code-vb[string.lastindexof8#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOf8/VB/lastixof8.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2279">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2279">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2280">
            <paramref name="count" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2280">
              <paramref name="count" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-2281">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2281">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-2282">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é maior que o tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2282">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span>
          </span>
          <span data-ttu-id="58835-2283">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> - <paramref name="count" />+ 1 especifica uma posição que não está dentro dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2283">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> - <paramref name="count" />+ 1 specifies a position that is not within this instance.</span>
          </span>
          <span data-ttu-id="58835-2284">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="start" /> é menor que -1 ou maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2284">-or-  The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span>
          </span>
          <span data-ttu-id="58835-2285">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="count" /> é maior que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2285">-or-  The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2286">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para executar essa operação usando as regras de comparação da cultura atual, chame o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2286">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To perform this operation by using the comparison rules of the current culture, call the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOfAny(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2287">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2287">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2288">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2288">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2289">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2289">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-2290">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2290">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2291">Relata o índice com base em zero da última ocorrência de uma cadeia de caracteres especificada dentro do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2291">Reports the zero-based index of the last occurrence of a specified string within the current <see cref="T:System.String" /> object.</span>
          </span>
          <span data-ttu-id="58835-2292">A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2292">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span>
          </span>
          <span data-ttu-id="58835-2293">Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2293">A parameter specifies the type of comparison to perform when searching for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2294">A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2294">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="58835-2295">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2295">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2296">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2296">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2297">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2297">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2298">A pesquisa começa na `startIndex` caracteres de posição e continua para trás até que `value` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2298">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2299">Por exemplo, se `startIndex` é <xref:System.String.Length%2A> - 1, o método procura todos os caracteres do último caractere na cadeia de caracteres para o início.</span><span class="sxs-lookup"><span data-stu-id="58835-2299">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches every character from the last character in the string to the beginning.</span></span>  
  
 <span data-ttu-id="58835-2300">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-2300">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2301">A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2301">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2302">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2302">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2303">A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que zero ou maior que o comprimento da instância atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2303">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than zero or greater than the length of the current instance.</span>
          </span>
          <span data-ttu-id="58835-2304">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é menor que -1 ou maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2304">-or-  The current instance equals <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is less than -1 or greater than zero.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2305">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2305">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2306">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguida por um "m", começando com o último "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. No caso da primeira cadeia de caracteres, que inclui o hífen condicional seguido de um "m", o método não retorna o índice do hífen virtual, mas retorna o índice do "m". O método retorna o índice do hífen na primeira cadeia de caracteres somente quando ele executa uma comparação ordinal.  [! código csharp [System.String.LastIndexOf#25] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.LastIndexOf/cs/lastindexof25.cs#25)] [! código vb [System.String.LastIndexOf#25] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2306">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m", starting with the final "m" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m". The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  [!code-csharp[System.String.LastIndexOf#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof25.cs#25)] [!code-vb[System.String.LastIndexOf#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof25.vb#25)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public int LastIndexOf (string value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOf(string value, int32 startIndex, int32 count, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOf (value As String, startIndex As Integer, count As Integer, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOf(System::String ^ value, int startIndex, int count, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOf : string * int * int * StringComparison -&gt; int" Usage="string.LastIndexOf (value, startIndex, count, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2307">A cadeia de caracteres a ser buscada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2307">The string to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2308">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2308">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2309">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2309">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2310">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2310">The number of character positions to examine.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-2311">Um dos valores de enumeração que especifica as regras para a pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2311">One of the enumeration values that specifies the rules for the search.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2312">Relata a posição de índice com base em zero da última ocorrência de uma cadeia de caracteres especificada nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2312">Reports the zero-based index position of the last occurrence of a specified string within this instance.</span>
          </span>
          <span data-ttu-id="58835-2313">A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2313">The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions.</span>
          </span>
          <span data-ttu-id="58835-2314">Um parâmetro especifica o tipo de comparação a ser realizada ao pesquisar a cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2314">A parameter specifies the type of comparison to perform when searching for the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2315">A posição do índice inicial baseado em zero do parâmetro <paramref name="value" />, se essa cadeia de caracteres for encontrada, ou -1, se ela não for encontrada ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2315">The zero-based starting index position of the <paramref name="value" /> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
          <span data-ttu-id="58835-2316">Se <paramref name="value" /> for <see cref="F:System.String.Empty" />, o valor retornado será o menor de <paramref name="startIndex" /> e a última posição de índice nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2316">If <paramref name="value" /> is <see cref="F:System.String.Empty" />, the return value is the smaller of <paramref name="startIndex" /> and the last index position in this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2317">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2317">Index numbering starts from zero.</span></span> <span data-ttu-id="58835-2318">Ou seja, o primeiro caractere na cadeia de caracteres está no índice zero e o último está em <xref:System.String.Length%2A> - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2318">That is, the first character in the string is at index zero and the last is at <xref:System.String.Length%2A> - 1.</span></span>  
  
 <span data-ttu-id="58835-2319">A pesquisa começa na `startIndex` caracteres de posição e continua para trás até que `value` for encontrado ou `count` foram examinadas posições de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2319">The search begins at the `startIndex` character position and proceeds backward until either `value` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="58835-2320">Por exemplo, se `startIndex` está <xref:System.String.Length%2A> - 1, o método de pesquisa para trás `count` caracteres do último caractere na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2320">For example, if `startIndex` is <xref:System.String.Length%2A> - 1, the method searches backward `count` characters from the last character in the string.</span></span>  
  
 <span data-ttu-id="58835-2321">O parâmetro `comparisonType` especifica a procura do parâmetro `value` usando a cultura atual ou invariável, usando uma pesquisa com ou sem diferenciação de maiúsculas e minúsculas e usando regras de comparação de palavra ou ordinais.</span><span class="sxs-lookup"><span data-stu-id="58835-2321">The `comparisonType` parameter specifies to search for the `value` parameter using the current or invariant culture, using a case-sensitive or case-insensitive search, and using word or ordinal comparison rules.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2322">A seguir exampledemonstrates três sobrecargas do <xref:System.String.LastIndexOf%2A> método de localizar a última ocorrência de uma cadeia de caracteres dentro de outra cadeia de caracteres usando valores diferentes da <xref:System.StringComparison> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2322">The following exampledemonstrates three overloads of the <xref:System.String.LastIndexOf%2A> method that find the last occurrence of a string within another string using different values of the <xref:System.StringComparison> enumeration.</span></span>  
  
 [!code-csharp[system.string.LastIndexOfCmp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/cs/liocmp.cs#1)]
 [!code-vb[system.string.LastIndexOfCmp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.LastIndexOfCmp/vb/liocmp.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2323">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2323">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2324">
            <paramref name="count" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2324">
              <paramref name="count" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-2325">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2325">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-2326">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> é maior que o tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2326">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> is greater than the length of this instance.</span>
          </span>
          <span data-ttu-id="58835-2327">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> + 1 - <paramref name="count" /> especifica uma posição que não está dentro dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2327">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> + 1 - <paramref name="count" /> specifies a position that is not within this instance.</span>
          </span>
          <span data-ttu-id="58835-2328">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="start" /> é menor que -1 ou maior que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2328">-or-  The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="start" /> is less than -1 or greater than zero.</span>
          </span>
          <span data-ttu-id="58835-2329">-ou- A instância atual é igual a <see cref="F:System.String.Empty" />, e <paramref name="count" /> é maior que 1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2329">-or-  The current instance equals <see cref="F:System.String.Empty" /> and <paramref name="count" /> is greater than 1.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2330">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2330">
              <paramref name="comparisonType" /> is not a valid <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2331">
            <para>Conjuntos de caracteres incluem caracteres ignoráveis, que são caracteres que não são considerados ao realizar uma comparação linguística ou sensível à cultura. Em uma pesquisa sensível à cultura (ou seja, caso <paramref name="comparisonType" /> não seja <see cref="F:System.StringComparison.Ordinal" /> ou <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), caso <paramref name="value" /> contenha um caractere ignorável, o resultado é equivalente à pesquisa com esse caractere removido. Se <paramref name="value" /> consiste apenas em um ou mais caracteres ignoráveis, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método sempre retorna <paramref name="startIndex" />, que é a posição do caractere no qual a pesquisa começa.  No exemplo a seguir, o <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> método é usado para localizar a posição de um hífen (U + 00AD) seguido por um "m" em todos, mas a primeira posição de caractere antes do final "m" em duas cadeias de caracteres. Apenas uma das cadeias de caracteres contém a subcadeia de caracteres necessária. Se o exemplo é executado o [! INCLUDE[netfx40_short](~/Includes/netfx40-Short-MD.MD)] ou posterior, em ambos os casos, como o hífen condicional é um caractere ignorável, o método retorna o índice do "m" na cadeia de caracteres quando ele executa uma comparação sensível à cultura. Quando ele executa uma comparação ordinal, no entanto, ele localiza a subcadeia de caracteres apenas na primeira cadeia de caracteres. Observe que no caso da primeira cadeia de caracteres, que inclui o hífen, seguido por um "m", o método não retorna o índice do hífen virtual, mas em vez disso, retorna o índice do "m", quando ele executa uma comparação sensível à cultura. O método retorna o índice do hífen na primeira cadeia de caracteres somente quando ele executa uma comparação ordinal.  [! código csharp [System.String.LastIndexOf#24] (~/samples/snippets/csharp/VS_Snippets_CLR_System/sistema. String.LastIndexOf/cs/lastindexof24.cs#24)] [! código vb [System.String.LastIndexOf#24] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System/sistema. String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2331">
              <para>Character sets include ignorable characters, which are characters that are not considered when performing a linguistic or culture-sensitive comparison. In a culture-sensitive search (that is, if <paramref name="comparisonType" /> is not <see cref="F:System.StringComparison.Ordinal" /> or <see cref="F:System.StringComparison.OrdinalIgnoreCase" />), if <paramref name="value" /> contains an ignorable character, the result is equivalent to searching with that character removed. If <paramref name="value" /> consists only of one or more ignorable characters, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method always returns <paramref name="startIndex" />, which is the character position at which the search begins.  In the following example, the <see cref="M:System.String.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)" /> method is used to find the position of a soft hyphen (U+00AD) followed by an "m" in all but the first character position before the final "m" in two strings. Only one of the strings contains the required substring. If the example is run on the [!INCLUDE[netfx40_short](~/includes/netfx40-short-md.md)] or later, in both cases, because the soft hyphen is an ignorable character, the method returns the index of "m" in the string when it performs a culture-sensitive comparison. When it performs an ordinal comparison, however, it finds the substring only in the first string. Note that in the case of the first string, which includes the soft hyphen followed by an "m", the method fails to return the index of the soft hyphen but instead returns the index of the "m" when it performs a culture-sensitive comparison. The method returns the index of the soft hyphen in the first string only when it performs an ordinal comparison.  [!code-csharp[System.String.LastIndexOf#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.LastIndexOf/cs/lastindexof24.cs#24)] [!code-vb[System.String.LastIndexOf#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.LastIndexOf/vb/lastindexof24.vb#24)]</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOfAny">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2332">Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2332">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span>
          </span>
          <span data-ttu-id="58835-2333">O método retorna -1 caso os caracteres na matriz não sejam encontrados nessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2333">The method returns -1 if the characters in the array are not found in this instance.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] -&gt; int" Usage="string.LastIndexOfAny anyOf" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-2334">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2334">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2335">Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2335">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2336">A posição do índice da última ocorrência nessa instância em que um caractere em <paramref name="anyOf" /> foi encontrado; -1, se nenhum caractere em <paramref name="anyOf" /> foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2336">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2337">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2337">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-2338">Esse método começa a procurar na última posição de caracteres dessa instância e continua para trás até o início até um caractere em `anyOf` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2338">This method begins searching at the last character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2339">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2339">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2340">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-2340">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-2341">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2341">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2342">O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2342">The following example finds the index of the last occurrence of any character in the string "is" within another string.</span></span>  
  
 [!code-cpp[string.lastindexofany1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny1/CPP/lastixany1.cpp#1)]
 [!code-csharp[string.lastindexofany1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny1/CS/lastixany1.cs#1)]
 [!code-vb[string.lastindexofany1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny1/VB/lastixany1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2343">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2343">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-2344">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2344">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2345">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2345">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2346">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2346">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2347">Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2347">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span>
          </span>
          <span data-ttu-id="58835-2348">A pesquisa começa em uma posição de caractere especificada e continua até o início da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2348">The search starts at a specified character position and proceeds backward toward the beginning of the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2349">A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2349">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2350">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2350">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-2351">Esse método começa a procurar na `startIndex` de caracteres dessa instância e continua para trás até o início até um caractere na posição de `anyOf` for encontrado ou a posição do primeiro caractere foi examinada.</span><span class="sxs-lookup"><span data-stu-id="58835-2351">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or the first character position has been examined.</span></span> <span data-ttu-id="58835-2352">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2352">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2353">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-2353">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-2354">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2354">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2355">O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na cadeia de caracteres "é" dentro de uma subcadeia de caracteres de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2355">The following example finds the index of the last occurrence of any character in the string "is" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany2#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny2/CPP/lastixany2.cpp#1)]
 [!code-csharp[string.lastindexofany2#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny2/CS/lastixany2.cs#1)]
 [!code-vb[string.lastindexofany2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny2/VB/lastixany2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2356">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2356">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2357">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="startIndex" /> especifica uma posição que não está dentro dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2357">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> specifies a position that is not within this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOfAny">
      <MemberSignature Language="C#" Value="public int LastIndexOfAny (char[] anyOf, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 LastIndexOfAny(char[] anyOf, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.LastIndexOfAny(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LastIndexOfAny (anyOf As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int LastIndexOfAny(cli::array &lt;char&gt; ^ anyOf, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.LastIndexOfAny : char[] * int * int -&gt; int" Usage="string.LastIndexOfAny (anyOf, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="anyOf" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="anyOf">
          <span data-ttu-id="58835-2358">Uma matriz de caracteres Unicode que contém um ou mais caracteres a serem buscados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2358">A Unicode character array containing one or more characters to seek.</span>
          </span>
        </param>
        <param name="startIndex">
          <span data-ttu-id="58835-2359">A posição inicial da pesquisa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2359">The search starting position.</span>
          </span>
          <span data-ttu-id="58835-2360">A pesquisa continua de <c>startIndex</c> até o início desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2360">The search proceeds from <c>startIndex</c> toward the beginning of this instance.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2361">O número de posições de caractere a serem examinadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2361">The number of character positions to examine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2362">Relata a posição de índice com base em zero da última ocorrência; neste caso, de um ou mais caracteres especificados em uma matriz Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2362">Reports the zero-based index position of the last occurrence in this instance of one or more characters specified in a Unicode array.</span>
          </span>
          <span data-ttu-id="58835-2363">A pesquisa começa em uma posição de caractere especificada e continua para trás até o início da cadeia de caracteres de um número especificado de posições de caractere.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2363">The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2364">A posição do índice da última ocorrência nessa instância em que algum caractere em <paramref name="anyOf" /> foi encontrado, -1, se nenhum caractere em <paramref name="anyOf" /> tiver sido encontrado ou se a instância atual for igual a <see cref="F:System.String.Empty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2364">The index position of the last occurrence in this instance where any character in <paramref name="anyOf" /> was found; -1 if no character in <paramref name="anyOf" /> was found or if the current instance equals <see cref="F:System.String.Empty" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2365">A numeração de índice começa do zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2365">Index numbering starts from zero.</span></span>  
  
 <span data-ttu-id="58835-2366">Esse método começa a procurar na `startIndex` de caracteres dessa instância e continua para trás até o início até um caractere na posição do `anyOf` for encontrado ou `count` foram examinadas posições de caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2366">This method begins searching at the `startIndex` character position of this instance and proceeds backward toward the beginning until either a character in `anyOf` is found or `count` character positions have been examined.</span></span> <span data-ttu-id="58835-2367">A pesquisa diferencia maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2367">The search is case-sensitive.</span></span>  
  
 <span data-ttu-id="58835-2368">Este método executa uma pesquisa ordinal (insensível à cultura), onde um caractere só é considerado equivalente a um outro caractere caso os valores escalares Unicode sejam os mesmos.</span><span class="sxs-lookup"><span data-stu-id="58835-2368">This method performs an ordinal (culture-insensitive) search, where a character is considered equivalent to another character only if their Unicode scalar values are the same.</span></span> <span data-ttu-id="58835-2369">Para executar uma pesquisa sensível à cultura, use o método <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType>, em que um valor escalar Unicode representando um caractere pré-composto como a ligadura "Æ" (U+00C6) pode ser considerado equivalente a qualquer ocorrência dos componentes do caractere na sequência correta, como "AE" (U+0041, U+0045), dependendo da cultura.</span><span class="sxs-lookup"><span data-stu-id="58835-2369">To perform a culture-sensitive search, use the <xref:System.Globalization.CompareInfo.LastIndexOf%2A?displayProperty=nameWithType> method, where a Unicode scalar value representing a precomposed character, such as the ligature "Æ" (U+00C6), might be considered equivalent to any occurrence of the character's components in the correct sequence, such as "AE" (U+0041, U+0045), depending on the culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2370">O exemplo a seguir localiza o índice da última ocorrência de qualquer caractere na "Ajuda" cadeia de caracteres dentro de uma subcadeia de caracteres de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2370">The following example finds the index of the last occurrence of any character in the string "aid" within a substring of another string.</span></span>  
  
 [!code-cpp[string.lastindexofany3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.LastIndexOfAny3/CPP/lastixany3.cpp#1)]
 [!code-csharp[string.lastindexofany3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.LastIndexOfAny3/CS/lastixany3.cs#1)]
 [!code-vb[string.lastindexofany3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.LastIndexOfAny3/VB/lastixany3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2371">
            <paramref name="anyOf" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2371">
              <paramref name="anyOf" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2372">A instância atual não é igual a <see cref="F:System.String.Empty" /> e <paramref name="count" /> ou <paramref name="startIndex" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2372">The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="count" /> or <paramref name="startIndex" /> is negative.</span>
          </span>
          <span data-ttu-id="58835-2373">-ou- A instância atual não é igual a <see cref="F:System.String.Empty" />, e <paramref name="startIndex" /> menos <paramref name="count" /> + 1 é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2373">-or-  The current instance does not equal <see cref="F:System.String.Empty" />, and <paramref name="startIndex" /> minus <paramref name="count" /> + 1 is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.Array" />
        <altmember cref="M:System.String.IndexOf(System.Char)" />
        <altmember cref="M:System.String.IndexOfAny(System.Char[])" />
        <altmember cref="M:System.String.LastIndexOf(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.String.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.string.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2374">Obtém o número de caracteres no objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2374">Gets the number of characters in the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="58835-2375">O número de caracteres na cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2375">The number of characters in the current string.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2376">O <xref:System.String.Length%2A> propriedade retorna o número de <xref:System.Char> objetos nesta instância, não o número de caracteres Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-2376">The <xref:System.String.Length%2A> property returns the number of <xref:System.Char> objects in this instance, not the number of Unicode characters.</span></span> <span data-ttu-id="58835-2377">O motivo é que um caractere Unicode pode ser representado por mais de um <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="58835-2377">The reason is that a Unicode character might be represented by more than one <xref:System.Char>.</span></span> <span data-ttu-id="58835-2378">Use o <xref:System.Globalization.StringInfo?displayProperty=nameWithType> classe para trabalhar com cada caractere Unicode em vez de cada <xref:System.Char>.</span><span class="sxs-lookup"><span data-stu-id="58835-2378">Use the <xref:System.Globalization.StringInfo?displayProperty=nameWithType> class to work with each Unicode character instead of each <xref:System.Char>.</span></span>  
  
 <span data-ttu-id="58835-2379">Em alguns idiomas, como C e C++, um caractere nulo indica o final de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2379">In some languages, such as C and C++, a null character indicates the end of a string.</span></span> <span data-ttu-id="58835-2380">No .NET Framework, um caractere nulo pode ser inserido em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2380">In the .NET Framework, a null character can be embedded in a string.</span></span> <span data-ttu-id="58835-2381">Quando uma cadeia de caracteres inclui um ou mais caracteres de null, eles são incluídos no comprimento da cadeia de caracteres total.</span><span class="sxs-lookup"><span data-stu-id="58835-2381">When a string includes one or more null characters, they are included in the length of the total string.</span></span> <span data-ttu-id="58835-2382">Por exemplo, na seguinte cadeia de caracteres, as subcadeias de caracteres "abc" e "def" são separados por um caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-2382">For example, in the following string, the substrings "abc" and "def" are separated by a null character.</span></span> <span data-ttu-id="58835-2383">O <xref:System.String.Length%2A> propriedade retorna 7, que indica que ele inclui os seis caracteres alfabéticos, bem como o caractere nulo.</span><span class="sxs-lookup"><span data-stu-id="58835-2383">The <xref:System.String.Length%2A> property returns 7, which indicates that it includes the six alphabetic characters as well as the null character.</span></span>  
  
 [!code-cpp[System.String.Class#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Class/cpp/system.string.class.cpp#1)]
 [!code-csharp[System.String.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Class/cs/System.String.Class.cs#1)]
 [!code-vb[System.String.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Class/vb/System.String.Class.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2384">O exemplo a seguir demonstra o <xref:System.String.Length%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="58835-2384">The following example demonstrates the <xref:System.String.Length%2A> property.</span></span>  
  
 [!code-cpp[string.length#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.length/CPP/length.cpp#1)]
 [!code-csharp[string.length#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.length/CS/length.cs#1)]
 [!code-vb[string.length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.length/VB/length.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Normalize">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2385">Retorna uma nova cadeia de caracteres cuja representação binária está em um formulário de normalização Unicode específico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2385">Returns a new string whose binary representation is in a particular Unicode normalization form.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize" />
      <MemberSignature Language="VB.NET" Value="Public Function Normalize () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize();" />
      <MemberSignature Language="F#" Value="member this.Normalize : unit -&gt; string" Usage="string.Normalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-2386">Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2386">Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2387">Uma nova cadeia de caracteres normalizada cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização C.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2387">A new, normalized string whose textual value is the same as this string, but whose binary representation is in normalization form C.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2388">Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos.</span><span class="sxs-lookup"><span data-stu-id="58835-2388">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="58835-2389">Por exemplo, qualquer um dos pontos de código a seguir pode representar a letra "ắ":</span><span class="sxs-lookup"><span data-stu-id="58835-2389">For example, any of the following code points can represent the letter "ắ":</span></span>  
  
-   <span data-ttu-id="58835-2390">U + 1EAF</span><span class="sxs-lookup"><span data-stu-id="58835-2390">U+1EAF</span></span>  
  
-   <span data-ttu-id="58835-2391">U+0103 U+0301</span><span class="sxs-lookup"><span data-stu-id="58835-2391">U+0103 U+0301</span></span>  
  
-   <span data-ttu-id="58835-2392">U+0061 U+0306 U+0301</span><span class="sxs-lookup"><span data-stu-id="58835-2392">U+0061 U+0306 U+0301</span></span>  
  
 <span data-ttu-id="58835-2393">A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.</span><span class="sxs-lookup"><span data-stu-id="58835-2393">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="58835-2394">O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2394">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="58835-2395">A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-2395">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="58835-2396">O .NET Framework oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, theycan ser comparados usando comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-2396">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, theycan be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="58835-2397">Para normalizar e comparar duas cadeias de caracteres, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-2397">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="58835-2398">Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="58835-2398">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="58835-2399">Chamar o <xref:System.String.Normalize> método normalizar as cadeias de caracteres para o formulário de normalização C.</span><span class="sxs-lookup"><span data-stu-id="58835-2399">Call the <xref:System.String.Normalize> method to normalize the strings to normalization form C.</span></span>  
  
3.  <span data-ttu-id="58835-2400">Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinais, tais como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento.</span><span class="sxs-lookup"><span data-stu-id="58835-2400">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="58835-2401">Para classificar uma matriz de cadeias de caracteres normalizadas, passe uma `comparer` valor de <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2401">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="58835-2402">Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.</span><span class="sxs-lookup"><span data-stu-id="58835-2402">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="58835-2403">Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2403">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2404">O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado, em seguida, lista os pontos de código na cadeia de caracteres normalizada.</span><span class="sxs-lookup"><span data-stu-id="58835-2404">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2405">A instância atual contém caracteres Unicode inválidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2405">The current instance contains invalid Unicode characters.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2406">
            <para>O <see cref="Overload:System.String.IsNormalized" /> método retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método lançará uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2406">
              <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method will throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="Normalize">
      <MemberSignature Language="C#" Value="public string Normalize (System.Text.NormalizationForm normalizationForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Normalize(valuetype System.Text.NormalizationForm normalizationForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Normalize(System.Text.NormalizationForm)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Normalize(System::Text::NormalizationForm normalizationForm);" />
      <MemberSignature Language="F#" Value="member this.Normalize : System.Text.NormalizationForm -&gt; string" Usage="string.Normalize normalizationForm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="normalizationForm" Type="System.Text.NormalizationForm" />
      </Parameters>
      <Docs>
        <param name="normalizationForm">
          <span data-ttu-id="58835-2407">Um formato de normalização Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2407">A Unicode normalization form.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2408">Retorna uma nova cadeia de caracteres cujo valor textual é o mesmo que essa cadeia de caracteres, mas cuja representação binária está no formato de normalização Unicode especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2408">Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2409">Uma nova cadeia de caracteres cujo valor textual é igual a essa cadeia de caracteres, mas cuja representação binária está no formato de normalização especificado pelo parâmetro <paramref name="normalizationForm" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2409">A new string whose textual value is the same as this string, but whose binary representation is in the normalization form specified by the <paramref name="normalizationForm" /> parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2410">Alguns caracteres Unicode têm várias representações binárias equivalentes que consistem em conjuntos de combinação e/ou de caracteres Unicode compostos.</span><span class="sxs-lookup"><span data-stu-id="58835-2410">Some Unicode characters have multiple equivalent binary representations consisting of sets of combining and/or composite Unicode characters.</span></span> <span data-ttu-id="58835-2411">A existência de várias representações para um único caractere complica a pesquisa, a classificação, a correspondência e outras operações.</span><span class="sxs-lookup"><span data-stu-id="58835-2411">The existence of multiple representations for a single character complicates searching, sorting, matching, and other operations.</span></span>  
  
 <span data-ttu-id="58835-2412">O padrão Unicode define um processo chamado normalização que retorna uma representação binária quando recebe qualquer uma das representações binárias equivalentes de um caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2412">The Unicode standard defines a process called normalization that returns one binary representation when given any of the equivalent binary representations of a character.</span></span> <span data-ttu-id="58835-2413">A normalização pode ser realizada com vários algoritmos, chamados de formulários de normalização, que obedecem regras diferentes.</span><span class="sxs-lookup"><span data-stu-id="58835-2413">Normalization can be performed with several algorithms, called normalization forms, that obey different rules.</span></span> <span data-ttu-id="58835-2414">O .NET Framework oferece suporte os quatro formulários de normalização (C, D, KC e KD) que são definidos pelo padrão Unicode. Quando duas cadeias de caracteres são representadas no mesmo formato de normalização, eles podem ser comparados usando a comparação ordinal.</span><span class="sxs-lookup"><span data-stu-id="58835-2414">The .NET Framework supports the four normalization forms (C, D, KC, and KD)that are defined by the Unicode standard.When two strings are represented in the same normalization form, they can be compared by using ordinal comparison.</span></span>  
  
 <span data-ttu-id="58835-2415">Para normalizar e comparar duas cadeias de caracteres, faça o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-2415">To normalize and compare two strings, do the following:</span></span>  
  
1.  <span data-ttu-id="58835-2416">Obter as cadeias de caracteres a serem comparados de uma fonte de entrada, como um arquivo ou um dispositivo de entrada do usuário.</span><span class="sxs-lookup"><span data-stu-id="58835-2416">Obtain the strings to be compared from an input source, such as a file or a user input device.</span></span>  
  
2.  <span data-ttu-id="58835-2417">Chamar o <xref:System.String.Normalize%28System.Text.NormalizationForm%29> método normalizar as cadeias de caracteres a um formulário de normalização especificada.</span><span class="sxs-lookup"><span data-stu-id="58835-2417">Call the <xref:System.String.Normalize%28System.Text.NormalizationForm%29> method to normalize the strings to a specified normalization form.</span></span>  
  
3.  <span data-ttu-id="58835-2418">Para comparar duas cadeias de caracteres, chamar um método que dá suporte à comparação de cadeia de caracteres ordinais, tais como o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> método e fornecer um valor de <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> como o <xref:System.StringComparison> argumento.</span><span class="sxs-lookup"><span data-stu-id="58835-2418">To compare two strings, call a method that supports ordinal string comparison, such as the <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29> method, and supply a value of <xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType> as the <xref:System.StringComparison> argument.</span></span> <span data-ttu-id="58835-2419">Para classificar uma matriz de cadeias de caracteres normalizadas, passe uma `comparer` valor de <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> ou <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> para uma sobrecarga apropriada do <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2419">To sort an array of normalized strings, pass a `comparer` value of <xref:System.StringComparer.Ordinal%2A?displayProperty=nameWithType> or <xref:System.StringComparer.OrdinalIgnoreCase%2A?displayProperty=nameWithType> to an appropriate overload of <xref:System.Array.Sort%2A?displayProperty=nameWithType>.</span></span>  
  
4.  <span data-ttu-id="58835-2420">Emita as cadeias de caracteres na saída classificada com base na ordem indicada pela etapa anterior.</span><span class="sxs-lookup"><span data-stu-id="58835-2420">Emit the strings in the sorted output based on the order indicated by the previous step.</span></span>  
  
 <span data-ttu-id="58835-2421">Para obter uma descrição dos formulários de normalização Unicode suportados, consulte <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2421">For a description of supported Unicode normalization forms, see <xref:System.Text.NormalizationForm?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2422">O exemplo a seguir normaliza uma cadeia de caracteres para cada um dos quatro formulários de normalização, confirma se a cadeia de caracteres foi normalizado de acordo com o formulário de normalização especificado, em seguida, lista os pontos de código na cadeia de caracteres normalizada.</span><span class="sxs-lookup"><span data-stu-id="58835-2422">The following example normalizes a string to each of four normalization forms, confirms the string was normalized to the specified normalization form, then lists the code points in the normalized string.</span></span>  
  
 [!code-cpp[string.normalize#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.normalize/CPP/norm.cpp#1)]
 [!code-csharp[string.normalize#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.normalize/CS/norm.cs#1)]
 [!code-vb[string.normalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.normalize/VB/norm.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2423">A instância atual contém caracteres Unicode inválidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2423">The current instance contains invalid Unicode characters.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2424">
            <para>O <see cref="Overload:System.String.IsNormalized" /> método retorna <see langword="false" /> assim que encontra o primeiro caractere não normalizado em uma cadeia de caracteres. Portanto, se uma cadeia de caracteres contém caracteres não normalizado seguidos por caracteres Unicode inválidos, o <see cref="Overload:System.String.Normalize" /> método pode lançar uma <see cref="T:System.ArgumentException" /> Embora <see cref="Overload:System.String.IsNormalized" /> retorna <see langword="false" />.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2424">
              <para>The <see cref="Overload:System.String.IsNormalized" /> method returns <see langword="false" /> as soon as it encounters the first non-normalized character in a string. Therefore, if a string contains non-normalized characters followed by invalid Unicode characters, the <see cref="Overload:System.String.Normalize" /> method may throw an <see cref="T:System.ArgumentException" /> although <see cref="Overload:System.String.IsNormalized" /> returns <see langword="false" />.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.IsNormalized" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Equality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : string * string -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="58835-2425">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2425">The first string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="58835-2426">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2426">The second string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2427">Determina se duas cadeias de caracteres especificadas têm o mesmo valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2427">Determines whether two specified strings have the same value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2428">
            <see langword="true" /> se o valor de <paramref name="a" /> for o mesmo que o valor de <paramref name="b" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2428">
              <see langword="true" /> if the value of <paramref name="a" /> is the same as the value of <paramref name="b" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2429">O <xref:System.String.op_Equality%2A> método define a operação do operador de igualdade para os <xref:System.String> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-2429">The <xref:System.String.op_Equality%2A> method defines the operation of the equality operator for the <xref:System.String> class.</span></span> <span data-ttu-id="58835-2430">Ele permite que o código, como a mostrada na seção de exemplo.</span><span class="sxs-lookup"><span data-stu-id="58835-2430">It enables code such as that shown in the Example section.</span></span> <span data-ttu-id="58835-2431">O operador, por sua vez, chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-2431">The operator, in turn, calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2432">O compilador do Visual Basic não resolve o operador de igualdade como uma chamada para o <xref:System.String.op_Equality%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2432">The Visual Basic compiler does not resolve the equality operator as a call to the <xref:System.String.op_Equality%2A> method.</span></span> <span data-ttu-id="58835-2433">Em vez disso, o operador de igualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2433">Instead, the equality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2434">O exemplo a seguir demonstra o operador de igualdade.</span><span class="sxs-lookup"><span data-stu-id="58835-2434">The following example demonstrates the equality operator.</span></span>  
  
 [!code-cpp[system.string.equality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Equality/CPP/equalityop.cpp#1)]
 [!code-csharp[system.string.equality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Equality/CS/equalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;char&gt; (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;char&gt; op_Implicit(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Implicit(System.String)~System.ReadOnlySpan{System.Char}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As String) As ReadOnlySpan(Of Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;char&gt;(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : string -&gt; ReadOnlySpan&lt;char&gt;" Usage="System.string.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (string a, string b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(string a, string b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.op_Inequality(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As String, b As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::String ^ a, System::String ^ b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : string * string -&gt; bool" Usage="System.string.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.String" />
        <Parameter Name="b" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="58835-2435">A primeira cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2435">The first string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="58835-2436">A segunda cadeia de caracteres a ser comparada ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2436">The second string to compare, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2437">Determina se duas cadeias de caracteres especificadas têm valores diferentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2437">Determines whether two specified strings have different values.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2438">
            <see langword="true" /> se o valor de <paramref name="a" /> for diferente do valor de <paramref name="b" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2438">
              <see langword="true" /> if the value of <paramref name="a" /> is different from the value of <paramref name="b" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2439">O <xref:System.String.op_Inequality%2A> método define a operação do operador de desigualdade para o <xref:System.String> classe.</span><span class="sxs-lookup"><span data-stu-id="58835-2439">The <xref:System.String.op_Inequality%2A> method defines the operation of the inequality operator for the <xref:System.String> class.</span></span>   <span data-ttu-id="58835-2440">Ele permite que o código, como a mostrada na seção exemplos.</span><span class="sxs-lookup"><span data-stu-id="58835-2440">It enables code such as that shown in the Examples section.</span></span>  
  
 <span data-ttu-id="58835-2441">O <xref:System.String.op_Inequality%2A> operador por sua vez chama estático <xref:System.String.Equals%28System.String%2CSystem.String%29> método, que executa uma comparação ordinal (diferencia maiusculas de minúsculas e insensível à cultura).</span><span class="sxs-lookup"><span data-stu-id="58835-2441">The <xref:System.String.op_Inequality%2A> operator in turn calls the static <xref:System.String.Equals%28System.String%2CSystem.String%29> method, which  performs an ordinal (case-sensitive and culture-insensitive) comparison.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2442">O compilador do Visual Basic não resolve o operador de desigualdade como uma chamada para o <xref:System.String.op_Inequality%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2442">The Visual Basic compiler does not resolve the inequality operator as a call to the <xref:System.String.op_Inequality%2A> method.</span></span> <span data-ttu-id="58835-2443">Em vez disso, o operador de desigualdade encapsula uma chamada para o <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2443">Instead, the inequality operator wraps a call to the <xref:Microsoft.VisualBasic.CompilerServices.Operators.CompareString%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2444">O exemplo a seguir demonstra o operador de desigualdade.</span><span class="sxs-lookup"><span data-stu-id="58835-2444">The following example demonstrates the inequality operator.</span></span>  
  
 [!code-cpp[system.string.inequality#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Inequality/CPP/inequalityop.cpp#1)]
 [!code-csharp[system.string.inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Inequality/CS/inequalityop.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PadLeft">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2445">Retorna uma nova cadeia de caracteres de um comprimento especificado no qual o início da cadeia de caracteres atual é preenchido com espaços ou com um caractere Unicode especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2445">Returns a new string of a specified length in which the beginning of the current string is padded with spaces or with a specified Unicode character.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int -&gt; string" Usage="string.PadLeft totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">
          <span data-ttu-id="58835-2446">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2446">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2447">Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os com espaços à esquerda, para um tamanho total especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2447">Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2448">Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de espaços necessários para criar um tamanho <paramref name="totalWidth" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2448">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span>
          </span>
          <span data-ttu-id="58835-2449">No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2449">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span>
          </span>
          <span data-ttu-id="58835-2450">Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2450">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2451">Um espaço de Unicode é definido como 0x0020 hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="58835-2451">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="58835-2452">O <xref:System.String.PadLeft%28System.Int32%29> método preenche o início da cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2452">The <xref:System.String.PadLeft%28System.Int32%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="58835-2453">Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte direita da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2453">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2454">Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2454">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2455">Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à esquerda para que seu tamanho total é `totalWidth` caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2455">Instead, it returns a new string that is padded with leading white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2456">O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2456">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2457">
            <paramref name="totalWidth" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2457">
              <paramref name="totalWidth" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadLeft">
      <MemberSignature Language="C#" Value="public string PadLeft (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadLeft(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadLeft(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadLeft (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadLeft(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadLeft : int * char -&gt; string" Usage="string.PadLeft (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">
          <span data-ttu-id="58835-2458">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2458">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span>
          </span>
        </param>
        <param name="paddingChar">
          <span data-ttu-id="58835-2459">Um caractere de preenchimento de Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2459">A Unicode padding character.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2460">Retorna uma nova cadeia de caracteres que alinha os caracteres à direita nessa instância, preenchendo-os à esquerda com um caractere Unicode especificado, para um tamanho total especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2460">Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2461">Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à direita e preenchida à esquerda com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2461">A new string that is equivalent to this instance, but right-aligned and padded on the left with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span>
          </span>
          <span data-ttu-id="58835-2462">No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2462">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span>
          </span>
          <span data-ttu-id="58835-2463">Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2463">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2464">O <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> método preenche o início da cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2464">The <xref:System.String.PadLeft%28System.Int32%2CSystem.Char%29> method pads the beginning of the returned string.</span></span> <span data-ttu-id="58835-2465">Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte direita da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2465">This means that, when used with right-to-left languages, it pads the right portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2466">Se o <xref:System.String.PadLeft%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2466">If the <xref:System.String.PadLeft%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2467">Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com líderes `paddingChar` caracteres de modo que seu tamanho total é `totalWidth` caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2467">Instead, it returns a new string that is padded with leading `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2468">O exemplo a seguir demonstra o <xref:System.String.PadLeft%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2468">The following example demonstrates the <xref:System.String.PadLeft%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadLeft1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadLeft1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.PadLeft1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadLeft1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2469">
            <paramref name="totalWidth" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2469">
              <paramref name="totalWidth" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadRight(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="PadRight">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2470">Retorna uma nova cadeia de caracteres de um comprimento especificado no qual o fim da cadeia de caracteres atual é preenchido com espaços ou com um caractere Unicode especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2470">Returns a new string of a specified length in which the end of the current string is padded with spaces or with a specified Unicode character.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int -&gt; string" Usage="string.PadRight totalWidth" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="totalWidth">
          <span data-ttu-id="58835-2471">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2471">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2472">Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os com espaços à direita, para um tamanho total especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2472">Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2473">Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com quantos caracteres forem necessários para criar um tamanho de <paramref name="totalWidth" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2473">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many spaces as needed to create a length of <paramref name="totalWidth" />.</span>
          </span>
          <span data-ttu-id="58835-2474">No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2474">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span>
          </span>
          <span data-ttu-id="58835-2475">Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2475">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2476">Um espaço de Unicode é definido como 0x0020 hexadecimal.</span><span class="sxs-lookup"><span data-stu-id="58835-2476">A Unicode space is defined as hexadecimal 0x0020.</span></span>  
  
 <span data-ttu-id="58835-2477">O <xref:System.String.PadRight%28System.Int32%29> método preenche o final da cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2477">The <xref:System.String.PadRight%28System.Int32%29> method pads the end of the returned string.</span></span> <span data-ttu-id="58835-2478">Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte esquerda da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2478">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2479">Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2479">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2480">Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com espaços em branco à direita, para que seu tamanho total é `totalWidth` caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2480">Instead, it returns a new string that is padded with trailing white space so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2481">O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2481">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2482">
            <paramref name="totalWidth" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2482">
              <paramref name="totalWidth" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="PadRight">
      <MemberSignature Language="C#" Value="public string PadRight (int totalWidth, char paddingChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string PadRight(int32 totalWidth, char paddingChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.PadRight(System.Int32,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function PadRight (totalWidth As Integer, paddingChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ PadRight(int totalWidth, char paddingChar);" />
      <MemberSignature Language="F#" Value="member this.PadRight : int * char -&gt; string" Usage="string.PadRight (totalWidth, paddingChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalWidth" Type="System.Int32" />
        <Parameter Name="paddingChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="totalWidth">
          <span data-ttu-id="58835-2483">O número de caracteres na cadeia de caracteres resultante, igual ao número de caracteres originais mais alguns caracteres de preenchimento adicionais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2483">The number of characters in the resulting string, equal to the number of original characters plus any additional padding characters.</span>
          </span>
        </param>
        <param name="paddingChar">
          <span data-ttu-id="58835-2484">Um caractere de preenchimento de Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2484">A Unicode padding character.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2485">Retorna uma nova cadeia de caracteres que alinha os caracteres à esquerda nessa cadeia de caracteres, preenchendo-os à direita com um caractere Unicode especificado, para um tamanho total especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2485">Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2486">Uma nova cadeia de caracteres equivalente a essa instância, mas alinhada à esquerda e preenchida à direita com o máximo de caracteres <paramref name="paddingChar" /> necessários para criar um tamanho <paramref name="totalWidth" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2486">A new string that is equivalent to this instance, but left-aligned and padded on the right with as many <paramref name="paddingChar" /> characters as needed to create a length of <paramref name="totalWidth" />.</span>
          </span>
          <span data-ttu-id="58835-2487">No entanto, se <paramref name="totalWidth" /> for menor que o tamanho dessa instância, o método retornará uma referência à instância existente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2487">However, if <paramref name="totalWidth" /> is less than the length of this instance, the method returns a reference to the existing instance.</span>
          </span>
          <span data-ttu-id="58835-2488">Caso <paramref name="totalWidth" /> seja igual ao tamanho desta instância, o método retorna uma nova cadeia de caracteres idêntica a essa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2488">If <paramref name="totalWidth" /> is equal to the length of this instance, the method returns a new string that is identical to this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2489">O <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> método preenche o final da cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2489">The <xref:System.String.PadRight%28System.Int32%2CSystem.Char%29> method pads the end of the returned string.</span></span> <span data-ttu-id="58835-2490">Isso significa que, quando usada com idiomas da direita para esquerda, ele preenche a parte esquerda da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2490">This means that, when used with right-to-left languages, it pads the left portion of the string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2491">Se o <xref:System.String.PadRight%2A> método preenche a instância atual com caracteres de espaço em branco, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2491">If the <xref:System.String.PadRight%2A> method pads the current instance with whitespace characters, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2492">Em vez disso, ele retorna uma nova cadeia de caracteres que é preenchida com à direita `paddingChar` caracteres de modo que seu tamanho total é `totalWidth` caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2492">Instead, it returns a new string that is padded with trailing `paddingChar` characters so that its total length is `totalWidth` characters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2493">O exemplo a seguir demonstra o <xref:System.String.PadRight%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2493">The following example demonstrates the <xref:System.String.PadRight%2A> method.</span></span>  
  
 [!code-cpp[Classic String.PadRight1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic String.PadRight1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/cs/source.cs#1)]
 [!code-vb[Classic String.PadRight1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.PadRight1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2494">
            <paramref name="totalWidth" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2494">
              <paramref name="totalWidth" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.PadLeft(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2495">Retorna uma nova cadeia de caracteres na qual um número especificado de caracteres da cadeia de caracteres atual é excluído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2495">Returns a new string in which a specified number of characters from the current string are deleted.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Remove : int -&gt; string" Usage="string.Remove startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-2496">A posição baseada em zero para iniciar a exclusão de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2496">The zero-based position to begin deleting characters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2497">Retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual, começando na posição especificada e continuando até a última posição, foram excluídos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2497">Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2498">Uma nova cadeia de caracteres equivalente a essa cadeia de caracteres, exceto os caracteres removidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2498">A new string that is equivalent to this string except for the removed characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2499">No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseados em zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2499">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="58835-2500">O valor da `startIndex` parâmetro pode variar de zero, a menos que o comprimento da instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2500">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2501">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2501">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2502">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres da posição `startIndex` ao final da cadeia de caracteres original tenha sido removido.</span><span class="sxs-lookup"><span data-stu-id="58835-2502">Instead, it returns a new string in which all characters from position `startIndex` to the end of the original string have been removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2503">O exemplo a seguir demonstra o <xref:System.String.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2503">The following example demonstrates the <xref:System.String.Remove%2A> method.</span></span> <span data-ttu-id="58835-2504">O próximo ao último caso remove todo o texto a partir do índice especificado até o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2504">The next-to-last case removes all text starting from the specified index through the end of the string.</span></span> <span data-ttu-id="58835-2505">O último caso remove três caracteres, começando do índice especificado.</span><span class="sxs-lookup"><span data-stu-id="58835-2505">The last case removes three characters starting from the specified index.</span></span>  
  
 [!code-cpp[string.remove#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.remove/CPP/r.cpp#1)]
 [!code-csharp[string.remove#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.remove/CS/r.cs#1)]
 [!code-vb[string.remove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.remove/VB/r.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2506">
            <paramref name="startIndex" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2506">
              <paramref name="startIndex" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-2507">-ou- <paramref name="startIndex" /> especifica uma posição que não está nessa cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2507">-or-  <paramref name="startIndex" /> specifies a position that is not within this string.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public string Remove (int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Remove(int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Remove(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (startIndex As Integer, count As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Remove(int startIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.Remove : int * int -&gt; string" Usage="string.Remove (startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-2508">A posição baseada em zero para iniciar a exclusão de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2508">The zero-based position to begin deleting characters.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2509">O número de caracteres a ser excluído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2509">The number of characters to delete.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2510">Retorna uma nova cadeia de caracteres em que um número especificado de caracteres na instância atual que começa na posição especificada foi excluído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2510">Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2511">Uma nova cadeia de caracteres equivalente a essa instância, exceto os caracteres removidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2511">A new string that is equivalent to this instance except for the removed characters.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2512">No [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], cadeias de caracteres são baseados em zero.</span><span class="sxs-lookup"><span data-stu-id="58835-2512">In the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], strings are zero-based.</span></span> <span data-ttu-id="58835-2513">O valor da `startIndex` parâmetro pode variar de zero, a menos que o comprimento da instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2513">The value of the `startIndex` parameter can range from zero to one less than the length of the string instance.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2514">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2514">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2515">Em vez disso, ele retorna uma nova cadeia de caracteres na qual o número de caracteres especificado pelo `count` parâmetro foram removidos.</span><span class="sxs-lookup"><span data-stu-id="58835-2515">Instead, it returns a new string in which the number of characters specified by the `count` parameter have been removed.</span></span> <span data-ttu-id="58835-2516">Os caracteres são removidos na posição especificada por `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="58835-2516">The characters are removed at the position specified by `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2517">O exemplo a seguir demonstra como você pode remover o nome do meio de um nome completo.</span><span class="sxs-lookup"><span data-stu-id="58835-2517">The following example demonstrates how you can remove the middle name from a complete name.</span></span>  
  
 [!code-cpp[stringremove#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringremove/CPP/stringremove.cpp#1)]
 [!code-csharp[stringremove#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringremove/CS/stringremove.cs#1)]
 [!code-vb[stringremove#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringremove/VB/stringremove.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2518">
            <paramref name="startIndex" /> ou <paramref name="count" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2518">Either <paramref name="startIndex" /> or <paramref name="count" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-2519">-ou- A soma de <paramref name="startIndex" /> e <paramref name="count" /> especifica uma posição fora dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2519">-or-  <paramref name="startIndex" /> plus <paramref name="count" /> specify a position outside this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Replace">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2520">Retorna uma nova cadeia de caracteres na qual todas as ocorrências de um caractere Unicode especificado ou <see cref="T:System.String" /> na cadeia de caracteres atual são substituídas por outro caractere Unicode especificado ou por <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2520">Returns a new string in which all occurrences of a specified Unicode character or <see cref="T:System.String" /> in the current string are replaced with another specified Unicode character or <see cref="T:System.String" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (char oldChar, char newChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(char oldChar, char newChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.Char,System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldChar As Char, newChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(char oldChar, char newChar);" />
      <MemberSignature Language="F#" Value="member this.Replace : char * char -&gt; string" Usage="string.Replace (oldChar, newChar)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldChar" Type="System.Char" />
        <Parameter Name="newChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="oldChar">
          <span data-ttu-id="58835-2521">O caractere Unicode a ser substituído.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2521">The Unicode character to be replaced.</span>
          </span>
        </param>
        <param name="newChar">
          <span data-ttu-id="58835-2522">O caractere Unicode para substituir todas as ocorrências de <c>oldChar</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2522">The Unicode character to replace all occurrences of <c>oldChar</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2523">Retorna uma nova cadeia de caracteres na qual todas as ocorrências de um caractere Unicode especificado nessa instância são substituídas por outro caractere Unicode especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2523">Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2524">Uma cadeia de caracteres equivalente a essa instância, com exceção de que todas as instâncias de <paramref name="oldChar" /> são substituídas por <paramref name="newChar" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2524">A string that is equivalent to this instance except that all instances of <paramref name="oldChar" /> are replaced with <paramref name="newChar" />.</span>
          </span>
          <span data-ttu-id="58835-2525">Se <paramref name="oldChar" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2525">If <paramref name="oldChar" /> is not found in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2526">Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e insensível à cultura) para localizar `oldChar`.</span><span class="sxs-lookup"><span data-stu-id="58835-2526">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldChar`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2527">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2527">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2528">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldChar` são substituídos por `newChar`.</span><span class="sxs-lookup"><span data-stu-id="58835-2528">Instead, it returns a new string in which all occurrences of `oldChar` are replaced by `newChar`.</span></span>  
  
 <span data-ttu-id="58835-2529">Como esse método retorna a cadeia de caracteres modificada, é possível encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original.</span><span class="sxs-lookup"><span data-stu-id="58835-2529">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="58835-2530">Chamadas de método são executadas da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="58835-2530">Method calls are executed from left to right.</span></span> <span data-ttu-id="58835-2531">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="58835-2531">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace2.cs#2)]
 [!code-vb[System.String.Replace#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace2.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2532">O exemplo a seguir cria uma lista de valores separados por vírgula, substituindo vírgulas para os espaços em branco entre uma série de números.</span><span class="sxs-lookup"><span data-stu-id="58835-2532">The following example creates a comma separated value list by substituting commas for the blanks between a series of numbers.</span></span>  
  
 [!code-cpp[string.replace1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.replace1/CPP/string.replace1.cpp#1)]
 [!code-csharp[string.replace1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.replace1/CS/string.replace1.cs#1)]
 [!code-vb[string.replace1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.replace1/VB/string.replace1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string -&gt; string" Usage="string.Replace (oldValue, newValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="oldValue">
          <span data-ttu-id="58835-2533">A cadeia de caracteres a ser substituída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2533">The string to be replaced.</span>
          </span>
        </param>
        <param name="newValue">
          <span data-ttu-id="58835-2534">A cadeia de caracteres para substituir todas as ocorrências de <c>oldValue</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2534">The string to replace all occurrences of <c>oldValue</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2535">Retorna uma nova cadeia de caracteres na qual todas as ocorrências de uma cadeia de caracteres especificada na instância atual são substituídas por outra cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2535">Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2536">Uma cadeia de caracteres equivalente à atual cadeia de caracteres, com exceção de que todas as instâncias de <paramref name="oldValue" /> são substituídas por <paramref name="newValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2536">A string that is equivalent to the current string except that all instances of <paramref name="oldValue" /> are replaced with <paramref name="newValue" />.</span>
          </span>
          <span data-ttu-id="58835-2537">Se <paramref name="oldValue" /> não for encontrado na instância atual, o método retornará a instância atual inalterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2537">If <paramref name="oldValue" /> is not found in the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2538">Se `newValue` está `null`, todas as ocorrências de `oldValue` são removidos.</span><span class="sxs-lookup"><span data-stu-id="58835-2538">If `newValue` is `null`, all occurrences of `oldValue` are removed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-2539">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2539">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-2540">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todas as ocorrências de `oldValue` são substituídos por `newValue`.</span><span class="sxs-lookup"><span data-stu-id="58835-2540">Instead, it returns a new string in which all occurrences of `oldValue` are replaced by `newValue`.</span></span>  
  
 <span data-ttu-id="58835-2541">Esse método executa uma pesquisa ordinal (diferencia maiusculas de minúsculas e insensível à cultura) para localizar `oldValue`.</span><span class="sxs-lookup"><span data-stu-id="58835-2541">This method performs an ordinal (case-sensitive and culture-insensitive) search to find `oldValue`.</span></span>  
  
 <span data-ttu-id="58835-2542">Como esse método retorna a cadeia de caracteres modificada, é possível encadear chamadas sucessivas para o <xref:System.String.Replace%2A> método para executar várias substituições na cadeia de caracteres original.</span><span class="sxs-lookup"><span data-stu-id="58835-2542">Because this method returns the modified string, you can chain together successive calls to the <xref:System.String.Replace%2A> method to perform multiple replacements on the original string.</span></span> <span data-ttu-id="58835-2543">Chamadas de método são executadas da esquerda para a direita.</span><span class="sxs-lookup"><span data-stu-id="58835-2543">Method calls are executed from left to right.</span></span> <span data-ttu-id="58835-2544">O exemplo a seguir fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="58835-2544">The following example provides an illustration.</span></span>  
  
 [!code-csharp[System.String.Replace#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.replace/cs/replace1.cs#1)]
 [!code-vb[System.String.Replace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.replace/vb/replace1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="58835-2545">O exemplo a seguir demonstra como você pode usar o <xref:System.String.Replace%2A> método para corrigir um erro de ortografia.</span><span class="sxs-lookup"><span data-stu-id="58835-2545">The following example demonstrates how you can use the <xref:System.String.Replace%2A> method to correct a spelling error.</span></span>  
  
 [!code-cpp[stringreplace#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringreplace/CPP/stringreplace.cpp#1)]
 [!code-csharp[stringreplace#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringreplace/CS/stringreplace.cs#1)]
 [!code-vb[stringreplace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringreplace/VB/stringreplace.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2546">
            <paramref name="oldValue" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2546">
              <paramref name="oldValue" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2547">
            <paramref name="oldValue" /> é a cadeia de caracteres vazia ("").</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2547">
              <paramref name="oldValue" /> is the empty string ("").</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, comparisonType As StringComparison) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * StringComparison -&gt; string" Usage="string.Replace (oldValue, newValue, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="comparisonType">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Replace">
      <MemberSignature Language="C#" Value="public string Replace (string oldValue, string newValue, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Replace(string oldValue, string newValue, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Replace(System.String,System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function Replace (oldValue As String, newValue As String, ignoreCase As Boolean, culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Replace(System::String ^ oldValue, System::String ^ newValue, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.Replace : string * string * bool * System.Globalization.CultureInfo -&gt; string" Usage="string.Replace (oldValue, newValue, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.String" />
        <Parameter Name="newValue" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="oldValue">To be added.</param>
        <param name="newValue">To be added.</param>
        <param name="ignoreCase">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Split">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2548">Retorna uma matriz de cadeia de caracteres que contém as subcadeias de caracteres nesta instância delimitadas por elementos de uma cadeia de caracteres especificada ou da matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2548">Returns a string array that contains the substrings in this instance that are delimited by elements of a specified string or Unicode character array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2549"><xref:System.String.Split%2A> é usado para dividir uma cadeia de caracteres delimitada em subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2549"><xref:System.String.Split%2A> is used to break a delimited string into substrings.</span></span> <span data-ttu-id="58835-2550">Você pode usar uma matriz de caracteres para especificar zero, um ou vários caracteres de delimitação (o <xref:System.String.Split%28System.Char%5B%5D%29> método), ou você pode usar uma matriz de caracteres para especificar zero, uma ou várias cadeias de caracteres de delimitação.</span><span class="sxs-lookup"><span data-stu-id="58835-2550">You can use either a character array to specify zero, one, or multiple delimiting characters (the <xref:System.String.Split%28System.Char%5B%5D%29> method), or you can use a character array to specify zero, one, or multiple delimiting strings.</span></span> <span data-ttu-id="58835-2551">Sobrecargas do <xref:System.String.Split%2A> método permitem que você limite o número de subcadeias de caracteres retornada pelo método (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> método), para determinar se cadeias de caracteres vazias são incluídas nas subcadeias de caracteres retornadas (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> métodos, ou ambos (o <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> e <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> métodos).</span><span class="sxs-lookup"><span data-stu-id="58835-2551">Overloads of the <xref:System.String.Split%2A> method allow you to limit the number of substrings returned by the method (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%29> method), to determine whether empty strings are included in the returned substrings (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> methods, or to do both (the <xref:System.String.Split%28System.Char%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> and <xref:System.String.Split%28System.String%5B%5D%2CSystem.Int32%2CSystem.StringSplitOptions%29> methods).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="58835-2552">Para obter mais informações sobre o <xref:System.String.Split%2A> método, pois assim como para obter exemplos que chamarem cada sobrecarga, consulte a documentação para as sobrecargas individuais do <xref:System.String.Split%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-2552">For more detailed information on the <xref:System.String.Split%2A> method, as well as for examples that call each overload, see the documentation for the individual overloads of <xref:System.String.Split%2A>.</span></span>  
  
 <span data-ttu-id="58835-2553">O <xref:System.String.Split%2A> método nem sempre é a melhor maneira de dividir uma cadeia de caracteres delimitada em subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2553">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="58835-2554">Se você não deseja extrair todas as subcadeias de caracteres de uma cadeia de caracteres delimitada, ou se você quiser analisar uma cadeia de caracteres com base em um padrão em vez de um conjunto de caracteres do delimitador, considere alternativas a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-2554">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
## <a name="regular-expressions"></a><span data-ttu-id="58835-2555">Expressões regulares</span><span class="sxs-lookup"><span data-stu-id="58835-2555">Regular expressions</span></span>  
 <span data-ttu-id="58835-2556">Se suas cadeias de caracteres estão em conformidade com um padrão fixo, você pode usar uma expressão regular para extrair e manipular seus elementos.</span><span class="sxs-lookup"><span data-stu-id="58835-2556">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="58835-2557">Por exemplo, se as cadeias de caracteres assumem a forma "*número* *operando* *número*" você pode usar um [expressão regular](~/docs/standard/base-types/regular-expressions.md) para extrair e lidar com o elementos da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2557">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="58835-2558">Veja um exemplo:</span><span class="sxs-lookup"><span data-stu-id="58835-2558">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="58835-2559">O padrão de expressão regular `(\d+)\s+([-+*/])\s+(\d+)` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2559">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2560">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2560">Pattern</span></span>|<span data-ttu-id="58835-2561">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2561">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="58835-2562">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="58835-2562">Match one or more decimal digits.</span></span> <span data-ttu-id="58835-2563">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2563">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="58835-2564">Corresponde a um ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2564">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="58835-2565">Corresponder ao sinal de um operador aritmético (+, -, \*, ou /).</span><span class="sxs-lookup"><span data-stu-id="58835-2565">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="58835-2566">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2566">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="58835-2567">Corresponde a um ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2567">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="58835-2568">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="58835-2568">Match one or more decimal digits.</span></span> <span data-ttu-id="58835-2569">Este é o terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2569">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="58835-2570">Você também pode usar uma expressão regular para extrair subcadeias de caracteres de uma cadeia de caracteres com base em um padrão em vez de um conjunto fixo de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2570">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="58835-2571">Isso é um cenário comum quando qualquer uma dessas condições ocorre:</span><span class="sxs-lookup"><span data-stu-id="58835-2571">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="58835-2572">Um ou mais dos caracteres delimitador não sempre funciona como um delimitador no <xref:System.String> instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2572">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="58835-2573">A sequência e o número de caracteres de delimitador é desconhecido ou variável.</span><span class="sxs-lookup"><span data-stu-id="58835-2573">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="58835-2574">Por exemplo, o <xref:System.String.Split%2A> método não pode ser usado para dividir a cadeia de caracteres a seguir, porque o número de `\n` (em c#) ou `vbCrLf` (no Visual Basic) caracteres é variável, e eles não servem sempre como delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2574">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="58835-2575">Uma expressão regular pode dividir essa cadeia de caracteres com facilidade, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-2575">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="58835-2576">O padrão de expressão regular `\[([^\[\]]+)\]` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2576">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2577">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2577">Pattern</span></span>|<span data-ttu-id="58835-2578">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2578">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="58835-2579">Corresponde a um colchete de abertura.</span><span class="sxs-lookup"><span data-stu-id="58835-2579">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="58835-2580">Corresponde a qualquer caractere que não é uma colchete de abertura ou um fechamento uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="58835-2580">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="58835-2581">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2581">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="58835-2582">Corresponde a um colchete de fechamento.</span><span class="sxs-lookup"><span data-stu-id="58835-2582">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="58835-2583">O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método é quase idêntico ao <xref:System.String.Split%2A?displayProperty=nameWithType>, exceto que ele divide uma cadeia de caracteres com base em um padrão de expressão regular, em vez de um conjunto de caracteres fixa.</span><span class="sxs-lookup"><span data-stu-id="58835-2583">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="58835-2584">Por exemplo, o exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir uma cadeia de caracteres que contém as subcadeias de caracteres delimitadas por várias combinações de outros caracteres e hifens.</span><span class="sxs-lookup"><span data-stu-id="58835-2584">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="58835-2585">O padrão de expressão regular `\s-\s?[+*]?\s?-\s` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2585">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2586">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2586">Pattern</span></span>|<span data-ttu-id="58835-2587">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2587">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="58835-2588">Corresponde a um caractere de espaço em branco seguido por um hífen.</span><span class="sxs-lookup"><span data-stu-id="58835-2588">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="58835-2589">Corresponde a zero ou um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2589">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="58835-2590">Corresponde a zero ou uma ocorrência de qualquer um de + ou \* caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2590">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="58835-2591">Corresponde a zero ou um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2591">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="58835-2592">Corresponde a um hífen seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2592">Match a hyphen followed by a whitespace character.</span></span>|  
  
## <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="58835-2593">Métodos de pesquisa e o método Substring</span><span class="sxs-lookup"><span data-stu-id="58835-2593">Search methods and the Substring method</span></span>  
 <span data-ttu-id="58835-2594">Se você não estiver interessado em todas as subcadeias de caracteres em uma cadeia de caracteres, você talvez prefira trabalhar com um dos métodos de comparação de cadeia de caracteres que retorna o índice no qual a correspondência começa.</span><span class="sxs-lookup"><span data-stu-id="58835-2594">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="58835-2595">Em seguida, você pode chamar o <xref:System.String.Substring%2A> método para extrair a subcadeia de caracteres que você deseja.</span><span class="sxs-lookup"><span data-stu-id="58835-2595">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="58835-2596">Os métodos de comparação de cadeia de caracteres incluem:</span><span class="sxs-lookup"><span data-stu-id="58835-2596">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="58835-2597"><xref:System.String.IndexOf%2A>, que retorna o índice baseado em zero da primeira ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2597"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="58835-2598"><xref:System.String.IndexOfAny%2A>, que retorna o índice baseado em zero na instância atual de cadeia de caracteres da primeira ocorrência de qualquer caractere em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2598"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="58835-2599"><xref:System.String.LastIndexOf%2A>, que retorna o índice baseado em zero da última ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2599"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="58835-2600"><xref:System.String.LastIndexOfAny%2A>, que retorna um índice baseado em zero na instância atual de cadeia de caracteres da última ocorrência de qualquer caractere em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2600"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="58835-2601">O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para localizar os períodos em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2601">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="58835-2602">Ele usa o <xref:System.String.Substring%2A> método para retornar frases completas.</span><span class="sxs-lookup"><span data-stu-id="58835-2602">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (params char[] separator);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (ParamArray separator As Char()) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(... cli::array &lt;char&gt; ^ separator);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] -&gt; string[]" Usage="string.Split separator" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2603">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2603">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2604">Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2604">Splits a string into substrings that are based on the characters in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2605">Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2605">An array whose elements contain the substrings from this instance that are delimited by one or more characters in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2606">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2606">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2607">Quando uma cadeia de caracteres é delimitada por um conjunto conhecido de caracteres, você pode usar o <xref:System.String.Split%28System.Char%5B%5D%29> método para separá-lo em subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2607">When a string is delimited by a known set of characters, you can use the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate it into substrings.</span></span> <span data-ttu-id="58835-2608">Para outras maneiras de extrair subcadeias de caracteres de uma cadeia de caracteres, consulte a [alternativas para String. Split](#Alternatives) seção.</span><span class="sxs-lookup"><span data-stu-id="58835-2608">For other ways to extract substrings from a string, see the [Alternatives to String.Split](#Alternatives) section.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="58835-2609">Detalhes do valor de retorno</span><span class="sxs-lookup"><span data-stu-id="58835-2609">Return value details</span></span>  
 <span data-ttu-id="58835-2610">Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2610">Delimiter characters are not included in the elements of the returned array.</span></span> <span data-ttu-id="58835-2611">Por exemplo, se a matriz de separador inclui o caractere "-" e o valor da instância atual de cadeia de caracteres "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".</span><span class="sxs-lookup"><span data-stu-id="58835-2611">For example, if the separator array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="58835-2612">Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2612">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="58835-2613">Cada elemento de `separator` define um caractere delimitador à parte.</span><span class="sxs-lookup"><span data-stu-id="58835-2613">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="58835-2614">Se dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento correspondente na matriz retornada contém <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-2614">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding element in the returned array contains <xref:System.String.Empty>.</span></span> <span data-ttu-id="58835-2615">Estes são alguns exemplos:</span><span class="sxs-lookup"><span data-stu-id="58835-2615">Here are some examples:</span></span>  
  
|<span data-ttu-id="58835-2616">Valor da cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-2616">String value</span></span>|<span data-ttu-id="58835-2617">Separador</span><span class="sxs-lookup"><span data-stu-id="58835-2617">Separator</span></span>|<span data-ttu-id="58835-2618">Matriz retornada</span><span class="sxs-lookup"><span data-stu-id="58835-2618">Returned array</span></span>|  
|------------------|---------------|--------------------|  
|<span data-ttu-id="58835-2619">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="58835-2619">"42, 12, 19"</span></span>|<span data-ttu-id="58835-2620">novo Char [] {',', ' '} (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2620">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="58835-2621">Char () = {"," c, "" c}) (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2621">Char() = {","c, " "c}) (Visual Basic)</span></span>|<span data-ttu-id="58835-2622">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="58835-2622">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="58835-2623">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="58835-2623">"42..12..19"</span></span>|<span data-ttu-id="58835-2624">novo Char [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="58835-2624">new Char[] {'.'}</span></span> <span data-ttu-id="58835-2625">(C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2625">(C#)</span></span><br /><br /> <span data-ttu-id="58835-2626">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2626">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="58835-2627">{"42", "", "12", "", "19"}</span><span class="sxs-lookup"><span data-stu-id="58835-2627">{"42", "", "12", "", "19"}</span></span>|  
|<span data-ttu-id="58835-2628">"Banana"</span><span class="sxs-lookup"><span data-stu-id="58835-2628">"Banana"</span></span>|<span data-ttu-id="58835-2629">novo Char [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="58835-2629">new Char[] {'.'}</span></span> <span data-ttu-id="58835-2630">(C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2630">(C#)</span></span><br /><br /> <span data-ttu-id="58835-2631">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2631">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="58835-2632">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="58835-2632">{"Banana"}</span></span>|  
|<span data-ttu-id="58835-2633">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2633">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="58835-2634">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2634">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="58835-2635">novo Char [] {} (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2635">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="58835-2636">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2636">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="58835-2637">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="58835-2637">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="58835-2638">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2638">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="58835-2639">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2639">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="58835-2640">null (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2640">null (C#)</span></span><br /><br /> <span data-ttu-id="58835-2641">Nada (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2641">Nothing (Visual Basic)</span></span>|<span data-ttu-id="58835-2642">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="58835-2642">{"Darb", "Smarba"}</span></span>|  
  
## <a name="the-separator-array"></a><span data-ttu-id="58835-2643">A matriz de separador</span><span class="sxs-lookup"><span data-stu-id="58835-2643">The separator array</span></span>  
 <span data-ttu-id="58835-2644">Cada elemento do separador define um delimitador separado que consiste em um único caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2644">Each element of separator defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="58835-2645">Se o `separator` argumento for `null` ou não contiver caracteres, o método trata caracteres de espaço em branco como delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2645">If the `separator` argument is `null` or contains no characters, the method treats white-space characters as the delimiters.</span></span> <span data-ttu-id="58835-2646">Os caracteres de espaço em branco são definidos por padrão; Unicode elas retornam `true` se eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2646">White-space characters are defined by the Unicode standard; they return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
## <a name="stringsplitchar-and-compiler-overload-resolution"></a><span data-ttu-id="58835-2647">Resolução de sobrecarga do compilador e String.Split(Char[])</span><span class="sxs-lookup"><span data-stu-id="58835-2647">String.Split(Char[]) and compiler overload resolution</span></span>  
 <span data-ttu-id="58835-2648">Embora o único parâmetro para essa sobrecarga de <xref:System.String.Split%2A?displayProperty=nameWithType> é uma matriz de caracteres, você pode chamá-lo com um único caractere, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-2648">Although the single parameter for this overload of <xref:System.String.Split%2A?displayProperty=nameWithType> is a character array, you can call it with a single character, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split_CompilerResolution1.cs#12)]
 [!code-vb[System.String.Split#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split_CompilerResolution1.vb#12)]  
  
 <span data-ttu-id="58835-2649">Porque o `separator` parâmetro seja decorado com o <xref:System.ParamArrayAttribute> atributo, os compiladores irá interpretar um único caractere como uma matriz de caracteres de elemento único.</span><span class="sxs-lookup"><span data-stu-id="58835-2649">Because the `separator` parameter is decorated  with the <xref:System.ParamArrayAttribute> attribute, compilers will interpret a single character as a single-element character array.</span></span> <span data-ttu-id="58835-2650">Isso não for o caso para outros <xref:System.String.Split%2A?displayProperty=nameWithType> sobrecargas que incluem uma `separator` parâmetro; deve passar essas sobrecargas explicitamente uma matriz de caracteres como o `separator` argumento.</span><span class="sxs-lookup"><span data-stu-id="58835-2650">This is not the case for other <xref:System.String.Split%2A?displayProperty=nameWithType> overloads that include a `separator` parameter; you must explicitly pass these overloads a character array as the `separator` argument.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="58835-2651">Detalhes de comparação</span><span class="sxs-lookup"><span data-stu-id="58835-2651">Comparison details</span></span>  
 <span data-ttu-id="58835-2652">O <xref:System.String.Split%28System.Char%5B%5D%29> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por um ou mais dos caracteres no `separator` de matriz e retorna as subcadeias de caracteres como elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2652">The <xref:System.String.Split%28System.Char%5B%5D%29> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` array, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="58835-2653">O <xref:System.String.Split%28System.Char%5B%5D%29> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2653">The <xref:System.String.Split%28System.Char%5B%5D%29> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="58835-2654">Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2654">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
<a name="Alternatives"></a>   
## <a name="alternatives-to-stringsplit"></a><span data-ttu-id="58835-2655">Alternativas para String. Split</span><span class="sxs-lookup"><span data-stu-id="58835-2655">Alternatives to String.Split</span></span>  
 <span data-ttu-id="58835-2656">O <xref:System.String.Split%2A> método nem sempre é a melhor maneira de dividir uma cadeia de caracteres delimitada em subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2656">The <xref:System.String.Split%2A> method is not always the best way to break a delimited string into substrings.</span></span> <span data-ttu-id="58835-2657">Se você não deseja extrair todas as subcadeias de caracteres de uma cadeia de caracteres delimitada, ou se você quiser analisar uma cadeia de caracteres com base em um padrão em vez de um conjunto de caracteres do delimitador, considere alternativas a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-2657">If you don't want to extract all of the substrings of a delimited string, or if you want to parse a string based on a pattern instead of a set of delimiter characters, consider the following alternatives.</span></span>  
  
### <a name="regular-expressions"></a><span data-ttu-id="58835-2658">Expressões regulares</span><span class="sxs-lookup"><span data-stu-id="58835-2658">Regular expressions</span></span>  
 <span data-ttu-id="58835-2659">Se suas cadeias de caracteres estão em conformidade com um padrão fixo, você pode usar uma expressão regular para extrair e manipular seus elementos.</span><span class="sxs-lookup"><span data-stu-id="58835-2659">If your strings conform to a fixed pattern, you can use a regular expression to extract and handle their elements.</span></span> <span data-ttu-id="58835-2660">Por exemplo, se as cadeias de caracteres assumem a forma "*número* *operando* *número*" você pode usar um [expressão regular](~/docs/standard/base-types/regular-expressions.md) para extrair e lidar com o elementos da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2660">For example, if strings take the form "*number* *operand* *number*" you can use a [regular expression](~/docs/standard/base-types/regular-expressions.md) to extract and handle the string's elements.</span></span> <span data-ttu-id="58835-2661">Veja um exemplo:</span><span class="sxs-lookup"><span data-stu-id="58835-2661">Here's an example:</span></span>  
  
 [!code-csharp[System.String.Split#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt1.cs#8)]
 [!code-vb[System.String.Split#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt1.vb#8)]  
  
 <span data-ttu-id="58835-2662">O padrão de expressão regular `(\d+)\s+([-+*/])\s+(\d+)` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2662">The regular expression pattern `(\d+)\s+([-+*/])\s+(\d+)` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2663">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2663">Pattern</span></span>|<span data-ttu-id="58835-2664">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2664">Description</span></span>|  
|-------------|-----------------|  
|`(\d+)`|<span data-ttu-id="58835-2665">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="58835-2665">Match one or more decimal digits.</span></span> <span data-ttu-id="58835-2666">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2666">This is the first capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="58835-2667">Corresponde a um ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2667">Match one or more whitespace characters.</span></span>|  
|`([-+*/])`|<span data-ttu-id="58835-2668">Corresponder ao sinal de um operador aritmético (+, -, \*, ou /).</span><span class="sxs-lookup"><span data-stu-id="58835-2668">Match an arithmetic operator sign (+, -, \*, or /).</span></span> <span data-ttu-id="58835-2669">Este é o segundo grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2669">This is the second capturing group.</span></span>|  
|`\s+`|<span data-ttu-id="58835-2670">Corresponde a um ou mais caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2670">Match one or more whitespace characters.</span></span>|  
|`(\d+)`|<span data-ttu-id="58835-2671">Corresponde a um ou mais dígitos decimais.</span><span class="sxs-lookup"><span data-stu-id="58835-2671">Match one or more decimal digits.</span></span> <span data-ttu-id="58835-2672">Este é o terceiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2672">This is the third capturing group.</span></span>|  
  
 <span data-ttu-id="58835-2673">Você também pode usar uma expressão regular para extrair subcadeias de caracteres de uma cadeia de caracteres com base em um padrão em vez de um conjunto fixo de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2673">You can also use a regular expression to extract substrings from a string based on a pattern rather than a fixed set of characters.</span></span> <span data-ttu-id="58835-2674">Isso é um cenário comum quando qualquer uma dessas condições ocorre:</span><span class="sxs-lookup"><span data-stu-id="58835-2674">This is a common scenario when either of these conditions occurs:</span></span>  
  
-   <span data-ttu-id="58835-2675">Um ou mais dos caracteres delimitador não sempre funciona como um delimitador no <xref:System.String> instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2675">One or more of the delimiter characters does not always serve as a delimiter in the <xref:System.String> instance.</span></span>  
  
-   <span data-ttu-id="58835-2676">A sequência e o número de caracteres de delimitador é desconhecido ou variável.</span><span class="sxs-lookup"><span data-stu-id="58835-2676">The sequence and number of delimiter characters is variable or unknown.</span></span>  
  
 <span data-ttu-id="58835-2677">Por exemplo, o <xref:System.String.Split%2A> método não pode ser usado para dividir a cadeia de caracteres a seguir, porque o número de `\n` (em c#) ou `vbCrLf` (no Visual Basic) caracteres é variável, e eles não servem sempre como delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2677">For example, the <xref:System.String.Split%2A> method cannot be used to split the following string, because the number of `\n` (in C#) or `vbCrLf` (in Visual Basic) characters is variable, and they don't always serve as delimiters.</span></span>  
  
```  
  
[This is captured\ntext.]\n\n[\n[This is more captured text.]\n]  
\n[Some more captured text:\n   Option1\n   Option2][Terse text.]  
  
```  
  
 <span data-ttu-id="58835-2678">Uma expressão regular pode dividir essa cadeia de caracteres com facilidade, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="58835-2678">A regular expression can split this string easily, as the following example shows.</span></span>  
  
 [!code-csharp[System.String.Split#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt2.cs#9)]
 [!code-vb[System.String.Split#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt2.vb#9)]  
  
 <span data-ttu-id="58835-2679">O padrão de expressão regular `\[([^\[\]]+)\]` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2679">The regular expression pattern `\[([^\[\]]+)\]` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2680">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2680">Pattern</span></span>|<span data-ttu-id="58835-2681">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2681">Description</span></span>|  
|-------------|-----------------|  
|`\[`|<span data-ttu-id="58835-2682">Corresponde a um colchete de abertura.</span><span class="sxs-lookup"><span data-stu-id="58835-2682">Match an opening bracket.</span></span>|  
|`([^\[\]]+)`|<span data-ttu-id="58835-2683">Corresponde a qualquer caractere que não é uma colchete de abertura ou um fechamento uma ou mais vezes.</span><span class="sxs-lookup"><span data-stu-id="58835-2683">Match any character that is not an opening or a closing bracket one or more times.</span></span> <span data-ttu-id="58835-2684">Este é o primeiro grupo de captura.</span><span class="sxs-lookup"><span data-stu-id="58835-2684">This is the first capturing group.</span></span>|  
|`\]`|<span data-ttu-id="58835-2685">Corresponde a um colchete de fechamento.</span><span class="sxs-lookup"><span data-stu-id="58835-2685">Match a closing bracket.</span></span>|  
  
 <span data-ttu-id="58835-2686">O <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método é quase idêntico ao <xref:System.String.Split%2A?displayProperty=nameWithType>, exceto que ele divide uma cadeia de caracteres com base em um padrão de expressão regular, em vez de um conjunto de caracteres fixa.</span><span class="sxs-lookup"><span data-stu-id="58835-2686">The <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method is almost identical to <xref:System.String.Split%2A?displayProperty=nameWithType>, except that it splits a string based on a regular expression pattern instead of a fixed character set.</span></span> <span data-ttu-id="58835-2687">Por exemplo, o exemplo a seguir usa o <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> método para dividir uma cadeia de caracteres que contém as subcadeias de caracteres delimitadas por várias combinações de outros caracteres e hifens.</span><span class="sxs-lookup"><span data-stu-id="58835-2687">For example, the following example uses the <xref:System.Text.RegularExpressions.Regex.Split%2A?displayProperty=nameWithType> method to split a string that contains substrings delimited by various combinations of hyphens and other characters.</span></span>  
  
 [!code-csharp[System.String.Split#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt3.cs#10)]
 [!code-vb[System.String.Split#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt3.vb#10)]  
  
 <span data-ttu-id="58835-2688">O padrão de expressão regular `\s-\s?[+*]?\s?-\s` é definido como este:</span><span class="sxs-lookup"><span data-stu-id="58835-2688">The regular expression pattern `\s-\s?[+*]?\s?-\s` is defined like this:</span></span>  
  
|<span data-ttu-id="58835-2689">Padrão</span><span class="sxs-lookup"><span data-stu-id="58835-2689">Pattern</span></span>|<span data-ttu-id="58835-2690">Descrição</span><span class="sxs-lookup"><span data-stu-id="58835-2690">Description</span></span>|  
|-------------|-----------------|  
|`\s-`|<span data-ttu-id="58835-2691">Corresponde a um caractere de espaço em branco seguido por um hífen.</span><span class="sxs-lookup"><span data-stu-id="58835-2691">Match a whitespace character followed by a hyphen.</span></span>|  
|`\s?`|<span data-ttu-id="58835-2692">Corresponde a zero ou um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2692">Match zero or one whitespace character.</span></span>|  
|`[+*]?`|<span data-ttu-id="58835-2693">Corresponde a zero ou uma ocorrência de qualquer um de + ou \* caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2693">Match zero or one occurrence of either the + or \* character.</span></span>|  
|`\s?`|<span data-ttu-id="58835-2694">Corresponde a zero ou um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2694">Match zero or one whitespace character.</span></span>|  
|`-\s`|<span data-ttu-id="58835-2695">Corresponde a um hífen seguido por um caractere de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2695">Match a hyphen followed by a whitespace character.</span></span>|  
  
### <a name="search-methods-and-the-substring-method"></a><span data-ttu-id="58835-2696">Métodos de pesquisa e o método Substring</span><span class="sxs-lookup"><span data-stu-id="58835-2696">Search methods and the Substring method</span></span>  
 <span data-ttu-id="58835-2697">Se você não estiver interessado em todas as subcadeias de caracteres em uma cadeia de caracteres, você talvez prefira trabalhar com um dos métodos de comparação de cadeia de caracteres que retorna o índice no qual a correspondência começa.</span><span class="sxs-lookup"><span data-stu-id="58835-2697">If you aren't interested in all of the substrings in a string, you might prefer to work with one of the string comparison methods that returns the index at which the match begins.</span></span> <span data-ttu-id="58835-2698">Em seguida, você pode chamar o <xref:System.String.Substring%2A> método para extrair a subcadeia de caracteres que você deseja.</span><span class="sxs-lookup"><span data-stu-id="58835-2698">You can then call the <xref:System.String.Substring%2A> method to extract the substring that you want.</span></span> <span data-ttu-id="58835-2699">Os métodos de comparação de cadeia de caracteres incluem:</span><span class="sxs-lookup"><span data-stu-id="58835-2699">The string comparison methods include:</span></span>  
  
-   <span data-ttu-id="58835-2700"><xref:System.String.IndexOf%2A>, que retorna o índice baseado em zero da primeira ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2700"><xref:System.String.IndexOf%2A>, which returns the zero-based index of the first occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="58835-2701"><xref:System.String.IndexOfAny%2A>, que retorna o índice baseado em zero na instância atual de cadeia de caracteres da primeira ocorrência de qualquer caractere em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2701"><xref:System.String.IndexOfAny%2A>, which returns the zero-based index in the current string instance of the first occurrence of any character in a character array.</span></span>  
  
-   <span data-ttu-id="58835-2702"><xref:System.String.LastIndexOf%2A>, que retorna o índice baseado em zero da última ocorrência de um caractere ou cadeia de caracteres em uma instância de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2702"><xref:System.String.LastIndexOf%2A>, which returns the zero-based index of the last occurrence of a character or string in a string instance.</span></span>  
  
-   <span data-ttu-id="58835-2703"><xref:System.String.LastIndexOfAny%2A>, que retorna um índice baseado em zero na instância atual de cadeia de caracteres da última ocorrência de qualquer caractere em uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2703"><xref:System.String.LastIndexOfAny%2A>, which returns a zero-based index in the current string instance of the last occurrence of any character in a character array.</span></span>  
  
 <span data-ttu-id="58835-2704">O exemplo a seguir usa o <xref:System.String.IndexOf%2A> método para localizar os períodos em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2704">The following example uses the <xref:System.String.IndexOf%2A> method to find the periods in a string.</span></span> <span data-ttu-id="58835-2705">Ele usa o <xref:System.String.Substring%2A> método para retornar frases completas.</span><span class="sxs-lookup"><span data-stu-id="58835-2705">It then uses the <xref:System.String.Substring%2A> method to return full sentences.</span></span>  
  
 [!code-csharp[System.String.Split#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/splitalt4.cs#11)]
 [!code-vb[System.String.Split#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/splitalt4.vb#11)]  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2706">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2706">Performance Considerations</span></span>  
 <span data-ttu-id="58835-2707">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2707">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2708">Se seu aplicativo exija desempenho ideal ou gerenciar a alocação de memória é essencial para seu aplicativo, considere usar o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2708">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method.</span></span> <span data-ttu-id="58835-2709">Você também tem a opção de usar o <xref:System.String.Compare%2A> método para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2709">You also have the option of using the <xref:System.String.Compare%2A> method to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2710">Para dividir uma cadeia de caracteres em um caractere separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2710">To split a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2711">Para dividir uma cadeia de caracteres em uma cadeia de caracteres de separador, use o <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> método para localizar o primeiro caractere da cadeia de caracteres de separador.</span><span class="sxs-lookup"><span data-stu-id="58835-2711">To split a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2712">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2712">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2713">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2713">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2714">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2714">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2715">O exemplo a seguir demonstra como extrair palavras individuais de um bloco de texto, tratando o espaço em branco e sinais de pontuação como delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2715">The following example demonstrates how to extract individual words from a block of text by treating white space and punctuation marks as delimiters.</span></span> <span data-ttu-id="58835-2716">A matriz de caracteres passada para o `separator` parâmetro do <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> método consiste em um caractere de espaço e um caractere de tabulação, junto com alguns símbolos de pontuação comuns.</span><span class="sxs-lookup"><span data-stu-id="58835-2716">The character array passed to the `separator` parameter of the <xref:System.String.Split%28System.Char%5B%5D%29?displayProperty=nameWithType> method consists of a space character and a tab character, together with some common punctuation symbols.</span></span>  
  
 [!code-csharp[System.String.Split#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split2.cs#2)]
 [!code-vb[System.String.Split#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2717">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2717">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int -&gt; string[]" Usage="string.Split (separator, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2718">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2718">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2719">O número máximo de subcadeias de caracteres a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2719">The maximum number of substrings to return.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2720">Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2720">Splits a string into a maximum number of substrings based on the characters in an array.</span>
          </span>
          <span data-ttu-id="58835-2721">Especifique também o número máximo de subcadeias de caracteres a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2721">You also specify the maximum number of substrings to return.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2722">Uma matriz cujos elementos contêm as subcadeias de caracteres desta instância que são delimitadas por um ou mais caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2722">An array whose elements contain the substrings in this instance that are delimited by one or more characters in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2723">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2723">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2724">Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2724">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="58835-2725">Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2725">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="58835-2726">Se `count` for zero, uma matriz vazia será retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2726">If `count` is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="58835-2727">Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2727">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="58835-2728">Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2728">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-2729">Cada elemento de `separator` define um caractere delimitador à parte.</span><span class="sxs-lookup"><span data-stu-id="58835-2729">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="58835-2730">Se dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-2730">If two delimiters are adjacent, or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="58835-2731">Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="58835-2731">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="58835-2732">Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="58835-2732">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
 <span data-ttu-id="58835-2733">A tabela a seguir fornece exemplos.</span><span class="sxs-lookup"><span data-stu-id="58835-2733">The following table provides examples.</span></span>  
  
|<span data-ttu-id="58835-2734">Valor da cadeia de caracteres</span><span class="sxs-lookup"><span data-stu-id="58835-2734">String value</span></span>|<span data-ttu-id="58835-2735">Separador</span><span class="sxs-lookup"><span data-stu-id="58835-2735">Separator</span></span>|<span data-ttu-id="58835-2736">Contagem</span><span class="sxs-lookup"><span data-stu-id="58835-2736">Count</span></span>|<span data-ttu-id="58835-2737">Matriz retornada</span><span class="sxs-lookup"><span data-stu-id="58835-2737">Returned array</span></span>|  
|------------------|---------------|-----------|--------------------|  
|<span data-ttu-id="58835-2738">"42, 12, 19"</span><span class="sxs-lookup"><span data-stu-id="58835-2738">"42, 12, 19"</span></span>|<span data-ttu-id="58835-2739">novo Char [] {',', ' '} (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2739">new Char[] {',', ' '} (C#)</span></span><br /><br /> <span data-ttu-id="58835-2740">Char () = {"," c, "" c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2740">Char() = {","c, " "c} (Visual Basic)</span></span>|<span data-ttu-id="58835-2741">2</span><span class="sxs-lookup"><span data-stu-id="58835-2741">2</span></span>|<span data-ttu-id="58835-2742">{"42", " 12, 19"}</span><span class="sxs-lookup"><span data-stu-id="58835-2742">{"42", " 12, 19"}</span></span>|  
|<span data-ttu-id="58835-2743">"42..12..19"</span><span class="sxs-lookup"><span data-stu-id="58835-2743">"42..12..19"</span></span>|<span data-ttu-id="58835-2744">novo Char [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="58835-2744">new Char[] {'.'}</span></span> <span data-ttu-id="58835-2745">(C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2745">(C#)</span></span><br /><br /> <span data-ttu-id="58835-2746">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2746">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="58835-2747">4</span><span class="sxs-lookup"><span data-stu-id="58835-2747">4</span></span>|<span data-ttu-id="58835-2748">{"42", "", "12", ".19"}</span><span class="sxs-lookup"><span data-stu-id="58835-2748">{"42", "", "12", ".19"}</span></span>|  
|<span data-ttu-id="58835-2749">"Banana"</span><span class="sxs-lookup"><span data-stu-id="58835-2749">"Banana"</span></span>|<span data-ttu-id="58835-2750">novo Char [] {'. '}</span><span class="sxs-lookup"><span data-stu-id="58835-2750">new Char[] {'.'}</span></span> <span data-ttu-id="58835-2751">(C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2751">(C#)</span></span><br /><br /> <span data-ttu-id="58835-2752">Char() = {"."c} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2752">Char() = {"."c} (Visual Basic)</span></span>|<span data-ttu-id="58835-2753">2</span><span class="sxs-lookup"><span data-stu-id="58835-2753">2</span></span>|<span data-ttu-id="58835-2754">{"Banana"}</span><span class="sxs-lookup"><span data-stu-id="58835-2754">{"Banana"}</span></span>|  
|<span data-ttu-id="58835-2755">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2755">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="58835-2756">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2756">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="58835-2757">novo Char [] {} (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2757">new Char[] {} (C#)</span></span><br /><br /> <span data-ttu-id="58835-2758">Char () = {} (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2758">Char() = {} (Visual Basic)</span></span>|<span data-ttu-id="58835-2759">1</span><span class="sxs-lookup"><span data-stu-id="58835-2759">1</span></span>|<span data-ttu-id="58835-2760">{"Darb\nSmarba"} (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2760">{"Darb\nSmarba"} (C#)</span></span><br /><br /> <span data-ttu-id="58835-2761">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2761">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|  
|<span data-ttu-id="58835-2762">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2762">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="58835-2763">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2763">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="58835-2764">novo Char [] nulos (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2764">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="58835-2765">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="58835-2765">Char() = Nothing</span></span>|<span data-ttu-id="58835-2766">2</span><span class="sxs-lookup"><span data-stu-id="58835-2766">2</span></span>|<span data-ttu-id="58835-2767">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="58835-2767">{"Darb", "Smarba"}</span></span>|  
|<span data-ttu-id="58835-2768">"Darb\nSmarba" (C#)</span><span class="sxs-lookup"><span data-stu-id="58835-2768">"Darb\nSmarba" (C#)</span></span><br /><br /> <span data-ttu-id="58835-2769">"Darb" & vbLf & "Smarba" (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="58835-2769">"Darb" & vbLf & "Smarba" (Visual Basic)</span></span>|<span data-ttu-id="58835-2770">novo Char [] nulos (c#)</span><span class="sxs-lookup"><span data-stu-id="58835-2770">new Char[] null (C#)</span></span><br /><br /> <span data-ttu-id="58835-2771">Char () = Nothing</span><span class="sxs-lookup"><span data-stu-id="58835-2771">Char() = Nothing</span></span>|<span data-ttu-id="58835-2772">100</span><span class="sxs-lookup"><span data-stu-id="58835-2772">100</span></span>|<span data-ttu-id="58835-2773">{"Darb", "Smarba"}</span><span class="sxs-lookup"><span data-stu-id="58835-2773">{"Darb", "Smarba"}</span></span>|  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2774">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2774">Performance Considerations</span></span>  
 <span data-ttu-id="58835-2775">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2775">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2776">Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2776">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2777">Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2777">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2778">Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2778">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2779">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2779">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2780">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2780">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2781">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2781">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2782">O exemplo a seguir demonstra como `count` afeta o número de cadeias de caracteres retornadas por <xref:System.String.Split%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-2782">The following example demonstrates how `count` affects the number of strings returned by <xref:System.String.Split%2A>.</span></span>  
  
 [!code-csharp[StringSplit2#10](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/StringSplit10.cs#10)]
 [!code-vb[StringSplit2#10](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit10.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2783">
            <paramref name="count" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2783">
              <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2784">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2784">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Substring(System.Int32)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2785">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2785">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-2786">
            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2786">
              <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2787">Divide uma cadeia de caracteres em subcadeias de caracteres baseadas nos caracteres de uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2787">Splits a string into substrings based on the characters in an array.</span>
          </span>
          <span data-ttu-id="58835-2788">Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2788">You can specify whether the substrings include empty array elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2789">Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2789">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2790">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2790">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="58835-2791">Detalhes do valor de retorno</span><span class="sxs-lookup"><span data-stu-id="58835-2791">Return value details</span></span>  
 <span data-ttu-id="58835-2792">Os caracteres delimitadores (os caracteres no `separator` matriz) não estão incluídos nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2792">Delimiter characters (the characters in the `separator` array) are not included in the elements of the returned array.</span></span> <span data-ttu-id="58835-2793">Por exemplo, se o `separator` matriz inclui o caractere "-" e o valor da instância atual de cadeia de caracteres "aa-bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".</span><span class="sxs-lookup"><span data-stu-id="58835-2793">For example, if the `separator` array includes the character "-" and the value of the current string instance is "aa-bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="58835-2794">Se esta instância não contém nenhum dos caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2794">If this instance does not contain any of the characters in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="58835-2795">Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="58835-2795">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="58835-2796">Cada elemento da `separator` define um delimitador separado que consiste em um único caractere.</span><span class="sxs-lookup"><span data-stu-id="58835-2796">Each element of `separator` defines a separate delimiter that consists of a single character.</span></span> <span data-ttu-id="58835-2797">Se o `options` argumento for <xref:System.StringSplitOptions.None>e dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2797">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-2798">Por exemplo, se `separator` inclui dois elementos, "-" e "\_", o valor da instância de cadeia de caracteres é "-\_aa -\_" e o valor da `options` argumento é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de cadeia de caracteres com os seguintes cinco elementos:</span><span class="sxs-lookup"><span data-stu-id="58835-2798">For example, if `separator` includes  two elements, "-" and "\_", the value of the string instance is "-\_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a string array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="58835-2799"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" caractere no índice 0.</span><span class="sxs-lookup"><span data-stu-id="58835-2799"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" character at index 0.</span></span>  
  
2.  <span data-ttu-id="58835-2800"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" caractere no índice 0 e o caractere "_" no índice 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2800"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" character at index 0 and the "_" character at index 1.</span></span>  
  
3.  <span data-ttu-id="58835-2801">"aa",</span><span class="sxs-lookup"><span data-stu-id="58835-2801">"aa",</span></span>  
  
4.  <span data-ttu-id="58835-2802"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o caractere "_" no índice 4.</span><span class="sxs-lookup"><span data-stu-id="58835-2802"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" character at index 4.</span></span>  
  
5.  <span data-ttu-id="58835-2803"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o "-" caractere no índice 5.</span><span class="sxs-lookup"><span data-stu-id="58835-2803"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" character at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="58835-2804">A matriz de separador</span><span class="sxs-lookup"><span data-stu-id="58835-2804">The separator array</span></span>  
 <span data-ttu-id="58835-2805">Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2805">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="58835-2806">Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2806">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-2807">Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga do compilador falha.</span><span class="sxs-lookup"><span data-stu-id="58835-2807">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="58835-2808">Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2808">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="58835-2809">O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58835-2809">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#5)]
 [!code-vb[System.String.Split#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#5)]  
  
## <a name="comparison-details"></a><span data-ttu-id="58835-2810">Detalhes de comparação</span><span class="sxs-lookup"><span data-stu-id="58835-2810">Comparison details</span></span>  
 <span data-ttu-id="58835-2811">O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por um ou mais dos caracteres no `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2811">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the characters in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="58835-2812">O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2812">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="58835-2813">Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2813">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2814">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2814">Performance Considerations</span></span>  
 <span data-ttu-id="58835-2815">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2815">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2816">Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2816">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2817">Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2817">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2818">Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2818">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2819">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2819">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2820">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2820">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2821">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2821">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2822">O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2822">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2823">
            <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2823">
              <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2824">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2824">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2825">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2825">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-2826">
            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2826">
              <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2827">Divide uma cadeia de caracteres em subcadeias de caracteres com base nas cadeias de caracteres em uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2827">Splits a string into substrings based on the strings in an array.</span>
          </span>
          <span data-ttu-id="58835-2828">Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2828">You can specify whether the substrings include empty array elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2829">Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2829">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2830">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2830">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2831">Quando uma cadeia de caracteres é delimitada por um conjunto conhecido de cadeias de caracteres, você pode usar o <xref:System.String.Split%2A> método para separá-lo em subcadeias de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2831">When a string is delimited by a known set of strings, you can use the <xref:System.String.Split%2A> method to separate it into substrings.</span></span>  
  
## <a name="return-value-details"></a><span data-ttu-id="58835-2832">Detalhes do valor de retorno</span><span class="sxs-lookup"><span data-stu-id="58835-2832">Return value details</span></span>  
 <span data-ttu-id="58835-2833">Cadeias de caracteres de delimitador não estão incluídas nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2833">Delimiter strings are not included in the elements of the returned array.</span></span> <span data-ttu-id="58835-2834">Por exemplo, se o `separator` matriz inclui a cadeia de caracteres "-" e o valor da instância atual de cadeia de caracteres "aa - bb-cc", o método retorna uma matriz que contém três elementos: "aa", "bb" e "cc".</span><span class="sxs-lookup"><span data-stu-id="58835-2834">For example, if the `separator` array includes the string "--" and the value of the current string instance is "aa--bb-cc", the method returns an array that contains three elements: "aa", "bb", and "cc".</span></span>  
  
 <span data-ttu-id="58835-2835">Se esta instância não contém qualquer uma das cadeias de caracteres no `separator`, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2835">If this instance does not contain any of the strings in `separator`, the returned array consists of a single element that contains this instance.</span></span>  
  
 <span data-ttu-id="58835-2836">Se o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, o método retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="58835-2836">If the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, the method returns an empty array.</span></span>  
  
 <span data-ttu-id="58835-2837">Cada elemento da `separator` define um delimitador separado que consiste em um ou mais caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2837">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="58835-2838">Se o `options` argumento for <xref:System.StringSplitOptions.None>e dois delimitadores sejam adjacentes ou um delimitador for encontrado no início ou no final dessa instância, o elemento de matriz correspondente contém <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2838">If the `options` argument is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-2839">Por exemplo, se `separator` inclui dois elementos, "-" e "_", o valor da instância de cadeia de caracteres é "- _aa -\_" e o valor da `options` argumento é <xref:System.StringSplitOptions.None>, o método retorna uma matriz de cadeia de caracteres com cinco elementos a seguir:</span><span class="sxs-lookup"><span data-stu-id="58835-2839">For example, if `separator` includes  two elements, "-" and "_", the value of the string instance is "-_aa-\_", and the value of   the `options` argument is <xref:System.StringSplitOptions.None>, the method returns a sting array with the following five elements:</span></span>  
  
1.  <span data-ttu-id="58835-2840"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que precede o "-" a subcadeia de caracteres no índice 0.</span><span class="sxs-lookup"><span data-stu-id="58835-2840"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that precedes the "-" substring at index 0.</span></span>  
  
2.  <span data-ttu-id="58835-2841"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia entre o "-" subcadeia de caracteres no índice 0 e a subcadeia de caracteres "_" no índice 1.</span><span class="sxs-lookup"><span data-stu-id="58835-2841"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string between the "-" substring at index 0 and the "_" substring at index 1.</span></span>  
  
3.  <span data-ttu-id="58835-2842">"aa",</span><span class="sxs-lookup"><span data-stu-id="58835-2842">"aa",</span></span>  
  
4.  <span data-ttu-id="58835-2843"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue a subcadeia de caracteres "_" no índice 4.</span><span class="sxs-lookup"><span data-stu-id="58835-2843"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "_" substring at index 4.</span></span>  
  
5.  <span data-ttu-id="58835-2844"><xref:System.String.Empty?displayProperty=nameWithType>, que representa a cadeia de caracteres vazia que segue o "-" a subcadeia de caracteres no índice 5.</span><span class="sxs-lookup"><span data-stu-id="58835-2844"><xref:System.String.Empty?displayProperty=nameWithType>, which represents the empty string that follows the "-" substring at index 5.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="58835-2845">A matriz de separador</span><span class="sxs-lookup"><span data-stu-id="58835-2845">The separator array</span></span>  
 <span data-ttu-id="58835-2846">Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador.</span><span class="sxs-lookup"><span data-stu-id="58835-2846">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="58835-2847">Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string".</span><span class="sxs-lookup"><span data-stu-id="58835-2847">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="58835-2848">Retorna a matriz de quatro elementos a seguir: {"This", "is", "a", "string".</span><span class="sxs-lookup"><span data-stu-id="58835-2848">returns the following four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="58835-2849">}.</span><span class="sxs-lookup"><span data-stu-id="58835-2849">}.</span></span>  
  
 <span data-ttu-id="58835-2850">Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2850">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="58835-2851">Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2851">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="58835-2852">Se o `separator` parâmetro na chamada para essa sobrecarga de método é `null`, resolução de sobrecarga do compilador falha.</span><span class="sxs-lookup"><span data-stu-id="58835-2852">If the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="58835-2853">Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2853">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="58835-2854">O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58835-2854">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#6)]
 [!code-vb[System.String.Split#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#6)]  
  
## <a name="comparison-details"></a><span data-ttu-id="58835-2855">Detalhes de comparação</span><span class="sxs-lookup"><span data-stu-id="58835-2855">Comparison details</span></span>  
 <span data-ttu-id="58835-2856">O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais das cadeias de caracteres a `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2856">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="58835-2857">O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2857">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="58835-2858">Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2858">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="58835-2859">O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="58835-2859">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="58835-2860">Para evitar resultados ambíguos quando cadeias de caracteres no `separator` têm caracteres em comum, o <xref:System.String.Split%2A> operação continua desde o início até o final do valor da instância e corresponde ao primeiro elemento no `separator` que é igual a um delimitador no instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2860">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> operation proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="58835-2861">A ordem na qual as subcadeias de caracteres são encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.</span><span class="sxs-lookup"><span data-stu-id="58835-2861">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="58835-2862">Por exemplo, considere uma instância cujo valor é "abcdef".</span><span class="sxs-lookup"><span data-stu-id="58835-2862">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="58835-2863">Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação de divisão seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "f".</span><span class="sxs-lookup"><span data-stu-id="58835-2863">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be a string array that contains two elements, "a" and "f".</span></span> <span data-ttu-id="58835-2864">Isso ocorre porque a subcadeia de caracteres na instância, "bcde" é encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.</span><span class="sxs-lookup"><span data-stu-id="58835-2864">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="58835-2865">No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação de divisão seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "ef".</span><span class="sxs-lookup"><span data-stu-id="58835-2865">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be a string array that contains two elements, "a" and "ef".</span></span> <span data-ttu-id="58835-2866">Isso ocorre porque "bcd" é o primeiro delimitador no `separator` que corresponde a um delimitador na instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2866">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="58835-2867">Se a ordem dos separadores de foi revertida de modo que o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria uma matriz de cadeia de caracteres que contém dois elementos, "a" e "def".</span><span class="sxs-lookup"><span data-stu-id="58835-2867">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be a string array that contains two elements,  "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2868">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2868">Performance considerations</span></span>  
 <span data-ttu-id="58835-2869">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2869">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2870">Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2870">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2871">Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2871">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2872">Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2872">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2873">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2873">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2874">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2874">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2875">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2875">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2876">O exemplo a seguir ilustra a diferença nas matrizes retornado ao chamar uma cadeia de caracteres <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> método com seus `options` parâmetro igual a <xref:System.StringSplitOptions.None?displayProperty=nameWithType> e <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2876">The following example illustrates the difference in the arrays returned by calling a string's <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29?displayProperty=nameWithType> method with its `options` parameter equal to <xref:System.StringSplitOptions.None?displayProperty=nameWithType> and <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.String.Split#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/Split.cs#1)]
 [!code-vb[System.String.Split#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/Split.vb#1)]  
  
 <span data-ttu-id="58835-2877">O exemplo a seguir define uma matriz de separadores que incluem a pontuação e caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2877">The following example defines an array of separators that include punctuation and white-space characters.</span></span> <span data-ttu-id="58835-2878">Passar essa matriz, juntamente com um valor de <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> para o <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> método retorna uma matriz que consiste em palavras individuais da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2878">Passing this array along with a value of <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType> to the <xref:System.String.Split%28System.String%5B%5D%2CSystem.StringSplitOptions%29> method returns an array that consists of the individual words from the string.</span></span>  
  
 [!code-csharp[System.String.Split#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split7.cs#7)]
 [!code-vb[System.String.Split#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split7.vb#7)]  
  
 <span data-ttu-id="58835-2879">Observe que o método é chamado com o `options` argumento definido como <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2879">Note that the method is called with the `options` argument set to <xref:System.StringSplitOptions.RemoveEmptyEntries?displayProperty=nameWithType>.</span></span> <span data-ttu-id="58835-2880">Isso impede que a matriz retornada incluindo <xref:System.String.Empty?displayProperty=nameWithType> valores que representam correspondências de subcadeia de caracteres vazia entre sinais de pontuação e caracteres de espaço em branco.</span><span class="sxs-lookup"><span data-stu-id="58835-2880">This prevents the returned array from including <xref:System.String.Empty?displayProperty=nameWithType> values that represent empty substring matches between punctuation marks and white-space characters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2881">
            <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2881">
              <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2882">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2882">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : char * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (char[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(char[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.Char[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As Char(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;char&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : char[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.Char[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2883">Uma matriz de caracteres que delimita as subcadeias de caracteres nesta cadeia de caracteres, uma matriz vazia que não contém delimitadores ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2883">A character array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2884">O número máximo de subcadeias de caracteres a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2884">The maximum number of substrings to return.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-2885">
            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2885">
              <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2886">Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nos caracteres em uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2886">Splits a string into a maximum number of substrings based on the characters in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2887">Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por um ou mais caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2887">An array whose elements contain the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2888">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2888">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2889">Os caracteres delimitadores não estão incluídos nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2889">Delimiter characters are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="58835-2890">Se esta instância não contém nenhum dos caracteres na `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2890">If this instance does not contain any of the characters in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="58835-2891">Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2891">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="58835-2892">Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2892">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-2893">No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha.</span><span class="sxs-lookup"><span data-stu-id="58835-2893">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="58835-2894">Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo de NULL.</span><span class="sxs-lookup"><span data-stu-id="58835-2894">To unambiguously identify the called method, your code must indicate the type of the null.</span></span> <span data-ttu-id="58835-2895">O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58835-2895">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#3)]
 [!code-vb[System.String.Split#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#3)]  
  
 <span data-ttu-id="58835-2896">Se o `count` parâmetro é zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia é retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2896">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="58835-2897">Cada elemento de `separator` define um caractere delimitador à parte.</span><span class="sxs-lookup"><span data-stu-id="58835-2897">Each element of `separator` defines a separate delimiter character.</span></span> <span data-ttu-id="58835-2898">Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-2898">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="58835-2899">Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="58835-2899">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="58835-2900">Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="58835-2900">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2901">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2901">Performance Considerations</span></span>  
 <span data-ttu-id="58835-2902">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2902">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2903">Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2903">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2904">Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2904">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2905">Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2905">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2906">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2906">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2907">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2907">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2908">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2908">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2909">O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2909">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2910">
            <paramref name="count" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2910">
              <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2911">
            <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2911">
              <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2912">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2912">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string separator, int count, StringSplitOptions options = System.StringSplitOptions.None);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String,System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String, count As Integer, Optional options As StringSplitOptions = System.StringSplitOptions.None) As String()" />
      <MemberSignature Language="F#" Value="member this.Split : string * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">To be added.</param>
        <param name="count">To be added.</param>
        <param name="options">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Split">
      <MemberSignature Language="C#" Value="public string[] Split (string[] separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string[] Split(string[] separator, int32 count, valuetype System.StringSplitOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Split(System.String[],System.Int32,System.StringSplitOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function Split (separator As String(), count As Integer, options As StringSplitOptions) As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::String ^&gt; ^ Split(cli::array &lt;System::String ^&gt; ^ separator, int count, StringSplitOptions options);" />
      <MemberSignature Language="F#" Value="member this.Split : string[] * int * StringSplitOptions -&gt; string[]" Usage="string.Split (separator, count, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="separator" Type="System.String[]" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="options" Type="System.StringSplitOptions" />
      </Parameters>
      <Docs>
        <param name="separator">
          <span data-ttu-id="58835-2913">Uma matriz de cadeia de caracteres que delimita as subcadeias nessa cadeia de caracteres, uma matriz vazia que não contém delimitadores, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2913">A string array that delimits the substrings in this string, an empty array that contains no delimiters, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="58835-2914">O número máximo de subcadeias de caracteres a serem retornadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2914">The maximum number of substrings to return.</span>
          </span>
        </param>
        <param name="options">
          <span data-ttu-id="58835-2915">
            <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> para omitir elementos de matriz vazia da matriz retornada; ou <see cref="F:System.StringSplitOptions.None" /> para incluir elementos de matriz vazia na matriz retornada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2915">
              <see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2916">Divide uma cadeia de caracteres em um número máximo de subcadeias de caracteres baseadas nas cadeias de caracteres de uma matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2916">Splits a string into a maximum number of substrings based on the strings in an array.</span>
          </span>
          <span data-ttu-id="58835-2917">Especifique se as subcadeias de caracteres incluem elementos de matriz vazia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2917">You can specify whether the substrings include empty array elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2918">Uma matriz cujos elementos contêm as subcadeias de caracteres desta cadeia de caracteres que são delimitadas por uma ou mais cadeias de caracteres em <paramref name="separator" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2918">An array whose elements contain the substrings in this string that are delimited by one or more strings in <paramref name="separator" />.</span>
          </span>
          <span data-ttu-id="58835-2919">Para obter mais informações, consulte a seção Comentários.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2919">For more information, see the Remarks section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="return-value-details"></a><span data-ttu-id="58835-2920">Detalhes do valor de retorno</span><span class="sxs-lookup"><span data-stu-id="58835-2920">Return value details</span></span>  
 <span data-ttu-id="58835-2921">Cadeias de caracteres de delimitador não estão incluídas nos elementos da matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2921">Delimiter strings are not included in the elements of the returned array.</span></span>  
  
 <span data-ttu-id="58835-2922">Se esta instância não contém qualquer uma das cadeias de caracteres `separator`, ou o `count` parâmetro é 1, a matriz retornada consiste em um único elemento que contém essa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2922">If this instance does not contain any of the strings in `separator`, or the `count` parameter is 1, the returned array consists of a single element that contains this instance.</span></span> <span data-ttu-id="58835-2923">Caso o parâmetro `separator` seja `null` ou não contenha nenhum caractere, os caracteres de espaço em branco devem ser considerados os delimitadores.</span><span class="sxs-lookup"><span data-stu-id="58835-2923">If the `separator` parameter is `null` or contains no characters, white-space characters are assumed to be the delimiters.</span></span> <span data-ttu-id="58835-2924">Os caracteres de espaço em branco são definidos pelo padrão Unicode e retornam `true` caso sejam passados para o método <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-2924">White-space characters are defined by the Unicode standard and return `true` if they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-2925">No entanto, caso o parâmetro `separator` na chamada para esta sobrecarga de método seja `null`, a resolução de sobrecarga do compilador falha.</span><span class="sxs-lookup"><span data-stu-id="58835-2925">However, if the `separator` parameter in the call to this method overload is `null`, compiler overload resolution fails.</span></span> <span data-ttu-id="58835-2926">Para identificar sem ambiguidade o método chamado, seu código deve indicar o tipo do `null`.</span><span class="sxs-lookup"><span data-stu-id="58835-2926">To unambiguously identify the called method, your code must indicate the type of the `null`.</span></span> <span data-ttu-id="58835-2927">O exemplo a seguir mostra várias maneiras para identificar sem ambiguidade essa sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="58835-2927">The following example shows several ways to unambiguously identify this overload.</span></span>  
  
 [!code-csharp[System.String.Split#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Split/cs/split3.cs#4)]
 [!code-vb[System.String.Split#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Split/vb/split3.vb#4)]  
  
 <span data-ttu-id="58835-2928">Se o `count` parâmetro é zero, ou o `options` parâmetro é <xref:System.StringSplitOptions.RemoveEmptyEntries> e o comprimento dessa instância for zero, uma matriz vazia é retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-2928">If the `count` parameter is zero, or the `options` parameter is <xref:System.StringSplitOptions.RemoveEmptyEntries> and the length of this instance is zero, an empty array is returned.</span></span>  
  
 <span data-ttu-id="58835-2929">Cada elemento da `separator` define um delimitador separado que consiste em um ou mais caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2929">Each element of `separator` defines a separate delimiter that consists of one or more characters.</span></span> <span data-ttu-id="58835-2930">Caso o parâmetro `options` seja <xref:System.StringSplitOptions.None> e dois delimitadores sejam adjacentes ou um delimitador esteja no início ou no fim dessa instância, o elemento da matriz correspondente contém <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-2930">If the `options` parameter is <xref:System.StringSplitOptions.None>, and two delimiters are adjacent or a delimiter is found at the beginning or end of this instance, the corresponding array element contains <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="58835-2931">Se houver mais de `count` subcadeias de caracteres nesta instância, a primeira `count` menos 1 subcadeias de caracteres são retornados na primeira `count` menos 1 elementos de valor de retorno e os caracteres restantes nesta instância são retornados no último elemento do valor de retorno.</span><span class="sxs-lookup"><span data-stu-id="58835-2931">If there are more than `count` substrings in this instance, the first `count` minus 1 substrings are returned in the first `count` minus 1 elements of the return value, and the remaining characters in this instance are returned in the last element of the return value.</span></span>  
  
 <span data-ttu-id="58835-2932">Se `count` é maior que o número de subcadeias de caracteres, as subcadeias de caracteres disponíveis são retornadas e nenhuma exceção é lançada.</span><span class="sxs-lookup"><span data-stu-id="58835-2932">If `count` is greater than the number of substrings, the available substrings are returned and no exception is thrown.</span></span>  
  
## <a name="the-separator-array"></a><span data-ttu-id="58835-2933">A matriz de separador</span><span class="sxs-lookup"><span data-stu-id="58835-2933">The separator array</span></span>  
 <span data-ttu-id="58835-2934">Se qualquer um dos elementos no `separator` é composto de vários caracteres, a subcadeia de caracteres inteira é considerada um delimitador.</span><span class="sxs-lookup"><span data-stu-id="58835-2934">If any of the elements in `separator` consists of multiple characters, the entire substring is considered a delimiter.</span></span> <span data-ttu-id="58835-2935">Por exemplo, se um dos elementos no `separator` é "10", a tentativa de dividir a cadeia de caracteres "This10is10a10string".</span><span class="sxs-lookup"><span data-stu-id="58835-2935">For example, if one of the elements in `separator` is "10", attempting to split the string "This10is10a10string."</span></span> <span data-ttu-id="58835-2936">retornará essa matriz de quatro elementos: {"This", "is", "a", "string".</span><span class="sxs-lookup"><span data-stu-id="58835-2936">returns this four-element array: { "This", "is", "a", "string."</span></span> <span data-ttu-id="58835-2937">}.</span><span class="sxs-lookup"><span data-stu-id="58835-2937">}.</span></span>  
  
## <a name="comparison-details"></a><span data-ttu-id="58835-2938">Detalhes de comparação</span><span class="sxs-lookup"><span data-stu-id="58835-2938">Comparison details</span></span>  
 <span data-ttu-id="58835-2939">O <xref:System.String.Split%2A> método extrai as subcadeias de caracteres na cadeia de caracteres que são delimitadas por uma ou mais das cadeias de caracteres a `separator` parâmetro e retorna as subcadeias de caracteres como elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2939">The <xref:System.String.Split%2A> method extracts the substrings in this string that are delimited by one or more of the strings in the `separator` parameter, and returns those substrings as elements of an array.</span></span>  
  
 <span data-ttu-id="58835-2940">O <xref:System.String.Split%2A> método procura delimitadores executando comparações usando regras de classificação ordinal diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-2940">The <xref:System.String.Split%2A> method looks for delimiters by performing comparisons using case-sensitive ordinal sort rules.</span></span> <span data-ttu-id="58835-2941">Para obter mais informações sobre palavra, cadeia de caracteres e tipos ordinais, consulte o <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeração.</span><span class="sxs-lookup"><span data-stu-id="58835-2941">For more information about word, string, and ordinal sorts, see the <xref:System.Globalization.CompareOptions?displayProperty=nameWithType> enumeration.</span></span>  
  
 <span data-ttu-id="58835-2942">O <xref:System.String.Split%2A> método ignora qualquer elemento de `separator` cujo valor é `null` ou cadeia de caracteres vazia ("").</span><span class="sxs-lookup"><span data-stu-id="58835-2942">The <xref:System.String.Split%2A> method ignores any element of `separator` whose value is `null` or the empty string ("").</span></span>  
  
 <span data-ttu-id="58835-2943">Para evitar resultados ambíguos quando cadeias de caracteres no `separator` têm caracteres em comum, o <xref:System.String.Split%2A> método continua desde o início até o final do valor da instância e corresponde ao primeiro elemento no `separator` que é igual a um delimitador no instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2943">To avoid ambiguous results when strings in `separator` have characters in common, the <xref:System.String.Split%2A> method proceeds from the beginning to the end of the value of the instance, and matches the first element in `separator` that is equal to a delimiter in the instance.</span></span> <span data-ttu-id="58835-2944">A ordem na qual as subcadeias de caracteres são encontradas na instância tem precedência sobre a ordem dos elementos no `separator`.</span><span class="sxs-lookup"><span data-stu-id="58835-2944">The order in which substrings are encountered in the instance takes precedence over the order of elements in `separator`.</span></span>  
  
 <span data-ttu-id="58835-2945">Por exemplo, considere uma instância cujo valor é "abcdef".</span><span class="sxs-lookup"><span data-stu-id="58835-2945">For example, consider an instance whose value is "abcdef".</span></span> <span data-ttu-id="58835-2946">Se o primeiro elemento em `separator` foi "ef" e o segundo elemento era "bcde", o resultado da operação de divisão seria "a" e "f".</span><span class="sxs-lookup"><span data-stu-id="58835-2946">If the first element in `separator` was "ef" and the second element was "bcde", the result of the split operation would be "a" and "f".</span></span> <span data-ttu-id="58835-2947">Isso ocorre porque a subcadeia de caracteres na instância, "bcde" é encontrada e corresponde a um elemento em `separator` antes que a subcadeia de caracteres "f" for encontrada.</span><span class="sxs-lookup"><span data-stu-id="58835-2947">This is because the substring in the instance, "bcde", is encountered and matches an element in `separator` before the substring "f" is encountered.</span></span>  
  
 <span data-ttu-id="58835-2948">No entanto, se o primeiro elemento da `separator` foi "bcd" e o segundo elemento era "bc", o resultado da operação de divisão seria "a" e "ef".</span><span class="sxs-lookup"><span data-stu-id="58835-2948">However, if the first element of `separator` was "bcd" and the second element was "bc", the result of the split operation would be "a" and "ef".</span></span> <span data-ttu-id="58835-2949">Isso ocorre porque "bcd" é o primeiro delimitador no `separator` que corresponde a um delimitador na instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2949">This is because "bcd" is the first delimiter in `separator` that matches a delimiter in the instance.</span></span> <span data-ttu-id="58835-2950">Se a ordem dos separadores de foi revertida de modo que o primeiro elemento foi "bc" e o segundo elemento foi "bcd", o resultado seria "a" e "def".</span><span class="sxs-lookup"><span data-stu-id="58835-2950">If the order of the separators was reversed so the first element was "bc" and the second element was "bcd", the result would be "a" and "def".</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="58835-2951">Considerações sobre desempenho</span><span class="sxs-lookup"><span data-stu-id="58835-2951">Performance considerations</span></span>  
 <span data-ttu-id="58835-2952">Os métodos <xref:System.String.Split%2A> alocam memória para o objeto de matriz retornado e um objeto <xref:System.String> para cada elemento da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-2952">The <xref:System.String.Split%2A> methods allocate memory for the returned array object and a <xref:System.String> object for each array element.</span></span> <span data-ttu-id="58835-2953">Caso o aplicativo exija desempenho ideal ou em caso de gerenciamento da alocação da memória ser importante no aplicativo, considere o uso do método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A>, e opcionalmente o método de <xref:System.String.Compare%2A> para localizar uma subcadeia de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2953">If your application requires optimal performance or if managing memory allocation is critical in your application, consider using the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method, and optionally the <xref:System.String.Compare%2A> method, to locate a substring within a string.</span></span>  
  
 <span data-ttu-id="58835-2954">Caso você esteja dividindo uma cadeia de caracteres em um separador de caractere, use o método <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOfAny%2A> para localizar um caractere separador na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2954">If you are splitting a string at a separator character, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate a separator character in the string.</span></span> <span data-ttu-id="58835-2955">Caso você esteja dividindo uma cadeia de caracteres em uma cadeia de caracteres separadora, use o método <xref:System.String.IndexOf%2A> ou de <xref:System.String.IndexOfAny%2A> para localizar o primeiro caractere da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2955">If you are splitting a string at a separator string, use the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOfAny%2A> method to locate the first character of the separator string.</span></span> <span data-ttu-id="58835-2956">Em seguida, use o método <xref:System.String.Compare%2A> para determinar se os caracteres depois desse primeiro caractere são iguais aos caracteres restantes da cadeia de caracteres separadora.</span><span class="sxs-lookup"><span data-stu-id="58835-2956">Then use the <xref:System.String.Compare%2A> method to determine whether the characters after that first character are equal to the remaining characters of the separator string.</span></span>  
  
 <span data-ttu-id="58835-2957">Além disso, caso o mesmo conjunto de caracteres seja usado para dividir cadeias de caracteres em várias chamadas de método <xref:System.String.Split%2A>, considere criar uma matriz única e referencie-a em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2957">In addition, if the same set of characters is used to split strings in multiple <xref:System.String.Split%2A> method calls, consider creating a single array and referencing it in each method call.</span></span> <span data-ttu-id="58835-2958">Isso reduz significativamente a sobrecarga adicional de cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="58835-2958">This significantly reduces the additional overhead of each method call.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2959">O exemplo a seguir usa o <xref:System.StringSplitOptions> enumeração para incluir ou excluir subcadeias de caracteres geradas pelo <xref:System.String.Split%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-2959">The following example uses the <xref:System.StringSplitOptions> enumeration to include or exclude substrings generated by the <xref:System.String.Split%2A> method.</span></span>  
  
 [!code-cpp[string.split3#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.split3/CPP/omit.cpp#1)]
 [!code-csharp[string.split3#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.split3/CS/omit.cs#1)]
 [!code-vb[string.split3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.split3/VB/omit.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-2960">
            <paramref name="count" /> é negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2960">
              <paramref name="count" /> is negative.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2961">
            <paramref name="options" /> não é um dos valores <see cref="T:System.StringSplitOptions" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2961">
              <paramref name="options" /> is not one of the <see cref="T:System.StringSplitOptions" /> values.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2962">
            <para>No [! INCLUDE[net_v35_short](~/Includes/NET-v35-Short-MD.MD)] e versões anteriores, se o <see cref="M:System.String.Split(System.Char[])" /> método recebe um <paramref name="separator" /> que é <see langword="null" /> ou não contiver caracteres, o método usa um conjunto de caracteres ligeiramente diferente para dividir o cadeia de caracteres que o <see cref="M:System.String.Trim(System.Char[])" /> método faz para cortar a cadeia de caracteres. No [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], ambos os métodos usam um conjunto idêntico de caracteres de espaço em branco Unicode.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2962">
              <para>In the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] and earlier versions, if the <see cref="M:System.String.Split(System.Char[])" /> method is passed a <paramref name="separator" /> that is <see langword="null" /> or contains no characters, the method uses a slightly different set of characters to split the string than the <see cref="M:System.String.Trim(System.Char[])" /> method does to trim the string. In the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], both methods use an identical set of Unicode white-space characters.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="StartsWith">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-2963">Determina se o começo desta instância de cadeia de caracteres corresponde a uma cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2963">Determines whether the beginning of this string instance matches a specified string.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(char value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : char -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string -&gt; bool" Usage="string.StartsWith value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2964">A cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2964">The string to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2965">Determina se o começo desta instância de cadeia de caracteres corresponde à cadeia de caracteres especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2965">Determines whether the beginning of this string instance matches the specified string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2966">
            <see langword="true" /> se o <paramref name="value" /> corresponde ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2966">
              <see langword="true" /> if <paramref name="value" /> matches the beginning of this string; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2967">Esse método compara `value` à subcadeia de caracteres no início desta instância que é o mesmo tamanho que `value`e retorna uma indicação se eles forem iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2967">This method compares `value` to the substring at the beginning of this instance that is the same length as `value`, and returns an indication whether they are equal.</span></span> <span data-ttu-id="58835-2968">Como iguais `value` deve ser uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início dessa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-2968">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="58835-2969">Este método executa uma comparação de palavra (diferencia maiúsculas de minúsculas e sensível à cultura) usando a cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-2969">This method performs a word (case-sensitive and culture-sensitive) comparison using the current culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2970">O exemplo a seguir define uma `StripStartTags` método que usa o <xref:System.String.StartsWith%28System.String%29> método para remover o HTML começar marcas desde o início de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2970">The following example defines a `StripStartTags` method that uses the <xref:System.String.StartsWith%28System.String%29> method to remove HTML start tags from the beginning of a string.</span></span> <span data-ttu-id="58835-2971">Observe que o `StripStartTags` método é chamado recursivamente para garantir que as várias marcas de início HTML no início da linha são removidas.</span><span class="sxs-lookup"><span data-stu-id="58835-2971">Note that the `StripStartTags` method is called recursively to ensure that multiple HTML start tags at the beginning of the line are removed.</span></span> <span data-ttu-id="58835-2972">O exemplo não remove as marcas HTML inseridas em uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2972">The example does not remove HTML tags embedded in a string.</span></span>  
  
 [!code-cpp[stringstartswith#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringstartswith/CPP/stringstartswith.cpp#1)]
 [!code-csharp[stringstartswith#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringstartswith/CS/stringstartswith.cs#1)]
 [!code-vb[stringstartswith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringstartswith/VB/stringstartswith.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2973">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2973">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-2974">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de comparação de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para determinar se uma cadeia de caracteres começa com uma subcadeia de caracteres específica usando as regras de comparação de cadeia de caracteres da cultura atual, chame o <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> sobrecarga de método com um valor de <see cref="F:System.StringComparison.CurrentCulture" /> para seu <paramref name="comparisonType" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2974">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string comparison methods that substitute default values and instead call methods that require parameters to be explicitly specified. To determine whether a string begins with a particular substring by using the string comparison rules of the current culture, call the <see cref="M:System.String.StartsWith(System.String,System.StringComparison)" /> method overload with a value of <see cref="F:System.StringComparison.CurrentCulture" /> for its <paramref name="comparisonType" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.EndsWith(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, comparisonType As StringComparison) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, StringComparison comparisonType);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * StringComparison -&gt; bool" Usage="string.StartsWith (value, comparisonType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2975">A cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2975">The string to compare.</span>
          </span>
        </param>
        <param name="comparisonType">
          <span data-ttu-id="58835-2976">Um dos valores de enumeração que determina como essa cadeia de caracteres e o <c>valor</c> são comparados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2976">One of the enumeration values that determines how this string and <c>value</c> are compared.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2977">Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparado à opção de comparação especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2977">Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2978">
            <see langword="true" /> se essa instância começar com <paramref name="value" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2978">
              <see langword="true" /> if this instance begins with <paramref name="value" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2979">O <xref:System.String.StartsWith%2A> método compara o `value` parâmetro à subcadeia de caracteres no início dessa cadeia de caracteres e retorna um valor que indica se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2979">The <xref:System.String.StartsWith%2A> method compares the `value` parameter to the substring at the beginning of this string and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="58835-2980">Para que seja igual, `value` deve ser uma referência a essa mesma cadeia de caracteres, deve ser a cadeia de caracteres vazia (""), ou deve corresponder ao início dessa cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2980">To be equal, `value` must be a reference to this same string, must be the empty string (""), or must match the beginning of this string.</span></span> <span data-ttu-id="58835-2981">O tipo de comparação executada pelo <xref:System.String.StartsWith%2A> método depende do valor da `comparisonType` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-2981">The type of comparison performed by the <xref:System.String.StartsWith%2A> method depends on the value of the `comparisonType` parameter.</span></span> <span data-ttu-id="58835-2982">A comparação pode usar as convenções da cultura atual (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> e <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) ou a cultura invariável (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> e <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), ou pode consistir em uma comparação de caractere por caractere de pontos de código (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> ou <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="58835-2982">The comparison can use the conventions of the current culture (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType> and <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>) or the invariant culture (<xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType> and <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>), or it can consist of a character-by-character comparison of code points (<xref:System.StringComparison.Ordinal?displayProperty=nameWithType> or <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span> <span data-ttu-id="58835-2983">A comparação também pode ser diferencia maiusculas de minúsculas (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, ou <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), ou ele pode ignorar maiusculas e minúsculas (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="58835-2983">The comparison can also be case-sensitive (<xref:System.StringComparison.CurrentCulture?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCulture?displayProperty=nameWithType>, or <xref:System.StringComparison.Ordinal?displayProperty=nameWithType>), or it can ignore case (<xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.InvariantCultureIgnoreCase?displayProperty=nameWithType>, <xref:System.StringComparison.OrdinalIgnoreCase?displayProperty=nameWithType>).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-2984">O exemplo a seguir procura a cadeia de caracteres "a" no início de uma cadeia de caracteres mais tempo que começa com a palavra "The".</span><span class="sxs-lookup"><span data-stu-id="58835-2984">The following example searches for the string "the" at the beginning of a longer string that begins with the word "The".</span></span> <span data-ttu-id="58835-2985">Como a saída do exemplo mostra uma chamada para o <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> método que executa uma comparação que diferencia maiusculas de minúsculas mas insensível à cultura não corresponde a cadeia de caracteres, enquanto uma chamada que executa uma comparação insensitive cultura e maiusculas corresponde a cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2985">As the output from the example shows, a call to the <xref:System.String.StartsWith%28System.String%2CSystem.StringComparison%29> method that performs a culture-insensitive but case-sensitive comparison fails to match the string, while a call that performs a culture- and case-insensitive comparison matches the string.</span></span>  
  
 [!code-cpp[System.String.StartsWith#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/StartsWith2.cpp#2)]
 [!code-csharp[System.String.StartsWith#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/StartsWith2.cs#2)]
 [!code-vb[System.String.StartsWith#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/StartsWith2.vb#2)]  
  
 <span data-ttu-id="58835-2986">O exemplo a seguir determina se uma cadeia de caracteres começa com uma subcadeia de caracteres específica.</span><span class="sxs-lookup"><span data-stu-id="58835-2986">The following example determines whether a string starts with a particular substring.</span></span> <span data-ttu-id="58835-2987">Inicializa uma matriz bidimensional de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2987">It initializes a two-dimensional string array.</span></span> <span data-ttu-id="58835-2988">O primeiro elemento na segunda dimensão contém uma cadeia de caracteres e o segundo elemento contém a cadeia de caracteres a ser pesquisado no início da primeira cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-2988">The first element in the second dimension contains a string, and the second element contains the string to search for at the start of the first string.</span></span> <span data-ttu-id="58835-2989">Os resultados são afetados pela escolha de cultura, se o caso é ignorado, e se uma comparação ordinal é executada.</span><span class="sxs-lookup"><span data-stu-id="58835-2989">The results are affected by the choice of culture, whether case is ignored, and whether an ordinal comparison is performed.</span></span> <span data-ttu-id="58835-2990">Observe que quando a instância de cadeia de caracteres contém uma ligadura, comparações sensíveis à cultura com seus caracteres consecutivos correspondam bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="58835-2990">Note that when the string instance contains a ligature, culture-sensitive comparisons with its consecutive characters successfully match.</span></span>  
  
 [!code-cpp[System.String.StartsWith#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.string.startswith/cpp/startswith1.cpp#1)]
 [!code-csharp[System.String.StartsWith#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.startswith/cs/startswith1.cs#1)]
 [!code-vb[System.String.StartsWith#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.startswith/vb/startswith1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-2991">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2991">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="58835-2992">
            <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2992">
              <paramref name="comparisonType" /> is not a <see cref="T:System.StringComparison" /> value.</span>
          </span>
        </exception>
        <altmember cref="T:System.StringComparison" />
      </Docs>
    </Member>
    <Member MemberName="StartsWith">
      <MemberSignature Language="C#" Value="public bool StartsWith (string value, bool ignoreCase, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool StartsWith(string value, bool ignoreCase, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.StartsWith(System.String,System.Boolean,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function StartsWith (value As String, ignoreCase As Boolean, culture As CultureInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool StartsWith(System::String ^ value, bool ignoreCase, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.StartsWith : string * bool * System.Globalization.CultureInfo -&gt; bool" Usage="string.StartsWith (value, ignoreCase, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="58835-2993">A cadeia de caracteres a ser comparada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2993">The string to compare.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="58835-2994">
            <see langword="true" /> para ignorar maiúsculas durante a comparação; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2994">
              <see langword="true" /> to ignore case during the comparison; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="58835-2995">As informações culturais que determinam como essa cadeia de caracteres e <c>value</c> são comparados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2995">Cultural information that determines how this string and <c>value</c> are compared.</span>
          </span>
          <span data-ttu-id="58835-2996">Se <c>culture</c> for <see langword="null" />, a cultura atual será usada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2996">If <c>culture</c> is <see langword="null" />, the current culture is used.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-2997">Determina se o início dessa instância de cadeia de caracteres corresponde à cadeia de caracteres especificada quando comparada usando a cultura especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2997">Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-2998">
            <see langword="true" /> se o parâmetro <paramref name="value" /> corresponder ao início dessa cadeia de caracteres; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-2998">
              <see langword="true" /> if the <paramref name="value" /> parameter matches the beginning of this string; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-2999">Esse método compara os `value` parâmetro para a subcadeia de caracteres no início dessa cadeia de caracteres que é o mesmo tamanho que `value`e retorna um valor que indica se eles são iguais.</span><span class="sxs-lookup"><span data-stu-id="58835-2999">This method compares the `value` parameter to the substring at the beginning of this string that is the same length as `value`, and returns a value that indicates whether they are equal.</span></span> <span data-ttu-id="58835-3000">Como iguais `value` deve ser uma cadeia de caracteres vazia (<xref:System.String.Empty?displayProperty=nameWithType>), deve ser uma referência a essa mesma instância ou deve corresponder ao início dessa instância.</span><span class="sxs-lookup"><span data-stu-id="58835-3000">To be equal, `value` must be an empty string (<xref:System.String.Empty?displayProperty=nameWithType>), must be a reference to this same instance, or must match the beginning of this instance.</span></span>  
  
 <span data-ttu-id="58835-3001">Esse método executa uma comparação usando a cultura e maiusculas e minúsculas especificada.</span><span class="sxs-lookup"><span data-stu-id="58835-3001">This method performs a comparison using the specified casing and culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3002">O exemplo a seguir determina se uma cadeia de caracteres ocorre no início de outra cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3002">The following example determines whether a string occurs at the beginning of another string.</span></span> <span data-ttu-id="58835-3003">O <xref:System.String.StartsWith%2A> método é chamado várias vezes com diferenciação de maiusculas e minúsculas e diferentes culturas que influenciam os resultados da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="58835-3003">The <xref:System.String.StartsWith%2A> method is called several times using case sensitivity, case insensitivity, and different cultures that influence the results of the search.</span></span>  
  
 [!code-csharp[system.string.StartsWithCI#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.StartsWithCI/cs/swci.cs#1)]
 [!code-vb[system.string.StartsWithCI#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.StartsWithCI/vb/swci.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-3004">
            <paramref name="value" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3004">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Substring">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3005">Recupera uma subcadeia de caracteres desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3005">Retrieves a substring from this instance.</span>
          </span>
          <span data-ttu-id="58835-3006">Esse membro está sobrecarregado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3006">This member is overloaded.</span>
          </span>
          <span data-ttu-id="58835-3007">Para informação completa sobre esse membro, incluindo sintaxe, uso e exemplos, clique em um nome na lista de sobrecargas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3007">For complete information about this member, including syntax, usage, and examples, click a name in the overload list.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex);" />
      <MemberSignature Language="F#" Value="member this.Substring : int -&gt; string" Usage="string.Substring startIndex" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-3008">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3008">The zero-based starting character position of a substring in this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3009">Recupera uma subcadeia de caracteres desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3009">Retrieves a substring from this instance.</span>
          </span>
          <span data-ttu-id="58835-3010">A subcadeia de caracteres começa em uma posição de caractere especificado e continua até o final da cadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3010">The substring starts at a specified character position and continues to the end of the string.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3011">Uma cadeia de caracteres equivalente à subcadeia de caracteres que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3011">A string that is equivalent to the substring that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3012">Você chama o <xref:System.String.Substring%28System.Int32%29> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa em uma posição de caractere especificado e termina no final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3012">You call the <xref:System.String.Substring%28System.Int32%29> method to extract a substring from a string that begins at a specified character position and ends at the end of the string.</span></span> <span data-ttu-id="58835-3013">A posição do caractere inicial é baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1.</span><span class="sxs-lookup"><span data-stu-id="58835-3013">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="58835-3014">Para extrair uma subcadeia de caracteres que começa em uma posição de caractere especificado e termina antes até o final da cadeia de caracteres, chame o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3014">To extract a substring that begins at a specified character position and ends before to the end of the string, call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3015">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3015">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3016">Em vez disso, ele retorna uma nova cadeia de caracteres que começa no `startIndex` posição na cadeia de caracteres atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3016">Instead, it returns a new string that begins at the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="58835-3017">Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou sequência de caracteres, chame um método como <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> para obter o valor de `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="58835-3017">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> to get the value of `startIndex`.</span></span> <span data-ttu-id="58835-3018">O segundo exemplo ilustra isso. ele extrai um valor de chave que inicia uma posição de caractere após o caractere "=".</span><span class="sxs-lookup"><span data-stu-id="58835-3018">The second example illustrates this; it extracts a key value that begins one character position after the "=" character.</span></span>  
  
 <span data-ttu-id="58835-3019">Se `startIndex` é igual a zero, o método retorna a cadeia de caracteres original inalterada.</span><span class="sxs-lookup"><span data-stu-id="58835-3019">If `startIndex` is equal to zero, the method returns the original string unchanged.</span></span>  
   
  
## Examples  
 <span data-ttu-id="58835-3020">O exemplo a seguir demonstra a obtenção de uma subcadeia de caracteres de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3020">The following example demonstrates obtaining a substring from a string.</span></span>  
  
 [!code-cpp[System.String.Substring#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.String.Substring/cpp/Substring10.cpp#10)]
 [!code-csharp[System.String.Substring#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring10.cs#10)]
 [!code-vb[System.String.Substring#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring10.vb#10)]  
  
 <span data-ttu-id="58835-3021">O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").</span><span class="sxs-lookup"><span data-stu-id="58835-3021">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="58835-3022">O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere de igual na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3022">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="58835-3023">A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai o nome da chave, que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3023">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="58835-3024">A chamada para o <xref:System.String.Substring%28System.Int32%29> método, em seguida, extrai o valor atribuído à chave.</span><span class="sxs-lookup"><span data-stu-id="58835-3024">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="58835-3025">Ele começa em uma posição de caractere depois o caractere de igual e estende até o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3025">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-3026">
            <paramref name="startIndex" /> for menor que zero ou maior que o comprimento dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3026">
              <paramref name="startIndex" /> is less than zero or greater than the length of this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Int32" />
        <altmember cref="M:System.String.Concat(System.Object)" />
        <altmember cref="M:System.String.Insert(System.Int32,System.String)" />
        <altmember cref="M:System.String.Join(System.String,System.String[])" />
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Split(System.Char[])" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="Substring">
      <MemberSignature Language="C#" Value="public string Substring (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Substring(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Substring(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Substring (startIndex As Integer, length As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Substring(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.Substring : int * int -&gt; string" Usage="string.Substring (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-3027">A posição de caractere de início de base zero de uma subcadeia de caracteres nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3027">The zero-based starting character position of a substring in this instance.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-3028">O número de caracteres na subcadeia de caracteres.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3028">The number of characters in the substring.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3029">Recupera uma subcadeia de caracteres desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3029">Retrieves a substring from this instance.</span>
          </span>
          <span data-ttu-id="58835-3030">A subcadeia de caracteres começa em uma posição de caractere especificado e tem um comprimento especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3030">The substring starts at a specified character position and has a specified length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3031">Uma cadeia de caracteres é equivalente à subcadeia de caracteres de comprimento <paramref name="length" /> que começa em <paramref name="startIndex" /> nessa instância, ou <see cref="F:System.String.Empty" />, se <paramref name="startIndex" /> for igual ao comprimento dessa instância e <paramref name="length" /> for zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3031">A string that is equivalent to the substring of length <paramref name="length" /> that begins at <paramref name="startIndex" /> in this instance, or <see cref="F:System.String.Empty" /> if <paramref name="startIndex" /> is equal to the length of this instance and <paramref name="length" /> is zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3032">Você chama o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método para extrair uma subcadeia de caracteres de uma cadeia de caracteres que começa em uma posição de caractere especificado e termina antes do final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3032">You call the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method to extract a substring from a string that begins at a specified character position and ends before the end of the string.</span></span> <span data-ttu-id="58835-3033">A posição do caractere inicial é baseado em zero; em outras palavras, o primeiro caractere na cadeia de caracteres está no índice 0, o índice 1.</span><span class="sxs-lookup"><span data-stu-id="58835-3033">The starting character position is a zero-based; in other words, the first character in the string is at index 0, not index 1.</span></span> <span data-ttu-id="58835-3034">Para extrair uma subcadeia de caracteres que começa na posição do caractere especificada e continua até o final da cadeia de caracteres, chame o <xref:System.String.Substring%28System.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3034">To extract a substring that begins at a specified character position and continues to the end of the string, call the <xref:System.String.Substring%28System.Int32%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3035">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3035">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3036">Em vez disso, ele retorna uma nova cadeia de caracteres com `length` caracteres a partir de `startIndex` posição na cadeia de caracteres atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3036">Instead, it returns a new string with `length` characters starting from the `startIndex` position in the current string.</span></span>  
  
 <span data-ttu-id="58835-3037">O `length` parâmetro representa o número total de caracteres a serem extraídos da instância atual de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3037">The `length` parameter represents the total number of characters to extract from the current string instance.</span></span> <span data-ttu-id="58835-3038">Isso inclui o caractere inicial foi encontrado no índice `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="58835-3038">This includes the starting character found at index  `startIndex`.</span></span>  <span data-ttu-id="58835-3039">Em outras palavras, o <xref:System.String.Substring%2A> método tenta extrair caracteres de índice `startIndex` índice `startIndex`  +  `length` - 1.</span><span class="sxs-lookup"><span data-stu-id="58835-3039">In other words, the <xref:System.String.Substring%2A> method attempts to extract characters from index `startIndex` to index `startIndex` + `length` - 1.</span></span>  
  
 <span data-ttu-id="58835-3040">Para extrair uma subcadeia de caracteres que começa com um determinado caractere ou sequência de caracteres, chame um método como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o valor de `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="58835-3040">To extract a substring that begins with a particular character or character sequence, call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the value of `startIndex`.</span></span>  
  
 <span data-ttu-id="58835-3041">Se a subcadeia de caracteres se estende do `startIndex` a uma sequência de caracteres especificada, você pode chamar um método, como <xref:System.String.IndexOf%2A> ou <xref:System.String.LastIndexOf%2A> para obter o índice do caractere final ou sequência de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3041">If the substring extends from `startIndex` to a specified character sequence, you can call a method such as  <xref:System.String.IndexOf%2A> or <xref:System.String.LastIndexOf%2A> to get the index of the ending character or character sequence.</span></span>  <span data-ttu-id="58835-3042">Em seguida, você pode converter esse valor em uma posição de índice na cadeia de caracteres da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="58835-3042">You can then convert that value to an index position in the string as follows:</span></span>  
  
-   <span data-ttu-id="58835-3043">Se você procurar por um único caractere que é marcar o final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  -  `startIndex` + 1, onde `endIndex` é o valor de retorno a <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3043">If you've searched for a single character that is to mark the end of the substring, the `length` parameter equals  `endIndex` - `startIndex` + 1, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="58835-3044">O exemplo a seguir extrai um bloco contínuo de caracteres "b" de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3044">The following example extracts a continuous block of "b" characters from a string.</span></span>  
  
     [!code-csharp[System.String.Substring#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring2.cs#2)]
     [!code-vb[System.String.Substring#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring2.vb#2)]  
  
-   <span data-ttu-id="58835-3045">Se você já procurou por vários caracteres que são marcar o final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  +  `endMatchLength`  -  `startIndex`, onde `endIndex` é o valor retornado do <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método. e `endMatchLength` é o comprimento da sequência de caracteres que marca o final da subcadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3045">If you've searched for multiple characters that are to mark the end of the substring, the `length` parameter equals  `endIndex` + `endMatchLength` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method., and `endMatchLength` is the length of the character sequence that marks the end of the substring.</span></span> <span data-ttu-id="58835-3046">O exemplo a seguir extrai um bloco de texto que contém um XML `<definition>` elemento.</span><span class="sxs-lookup"><span data-stu-id="58835-3046">The following example extracts a block of text that contains an XML `<definition>` element.</span></span>  
  
     [!code-csharp[System.String.Substring#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring3.cs#3)]
     [!code-vb[System.String.Substring#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring3.vb#3)]  
  
-   <span data-ttu-id="58835-3047">Se o caractere ou cadeia de caracteres não está incluída no final da subcadeia de caracteres, o `length` for igual ao parâmetro `endIndex`  -  `startIndex`, onde `endIndex` é o valor de retorno a <xref:System.String.IndexOf%2A> ou <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3047">If the character or character sequence is not included in the end of the substring, the `length` parameter equals `endIndex` - `startIndex`, where `endIndex` is the return value of the <xref:System.String.IndexOf%2A> or <xref:System.String.IndexOf%2A> method.</span></span>  
  
 <span data-ttu-id="58835-3048">Se `startIndex` é igual a zero e é igual a, o comprimento da cadeia de caracteres atual, o método retorna a cadeia de caracteres original inalterada.</span><span class="sxs-lookup"><span data-stu-id="58835-3048">If `startIndex` is equal to zero and  equals the length of the current string, the method returns the original string unchanged.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3049">O exemplo a seguir ilustra uma chamada simples para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método que extrai os dois caracteres de uma cadeia de caracteres começando na sexta posição de caractere (isto é, no índice cinco).</span><span class="sxs-lookup"><span data-stu-id="58835-3049">The following example illustrates a simple call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method that extracts two characters from a string starting at the sixth character position (that is, at index five).</span></span>  
  
 [!code-csharp[System.String.Substring#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring4.cs#4)]
 [!code-vb[System.String.Substring#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring4.vb#4)]  
  
 <span data-ttu-id="58835-3050">O exemplo a seguir usa o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método em três casos a seguir para isolar as subcadeias de caracteres dentro de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3050">The following example uses the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method in the following three cases to isolate substrings within a string.</span></span> <span data-ttu-id="58835-3051">Nos dois casos as subcadeias de caracteres são usadas em comparações e o terceiro caso uma exceção é gerada porque parâmetros inválidos foram especificados.</span><span class="sxs-lookup"><span data-stu-id="58835-3051">In two cases the substrings are used in comparisons, and in the third case an exception is thrown because invalid parameters are specified.</span></span>  
  
-   <span data-ttu-id="58835-3052">Ele extrai o caractere único e a terceira posição na cadeia de caracteres (no índice 2) e o compara com um "c".</span><span class="sxs-lookup"><span data-stu-id="58835-3052">It extracts the single character and the third position in the string (at index 2) and compares it with a "c".</span></span> <span data-ttu-id="58835-3053">Essa comparação retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="58835-3053">This comparison returns `true`.</span></span>  
  
-   <span data-ttu-id="58835-3054">Ele extrai caracteres começando na quarta posição na cadeia de caracteres (no índice 3) e passa-o para o <xref:System.String.IsNullOrEmpty%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3054">It extracts zero characters starting at the fourth position in the string (at index 3) and passes it to the <xref:System.String.IsNullOrEmpty%2A> method.</span></span> <span data-ttu-id="58835-3055">Isso retorna true, porque a chamada para o <xref:System.String.Substring%2A> retorno do método <xref:System.String.Empty?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-3055">This returns true because the call to the <xref:System.String.Substring%2A> method returns <xref:System.String.Empty?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="58835-3056">Ele tenta extrair um caractere começando na quarta posição na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3056">It attempts to extract one character starting at the fourth position in the string.</span></span> <span data-ttu-id="58835-3057">Como não há nenhum caractere nessa posição, a chamada de método lança um <xref:System.ArgumentOutOfRangeException> exceção.</span><span class="sxs-lookup"><span data-stu-id="58835-3057">Because there is no character at that position, the method call throws an <xref:System.ArgumentOutOfRangeException> exception.</span></span>  
  
 [!code-csharp[Classic String.Substring1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic String.Substring1 Example/CS/source.cs#1)]
 [!code-vb[Classic String.Substring1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic String.Substring1 Example/VB/source.vb#1)]  
  
 <span data-ttu-id="58835-3058">O exemplo a seguir usa o <xref:System.String.Substring%2A> método para separar os pares chave/valor que são delimitados por igual a caractere ("=").</span><span class="sxs-lookup"><span data-stu-id="58835-3058">The following example uses the <xref:System.String.Substring%2A> method to separate key/value pairs that are delimited by an equals ("=") character.</span></span>  
  
 [!code-csharp[System.String.Substring#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.String.Substring/cs/Substring1.cs#1)]
 [!code-vb[System.String.Substring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.String.Substring/vb/Substring1.vb#1)]  
  
 <span data-ttu-id="58835-3059">O <xref:System.String.IndexOf%2A> método é usado para obter a posição do caractere de igual na cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3059">The <xref:System.String.IndexOf%2A> method is used to get the position of the equals character in the string.</span></span> <span data-ttu-id="58835-3060">A chamada para o <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> método extrai o nome da chave, que inicia a partir do primeiro caractere na cadeia de caracteres e se estende para o número de caracteres retornada pela chamada para o <xref:System.String.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3060">The call to the <xref:System.String.Substring%28System.Int32%2CSystem.Int32%29> method extracts the key name, which starts from the first character in the string and extends for the number of characters returned by the call to the <xref:System.String.IndexOf%2A> method.</span></span> <span data-ttu-id="58835-3061">A chamada para o <xref:System.String.Substring%28System.Int32%29> método, em seguida, extrai o valor atribuído à chave.</span><span class="sxs-lookup"><span data-stu-id="58835-3061">The call to the <xref:System.String.Substring%28System.Int32%29> method then extracts the value assigned to the key.</span></span> <span data-ttu-id="58835-3062">Ele começa em uma posição de caractere depois o caractere de igual e estende até o final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3062">It starts at one character position beyond the equals character and extends to the end of the string.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-3063">A soma de <paramref name="startIndex" /> e <paramref name="length" /> indica uma posição que não está dentro dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3063">
              <paramref name="startIndex" /> plus <paramref name="length" /> indicates a position not within this instance.</span>
          </span>
          <span data-ttu-id="58835-3064">-ou- <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3064">-or-  <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.Remove(System.Int32,System.Int32)" />
        <altmember cref="M:System.String.Replace(System.Char,System.Char)" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Char&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;char&gt; IEnumerable&lt;char&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;char&gt; System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#Generic#IEnumerable&lt;char&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of Char) Implements IEnumerable(Of Char).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;char&gt; ^ System.Collections.Generic.IEnumerable&lt;char&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;char&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Char&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3065">Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3065">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3066">Um enumerador fortemente tipado que pode ser usado para iterar pelo objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3066">A strongly-typed enumerator that can be used to iterate through the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3067">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3067">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3068">Ele pode ser usado somente quando o <xref:System.String> instância é convertida para um <xref:System.Collections.Generic.IEnumerable%601> objeto de interface.</span><span class="sxs-lookup"><span data-stu-id="58835-3068">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.Generic.IEnumerable%601> interface object.</span></span> <span data-ttu-id="58835-3069">Para obter mais informações, consulte o método <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A>.</span><span class="sxs-lookup"><span data-stu-id="58835-3069">For more information, see the <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3070">Retorna um enumerador que itera pelo objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3070">Returns an enumerator that iterates through the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3071">Um enumerador que pode ser usado para iterar pela coleção atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3071">An enumerator that can be used to iterate through the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3072">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3072">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3073">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.Collections.IEnumerable>.</span><span class="sxs-lookup"><span data-stu-id="58835-3073">It can be used only when the <xref:System.String> instance is cast to an <xref:System.Collections.IEnumerable> interface.</span></span> <span data-ttu-id="58835-3074">Para obter mais informações, consulte o método <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-3074">For more information, see the <xref:System.Collections.IEnumerable.GetEnumerator%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3075">Este parâmetro é ignorado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3075">This parameter is ignored.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3076">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3076">For a description of this member, see <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3077">
            <see langword="true" /> se o valor da cadeia de caracteres atual for <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> se o valor da cadeia de caracteres atual for <see cref="F:System.Boolean.FalseString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3077">
              <see langword="true" /> if the value of the current string is <see cref="F:System.Boolean.TrueString" />; <see langword="false" /> if the value of the current string is <see cref="F:System.Boolean.FalseString" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3078">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3078">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3079">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3079">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3080">A alternativa recomendada é chamar o <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3080">The recommended alternative is to call the <xref:System.Convert.ToBoolean%28System.String%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3081">O valor da cadeia de caracteres atual não é <see cref="F:System.Boolean.TrueString" /> ou <see cref="F:System.Boolean.FalseString" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3081">The value of the current string is not <see cref="F:System.Boolean.TrueString" /> or <see cref="F:System.Boolean.FalseString" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3082">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3082">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3083">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3083">For a description of this member, see <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3084">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3084">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3085">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3085">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3086">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3086">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3087">A alternativa recomendada é chamar o <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3087">The recommended alternative is to call the <xref:System.Convert.ToByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3088">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3088">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3089">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Byte.MaxValue" /> ou menor que <see cref="F:System.Byte.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3089">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Byte.MaxValue" /> or less than <see cref="F:System.Byte.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3090">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3090">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3091">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3091">For a description of this member, see <see cref="M:System.IConvertible.ToChar(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3092">O caractere no índice 0 no objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3092">The character at index 0 in the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3093">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3093">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3094">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3094">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3095">A alternativa recomendada é chamar o <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3095">The recommended alternative is to call the <xref:System.Convert.ToChar%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3096">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3096">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3097">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3097">For a description of this member, see <see cref="M:System.IConvertible.ToDateTime(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3098">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3098">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3099">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3099">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3100">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3100">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3101">A alternativa recomendada é chamar o <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3101">The recommended alternative is to call the <xref:System.Convert.ToDateTime%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3102">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3102">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3103">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3103">For a description of this member, see <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3104">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3104">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3105">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3105">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3106">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3106">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3107">A alternativa recomendada é chamar o <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3107">The recommended alternative is to call the <xref:System.Convert.ToDecimal%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3108">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3108">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3109">O valor do objeto <see cref="T:System.String" /> atual é um número menor que <see cref="F:System.Decimal.MinValue" /> ou maior que <see cref="F:System.Decimal.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3109">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Decimal.MinValue" /> or than <see cref="F:System.Decimal.MaxValue" /> greater.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3110">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3110">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3111">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3111">For a description of this member, see <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3112">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3112">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3113">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3113">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3114">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3114">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3115">A alternativa recomendada é chamar o <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3115">The recommended alternative is to call the <xref:System.Convert.ToDouble%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3116">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3116">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3117">O valor do objeto <see cref="T:System.String" /> atual é um número menor que <see cref="F:System.Double.MinValue" /> ou maior que <see cref="F:System.Double.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3117">The value of the current <see cref="T:System.String" /> object is a number less than <see cref="F:System.Double.MinValue" /> or greater than <see cref="F:System.Double.MaxValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3118">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3118">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3119">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3119">For a description of this member, see <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3120">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3120">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3121">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3121">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3122">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3122">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3123">A alternativa recomendada é chamar o <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3123">The recommended alternative is to call the <xref:System.Convert.ToInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3124">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3124">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3125">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.Int16.MaxValue" /> ou menor que <see cref="F:System.Int16.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3125">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.Int16.MaxValue" /> or less than <see cref="F:System.Int16.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3126">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3126">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3127">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3127">For a description of this member, see <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3128">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3128">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3129">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3129">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3130">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3130">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3131">A alternativa recomendada é chamar o <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3131">The recommended alternative is to call the <xref:System.Convert.ToInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3132">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3132">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3133">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3133">For a description of this member, see <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3134">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3134">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3135">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3135">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3136">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3136">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3137">A alternativa recomendada é chamar o <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3137">The recommended alternative is to call the <xref:System.Convert.ToInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3138">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3138">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3139">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3139">For a description of this member, see <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3140">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3140">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3141">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3141">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3142">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3142">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3143">A alternativa recomendada é chamar o <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3143">The recommended alternative is to call the <xref:System.Convert.ToSByte%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3144">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3144">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3145">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.SByte.MaxValue" /> ou menor que <see cref="F:System.SByte.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3145">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.SByte.MaxValue" /> or less than <see cref="F:System.SByte.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3146">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3146">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3147">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3147">For a description of this member, see <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3148">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3148">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3149">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3149">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3150">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3150">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3151">A alternativa recomendada é chamar o <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3151">The recommended alternative is to call the <xref:System.Convert.ToSingle%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToString">
      <MemberSignature Language="C#" Value="string IConvertible.ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.IConvertible.ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToString (provider As IFormatProvider) As String Implements IConvertible.ToString" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.IConvertible.ToString(IFormatProvider ^ provider) = IConvertible::ToString;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="58835-3152">O tipo do objeto retornado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3152">The type of the returned object.</span>
          </span>
        </param>
        <param name="provider">
          <span data-ttu-id="58835-3153">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3153">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3154">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3154">For a description of this member, see <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3155">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3155">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3156">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3156">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3157">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3157">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3158">A alternativa recomendada é chamar o <xref:System.Convert.ChangeType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3158">The recommended alternative is to call the <xref:System.Convert.ChangeType%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-3159">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3159">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="58835-3160">O valor do objeto <see cref="T:System.String" /> atual não pode ser convertido para o tipo especificado pelo parâmetro <paramref name="type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3160">The value of the current <see cref="T:System.String" /> object cannot be converted to the type specified by the <paramref name="type" /> parameter.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3161">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3161">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3162">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3162">For a description of this member, see <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3163">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3163">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3164">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3164">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3165">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3165">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3166">A alternativa recomendada é chamar o <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3166">The recommended alternative is to call the <xref:System.Convert.ToUInt16%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3167">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3167">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3168">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt16.MaxValue" /> ou menor que <see cref="F:System.UInt16.MinValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3168">The value of the current <see cref="T:System.String" /> object is a number greater than <see cref="F:System.UInt16.MaxValue" /> or less than <see cref="F:System.UInt16.MinValue" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3169">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3169">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3170">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3170">For a description of this member, see <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3171">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3171">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3172">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3172">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3173">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3173">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3174">A alternativa recomendada é chamar o <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3174">The recommended alternative is to call the <xref:System.Convert.ToUInt32%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <span data-ttu-id="58835-3175">O valor do objeto <see cref="T:System.String" /> atual não pode ser analisado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3175">The value of the current <see cref="T:System.String" /> object cannot be parsed.</span>
          </span>
        </exception>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="58835-3176">O valor do objeto <see cref="T:System.String" /> atual é um número maior que <see cref="F:System.UInt32.MaxValue" /> ou menor que <see cref="F:System.UInt32.MinValue" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3176">The value of the current <see cref="T:System.String" /> object is a number greater <see cref="F:System.UInt32.MaxValue" /> or less than <see cref="F:System.UInt32.MinValue" /></span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3177">Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3177">An object that provides culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3178">Para obter uma descrição desse membro, consulte <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3178">For a description of this member, see <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3179">O valor convertido do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3179">The converted value of the current <see cref="T:System.String" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3180">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="58835-3180">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="58835-3181">Ele só pode ser usado quando a instância de <xref:System.String> é convertida em uma interface de <xref:System.IConvertible>.</span><span class="sxs-lookup"><span data-stu-id="58835-3181">It can be used only when the <xref:System.String> instance is cast to an <xref:System.IConvertible> interface.</span></span> <span data-ttu-id="58835-3182">A alternativa recomendada é chamar o <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3182">The recommended alternative is to call the <xref:System.Convert.ToUInt64%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToCharArray">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3183">Copia os caracteres nesta instância para uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3183">Copies the characters in this instance to a Unicode character array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray () As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray();" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : unit -&gt; char[]" Usage="string.ToCharArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3184">Copia os caracteres nesta instância para uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3184">Copies the characters in this instance to a Unicode character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3185">Uma matriz de caracteres Unicode cujos elementos são os caracteres individuais desta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3185">A Unicode character array whose elements are the individual characters of this instance.</span>
          </span>
          <span data-ttu-id="58835-3186">Se a instância for uma cadeia de caracteres vazia, a matriz retornada estará vazia e terá comprimento zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3186">If this instance is an empty string, the returned array is empty and has a zero length.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3187">Esse método copia cada caractere (ou seja, cada <xref:System.Char> objeto) em uma cadeia de caracteres para uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3187">This method copies each character (that is, each <xref:System.Char> object) in a string to a character array.</span></span> <span data-ttu-id="58835-3188">O primeiro caractere copiado está no índice zero da matriz de caracteres retornada; o último caractere copiado está no índice <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.</span><span class="sxs-lookup"><span data-stu-id="58835-3188">The first character copied is at index zero of the returned character array; the last character copied is at index <xref:System.Array.Length%2A?displayProperty=nameWithType> – 1.</span></span>  
  
 <span data-ttu-id="58835-3189">Para criar uma cadeia de caracteres dos caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-3189">To create a string from the characters in a character array, call the <xref:System.String.%23ctor%28System.Char%5B%5D%29> constructor.</span></span>  
  
 <span data-ttu-id="58835-3190">Para criar uma matriz de bytes que contém os caracteres codificados em uma cadeia de caracteres, instanciar apropriado <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3190">To create a byte array that contains the encoded characters in a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="58835-3191">Algumas das codificações padrão disponíveis no .NET Framework incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-3191">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="58835-3192">Codificando</span><span class="sxs-lookup"><span data-stu-id="58835-3192">Encoding</span></span>|<span data-ttu-id="58835-3193">Objeto</span><span class="sxs-lookup"><span data-stu-id="58835-3193">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="58835-3194">ASCII</span><span class="sxs-lookup"><span data-stu-id="58835-3194">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="58835-3195">UTF-7</span><span class="sxs-lookup"><span data-stu-id="58835-3195">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="58835-3196">UTF-8</span><span class="sxs-lookup"><span data-stu-id="58835-3196">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="58835-3197">UTF-16</span><span class="sxs-lookup"><span data-stu-id="58835-3197">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="58835-3198">UTF-32</span><span class="sxs-lookup"><span data-stu-id="58835-3198">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="58835-3199">Para obter mais informações, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="58835-3199">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3200">A exemplo a seguir chama o <xref:System.String.ToCharArray%2A> método para extrair os caracteres em uma cadeia de caracteres para uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3200">The following example calls the <xref:System.String.ToCharArray%2A> method to extract the characters in a string to a character array.</span></span> <span data-ttu-id="58835-3201">Ele exibe a cadeia de caracteres original e os elementos na matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-3201">It then displays the original string and the elements in the array.</span></span>  
  
 [!code-csharp[System.String.ToCharArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tochararray/cs/ToCharArray1.cs#1)]
 [!code-vb[System.String.ToCharArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tochararray/vb/ToCharArray1.vb#1)]  
  
 <span data-ttu-id="58835-3202">O exemplo a seguir define uma cadeia de caracteres que contém os caracteres que atuam como delimitadores em uma cadeia de caracteres delimitada.</span><span class="sxs-lookup"><span data-stu-id="58835-3202">The following example defines a string containing the characters that serve as delimiters in a delimited string.</span></span> <span data-ttu-id="58835-3203">Em seguida, ele chama o <xref:System.String.ToCharArray%2A> método para criar uma matriz de caracteres que pode ser passada para o <xref:System.String.Split%28System.Char%5B%5D%29> método para separar a cadeia de caracteres delimitada em seus subcadeias de caracteres individuais.</span><span class="sxs-lookup"><span data-stu-id="58835-3203">It then calls the <xref:System.String.ToCharArray%2A> method to create a character array that can be passed to the <xref:System.String.Split%28System.Char%5B%5D%29> method to separate the delimited string into its individual substrings.</span></span>  
  
 [!code-cpp[StringSplit2#1](~/samples/snippets/cpp/VS_Snippets_CLR/StringSplit2/CPP/stringsplit2.cpp#1)] 
 [!code-csharp[StringSplit2#1](~/samples/snippets/csharp/VS_Snippets_CLR/StringSplit2/CS/stringsplit2.cs#1)] 
 [!code-vb[StringSplit2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StringSplit2/VB/stringsplit2.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Array" />
      </Docs>
    </Member>
    <Member MemberName="ToCharArray">
      <MemberSignature Language="C#" Value="public char[] ToCharArray (int startIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance char[] ToCharArray(int32 startIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToCharArray(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToCharArray (startIndex As Integer, length As Integer) As Char()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;char&gt; ^ ToCharArray(int startIndex, int length);" />
      <MemberSignature Language="F#" Value="member this.ToCharArray : int * int -&gt; char[]" Usage="string.ToCharArray (startIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="startIndex">
          <span data-ttu-id="58835-3204">A posição inicial de uma subcadeia de caracteres nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3204">The starting position of a substring in this instance.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="58835-3205">O comprimento da subcadeia de caracteres nesta instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3205">The length of the substring in this instance.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3206">Copia os caracteres em uma subcadeia de caracteres especificada nesta instância para uma matriz de caracteres Unicode.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3206">Copies the characters in a specified substring in this instance to a Unicode character array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3207">Uma matriz de caracteres Unicode cujos elementos são o número de caracteres <paramref name="length" /> nesta instância a partir da posição do caractere <paramref name="startIndex" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3207">A Unicode character array whose elements are the <paramref name="length" /> number of characters in this instance starting from character position <paramref name="startIndex" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3208">Esse método copia os caracteres em uma parte de uma cadeia de caracteres para uma matriz de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3208">This method copies the characters in a portion of a string to a character array.</span></span> <span data-ttu-id="58835-3209">Para criar uma cadeia de caracteres de um intervalo de caracteres em uma matriz de caracteres, chame o <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="58835-3209">To create a string from a range of characters in a character array, call the  <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="58835-3210">O `startIndex` parâmetro é baseado em zero.</span><span class="sxs-lookup"><span data-stu-id="58835-3210">The `startIndex` parameter is zero-based.</span></span> <span data-ttu-id="58835-3211">Ou seja, o índice do primeiro caractere na instância de cadeia de caracteres é zero.</span><span class="sxs-lookup"><span data-stu-id="58835-3211">That is, the index of the first character in the string instance is zero.</span></span>  
  
 <span data-ttu-id="58835-3212">Se `length` for zero, a matriz retornada está vazia e tem comprimento zero.</span><span class="sxs-lookup"><span data-stu-id="58835-3212">If `length` is zero, the returned array is empty and has a zero length.</span></span> <span data-ttu-id="58835-3213">Se esta instância for `null` ou uma cadeia de caracteres vazia (""), a matriz retornada está vazia e tem comprimento zero.</span><span class="sxs-lookup"><span data-stu-id="58835-3213">If this instance is `null` or an empty string (""), the returned array is empty and has a zero length.</span></span>  
  
 <span data-ttu-id="58835-3214">Para criar uma matriz de bytes que contém os caracteres codificados em uma parte de uma cadeia de caracteres, instanciar apropriado <xref:System.Text.Encoding> objeto e chame seu <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3214">To create a byte array that contains the encoded characters in a portion of a string, instantiate the appropriate <xref:System.Text.Encoding> object and call its <xref:System.Text.Encoding.GetBytes%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Byte%5B%5D%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="58835-3215">Algumas das codificações padrão disponíveis no .NET Framework incluem o seguinte:</span><span class="sxs-lookup"><span data-stu-id="58835-3215">Some of the standard encodings available in the .NET Framework include the following:</span></span>  
  
|<span data-ttu-id="58835-3216">Codificando</span><span class="sxs-lookup"><span data-stu-id="58835-3216">Encoding</span></span>|<span data-ttu-id="58835-3217">Objeto</span><span class="sxs-lookup"><span data-stu-id="58835-3217">Object</span></span>|  
|--------------|------------|  
|<span data-ttu-id="58835-3218">ASCII</span><span class="sxs-lookup"><span data-stu-id="58835-3218">ASCII</span></span>|<xref:System.Text.ASCIIEncoding>|  
|<span data-ttu-id="58835-3219">UTF-7</span><span class="sxs-lookup"><span data-stu-id="58835-3219">UTF-7</span></span>|<xref:System.Text.UTF7Encoding>|  
|<span data-ttu-id="58835-3220">UTF-8</span><span class="sxs-lookup"><span data-stu-id="58835-3220">UTF-8</span></span>|<xref:System.Text.UTF8Encoding>|  
|<span data-ttu-id="58835-3221">UTF-16</span><span class="sxs-lookup"><span data-stu-id="58835-3221">UTF-16</span></span>|<xref:System.Text.UnicodeEncoding>|  
|<span data-ttu-id="58835-3222">UTF-32</span><span class="sxs-lookup"><span data-stu-id="58835-3222">UTF-32</span></span>|<xref:System.Text.UTF32Encoding>|  
  
 <span data-ttu-id="58835-3223">Para obter mais informações, consulte [codificação de caracteres no .NET Framework](~/docs/standard/base-types/character-encoding.md).</span><span class="sxs-lookup"><span data-stu-id="58835-3223">For more information, see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3224">O exemplo a seguir converte uma subcadeia de caracteres dentro de uma cadeia de caracteres em uma matriz de caracteres, em seguida, enumera e exibe os elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="58835-3224">The following example converts a substring within a string to an array of characters, then enumerates and displays the elements of the array.</span></span>  
  
 [!code-cpp[string.tochararray1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.ToCharArray1/CPP/tocharry1.cpp#1)]
 [!code-csharp[string.tochararray1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.ToCharArray1/CS/tocharry1.cs#1)]
 [!code-vb[string.tochararray1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.ToCharArray1/VB/tocharry1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="58835-3225">
            <paramref name="startIndex" /> ou <paramref name="length" /> é menor que zero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3225">
              <paramref name="startIndex" /> or <paramref name="length" /> is less than zero.</span>
          </span>
          <span data-ttu-id="58835-3226">-ou- A soma de <paramref name="startIndex" /> e <paramref name="length" /> é maior que o tamanho dessa instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3226">-or-  <paramref name="startIndex" /> plus <paramref name="length" /> is greater than the length of this instance.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToLower">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3227">Retorna uma cópia dessa cadeia de caracteres convertida em minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3227">Returns a copy of this string converted to lowercase.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower();" />
      <MemberSignature Language="F#" Value="member this.ToLower : unit -&gt; string" Usage="string.ToLower " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3228">Retorna uma cópia dessa cadeia de caracteres convertida em minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3228">Returns a copy of this string converted to lowercase.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3229">Uma cadeia de caracteres em letras minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3229">A string in lowercase.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3230">Esse método leva em conta as regras de maiusculas e minúsculas da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3230">This method takes into account the casing rules of the current culture.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3231">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3231">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3232">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3232">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3233">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3233">Security Considerations</span></span>  
 <span data-ttu-id="58835-3234">A operação de maiusculas e minúsculas que resulta de chamar o <xref:System.String.ToLower> método considera as convenções de capitalização da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3234">The casing operation that results from calling the <xref:System.String.ToLower> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="58835-3235">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-3235">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span> <span data-ttu-id="58835-3236">Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToLower> método) e executa com mais eficiência.</span><span class="sxs-lookup"><span data-stu-id="58835-3236">This produces the same result in every culture (unlike the <xref:System.String.ToLower> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3237">O exemplo a seguir converte várias cadeias de caracteres casos mistas em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3237">The following example converts several mixed case strings to lowercase.</span></span>  
  
 [!code-cpp[stringlowerupper#1](~/samples/snippets/cpp/VS_Snippets_CLR/stringlowerupper/CPP/stringtolower.cpp#1)]
 [!code-csharp[stringlowerupper#1](~/samples/snippets/csharp/VS_Snippets_CLR/stringlowerupper/CS/stringtolower.cs#1)]
 [!code-vb[stringlowerupper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/stringlowerupper/VB/stringtolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3238">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para converter um caractere em minúsculas usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para seu <paramref name="culture" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3238">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified. To convert a character to lowercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToLower(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToLower">
      <MemberSignature Language="C#" Value="public string ToLower (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLower(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLower(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLower (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLower(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToLower : System.Globalization.CultureInfo -&gt; string" Usage="string.ToLower culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="58835-3239">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3239">An object that supplies culture-specific casing rules.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3240">Retorna uma cópia desta cadeia de caracteres convertida em minúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3240">Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3241">O equivalente da cadeia de caracteres atual em minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3241">The lowercase equivalent of the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3242">As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a maneira como o caso da cadeia de caracteres é alterado.</span><span class="sxs-lookup"><span data-stu-id="58835-3242">The casing rules of the culture specified by the `culture` parameter determine the way the case of the string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3243">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3243">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3244">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3244">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3245">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3245">Security Considerations</span></span>  
 <span data-ttu-id="58835-3246">Se você passar o <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> método uma <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em consideração.</span><span class="sxs-lookup"><span data-stu-id="58835-3246">If you pass the <xref:System.String.ToLower%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="58835-3247">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3247">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="58835-3248">Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.</span><span class="sxs-lookup"><span data-stu-id="58835-3248">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3249">O exemplo a seguir converte duas cadeias de caracteres em maiusculas para minúsculas usando as culturas Inglês-Estados Unidos e Turco-Turquia e, em seguida, compara as cadeias de caracteres em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3249">The following example converts two strings of uppercase characters to lowercase characters using the English-United States and Turkish-Turkey cultures, then compares the lowercase strings.</span></span> <span data-ttu-id="58835-3250">As cadeias de caracteres maiusculos são idênticas, exceto para cada ocorrência do Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, a outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.</span><span class="sxs-lookup"><span data-stu-id="58835-3250">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-cpp[string.tolower1#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tolower1/CPP/tolower.cpp#1)]
 [!code-csharp[string.tolower1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tolower1/CS/tolower.cs#1)]
 [!code-vb[string.tolower1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tolower1/VB/tolower.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-3251">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3251">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="M:System.String.ToUpper" />
      </Docs>
    </Member>
    <Member MemberName="ToLowerInvariant">
      <MemberSignature Language="C#" Value="public string ToLowerInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToLowerInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToLowerInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToLowerInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToLowerInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToLowerInvariant : unit -&gt; string" Usage="string.ToLowerInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3252">Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em minúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3252">Returns a copy of this <see cref="T:System.String" /> object converted to lowercase using the casing rules of the invariant culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3253">O equivalente da cadeia de caracteres atual em minúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3253">The lowercase equivalent of the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3254">A cultura invariável representa uma cultura insensível.</span><span class="sxs-lookup"><span data-stu-id="58835-3254">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="58835-3255">Ele está associado com o idioma inglês, mas não com um país ou região específica.</span><span class="sxs-lookup"><span data-stu-id="58835-3255">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="58835-3256">Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-3256">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58835-3257">Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de uma maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToLowerInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3257">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToLowerInvariant%2A> method.</span></span> <span data-ttu-id="58835-3258">O <xref:System.String.ToLowerInvariant%2A> método é equivalente a `ToLower(CultureInfo.InvariantCulture)`.</span><span class="sxs-lookup"><span data-stu-id="58835-3258">The <xref:System.String.ToLowerInvariant%2A> method is equivalent to `ToLower(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="58835-3259">O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="58835-3259">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3260">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3260">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3261">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3261">Instead, it returns a new string in which all characters in the current instance are converted to lowercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3262">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3262">Security Considerations</span></span>  
 <span data-ttu-id="58835-3263">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-3263">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3264">O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas.</span><span class="sxs-lookup"><span data-stu-id="58835-3264">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="58835-3265">O <xref:System.String.ToLowerInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão sem diferenciação de cada palavra.</span><span class="sxs-lookup"><span data-stu-id="58835-3265">The <xref:System.String.ToLowerInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="58835-3266">O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz diferencia maiusculas de minúsculas, com base na ordem de elementos na matriz de letras minúsculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.</span><span class="sxs-lookup"><span data-stu-id="58835-3266">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the lowercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToLowerInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.tolowerinvariant/cs/tolowerinvariant.cs#1)]
 [!code-vb[System.String.ToLowerInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.tolowerinvariant/vb/tolowerinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToUpperInvariant" />
        <altmember cref="M:System.String.ToLower(System.Globalization.CultureInfo)" />
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3267">Converte o valor dessa instância em um <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3267">Converts the value of this instance to a <see cref="T:System.String" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="string.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3268">Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3268">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3269">A cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3269">The current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3270">Como esse método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente.</span><span class="sxs-lookup"><span data-stu-id="58835-3270">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span> <span data-ttu-id="58835-3271">Ele geralmente é chamado implicitamente em uma operação, como mostra o exemplo de formatação de composição.</span><span class="sxs-lookup"><span data-stu-id="58835-3271">It is usually called implicitly in a composite formatting operation, as the example shows.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3272">O exemplo a seguir demonstra o <xref:System.String.ToString%2A> método. Observe que o exemplo não chama explicitamente o <xref:System.String.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3272">The following example demonstrates the <xref:System.String.ToString%2A> method.Note that the example does not explicitly call the <xref:System.String.ToString%2A> method.</span></span> <span data-ttu-id="58835-3273">Em vez disso, o método é chamado implicitamente, o [formatação de composição](~/docs/standard/base-types/composite-formatting.md) recurso.</span><span class="sxs-lookup"><span data-stu-id="58835-3273">Instead, the method is called implicitly by the [composite formatting](~/docs/standard/base-types/composite-formatting.md) feature.</span></span>  
  
 [!code-cpp[string.tostring#1](~/samples/snippets/cpp/VS_Snippets_CLR/string.tostring/CPP/string.tostring.cpp#1)]
 [!code-csharp[string.tostring#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.tostring/CS/string.tostring.cs#1)]
 [!code-vb[string.tostring#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.tostring/VB/string.tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.Clone" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="string.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">
          <span data-ttu-id="58835-3274">(Reservado) Um objeto que fornece informações de formatação específicas de cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3274">(Reserved) An object that supplies culture-specific formatting information.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3275">Retorna esta instância do <see cref="T:System.String" />; nenhuma conversão em si é executada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3275">Returns this instance of <see cref="T:System.String" />; no actual conversion is performed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3276">A cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3276">The current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3277">`provider` é reservado e não participar no momento, esta operação.</span><span class="sxs-lookup"><span data-stu-id="58835-3277">`provider` is reserved, and does not currently participate in this operation.</span></span>  
  
 <span data-ttu-id="58835-3278">Como esse método simplesmente retorna a cadeia de caracteres atual inalterada, não é necessário chamá-lo diretamente.</span><span class="sxs-lookup"><span data-stu-id="58835-3278">Because this method simply returns the current string unchanged, there is no need to call it directly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToUpper">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3279">Retorna uma cópia dessa cadeia de caracteres convertida em maiúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3279">Returns a copy of this string converted to uppercase.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper();" />
      <MemberSignature Language="F#" Value="member this.ToUpper : unit -&gt; string" Usage="string.ToUpper " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3280">Retorna uma cópia dessa cadeia de caracteres convertida em maiúsculas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3280">Returns a copy of this string converted to uppercase.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3281">O equivalente, em maiúsculas, da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3281">The uppercase equivalent of the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3282">Esse método usa as regras de maiusculas e minúsculas da cultura atual para converter cada caractere na instância atual em seu equivalente em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3282">This method uses the casing rules of the current culture to convert each character in the current instance to its uppercase equivalent.</span></span> <span data-ttu-id="58835-3283">Se um caractere não tiver um equivalente em letras maiusculas, ele será incluído inalterado na cadeia de caracteres retornada.</span><span class="sxs-lookup"><span data-stu-id="58835-3283">If a character does not have an uppercase equivalent, it is included unchanged in the returned string.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3284">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3284">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3285">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3285">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
 <span data-ttu-id="58835-3286">O <xref:System.String.ToUpper%2A> método geralmente é usado para converter uma cadeia de caracteres em maiusculas, para que ele pode ser usado em uma comparação que diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3286">The <xref:System.String.ToUpper%2A> method is often used to convert a string to uppercase so that it can be used in a case-insensitive comparison.</span></span> <span data-ttu-id="58835-3287">Um método melhor para executar a comparação diferencia maiusculas de minúsculas é chamar um método de comparação de cadeia de caracteres que tem um <xref:System.StringComparison> parâmetro cujo valor é definido como <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> para obter uma comparação sensível à cultura, diferencia maiusculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3287">A better method to perform case-insensitive comparison is to call a string comparison method that has a <xref:System.StringComparison> parameter whose value you set to <xref:System.StringComparison.CurrentCultureIgnoreCase?displayProperty=nameWithType> for a culture-sensitive, case-insensitive comparison.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3288">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3288">Security Considerations</span></span>  
 <span data-ttu-id="58835-3289">A operação de maiusculas e minúsculas que resulta de chamar o <xref:System.String.ToUpper> método considera as convenções de capitalização da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3289">The casing operation that results from calling the <xref:System.String.ToUpper> method takes the casing conventions of the current culture into account.</span></span> <span data-ttu-id="58835-3290">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3290">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="58835-3291">Isso produz o mesmo resultado em cada cultura (ao contrário de <xref:System.String.ToUpper> método) e executa com mais eficiência.</span><span class="sxs-lookup"><span data-stu-id="58835-3291">This produces the same result in every culture (unlike the <xref:System.String.ToUpper> method) and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3292">A exemplo a seguir chama o <xref:System.String.ToUpper%2A> método para converter uma série de cadeias de caracteres de um caractere que contêm cada caractere nos conjuntos de caracteres estendido-A Latim básico, Latim-1 suplementar e latinos.</span><span class="sxs-lookup"><span data-stu-id="58835-3292">The following example calls the <xref:System.String.ToUpper%2A> method to convert a series of one-character strings that contain each character in the Basic Latin, Latin-1 Supplement, and Latin Extended-A character sets.</span></span> <span data-ttu-id="58835-3293">Ele então exibe cada cadeia de caracteres cujo caractere maiusculo é diferente do seu caractere em minúsculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3293">It then displays each string whose uppercase character is different from its lowercase character.</span></span>  
  
 [!code-cpp[System.String.ToUpper#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.ToUpper/cpp/ToUpperEx.cpp#1)]
 [!code-csharp[System.String.ToUpper#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.ToUpper/cs/ToUpperEx.cs#1)]
 [!code-vb[System.String.ToUpper#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.ToUpper/vb/ToUpperEx.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3294">
            <para>Conforme explicado em [práticas recomendadas para usar Strings](~/docs/standard/base-types/best-practices-strings.md), é recomendável que você evite chamar métodos de maiusculas e minúsculas de cadeia de caracteres que substituem valores padrão e chamam os métodos que exigem parâmetros a serem especificado explicitamente. Para converter uma cadeia de caracteres em maiusculas usando as convenções de maiusculas e minúsculas da cultura atual, chame o <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> sobrecarga de método com um valor de <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> para seu <paramref name="culture" /> parâmetro.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3294">
              <para>As explained in [Best Practices for Using Strings](~/docs/standard/base-types/best-practices-strings.md), we recommend that you avoid calling string casing methods that substitute default values and instead call methods that require parameters to be explicitly specified. To convert a string to uppercase by using the casing conventions of the current culture, call the <see cref="M:System.String.ToUpper(System.Globalization.CultureInfo)" /> method overload with a value of <see cref="P:System.Globalization.CultureInfo.CurrentCulture" /> for its <paramref name="culture" /> parameter.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpper">
      <MemberSignature Language="C#" Value="public string ToUpper (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpper(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpper(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpper (culture As CultureInfo) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpper(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="member this.ToUpper : System.Globalization.CultureInfo -&gt; string" Usage="string.ToUpper culture" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture">
          <span data-ttu-id="58835-3295">Um objeto que fornece regras de uso de maiúsculas específicas da cultura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3295">An object that supplies culture-specific casing rules.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3296">Retorna uma cópia desta cadeia de caracteres convertida em maiúsculas, usando as regras de maiúsculas e minúsculas da cultura especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3296">Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3297">O equivalente, em maiúsculas, da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3297">The uppercase equivalent of the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3298">As regras de maiusculas e minúsculas da cultura especificada pelo `culture` parâmetro determinar a maneira como no caso de uma cadeia de caracteres é alterado.</span><span class="sxs-lookup"><span data-stu-id="58835-3298">The casing rules of the culture specified by the `culture` parameter determine the way the case of a string is changed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3299">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3299">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3300">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3300">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3301">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3301">Security Considerations</span></span>  
 <span data-ttu-id="58835-3302">Se você passar o <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> método uma <xref:System.Globalization.CultureInfo> objeto diferente de <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, a operação de maiusculas e minúsculas levará regras específicas de cultura em consideração.</span><span class="sxs-lookup"><span data-stu-id="58835-3302">If you pass the <xref:System.String.ToUpper%28System.Globalization.CultureInfo%29> method a <xref:System.Globalization.CultureInfo> object other than <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>, the casing operation will take culture-specific rules into account.</span></span> <span data-ttu-id="58835-3303">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3303">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="58835-3304">Isso produz o mesmo resultado em cada cultura e executa com mais eficiência.</span><span class="sxs-lookup"><span data-stu-id="58835-3304">This produces the same result in every culture and performs more efficiently.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3305">O exemplo a seguir converte uma cadeia de caracteres minúsculos em duas cadeias de caracteres em maiusculas usando as culturas Inglês-Estados Unidos e Turco-Turquia e, em seguida, compara as cadeias de caracteres em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3305">The following example converts a string of lowercase characters to two strings of uppercase characters using the English-United States and Turkish-Turkey cultures, then compares the uppercase strings.</span></span> <span data-ttu-id="58835-3306">As cadeias de caracteres maiusculos são idênticas, exceto para cada ocorrência do Unicode LATINO LETRA maiuscula I em uma cadeia de caracteres, a outra cadeia de caracteres contém LATINO LETRA maiuscula I com ponto acima.</span><span class="sxs-lookup"><span data-stu-id="58835-3306">The uppercase strings are identical except that for each occurrence of the Unicode LATIN CAPITAL LETTER I in one string, the other string contains LATIN CAPITAL LETTER I WITH DOT ABOVE.</span></span>  
  
 [!code-csharp[string.toupper1#1](~/samples/snippets/csharp/VS_Snippets_CLR/string.toupper1/CS/toupper.cs#1)]
 [!code-vb[string.toupper1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/string.toupper1/VB/toupper.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="58835-3307">
            <paramref name="culture" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3307">
              <paramref name="culture" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.String.ToLower" />
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpperInvariant" />
      </Docs>
    </Member>
    <Member MemberName="ToUpperInvariant">
      <MemberSignature Language="C#" Value="public string ToUpperInvariant ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToUpperInvariant() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.ToUpperInvariant" />
      <MemberSignature Language="VB.NET" Value="Public Function ToUpperInvariant () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToUpperInvariant();" />
      <MemberSignature Language="F#" Value="member this.ToUpperInvariant : unit -&gt; string" Usage="string.ToUpperInvariant " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3308">Retorna uma cópia deste objeto <see cref="T:System.String" /> convertido em maiúsculas usando as regras de maiúsculas e minúsculas da cultura invariável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3308">Returns a copy of this <see cref="T:System.String" /> object converted to uppercase using the casing rules of the invariant culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3309">O equivalente, em maiúsculas, da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3309">The uppercase equivalent of the current string.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3310">A cultura invariável representa uma cultura insensível.</span><span class="sxs-lookup"><span data-stu-id="58835-3310">The invariant culture represents a culture that is culture-insensitive.</span></span> <span data-ttu-id="58835-3311">Ele está associado com o idioma inglês, mas não com um país ou região específica.</span><span class="sxs-lookup"><span data-stu-id="58835-3311">It is associated with the English language but not with a specific country or region.</span></span> <span data-ttu-id="58835-3312">Para obter mais informações, consulte a propriedade <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="58835-3312">For more information, see the <xref:System.Globalization.CultureInfo.InvariantCulture%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="58835-3313">Se seu aplicativo depende do caso de uma cadeia de caracteres que a alteração de uma maneira previsível que não é afetada pela cultura atual, use o <xref:System.String.ToUpperInvariant%2A> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3313">If your application depends on the case of a string changing in a predictable way that is unaffected by the current culture, use the <xref:System.String.ToUpperInvariant%2A> method.</span></span> <span data-ttu-id="58835-3314">O <xref:System.String.ToUpperInvariant%2A> método é equivalente a `ToUpper(CultureInfo.InvariantCulture)`.</span><span class="sxs-lookup"><span data-stu-id="58835-3314">The <xref:System.String.ToUpperInvariant%2A> method is equivalent to `ToUpper(CultureInfo.InvariantCulture)`.</span></span> <span data-ttu-id="58835-3315">O método é recomendado quando uma coleção de cadeias de caracteres deve aparecer em uma ordem previsível em um controle de interface do usuário.</span><span class="sxs-lookup"><span data-stu-id="58835-3315">The method is recommended when a collection of strings must appear in a predictable order in a user interface control.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3316">Este método não altera o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3316">This method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3317">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres na instância atual são convertidos em maiusculas.</span><span class="sxs-lookup"><span data-stu-id="58835-3317">Instead, it returns a new string in which all characters in the current instance are converted to uppercase.</span></span>  
  
## <a name="security-considerations"></a><span data-ttu-id="58835-3318">Considerações sobre segurança</span><span class="sxs-lookup"><span data-stu-id="58835-3318">Security Considerations</span></span>  
 <span data-ttu-id="58835-3319">Se você precisa da versão em maiuscula ou minúscula de um identificador de sistema operacional, como um nome de arquivo, chamado pipe ou chave do registro, use o <xref:System.String.ToLowerInvariant%2A> ou <xref:System.String.ToUpperInvariant%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="58835-3319">If you need the lowercase or uppercase version of an operating system identifier, such as a file name, named pipe, or registry key, use the <xref:System.String.ToLowerInvariant%2A> or <xref:System.String.ToUpperInvariant%2A> methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3320">O exemplo a seguir define uma matriz de cadeia de caracteres que contém uma única palavra em vários idiomas.</span><span class="sxs-lookup"><span data-stu-id="58835-3320">The following example defines a string array that contains a single word in a number of languages.</span></span> <span data-ttu-id="58835-3321">O <xref:System.String.ToUpperInvariant%2A> método é usado para preencher os elementos de uma matriz paralela com a versão sem diferenciação de cada palavra.</span><span class="sxs-lookup"><span data-stu-id="58835-3321">The <xref:System.String.ToUpperInvariant%2A> method is used to populate the elements of a parallel array with the case-insensitive version of each word.</span></span> <span data-ttu-id="58835-3322">O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> método é usado para classificar a matriz diferencia maiusculas de minúsculas, com base na ordem de elementos na matriz de letras maiusculas para garantir que os elementos aparecem na mesma ordem, independentemente do idioma.</span><span class="sxs-lookup"><span data-stu-id="58835-3322">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29?displayProperty=nameWithType> method is used to sort the case-sensitive array based on the order of elements in the uppercase array to ensure that elements appear in the same order regardless of language.</span></span>  
  
 [!code-csharp[System.String.ToUpperInvariant#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.string.toupperinvariant/cs/toupperinvariant.cs#1)]
 [!code-vb[System.String.ToUpperInvariant#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.string.toupperinvariant/vb/toupperinvariant.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.String.ToLowerInvariant" />
        <altmember cref="M:System.String.ToUpper" />
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Trim">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="58835-3323">Retorna uma nova cadeia de caracteres na qual todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificados do objeto <see cref="T:System.String" /> atual são removidas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3323">Returns a new string in which all leading and trailing occurrences of a set of specified characters from the current <see cref="T:System.String" /> object are removed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim();" />
      <MemberSignature Language="F#" Value="member this.Trim : unit -&gt; string" Usage="string.Trim " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="58835-3324">Remove todos os caracteres de espaço em branco à esquerda e à direita do objeto <see cref="T:System.String" /> atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3324">Removes all leading and trailing white-space characters from the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3325">A cadeia de caracteres que permanece depois que todos os caracteres de espaço em branco forem removidos do início e do final da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3325">The string that remains after all white-space characters are removed from the start and end of the current string.</span>
          </span>
          <span data-ttu-id="58835-3326">Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3326">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3327">O <xref:System.String.Trim%2A> método Remove todos os caracteres de espaço em branco à esquerda e à direita da cadeia de caracteres atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3327">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing white-space characters.</span></span> <span data-ttu-id="58835-3328">Cada operação de corte à esquerda e à direita é interrompido quando um caractere de espaço em branco não é encontrado.</span><span class="sxs-lookup"><span data-stu-id="58835-3328">Each leading and trailing trim operation stops when a non-white-space character is encountered.</span></span> <span data-ttu-id="58835-3329">Por exemplo, se a cadeia de caracteres atual é "abc xyz", o <xref:System.String.Trim%2A> método retorna "abc xyz".</span><span class="sxs-lookup"><span data-stu-id="58835-3329">For example, if the current string is "   abc   xyz   ", the <xref:System.String.Trim%2A> method returns "abc   xyz".</span></span> <span data-ttu-id="58835-3330">Para remover os caracteres de espaço em branco entre as palavras em uma cadeia de caracteres, use uma [expressões regulares do .NET Framework](~/docs/standard/base-types/regular-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="58835-3330">To remove white-space characters between words in a string, use a [.NET Framework Regular Expressions](~/docs/standard/base-types/regular-expressions.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3331">Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3331">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3332">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres de espaço em branco à esquerda e à direita encontrados na instância atual são removidos.</span><span class="sxs-lookup"><span data-stu-id="58835-3332">Instead, it returns a new string in which all leading and trailing white space characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="58835-3333">Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de espaço em branco, o método retornará <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-3333">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of white-space characters, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="58835-3334">Os caracteres de espaço em branco são definidos pelo padrão Unicode.</span><span class="sxs-lookup"><span data-stu-id="58835-3334">White-space characters are defined by the Unicode standard.</span></span> <span data-ttu-id="58835-3335">O <xref:System.String.Trim> método remove quaisquer caracteres à esquerda e à direita que produzem um valor de retorno `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="58835-3335">The <xref:System.String.Trim> method removes any leading and trailing characters that produce a return value of `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3336">O exemplo a seguir usa o <xref:System.String.Trim?displayProperty=nameWithType> método para remover qualquer espaço em branco extra de cadeias de caracteres inseridas pelo usuário antes de concatená-las.</span><span class="sxs-lookup"><span data-stu-id="58835-3336">The following example uses the <xref:System.String.Trim?displayProperty=nameWithType> method to remove any extra white space from strings entered by the user before concatenating them.</span></span>  
  
 [!code-cpp[System.String.Trim#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim2.cpp#2)]
 [!code-csharp[System.String.Trim#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim2.cs#2)]
 [!code-vb[System.String.Trim#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3337">
            <para>O [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e mantém uma lista interna de caracteres de espaço em branco que esse método corta a versões anteriores. Começando com o [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> valor de retorno quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)] e versões posteriores não remove. Além disso, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço de sem quebra ESTREITA (U + 202F) e espaço de MATEMÁTICA médio (U + 205F).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3337">
              <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintain an internal list of white-space characters that this method trims. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.Trim : char -&gt; string" Usage="string.Trim trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public string Trim (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string Trim(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.Trim(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ Trim(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.Trim : char[] -&gt; string" Usage="string.Trim trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">
          <span data-ttu-id="58835-3338">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3338">An array of Unicode characters to remove, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3339">Remove todas as ocorrências à esquerda e à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3339">Removes all leading and trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3340">A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início e do final da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3340">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the start and end of the current string.</span>
          </span>
          <span data-ttu-id="58835-3341">Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3341">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span>
          </span>
          <span data-ttu-id="58835-3342">Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3342">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3343">O <xref:System.String.Trim%2A> método Remove da cadeia de caracteres atual, todos os caracteres à esquerda e à direita que estão no `trimChars` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-3343">The <xref:System.String.Trim%2A> method removes from the current string all leading and trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="58835-3344">Cada um à direita e cortar a operação é interrompida quando um caractere que não esteja em `trimChars` for encontrado.</span><span class="sxs-lookup"><span data-stu-id="58835-3344">Each leading and trailing trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="58835-3345">Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.Trim%2A> método retorna "abc456xyz".</span><span class="sxs-lookup"><span data-stu-id="58835-3345">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.Trim%2A> method returns "abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3346">Se o <xref:System.String.Trim%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3346">If the <xref:System.String.Trim%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3347">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os esquerda e à direita `trimChars` encontrados na instância atual de caracteres são removidos.</span><span class="sxs-lookup"><span data-stu-id="58835-3347">Instead, it returns a new string in which all leading and trailing `trimChars` characters found in the current instance are removed.</span></span>  
  
 <span data-ttu-id="58835-3348">Se a cadeia de caracteres atual for igual a <xref:System.String.Empty> ou todos os caracteres na instância atual consistem em caracteres de `trimChars` de matriz, o método retorna <xref:System.String.Empty>.</span><span class="sxs-lookup"><span data-stu-id="58835-3348">If the current string equals <xref:System.String.Empty> or all the characters in the current instance consist of characters in the `trimChars` array, the method returns <xref:System.String.Empty>.</span></span>  
  
 <span data-ttu-id="58835-3349">Se `trimChars` está `null` ou uma matriz vazia, este método remove quaisquer caracteres à esquerda ou direita que resultam no retorno de método `true` quando eles são passados para o <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> método,</span><span class="sxs-lookup"><span data-stu-id="58835-3349">If `trimChars` is `null` or an empty array, this method removes any leading or trailing characters that result in the method returning `true` when they are passed to the <xref:System.Char.IsWhiteSpace%2A?displayProperty=nameWithType> method,</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3350">O exemplo a seguir usa o <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> método para remover espaço, asterisco (\*) e apóstrofo (') caracteres de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3350">The following example uses the <xref:System.String.Trim%28System.Char%5B%5D%29?displayProperty=nameWithType> method to remove space, asterisk (\*), and apostrophe (') characters from a string.</span></span>  
  
 [!code-cpp[System.String.Trim#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.String.Trim/cpp/trim1.cpp#1)]
 [!code-csharp[System.String.Trim#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.Trim/cs/Trim1.cs#1)]
 [!code-vb[System.String.Trim#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.Trim/vb/Trim1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3351">
            <para>O [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], se <paramref name="trimChars" /> está <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> retornar valor quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)] e versões posteriores não remove. Além disso, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço de sem quebra ESTREITA (U + 202F) e espaço de MATEMÁTICA médio (U + 205F).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3351">
              <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd();" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : unit -&gt; string" Usage="string.TrimEnd " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char -&gt; string" Usage="string.TrimEnd trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimEnd">
      <MemberSignature Language="C#" Value="public string TrimEnd (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimEnd(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimEnd(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimEnd (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimEnd(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimEnd : char[] -&gt; string" Usage="string.TrimEnd trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">
          <span data-ttu-id="58835-3352">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3352">An array of Unicode characters to remove, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3353">Remove todas as ocorrências à direita de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3353">Removes all trailing occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3354">A cadeia de caracteres que permanece depois que todas as ocorrências dos caracteres no parâmetro <paramref name="trimChars" /> forem removidas do final da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3354">The string that remains after all occurrences of the characters in the <paramref name="trimChars" /> parameter are removed from the end of the current string.</span>
          </span>
          <span data-ttu-id="58835-3355">Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco Unicode serão removidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3355">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, Unicode white-space characters are removed instead.</span>
          </span>
          <span data-ttu-id="58835-3356">Se não for possível cortar caracteres da instância atual, o método retornará a instância atual inalterada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3356">If no characters can be trimmed from the current instance, the method returns the current instance unchanged.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3357">O <xref:System.String.TrimEnd%2A> método Remove da cadeia de caracteres atual, todos os caracteres à direita que estão no `trimChars` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-3357">The <xref:System.String.TrimEnd%2A> method removes from the current string all trailing characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="58835-3358">A operação de corte é interrompido quando o primeiro caractere que não esteja em `trimChars` é encontrado no final da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3358">The trim operation stops when the first character that is not in `trimChars` is encountered at the end of the string.</span></span> <span data-ttu-id="58835-3359">Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimEnd%2A> método retorna "123abc456xyz".</span><span class="sxs-lookup"><span data-stu-id="58835-3359">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimEnd%2A> method returns "123abc456xyz".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3360">Se o <xref:System.String.TrimEnd%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3360">If the <xref:System.String.TrimEnd%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3361">Em vez disso, ele retorna uma nova cadeia de caracteres na qual caracteres tudo à direita encontrados no `trimChars` são removidos da cadeia de caracteres atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3361">Instead, it returns a new string in which all trailing characters found in `trimChars` are removed from the current string.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3362">O exemplo a seguir demonstra como você pode usar o <xref:System.String.TrimEnd%28System.Char%5B%5D%29> método Cortar espaços em branco ou marcas de pontuação do final de uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="58835-3362">The following example demonstrates how you can use the <xref:System.String.TrimEnd%28System.Char%5B%5D%29> method to trim white space or punctuation marks from the end of a string.</span></span>  
  
 [!code-csharp[System.String.TrimEnd#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimEnd/cs/sample2.cs#2)]
 [!code-vb[System.String.TrimEnd#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimEnd/vb/Sample2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3363">
            <para>O [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], se <paramref name="trimChars" /> está <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> retornar valor quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)] e versões posteriores não remove. Além disso, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço de sem quebra ESTREITA (U + 202F) e espaço de MATEMÁTICA médio (U + 205F).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3363">
              <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimStart(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart();" />
      <MemberSignature Language="F#" Value="member this.TrimStart : unit -&gt; string" Usage="string.TrimStart " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (char trimChar);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char trimChar) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (trimChar As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(char trimChar);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char -&gt; string" Usage="string.TrimStart trimChar" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChar" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="trimChar">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TrimStart">
      <MemberSignature Language="C#" Value="public string TrimStart (params char[] trimChars);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string TrimStart(char[] trimChars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.String.TrimStart(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function TrimStart (ParamArray trimChars As Char()) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ TrimStart(... cli::array &lt;char&gt; ^ trimChars);" />
      <MemberSignature Language="F#" Value="member this.TrimStart : char[] -&gt; string" Usage="string.TrimStart trimChars" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="trimChars" Type="System.Char[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="trimChars">
          <span data-ttu-id="58835-3364">Uma matriz de caracteres Unicode a ser removida, ou <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3364">An array of Unicode characters to remove, or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="58835-3365">Remove todas as ocorrências à esquerda de um conjunto de caracteres especificados em uma matriz do atual objeto <see cref="T:System.String" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3365">Removes all leading occurrences of a set of characters specified in an array from the current <see cref="T:System.String" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="58835-3366">A cadeia de caracteres que permanece depois que todas as ocorrências de caracteres no parâmetro <paramref name="trimChars" /> forem removidas do início da cadeia de caracteres atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3366">The string that remains after all occurrences of characters in the <paramref name="trimChars" /> parameter are removed from the start of the current string.</span>
          </span>
          <span data-ttu-id="58835-3367">Se <paramref name="trimChars" /> for <see langword="null" /> ou uma matriz vazia, os caracteres de espaço em branco serão removidos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3367">If <paramref name="trimChars" /> is <see langword="null" /> or an empty array, white-space characters are removed instead.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="58835-3368">O <xref:System.String.TrimStart%2A> método Remove da cadeia de caracteres atual, todos os caracteres à esquerda que estão no `trimChars` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="58835-3368">The <xref:System.String.TrimStart%2A> method removes from the current string all leading characters that are in the `trimChars` parameter.</span></span> <span data-ttu-id="58835-3369">A operação de corte é interrompido quando um caractere que não esteja em `trimChars` for encontrado.</span><span class="sxs-lookup"><span data-stu-id="58835-3369">The trim operation stops when a character that is not in `trimChars` is encountered.</span></span> <span data-ttu-id="58835-3370">Por exemplo, se a cadeia de caracteres atual é "123abc456xyz789" e `trimChars` contém os dígitos de "1" a "9", o <xref:System.String.TrimStart%2A> método retorna "abc456xyz789".</span><span class="sxs-lookup"><span data-stu-id="58835-3370">For example, if the current string is "123abc456xyz789" and `trimChars` contains the digits from "1" through "9", the <xref:System.String.TrimStart%2A> method returns "abc456xyz789".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="58835-3371">Se o <xref:System.String.TrimStart%2A> método Remove todos os caracteres da instância atual, esse método não modifica o valor da instância atual.</span><span class="sxs-lookup"><span data-stu-id="58835-3371">If the <xref:System.String.TrimStart%2A> method removes any characters from the current instance, this method does not modify the value of the current instance.</span></span> <span data-ttu-id="58835-3372">Em vez disso, ele retorna uma nova cadeia de caracteres na qual todos os caracteres de espaço em branco à esquerda encontrados na instância atual são removidos.</span><span class="sxs-lookup"><span data-stu-id="58835-3372">Instead, it returns a new string in which all leading white space characters found in the current instance are removed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="58835-3373">O exemplo a seguir usa o <xref:System.String.TrimStart%2A> método Cortar espaços em branco e caracteres de comentário das linhas de código-fonte.</span><span class="sxs-lookup"><span data-stu-id="58835-3373">The following example uses the <xref:System.String.TrimStart%2A> method to trim white space and comment characters from lines of source code.</span></span> <span data-ttu-id="58835-3374">O `StripComments` método encapsula uma chamada para <xref:System.String.TrimStart%2A> e passa uma matriz de caracteres que contém um espaço e o caractere de comentário, que é um apóstrofo (') no Visual Basic e uma barra (/) em c#.</span><span class="sxs-lookup"><span data-stu-id="58835-3374">The `StripComments` method wraps a call to <xref:System.String.TrimStart%2A> and passes it a character array that contains a space and the comment character, which is an apostrophe ( ' ) in Visual Basic and a slash ( / ) in C#.</span></span> <span data-ttu-id="58835-3375">O <xref:System.String.TrimStart%2A> método também é chamado para remover o espaço em branco ao avaliar se uma cadeia de caracteres é um comentário.</span><span class="sxs-lookup"><span data-stu-id="58835-3375">The <xref:System.String.TrimStart%2A> method is also called to remove leading white space when evaluating whether a string is a comment.</span></span>  
  
 [!code-csharp[System.String.TrimStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#1)]
 [!code-vb[System.String.TrimStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#1)]  
  
 <span data-ttu-id="58835-3376">O exemplo a seguir mostra uma chamada para o método `StripComments`.</span><span class="sxs-lookup"><span data-stu-id="58835-3376">The following example then illustrates a call to the `StripComments` method.</span></span>  
  
 [!code-csharp[System.String.TrimStart#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.String.TrimStart/cs/sample.cs#2)]
 [!code-vb[System.String.TrimStart#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.String.TrimStart/vb/sample.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <span data-ttu-id="58835-3377">
            <para>O [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores mantém uma lista interna de caracteres de espaço em branco que esse método corta se <paramref name="trimChars" /> é <see langword="null" /> ou uma matriz vazia. Começando com o [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)], se <paramref name="trimChars" /> está <see langword="null" /> ou uma matriz vazia, o método Remove todos os caracteres de espaço em branco Unicode (isto é, os caracteres que produzem um <see langword="true" /> retornar valor quando eles são passados para o <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> método). Por causa dessa alteração, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores remove dois caracteres, o espaço de largura ZERO (U + 200B) e espaço sem quebra de largura ZERO (U + FEFF), que o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v40_short](~/Includes/NET-v40-Short-MD.MD)] e versões posteriores não remove. Além disso, o <see cref="M:System.String.Trim" /> método no [! INCLUDE[net_v35SP1_short](~/Includes/NET-v35sp1-Short-MD.MD)] e versões anteriores não apare três caracteres de espaço em branco Unicode: SEPARADOR de VOGAL MONGOL (U + 180E), espaço de sem quebra ESTREITA (U + 202F) e espaço de MATEMÁTICA médio (U + 205F).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="58835-3377">
              <para>The [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions maintains an internal list of white-space characters that this method trims if <paramref name="trimChars" /> is <see langword="null" /> or an empty array. Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], if <paramref name="trimChars" /> is <see langword="null" /> or an empty array, the method trims all Unicode white-space characters (that is, characters that produce a <see langword="true" /> return value when they are passed to the <see cref="M:System.Char.IsWhiteSpace(System.Char)" /> method). Because of this change, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions removes two characters, ZERO WIDTH SPACE (U+200B) and ZERO WIDTH NO-BREAK SPACE (U+FEFF), that the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] and later versions does not remove. In addition, the <see cref="M:System.String.Trim" /> method in the [!INCLUDE[net_v35SP1_short](~/includes/net-v35sp1-short-md.md)] and earlier versions does not trim three Unicode white-space characters: MONGOLIAN VOWEL SEPARATOR (U+180E), NARROW NO-BREAK SPACE (U+202F), and MEDIUM MATHEMATICAL SPACE (U+205F).</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Char" />
        <altmember cref="M:System.String.Trim(System.Char[])" />
        <altmember cref="M:System.String.TrimEnd(System.Char[])" />
        <altmember cref="M:System.Char.IsWhiteSpace(System.Char)" />
      </Docs>
    </Member>
  </Members>
</Type>