<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11996d97bef6121bce982a8368bef5e8197c8a44" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31469393" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="d39f6-101">Controla o coletor de lixo do sistema, um serviço que recupera automaticamente a memória não utilizada.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d39f6-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-102">O coletor de lixo é um componente de tempo de execução de linguagem comum que controla a alocação e a liberação de memória gerenciada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="d39f6-103">Os métodos dessa classe influenciam quando a coleta de lixo é executada em um objeto e os recursos alocados por um objeto são liberados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="d39f6-104">Propriedades dessa classe fornecem informações sobre a quantidade total de memória disponível no sistema e a categoria de idade ou a geração de memória alocada para um objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="d39f6-105">O coletor de lixo rastreia e recupera objetos alocados na memória gerenciada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="d39f6-106">O coletor de lixo executa periodicamente, coleta de lixo para recuperar a memória alocada a objetos para os quais não há nenhuma referência válida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="d39f6-107">Coleta de lixo ocorre automaticamente quando uma solicitação de memória não pode ser atendida usando a memória livre disponível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="d39f6-108">Como alternativa, um aplicativo pode forçar o uso de coleta de lixo de <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="d39f6-109">Coleta de lixo consiste das seguintes etapas:</span><span class="sxs-lookup"><span data-stu-id="d39f6-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="d39f6-110">O coletor de lixo pesquisa de objetos gerenciados que são referenciados em código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="d39f6-111">O coletor de lixo tentar finalizar a objetos que não são referenciados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="d39f6-112">O coletor de lixo libera os objetos que não são referenciados e recupera a memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="d39f6-113">Este tópico inclui as seções a seguir:</span><span class="sxs-lookup"><span data-stu-id="d39f6-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="d39f6-114">[O coletor de lixo e recursos não gerenciados](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="d39f6-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="d39f6-115">[As gerações e vencimento do objeto](#generations) </span><span class="sxs-lookup"><span data-stu-id="d39f6-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="d39f6-116">A desabilitação de coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="d39f6-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="d39f6-117">O coletor de lixo e recursos não gerenciados</span><span class="sxs-lookup"><span data-stu-id="d39f6-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="d39f6-118">Durante uma coleta, o coletor de lixo não irá liberar um objeto se ele encontrar uma ou mais referências ao objeto no código gerenciado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="d39f6-119">No entanto, o coletor de lixo não reconhece as referências a um objeto de código não gerenciado e pode liberar objetos que estão sendo usados exclusivamente no código não gerenciado, a menos que explicitamente impedidos de fazer isso.</span><span class="sxs-lookup"><span data-stu-id="d39f6-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="d39f6-120">O <xref:System.GC.KeepAlive%2A> método fornece um mecanismo que impede que o coletor de lixo coletar objetos que ainda estão em uso em código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="d39f6-121">Além de alocações de memória gerenciada, implementações do coletor de lixo não precisam manter informações sobre os recursos mantidos por um objeto, como identificadores de arquivos ou conexões de banco de dados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="d39f6-122">Quando um tipo usa recursos não gerenciados que devem ser liberados antes de instâncias do tipo são recuperadas, o tipo pode implementar um finalizador.</span><span class="sxs-lookup"><span data-stu-id="d39f6-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="d39f6-123">Na maioria dos casos, os finalizadores são implementados por meio da substituição de <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método; no entanto, os tipos escritos em c# ou C++ implementam destruidores, os compiladores transformam em uma substituição de <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d39f6-124">Na maioria dos casos, se um objeto tiver um finalizador, o coletor de lixo chama antes de liberar o objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="d39f6-125">No entanto, o coletor de lixo não é necessário chamar finalizadores todas as situações. Por exemplo, o <xref:System.GC.SuppressFinalize%2A> método explicitamente impede finalizador de um objeto que está sendo chamado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="d39f6-126">Além disso, o coletor de lixo não é necessário usar um segmento específico para finalizar a objetos ou garante a ordem na qual os finalizadores são chamados de objetos que referenciam uns aos outros, mas caso contrário, estão disponíveis para coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="d39f6-127">Em cenários onde os recursos devem ser liberados em um momento específico, classes podem implementar o <xref:System.IDisposable> interface, que contém o <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método que executa tarefas de gerenciamento e a limpeza de recursos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="d39f6-128">As classes que implementam <xref:System.IDisposable.Dispose%2A> deve especificar, como parte de seu contrato de classe, se e quando os consumidores de classe chamam o método para limpar o objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="d39f6-129">O coletor de lixo não, por padrão, chame o <xref:System.IDisposable.Dispose%2A> método; no entanto, implementações do <xref:System.IDisposable.Dispose%2A> método pode chamar métodos <xref:System.GC> classe para personalizar o comportamento de finalização do coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="d39f6-130">Para obter mais informações sobre o padrão dispose e finalização de objeto, consulte [limpeza de recursos não gerenciados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="d39f6-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="d39f6-131">As gerações e vencimento do objeto</span><span class="sxs-lookup"><span data-stu-id="d39f6-131">Object aging and generations</span></span>  
 <span data-ttu-id="d39f6-132">O coletor de lixo no common language runtime oferece suporte a classificação por vencimento de objeto usando gerações.</span><span class="sxs-lookup"><span data-stu-id="d39f6-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="d39f6-133">Uma geração é uma unidade de medida da idade relativa dos objetos na memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="d39f6-134">O número de geração ou idade, de um objeto indica que a geração para o qual um objeto pertence.</span><span class="sxs-lookup"><span data-stu-id="d39f6-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="d39f6-135">Objetos criados mais recentemente fazem parte de gerações mais recentes e tem números menores de geração de ciclo de objetos criados anteriormente a vida do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="d39f6-136">Objetos de geração mais recente estão em geração 0.</span><span class="sxs-lookup"><span data-stu-id="d39f6-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="d39f6-137">Essa implementação do coletor de lixo oferece suporte a três gerações de objetos, gerações 0, 1 e 2.</span><span class="sxs-lookup"><span data-stu-id="d39f6-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="d39f6-138">Você pode recuperar o valor de <xref:System.GC.MaxGeneration%2A> propriedade para determinar o número de geração máximo suportado pelo sistema.</span><span class="sxs-lookup"><span data-stu-id="d39f6-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="d39f6-139">Duração de objeto permite que os aplicativos para coleta de lixo de destino em um conjunto específico de gerações em vez de exigir o coletor de lixo avaliar todas as gerações.</span><span class="sxs-lookup"><span data-stu-id="d39f6-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="d39f6-140">Sobrecargas do <xref:System.GC.Collect%2A> método que incluem um `generation` parâmetro permitem que você especifique a geração mais antiga para ser coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="d39f6-141">A desabilitação de coleta de lixo</span><span class="sxs-lookup"><span data-stu-id="d39f6-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="d39f6-142">Começando com o [!INCLUDE[net_v46](~/includes/net-v46-md.md)], o coletor de lixo não suporta um nenhum GC região latência modo que pode ser usado durante a execução de caminhos críticos no lixo coleção pode afetar adversamente o desempenho de um aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="d39f6-143">O modo sem-GC região latência requer que você especifique uma quantidade de memória que pode ser alocada sem interferência de coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="d39f6-144">Se o tempo de execução pode alocar memória, o tempo de execução não executará uma coleta de lixo durante a execução de código no caminho crítico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="d39f6-145">Definir o início do caminho crítico de nenhuma região de GC chamando uma das sobrecargas do <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="d39f6-146">Especificar o final de seu caminho crítico chamando o <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="d39f6-147">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-148">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-149">O exemplo a seguir usa vários métodos de GC para obter informações de memória sobre um bloco de objetos não utilizados e geração e imprimi-lo no console.</span><span class="sxs-lookup"><span data-stu-id="d39f6-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="d39f6-150">Os objetos não utilizados, em seguida, são coletados e os totais de memória resultantes são exibidos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="d39f6-151">O valor incremental de memória não gerenciada alocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-151">The incremental amount of unmanaged memory that has been allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-152">Informa o tempo de execução de uma alocação grande de memória não gerenciada que deve ser levada em conta durante o agendamento da coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-152">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-153">Para determinar quando Agendar coleta de lixo, o tempo de execução leva em consideração a quantidade de memória gerenciado é alocada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-153">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="d39f6-154">Se um objeto gerenciado pequeno aloca uma grande quantidade de memória não gerenciada, o tempo de execução leva em conta somente a memória gerenciada e, portanto, subestimar a urgência de agendamento de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-154">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="d39f6-155">O <xref:System.GC.AddMemoryPressure%2A> método informa o tempo de execução desse mais pressão na memória do sistema.</span><span class="sxs-lookup"><span data-stu-id="d39f6-155">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="d39f6-156">No padrão de uso mais simples, um objeto gerenciado aloca memória não gerenciada no construtor e o solta no `Dispose` ou `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-156">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="d39f6-157">Chamar o <xref:System.GC.AddMemoryPressure%2A> método depois de alocar a memória não gerenciada e chamar o <xref:System.GC.RemoveMemoryPressure%2A> método depois de liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-157">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="d39f6-158">Em cenários mais complexos, onde a alocação de memória não gerenciada altera significativamente durante o tempo de vida do objeto gerenciado, você pode chamar o <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> métodos para se comunicar essas alterações incrementais no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="d39f6-158">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="d39f6-159">Certifique-se de que você remova exatamente a quantidade de pressão de que você adicionar.</span><span class="sxs-lookup"><span data-stu-id="d39f6-159">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="d39f6-160">Falha ao fazer isso pode afetar adversamente o desempenho do sistema em aplicativos que são executados por longos períodos de tempo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-160">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-161">
            <paramref name="bytesAllocated" /> é menor ou igual a 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-161">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="d39f6-162">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-162">-or-</span>
          </span>
          <span data-ttu-id="d39f6-163">Em um computador de 32 bits, <paramref name="bytesAllocated" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-163">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="d39f6-164">a capacidade de chamar código não gerenciado ao manipular a prioridade de coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-164">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="d39f6-165">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-165">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-166">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-166">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-167">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-167">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-168">Cancela o registro de uma notificação de coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-168">Cancels the registration of a garbage collection notification.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-169">Esse método cancela uma notificação de coleta de lixo que foi registrada usando o <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-169">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="d39f6-170">Você não precisa chamar esse método antes de ajustar os valores de parâmetro de limite nas chamadas subsequentes para o <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-170">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-171">O exemplo a seguir cancela um registro de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-171">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="d39f6-172">Este exemplo é parte de um exemplo maior fornecido para o [notificações de coleta de lixo](~/docs/standard/garbage-collection/notifications.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-172">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-173">Este membro não está disponível quando a coleta de lixo simultânea está habilitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-173">This member is not available when concurrent garbage collection is enabled.</span>
          </span>
          <span data-ttu-id="d39f6-174">Consulte a configuração de tempo de execução [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) para obter informações sobre como desabilitar a coleta de lixo simultânea.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-174">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-175">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-175">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-176">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-176">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-177">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-177">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-178">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-178">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-179">Força a coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-179">Forces garbage collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-180">Força uma coleta de lixo imediata de todas as gerações.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-180">Forces an immediate garbage collection of all generations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-181">Use esse método para tentar recuperar toda a memória que está inacessível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-181">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="d39f6-182">Ele executa uma coleta de lixo de bloqueio de todas as gerações.</span><span class="sxs-lookup"><span data-stu-id="d39f6-182">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="d39f6-183">Todos os objetos, independentemente de quanto tempo estão na memória, são considerados para uma coleção. No entanto, os objetos que são referenciados em código gerenciado não são coletados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-183">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="d39f6-184">Use esse método para forçar o sistema para tentar recuperar a quantidade máxima de memória disponível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-184">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="d39f6-185">Começando com o [!INCLUDE[net_v451](~/includes/net-v451-md.md)], você pode compactar o heap de objeto grande (LOH) definindo o <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriedade <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de chamar o <xref:System.GC.Collect%2A> método, como o exemplo a seguir ilustra.</span><span class="sxs-lookup"><span data-stu-id="d39f6-185">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-186">O exemplo a seguir demonstra como usar o <xref:System.GC.Collect%2A> método para executar uma coleção em todas as gerações de memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-186">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="d39f6-187">O código gera um número de objetos não utilizados e, em seguida, chama o <xref:System.GC.Collect%2A> método de limpeza de memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-187">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="d39f6-188">O número da geração mais antiga a ser coletada como lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-188">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-189">Força uma coleta de lixo imediata da geração 0 por meio de uma geração especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-189">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-190">Use esse método para tentar recuperar a memória que está inacessível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-190">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="d39f6-191">No entanto, usando esse método não garante que toda a memória inacessível na geração especificada é recuperada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-191">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="d39f6-192">Se o vencimento do objeto é implementado, o coletor de lixo não coleta objetos com um número de geração que é maior do que a geração especificada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-192">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="d39f6-193">Se o vencimento do objeto não está implementado, o coletor de lixo considera todos os objetos durante a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-193">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="d39f6-194">Use o <xref:System.GC.MaxGeneration%2A> propriedade para determinar o valor válido máximo a `generation` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="d39f6-194">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="d39f6-195">Para que o coletor de lixo considerar todos os objetos, independentemente de sua geração, use a versão desse método que não usa nenhum parâmetro.</span><span class="sxs-lookup"><span data-stu-id="d39f6-195">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="d39f6-196">Para que o coletor de lixo recuperar os objetos com base em um <xref:System.GCCollectionMode> configuração, use o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-196">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-197">O exemplo a seguir demonstra como usar o <xref:System.GC.Collect%2A> método para executar uma coleção em camadas individuais de memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-197">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="d39f6-198">O código gera um número de objetos não utilizados e, em seguida, chama o <xref:System.GC.Collect%2A> método de limpeza de memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-198">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-199">
            <paramref name="generation" /> não é válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-199">
              <paramref name="generation" /> is not valid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="d39f6-200">O número da geração mais antiga a ser coletada como lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-200">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="d39f6-201">Um valor de enumeração que especifica se a coleta de lixo é forçada (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou otimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-201">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-202">Força uma coleta de lixo imediata da geração 0 por meio de uma geração especificada, em uma hora especificada por um valor <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-202">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-203">Use o `mode` para especificar se a coleta de lixo deve ocorrer imediatamente ou somente se o tempo é ideal para recuperar os objetos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-203">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="d39f6-204">Usando esse método não garante que toda a memória inacessível na geração especificada é recuperada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-204">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="d39f6-205">Para ajustar o risco de invasão da coleta de lixo durante períodos críticos em seu aplicativo, defina o <xref:System.Runtime.GCSettings.LatencyMode%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d39f6-205">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="d39f6-206">O coletor de lixo não coletar os objetos com um número de geração mais alto do que o especificado pelo `generation` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="d39f6-206">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="d39f6-207">Use o <xref:System.GC.MaxGeneration%2A> propriedade para determinar o valor válido máximo `generation`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-207">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="d39f6-208">Para que o coletor de lixo considerar todos os objetos, independentemente de sua geração, use a versão desse método que não usa nenhum parâmetro.</span><span class="sxs-lookup"><span data-stu-id="d39f6-208">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="d39f6-209">Para que o coletor de lixo recuperar objetos até uma geração especificada de objetos, use o <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-209">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="d39f6-210">Quando você especificar a geração máxima, todos os objetos são coletados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-210">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-211">O exemplo a seguir força uma coleta de lixo para objetos de geração 2 com o <xref:System.GCCollectionMode.Optimized> configuração.</span><span class="sxs-lookup"><span data-stu-id="d39f6-211">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-212">
            <paramref name="generation" /> não é válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-212">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="d39f6-213">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-213">-or-</span>
          </span>
          <span data-ttu-id="d39f6-214">
            <paramref name="mode" /> não é um dos valores <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-214">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="d39f6-215">O número da geração mais antiga a ser coletada como lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-215">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="d39f6-216">Um valor de enumeração que especifica se a coleta de lixo é forçada (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou otimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-216">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="d39f6-217">
            <see langword="true" /> para executar uma coleta de lixo de bloqueio; <see langword="false" /> para executar uma coleta de lixo em segundo plano sempre que possível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-217">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-218">Força uma coleta de lixo da geração 0 até uma geração especificada, em um momento especificado por um valor de <see cref="T:System.GCCollectionMode" />, com um valor que especifica se a coleção deve ser de bloqueio.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-218">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-219">A tabela a seguir resume a interação entre o `mode` e `blocking` parâmetros:</span><span class="sxs-lookup"><span data-stu-id="d39f6-219">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="d39f6-220">`blocking` é `true`</span><span class="sxs-lookup"><span data-stu-id="d39f6-220">`blocking` is `true`</span></span>|<span data-ttu-id="d39f6-221">`blocking` é `false`</span><span class="sxs-lookup"><span data-stu-id="d39f6-221">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="d39f6-222"><xref:System.GCCollectionMode.Forced> ou <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="d39f6-222"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="d39f6-223">Uma coleção de bloqueio é executada assim que possível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-223">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="d39f6-224">Se uma coleção de plano de fundo está em andamento e `generation` é 0 ou 1, o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método imediatamente dispara uma coleção de bloqueio e retorna quando a coleção é concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-224">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="d39f6-225">Se uma coleção de plano de fundo está em andamento e `generation` é 2, o método de espera até que a coleção de plano de fundo é concluída, aciona uma coleção de geração 2 bloqueio e, em seguida, retorna.</span><span class="sxs-lookup"><span data-stu-id="d39f6-225">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="d39f6-226">Uma coleta é executada assim que possível.</span><span class="sxs-lookup"><span data-stu-id="d39f6-226">A collection is performed as soon as possible.</span></span> <span data-ttu-id="d39f6-227">O método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita uma coleta em segundo plano, mas isso não é garantido; dependendo das circunstâncias, uma coleta de bloqueio ainda pode ser executada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-227">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="d39f6-228">Se uma coleta em segundo plano já estiver em andamento, o método retornará imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-228">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="d39f6-229">Uma coleta de bloqueio pode ser executada, dependendo do estado do coletor de lixo e do parâmetro `generation`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-229">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="d39f6-230">O coletor de lixo tenta fornecer um desempenho ideal.</span><span class="sxs-lookup"><span data-stu-id="d39f6-230">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="d39f6-231">Uma coleta pode ser executada, dependendo do estado do coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-231">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="d39f6-232">O método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita uma coleta em segundo plano, mas isso não é garantido; dependendo das circunstâncias, uma coleta de bloqueio ainda pode ser executada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-232">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="d39f6-233">O coletor de lixo tenta fornecer um desempenho ideal.</span><span class="sxs-lookup"><span data-stu-id="d39f6-233">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="d39f6-234">Se uma coleta em segundo plano já estiver em andamento, o método retornará imediatamente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="d39f6-235">Se uma chamada para o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método executa uma coleta de lixo de bloqueio completo, você também pode compactar o heap de objeto grande, definindo o <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriedade <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de chamar o <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-235">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-236">
            <paramref name="generation" /> não é válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-236">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="d39f6-237">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-237">-or-</span>
          </span>
          <span data-ttu-id="d39f6-238">
            <paramref name="mode" /> não é um dos valores <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-238">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="d39f6-239">O número da geração mais antiga a ser coletada como lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-239">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="d39f6-240">Um valor de enumeração que especifica se a coleta de lixo é forçada (<see cref="F:System.GCCollectionMode.Default" /> ou <see cref="F:System.GCCollectionMode.Forced" />) ou otimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-240">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="d39f6-241">
            <see langword="true" /> para executar uma coleta de lixo de bloqueio; <see langword="false" /> para executar uma coleta de lixo em segundo plano sempre que possível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-241">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <param name="compacting">
          <span data-ttu-id="d39f6-242">
            <see langword="true" /> para compactar o heap de objetos pequenos; <see langword="false" /> para somente limpar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-242">
              <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-243">Força uma coleta de lixo da geração 0 até uma geração especificada, em um momento especificado por um valor de <see cref="T:System.GCCollectionMode" />, com valores que especificam se a coleta deve ser de bloqueio e compactação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-243">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-244">Se `blocking` é `false`, o GC decide se executar um plano de fundo ou uma bloqueio coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-244">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="d39f6-245">Se `compacting` é `true`, ele executa uma coleta de lixo de bloqueio.</span><span class="sxs-lookup"><span data-stu-id="d39f6-245">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="d39f6-246">Se `compacting` é `true`, o tempo de execução compacta o heap de objeto pequeno (SOH).</span><span class="sxs-lookup"><span data-stu-id="d39f6-246">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="d39f6-247">Heap de objeto grande (LOH) não é compactado, a menos que o <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> está definida como <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-247">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d39f6-248">Observe que isso inclui todas as coleções lixo bloqueio, não apenas completos bloqueando coletas de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-248">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="d39f6-249">Você pode chamar o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método para reduzir o heap gerenciado para o menor valor possível de tamanho, como mostra o fragmento de código a seguir.</span><span class="sxs-lookup"><span data-stu-id="d39f6-249">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="d39f6-250">Especificando `true` para o `compacting` argumento garante uma coleta de lixo bloqueio completo, compactação.</span><span class="sxs-lookup"><span data-stu-id="d39f6-250">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="d39f6-251">Definindo o <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propriedade <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garante que o LOH e SOH são compactadas.</span><span class="sxs-lookup"><span data-stu-id="d39f6-251">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="d39f6-252">A geração de objetos para a qual a contagem de coletas de lixo deve ser determinada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-252">The generation of objects for which the garbage collection count is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-253">Retorna o número de vezes em que ocorreu a coleta de lixo para a geração de objetos especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-253">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-254">O número de vezes que a coleta de lixo ocorreu para a geração especificada desde que o processo foi iniciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-254">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-255">Se você implementar seu próprio gerenciamento de recursos, talvez seja necessário forçar a coleta de lixo periodicamente ao chamar o <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-255">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="d39f6-256">Como esta é uma operação dispendiosa, você pode melhorar o desempenho, ignorando a chamada quando uma coleta de lixo ocorreu recentemente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-256">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="d39f6-257">Salve o valor retornado por <xref:System.GC.CollectionCount%2A> imediatamente depois de chamar <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-257">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="d39f6-258">Na próxima vez que você precisa chamar <xref:System.GC.Collect%2A>, comparar o valor retornado por <xref:System.GC.CollectionCount%2A> para o valor salvo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-258">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="d39f6-259">Se os dois valores forem iguais, nenhuma coleção ocorreu nesse ínterim, e é razoável chamar <xref:System.GC.Collect%2A> novamente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-259">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-260">
            <paramref name="generation" /> é menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-260">
              <paramref name="generation" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-261">Encerra o modo de latência de região sem GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-261">Ends the no GC region latency mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-262">O <xref:System.GC.EndNoGCRegion%2A> método lança um <xref:System.InvalidOperationException> se o coletor de lixo não está em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-262">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-263">Isso ocorre em qualquer uma das seguintes condições:</span><span class="sxs-lookup"><span data-stu-id="d39f6-263">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="d39f6-264">O <xref:System.GC.TryStartNoGCRegion%2A> método não foi chamado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-264">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="d39f6-265">A chamada para o <xref:System.GC.TryStartNoGCRegion%2A> retornados pelo método `false`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-265">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="d39f6-266">A chamada para o <xref:System.GC.TryStartNoGCRegion%2A> método gerou uma exceção.</span><span class="sxs-lookup"><span data-stu-id="d39f6-266">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="d39f6-267">Você pode impedir que uma exceção para qualquer um dos seguintes motivos usando código como o seguinte:</span><span class="sxs-lookup"><span data-stu-id="d39f6-267">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-268">O coletor de lixo não está no modo de latência de região sem GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-268">The garbage collector is not in no GC region latency mode.</span>
          </span>
          <span data-ttu-id="d39f6-269">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-269">-or-</span>
          </span>
          <span data-ttu-id="d39f6-270">O modo de latência de região sem GC foi encerrado anteriormente porque uma coleta de lixo foi induzida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-270">The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          </span>
          <span data-ttu-id="d39f6-271">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-271">-or-</span>
          </span>
          <span data-ttu-id="d39f6-272">Uma alocação de memória excedeu o valor especificado na chamada para o método <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-272">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-273">Retorna o número de geração atual de um objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-273">Returns the current generation number of an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d39f6-274">O objeto cujas informações de geração são recuperadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-274">The object that generation information is retrieved for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-275">Retorna o número de geração atual do objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-275">Returns the current generation number of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-276">O número atual de geração de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-276">The current generation number of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-277">Use esse método para determinar a idade de um objeto e, em seguida, usar essas informações com o <xref:System.GC.Collect%2A> método para forçar o coletor de lixo para coletar objetos na mesma geração.</span><span class="sxs-lookup"><span data-stu-id="d39f6-277">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="d39f6-278">Por exemplo, use esse método quando você tem um conjunto de objetos que são criados como um grupo e que se torne inacessível ao mesmo tempo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-278">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-279">O exemplo a seguir demonstra como usar o <xref:System.GC.GetGeneration%2A> método para determinar a idade de um objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-279">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="d39f6-280">O exemplo, em seguida, executa as coletas de lixo para limpar a memória e comparar o pré e lançar totais de memória de coleção no console do.</span><span class="sxs-lookup"><span data-stu-id="d39f6-280">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <span data-ttu-id="d39f6-281">Uma <see cref="T:System.WeakReference" /> que se refere ao objeto de destino cujo número de geração deve ser determinado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-281">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-282">Retorna o número de geração atual do destino de uma referência fraca especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-282">Returns the current generation number of the target of a specified weak reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-283">O número de geração atual do destino de <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-283">The current generation number of the target of <paramref name="wo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="d39f6-284">O exemplo a seguir demonstra o uso do <xref:System.GC.GetGeneration%2A> método para determinar a idade de um objeto de referência fraca.</span><span class="sxs-lookup"><span data-stu-id="d39f6-284">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d39f6-285">A coleta de lixo já foi executada no <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-285">Garbage collection has already been performed on <paramref name="wo" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <span data-ttu-id="d39f6-286">
            <see langword="true" /> para indicar que esse método pode aguardar a coleta de lixo ocorrer antes de retornar; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-286">
              <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-287">Recupera o número de bytes atualmente considerados alocados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-287">Retrieves the number of bytes currently thought to be allocated.</span>
          </span>
          <span data-ttu-id="d39f6-288">Um parâmetro indica se esse método pode esperar um breve intervalo antes de retornar, para permitir que o sistema colete o lixo e finalize os objetos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-288">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-289">Um número que é a melhor aproximação disponível do número de bytes atualmente alocados na memória gerenciada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-289">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-290">Se o `forceFullCollection` parâmetro é `true`, este método espera um pequeno intervalo antes de voltar enquanto o sistema de coleta de lixo e finaliza a objetos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-290">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="d39f6-291">A duração do intervalo é um limite especificado internamente determinado pelo número de ciclos de coleta de lixo concluída e a alteração na quantidade de memória recuperada entre os ciclos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-291">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="d39f6-292">O coletor de lixo não garante que toda a memória acessível é coletada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-292">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-293">O exemplo a seguir demonstra como usar o <xref:System.GC.GetTotalMemory%2A> método para obter e exibir o número de bytes alocados atualmente na memória gerenciada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-293">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d39f6-294">O objeto a ser referenciado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-294">The object to reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-295">Referencia o objeto especificado, o que o torna não qualificado para a coleta de lixo, do início da rotina atual ao ponto em que esse método é chamado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-295">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-296">A finalidade de <xref:System.GC.KeepAlive%2A> método é para garantir a existência de uma referência a um objeto que está em risco de prematuramente sendo recuperado pelo coletor de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-296">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="d39f6-297">Um cenário comum em que isso pode ocorrer é quando existem referências ao objeto no código gerenciado ou de dados, mas o objeto ainda está em uso em código não gerenciado, como as APIs do Win32, DLLs não gerenciadas, nem os métodos usando COM.</span><span class="sxs-lookup"><span data-stu-id="d39f6-297">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="d39f6-298">Este método faz referência a `obj` parâmetro, tornando esse objeto não qualificados para coleta de lixo desde o início da rotina para o ponto, em ordem de execução, onde esse método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-298">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="d39f6-299">Esse método no final, não o início do intervalo de instruções de código onde `obj` devem estar disponíveis.</span><span class="sxs-lookup"><span data-stu-id="d39f6-299">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="d39f6-300">O <xref:System.GC.KeepAlive%2A> método não executa nenhuma operação e não produz nenhum efeito colateral diferente de estender o tempo de vida do objeto passado como um parâmetro.</span><span class="sxs-lookup"><span data-stu-id="d39f6-300">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-301">O exemplo de código a seguir cria um objeto no início do seu `Main` método e não se refere ao objeto novamente até o final, quando o <xref:System.GC.KeepAlive%2A> método é chamado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-301">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="d39f6-302">O objeto persiste durante 30 segundos a `Main` método, apesar de chamadas para o <xref:System.GC.Collect%2A> e <xref:System.GC.WaitForPendingFinalizers%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d39f6-302">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-303">Obtém o número máximo de gerações que o sistema dá suporte atualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-303">Gets the maximum number of generations that the system currently supports.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="d39f6-304">Um valor que varia de zero ao número máximo de gerações com suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-304">A value that ranges from zero to the maximum number of supported generations.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-305">O número de geração ou idade, de um objeto é uma medida relativa definido pela implementação de tempo de vida de um objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-305">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="d39f6-306">Os objetos criados mais recentemente são na geração 0 e os objetos mais antigos de uma geração menor ou igual à geração retornado pelo <xref:System.GC.MaxGeneration%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d39f6-306">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="d39f6-307">O coletor de lixo pressupõe que a memória mais recente é mais provável de ser qualificada para a coleta de lixo que a memória mais antiga.</span><span class="sxs-lookup"><span data-stu-id="d39f6-307">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="d39f6-308">Portanto, o coletor de lixo melhora o desempenho ajustando os números de geração cada vez que ele recupera a memória, e o <xref:System.GC.MaxGeneration%2A> pode aumentar o valor da propriedade ao longo do tempo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-308">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="d39f6-309">Se o vencimento do objeto é implementado, a <xref:System.GC.MaxGeneration%2A> propriedade retorna o número máximo de geração usado pelo sistema; caso contrário, essa propriedade retornará zero.</span><span class="sxs-lookup"><span data-stu-id="d39f6-309">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-310">O exemplo a seguir demonstra como usar a propriedade Collect ou para exibir o maior número de geração atualmente em uso.</span><span class="sxs-lookup"><span data-stu-id="d39f6-310">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="d39f6-311">Para esta implementação, o valor retornado pelo <see cref="P:System.GC.MaxGeneration" /> tem garantia de propriedade permanecem constantes durante o tempo de vida de um aplicativo em execução.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d39f6-311">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span>
            </span>
            <span data-ttu-id="d39f6-312">Use o <see cref="P:System.GC.MaxGeneration" /> propriedade para determinar o valor máximo que você pode especificar ao chamar o <see cref="M:System.GC.Collect(System.Int32)" /> método que utiliza um parâmetro de geração.</span>
            <span class="sxs-lookup">
              <span data-stu-id="d39f6-312">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">
          <span data-ttu-id="d39f6-313">Um número entre 1 e 99 que especifica quando a notificação deve ser gerada com base nos objetos alocados na geração 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-313">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          </span>
        </param>
        <param name="largeObjectHeapThreshold">
          <span data-ttu-id="d39f6-314">Um número entre 1 e 99 que especifica quando a notificação deve ser gerada com base nos objetos alocados no heap de objetos grandes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-314">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-315">Especifica que uma notificação de coleta de lixo deve ser gerada quando as condições favorecerem a coleta de lixo completa e quando a coleção tiver sido concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-315">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-316">Para cada geração, o coletor de lixo define um limite para as alocações em que geração.</span><span class="sxs-lookup"><span data-stu-id="d39f6-316">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="d39f6-317">Quando o tamanho das alocações excede esse limite, uma coleta de lixo é disparada nessa geração.</span><span class="sxs-lookup"><span data-stu-id="d39f6-317">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="d39f6-318">Para o exemplo, se o limite de geração 2 é de 20MB (o que significa que 20MB sobrevive a coleções de geração 1 e é promovido à geração 2) e mais de 20MB sobreviveu geração 1 e é solicitado na geração 2, a próxima coleta de lixo será tentada como uma coleção de geração 2.</span><span class="sxs-lookup"><span data-stu-id="d39f6-318">For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="d39f6-319">Da mesma forma, se o heap de objeto grande (LOH) limite é de 20MB e seu aplicativo alocou mais de 20MB de objetos grandes, a próxima coleta de lixo também será aplicada como uma coleção de geração 2 (desde o LOH só será coletado em gen2 coletas de lixo).</span><span class="sxs-lookup"><span data-stu-id="d39f6-319">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="d39f6-320">O `maxGenerationThreshold` e `largeObjectHeapThreshold` limites de controlam a antecedência você será notificado antes que ocorra uma coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-320">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="d39f6-321">Quanto maior o limite, mais alocações que podem ocorrer entre a notificação e a coleta de lixo completa Avançar.</span><span class="sxs-lookup"><span data-stu-id="d39f6-321">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="d39f6-322">Se você tiver situações em que uma coleta de lixo completa pelo common language runtime poderia afetar negativamente o desempenho do seu aplicativo, você pode pedir para ser notificado quando o tempo de execução está prestes a fazer uma coleta de lixo completa e contornar essa coleção induzindo uma coleção por conta própria (usando o <xref:System.GC.Collect%2A> método) quando as condições são ainda favoráveis.</span><span class="sxs-lookup"><span data-stu-id="d39f6-322">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="d39f6-323">Além de alterar a agenda de coleta de lixo, a notificação de GC total é útil para os cenários a seguir:</span><span class="sxs-lookup"><span data-stu-id="d39f6-323">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="d39f6-324">Monitorar para a abordagem de uma coleta de lixo completa e, quando for avisado de que um está se aproximando, você reduzir o tamanho de dados dinâmicos (por exemplo, liberando algumas entradas de cache).</span><span class="sxs-lookup"><span data-stu-id="d39f6-324">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="d39f6-325">Como resultado, quando ocorre a coleta de lixo, é capaz de recuperar mais memória.</span><span class="sxs-lookup"><span data-stu-id="d39f6-325">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="d39f6-326">Monitorar a conclusão da coleta de lixo completa para que você pode coletar algumas estatísticas.</span><span class="sxs-lookup"><span data-stu-id="d39f6-326">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="d39f6-327">Por exemplo, você talvez queira medir o tamanho do heap na conclusão de GC para que você saiba que o tamanho dos dados ao vivo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-327">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="d39f6-328">(Depois de um GC completo, o heap é em seu tamanho menor.)</span><span class="sxs-lookup"><span data-stu-id="d39f6-328">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="d39f6-329">Para obter mais informações sobre o que representa uma coleta de lixo completa, consulte [notificações de coleta de lixo](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="d39f6-329">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="d39f6-330">Quando você registrar uma notificação de coleta de lixo, você pode ser notificado quando uma coleta de lixo completa está se aproximando e quando ela estiver concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-330">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="d39f6-331">Esse padrão é semelhante a como o sistema operacional monitora as notificações de memória insuficiente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-331">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="d39f6-332">Use as diretrizes a seguir para especificar o `maxGenerationThreshold` e `largeObjectHeapThreshold` parâmetros:</span><span class="sxs-lookup"><span data-stu-id="d39f6-332">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="d39f6-333">Quanto maior o valor de limite, mais alocações ocorrerá entre a notificação e a coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-333">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="d39f6-334">Um valor de limite maior fornece mais oportunidades para o tempo de execução verificar se há uma coleção próximo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-334">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="d39f6-335">Isso aumenta a probabilidade de que você será notificado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-335">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="d39f6-336">No entanto, você não deve definir o limite muito alto, porque o que resulta em uma mais alocações antes do tempo de execução induzir a próxima coleta.</span><span class="sxs-lookup"><span data-stu-id="d39f6-336">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="d39f6-337">Quando você induzir uma coleção por conta própria após a notificação usando um valor de limite superior, menos objetos são recuperados de seria seja recuperada pela coleta de próximo do tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="d39f6-337">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="d39f6-338">Quanto menor o valor de limite, menos as alocações entre a notificação e a coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-338">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-339">O exemplo a seguir mostra como registrar uma notificação de coleta de lixo e iniciar um thread para monitorar o status da notificação de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-339">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="d39f6-340">Este exemplo de código é parte de um exemplo maior fornecido para [notificações de coleta de lixo](~/docs/standard/garbage-collection/notifications.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-340">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-341">
            <paramref name="maxGenerationThreshold" /> ou <paramref name="largeObjectHeapThreshold" /> não está entre 1 e 99.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-341">
              <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-342">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-342">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-343">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-343">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-344">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-344">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-345">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-345">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="d39f6-346">A quantidade de memória não gerenciada que foi liberada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-346">The amount of unmanaged memory that has been released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-347">Informa ao tempo de execução que memória não gerenciada foi liberada e não precisa ser considerada ao agendar a coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-347">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-348">Para determinar quando Agendar coleta de lixo, o tempo de execução leva em consideração a quantidade de memória gerenciado é alocada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-348">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="d39f6-349">Se um objeto gerenciado pequeno aloca uma grande quantidade de memória não gerenciada, o tempo de execução leva em conta somente a memória gerenciada e, portanto, subestimar a urgência de agendamento de coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-349">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="d39f6-350">O <xref:System.GC.AddMemoryPressure%2A> método informa o tempo de execução desse mais pressão na memória do sistema e o <xref:System.GC.RemoveMemoryPressure%2A> método informa o tempo de execução que a pressão adicional foi liberada.</span><span class="sxs-lookup"><span data-stu-id="d39f6-350">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="d39f6-351">No padrão de uso mais simples, um objeto gerenciado aloca memória não gerenciada no construtor e o solta no `Dispose` ou `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-351">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="d39f6-352">Chamar o <xref:System.GC.AddMemoryPressure%2A> método depois de alocar a memória não gerenciada e chamar o <xref:System.GC.RemoveMemoryPressure%2A> método depois de liberá-lo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-352">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="d39f6-353">Em cenários mais complexos, onde a alocação de memória não gerenciada altera significativamente durante o tempo de vida do objeto gerenciado, você pode chamar o <xref:System.GC.AddMemoryPressure%2A> e <xref:System.GC.RemoveMemoryPressure%2A> métodos para se comunicar essas alterações incrementais no tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="d39f6-353">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="d39f6-354">Certifique-se de que você remova exatamente a quantidade de pressão de que você adicionar.</span><span class="sxs-lookup"><span data-stu-id="d39f6-354">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="d39f6-355">Falha ao fazer isso pode afetar adversamente o desempenho do sistema em aplicativos que são executados por longos períodos de tempo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-355">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-356">
            <paramref name="bytesAllocated" /> é menor ou igual a 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-356">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="d39f6-357">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-357">-or-</span>
          </span>
          <span data-ttu-id="d39f6-358">Em um computador de 32 bits, <paramref name="bytesAllocated" /> é maior que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-358">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="d39f6-359">a capacidade de chamar código não gerenciado ao manipular a prioridade de coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-359">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="d39f6-360">Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-360">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-361">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-361">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-362">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-362">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d39f6-363">O objeto para o qual um finalizador deve ser chamado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-363">The object that a finalizer must be called for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-364">Solicita que o sistema chame o finalizador do objeto especificado para o qual <see cref="M:System.GC.SuppressFinalize(System.Object)" /> foi chamado anteriormente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-364">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-365">O <xref:System.GC.ReRegisterForFinalize%2A> método adiciona o `obj` parâmetro à lista de objetos que solicite finalização antes que o coletor de lixo libera o objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-365">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="d39f6-366">O `obj` parâmetro deve ser o chamador do método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-366">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="d39f6-367">Chamar o <xref:System.GC.ReRegisterForFinalize%2A> método não garante que o coletor de lixo chamará o finalizador de um objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-367">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="d39f6-368">Por padrão, todos os objetos que implementam os finalizadores são adicionados à lista de objetos que exigem a finalização; No entanto, um objeto pode já ter sido finalizado ou pode ter desabilitado finalização chamando o <xref:System.GC.SuppressFinalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-368">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="d39f6-369">Um finalizador pode usar esse método para lembrar a mesmo ou um objeto que faz referência a ele.</span><span class="sxs-lookup"><span data-stu-id="d39f6-369">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-370">O exemplo a seguir demonstra como usar o método ReRegisterForFinalize para finalizar um objeto uma segunda vez após a coleta de lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-370">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d39f6-371">
            <paramref name="obj" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-371">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d39f6-372">O objeto cujo finalizador não deve ser executado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-372">The object whose finalizer must not be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-373">Solicita que o Common Language Runtime não chame o finalizador do objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-373">Requests that the common language runtime not call the finalizer for the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-374">Esse método define um bit no cabeçalho do objeto de `obj`, que verifica se o tempo de execução ao chamar finalizadores.</span><span class="sxs-lookup"><span data-stu-id="d39f6-374">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="d39f6-375">Um finalizador, que é representado pelo <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método, é usado para liberar recursos não gerenciados antes de um objeto é coletado como lixo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-375">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="d39f6-376">Se `obj` não tem um finalizador, a chamada para o <xref:System.GC.SuppressFinalize%2A> método não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="d39f6-376">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="d39f6-377">Os objetos que implementam o <xref:System.IDisposable> interface pode chamar este método do objeto de <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação para impedir que o coletor de lixo chamar <xref:System.Object.Finalize%2A?displayProperty=nameWithType> em um objeto que ele não seja necessário.</span><span class="sxs-lookup"><span data-stu-id="d39f6-377">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="d39f6-378">Normalmente, isso é feito para impedir que o finalizador liberar recursos não gerenciados que já foi liberados pelo <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementação.</span><span class="sxs-lookup"><span data-stu-id="d39f6-378">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-379">O exemplo a seguir demonstra como usar o <xref:System.GC.SuppressFinalize%2A> método em uma classe de recurso para impedir que uma coleta de lixo de redundância do que está sendo chamado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-379">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="d39f6-380">O exemplo usa o [dispose padrão](~/docs/standard/design-guidelines/dispose-pattern.md) liberar ambos os recursos gerenciados (ou seja, os objetos que implementam <xref:System.IDisposable>) e os recursos não gerenciados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-380">The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d39f6-381">
            <paramref name="obj" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-381">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-382">Tentar desabilitar a coleta de lixo durante a execução de um caminho crítico.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-382">Attempts to disallow garbage collection during the execution of a critical path.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="d39f6-383">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-383">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-384">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-384">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="d39f6-385">A quantidade de memória em bytes a se alocar sem disparar uma coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-385">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="d39f6-386">Ela deve ser menor ou igual ao tamanho de um segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-386">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="d39f6-387">Para obter informações sobre o tamanho de um segmento efêmero, consulte a seção "Gerações e segmentos efêmeros" no artigo [Conceitos básicos sobre a coleta de lixo](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-387">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-388">Tentar desabilitar a coleta de lixo durante a execução de um caminho crítico se uma quantidade especificada de memória estiver disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-388">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-389">
            <see langword="true" /> se o tempo de execução for capaz de confirmar a quantidade necessária de memória e o coletor de lixo for capaz de entrar no modo de latência não região GC; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-389">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-390">O <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> método tenta colocar o coletor de lixo em nenhum modo de latência de região de GC, que não permite a coleta de lixo quando um aplicativo é executado, uma região crítica de código.</span><span class="sxs-lookup"><span data-stu-id="d39f6-390">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="d39f6-391">Se o tempo de execução não inicialmente aloque a quantidade solicitada de memória, o coletor de lixo executa uma coleta de lixo de bloqueio completo em uma tentativa de liberar memória adicional.</span><span class="sxs-lookup"><span data-stu-id="d39f6-391">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="d39f6-392">O coletor de lixo entra no modo de latência de região não GC se é possível alocar a quantidade necessária de memória, que nesse caso é realmente 2 \* `totalSize` bytes (ele tenta alocar `totalSize` bytes para o heap de objeto pequeno e `totalSize` bytes para o heap de objeto grande).</span><span class="sxs-lookup"><span data-stu-id="d39f6-392">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="d39f6-393">`totalSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-393">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="d39f6-394">Isso inclui as alocações pelo aplicativo, bem como alocações de tempo de execução em nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-394">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d39f6-395">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-395">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-396">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-396">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="d39f6-397">Não sair de nenhum modo de latência do GC região chamando o <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-397">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-398">
            <paramref name="totalSize" /> excede o tamanho do segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-398">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-399">O processo já está em modo de latência não região GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-399">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="d39f6-400">A quantidade de memória em bytes a se alocar sem disparar uma coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-400">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="d39f6-401">Ela deve ser menor ou igual ao tamanho de um segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-401">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="d39f6-402">Para obter informações sobre o tamanho de um segmento efêmero, consulte a seção "Gerações e segmentos efêmeros" no artigo [Conceitos básicos sobre a coleta de lixo](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-402">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="d39f6-403">
            <see langword="true" /> para omitir uma coleta de lixo de bloqueio completo se o coletor de lixo inicialmente não puder alocar <c>totalSize</c> bytes; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-403">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <c>totalSize</c> bytes; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-404">Tenta não permitir a coleta de lixo durante a execução de um caminho crítico se houver uma quantidade especificada de memória disponível e controla se o coletor de lixo faz uma coleta de lixo de bloqueio completo se nenhuma memória suficiente estiver inicialmente disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-404">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-405">
            <see langword="true" /> se o tempo de execução for capaz de confirmar a quantidade necessária de memória e o coletor de lixo for capaz de entrar no modo de latência não região GC; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-405">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-406">O <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> método tenta colocar o coletor de lixo em nenhum modo de latência de região de GC, que não permite a coleta de lixo quando um aplicativo é executado, uma região crítica de código.</span><span class="sxs-lookup"><span data-stu-id="d39f6-406">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="d39f6-407">Se o tempo de execução é impossível inicialmente alocar a quantidade solicitada de memória e o `disallowFullBlockingGC` argumento é `false`, o coletor de lixo executa uma coleta de lixo de bloqueio completo em uma tentativa de liberar memória adicional; caso contrário, a alocação falhará e o método retornará `false`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-407">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="d39f6-408">O coletor de lixo entra no modo de latência de região não GC se é possível alocar a quantidade necessária de memória, que nesse caso é realmente 2 \* `totalSize` (ele tenta alocar `totalSize` para o heap de objeto pequeno e `totalSize` para o heap de objeto grande).</span><span class="sxs-lookup"><span data-stu-id="d39f6-408">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="d39f6-409">`totalSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-409">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="d39f6-410">Isso inclui as alocações pelo aplicativo, bem como alocações de tempo de execução em nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-410">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="d39f6-411">Configuração `disallowFullBlockingGC` para `true` para impedir que um lixo bloqueio completo coleção se não há memória suficiente está disponível inicialmente é mais útil em cenários de balanceamento de carga: um sistema pode chamar este método e reporte como pronto para aceitar solicitações se ele retorna `true`, e ter o balanceador de carga redirecionar solicitações para outros sistemas se ele retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-411">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="d39f6-412">Ele pode, em seguida, fazer uma coleta de lixo de bloqueio completo quando ele não está manipulando as solicitações ao chamar o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-412">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d39f6-413">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-413">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-414">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-414">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="d39f6-415">Não sair de nenhum modo de latência do GC região chamando o <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-415">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-416">
            <paramref name="totalSize" /> excede o tamanho do segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-416">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-417">O processo já está em modo de latência não região GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-417">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="d39f6-418">A quantidade de memória em bytes a se alocar sem disparar uma coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-418">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="d39f6-419">
            <c>totalSize</c> –<c>lohSize</c> deve ser menor ou igual ao tamanho de um segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-419">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="d39f6-420">Para obter informações sobre o tamanho de um segmento efêmero, consulte a seção "Gerações e segmentos efêmeros" no artigo [Conceitos básicos sobre a coleta de lixo](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-420">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="d39f6-421">O número de bytes em <c>totalSize</c> a serem usados para alocações de LOH (heap de objetos grandes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-421">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-422">Tentar desabilitar a coleta de lixo durante a execução de um caminho crítico se uma quantidade especificada de memória estiver disponível para o heap de objeto grande e o heap de objeto pequeno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-422">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-423">
            <see langword="true" /> se o tempo de execução for capaz de confirmar a quantidade necessária de memória e o coletor de lixo for capaz de entrar no modo de latência não região GC; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-423">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-424">O <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> método tenta colocar o coletor de lixo em nenhum modo de latência de região de GC, que não permite a coleta de lixo quando um aplicativo é executado, uma região crítica de código.</span><span class="sxs-lookup"><span data-stu-id="d39f6-424">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="d39f6-425">Se o tempo de execução não inicialmente aloque a quantidade solicitada de memória, o coletor de lixo executa uma coleta de lixo de bloqueio completo em uma tentativa de liberar memória adicional.</span><span class="sxs-lookup"><span data-stu-id="d39f6-425">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="d39f6-426">O coletor de lixo entra no modo de latência de região não GC se ele é capaz de alocar `lohSize` para LOH e `totalSize` – `lohSize` para o heap de objeto pequeno (SOH).</span><span class="sxs-lookup"><span data-stu-id="d39f6-426">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="d39f6-427">`lohSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico para o LOH e `totalSize` – `lohSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico para o SOH.</span><span class="sxs-lookup"><span data-stu-id="d39f6-427">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="d39f6-428">Isso inclui as alocações pelo aplicativo, bem como alocações de tempo de execução em nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-428">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d39f6-429">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-429">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-430">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-430">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="d39f6-431">Não sair de nenhum modo de latência do GC região chamando o <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-431">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-432">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> excede o tamanho do segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-432">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-433">O processo já está em modo de latência não região GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-433">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="d39f6-434">A quantidade de memória em bytes a se alocar sem disparar uma coleta de lixo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-434">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="d39f6-435">
            <c>totalSize</c> –<c>lohSize</c> deve ser menor ou igual ao tamanho de um segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-435">
              <c>totalSize</c> –<c>lohSize</c> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="d39f6-436">Para obter informações sobre o tamanho de um segmento efêmero, consulte a seção "Gerações e segmentos efêmeros" no artigo [Conceitos básicos sobre a coleta de lixo](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-436">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="d39f6-437">O número de bytes em <c>totalSize</c> a serem usados para alocações de LOH (heap de objetos grandes).</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-437">The number of bytes in <c>totalSize</c> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="d39f6-438">
            <see langword="true" /> para omitir uma coleta de lixo de bloqueio completo se o coletor de lixo inicialmente não puder alocar a memória especificada no SOH (heap de objetos pequenos) e no LOH; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-438">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-439">Tenta não permitir a coleta de lixo durante a execução de um caminho crítico se há uma quantidade especificada de memória disponível para o heap de objetos grandes e o heap de objetos pequenos e controla se o coletor de lixo faz uma coleta de lixo de bloqueio completo se nenhuma memória suficiente está inicialmente disponível.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-439">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-440">
            <see langword="true" /> se o tempo de execução for capaz de confirmar a quantidade necessária de memória e o coletor de lixo for capaz de entrar no modo de latência não região GC; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-440">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-441">O <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> método tenta colocar o coletor de lixo em nenhum modo de latência de região de GC, que não permite a coleta de lixo quando um aplicativo é executado, uma região crítica de código.</span><span class="sxs-lookup"><span data-stu-id="d39f6-441">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="d39f6-442">Se o tempo de execução é impossível inicialmente alocar a quantidade solicitada de memória e o `disallowFullBlockingGC` argumento é `false`, o coletor de lixo executa uma coleta de lixo de bloqueio completo em uma tentativa de liberar memória adicional; caso contrário, a alocação falhará e o método retornará `false`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-442">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="d39f6-443">O coletor de lixo entra no modo de latência de região não GC se ele é capaz de alocar `lohSize` para LOH e `totalSize` – `lohSize` para o heap de objeto pequeno (SOH).</span><span class="sxs-lookup"><span data-stu-id="d39f6-443">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="d39f6-444">`lohSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico para o LOH e `totalSize` – `lohSize` deve ser grande o suficiente para lidar com todas as alocações de memória que ocorrem no caminho crítico para o SOH.</span><span class="sxs-lookup"><span data-stu-id="d39f6-444">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="d39f6-445">Isso inclui as alocações pelo aplicativo, bem como alocações de tempo de execução em nome do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-445">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="d39f6-446">Configuração `disallowFullBlockingGC` para `true` para impedir que um lixo bloqueio completo coleção se não há memória suficiente está disponível inicialmente é mais útil em cenários de balanceamento de carga: um sistema pode chamar este método e reporte como pronto para aceitar solicitações se ele retorna `true`, e ter o balanceador de carga redirecionar solicitações para outros sistemas se ele retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-446">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="d39f6-447">Ele pode, em seguida, fazer uma coleta de lixo de bloqueio completo quando ele não está manipulando as solicitações ao chamar o <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-447">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d39f6-448">Não é possível aninhar chamadas para o <xref:System.GC.TryStartNoGCRegion%2A> método e você só deve chamar o <xref:System.GC.EndNoGCRegion%2A> método se o tempo de execução está atualmente em nenhum modo de latência de região de GC.</span><span class="sxs-lookup"><span data-stu-id="d39f6-448">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="d39f6-449">Em outras palavras, você não deve chamar <xref:System.GC.TryStartNoGCRegion%2A> várias vezes (após a primeira chamada de método, as chamadas subsequentes não terá êxito), e você não deve esperar chamadas para <xref:System.GC.EndNoGCRegion%2A> tenha êxito apenas porque a primeira chamada para <xref:System.GC.TryStartNoGCRegion%2A> foi bem-sucedida.</span><span class="sxs-lookup"><span data-stu-id="d39f6-449">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="d39f6-450">Não sair de nenhum modo de latência do GC região chamando o <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-450">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-451">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> excede o tamanho do segmento efêmero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-451">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-452">O processo já está em modo de latência não região GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-452">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-453">Retorna o status de uma notificação registrada para determinar se uma coleção completa de lixo de bloqueio realizada pelo Common Language Runtime foi concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-453">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-454">Retorna o status de uma notificação registrada para determinar se uma coleção completa de lixo de bloqueio realizada pelo Common Language Runtime foi concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-454">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-455">O status da notificação de coleta de lixo registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-455">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-456">Use a enumeração <xref:System.GCNotificationStatus> retornada por esse método para determinar o status da notificação de coleta de lixo atual que foi registrado usando-se o método <xref:System.GC.RegisterForFullGCNotification%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-456">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="d39f6-457">Você também pode usar o <xref:System.GC.WaitForFullGCComplete%2A> método para determinar se a coleta de lixo completa foi concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-457">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="d39f6-458">Quando a enumeração retorna <xref:System.GCNotificationStatus.Succeeded>, você pode executar tarefas como impedindo objetos adicionais que está sendo alocado e induzindo uma coleção com o <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-458">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="d39f6-459">Observe que a notificação não garante que uma coleta de lixo completa ocorrerá, só que condições atingiu o limite são favorável para coleta de lixo completa ocorra.</span><span class="sxs-lookup"><span data-stu-id="d39f6-459">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="d39f6-460">Este método espera indefinidamente uma notificação de coleta de lixo ser obtido.</span><span class="sxs-lookup"><span data-stu-id="d39f6-460">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="d39f6-461">Se você deseja especificar um período de tempo limite para o método retornar se a notificação não pode ser obtida, use o <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-461">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="d39f6-462">Se você chamar esse método sem especificar um tempo limite, você pode chamar o <xref:System.GC.CancelFullGCNotification%2A> método se você estiver esperando mais do que o preferencial.</span><span class="sxs-lookup"><span data-stu-id="d39f6-462">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="d39f6-463">Você deve seguir este método com uma chamada para o <xref:System.GC.WaitForFullGCComplete%2A> método para certificar-se de que você teve uma coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-463">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="d39f6-464">Chamar esse método somente faz com que os resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-464">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-465">O exemplo a seguir mostra como usar esse método para determinar se um completo, bloqueio de coleta de lixo está se aproximando.</span><span class="sxs-lookup"><span data-stu-id="d39f6-465">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="d39f6-466">Sempre que o status da notificação é <xref:System.GCNotificationStatus.Succeeded>, o método de usuário `OnFullGCApproachNotify` é chamado para executar ações em resposta à coleção próximo.</span><span class="sxs-lookup"><span data-stu-id="d39f6-466">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="d39f6-467">Este exemplo de código é parte de um exemplo maior fornecido para [notificações de coleta de lixo](~/docs/standard/garbage-collection/notifications.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-467">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-468">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-468">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-469">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-469">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-470">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-470">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-471">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-471">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d39f6-472">O período de espera antes que um status de notificação possa ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-472">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="d39f6-473">Especifique -1 para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-473">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-474">Retorna, em um período de tempo limite especificado, o status de uma notificação registrada para determinar se uma coleta de lixo de bloqueio completa executada pelo Common Language Runtime é iminente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-474">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-475">O status da notificação de coleta de lixo registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-475">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-476">Use a enumeração <xref:System.GCNotificationStatus> retornada por esse método para determinar o status da notificação de coleta de lixo atual que foi registrado usando-se o método <xref:System.GC.RegisterForFullGCNotification%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-476">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="d39f6-477">Você também pode usar o <xref:System.GC.WaitForFullGCComplete%2A> método para determinar se a coleta de lixo completa foi concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-477">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="d39f6-478">Observe que esse método retorna imediatamente sempre que um status de notificação de coleta de lixo é obtido, independentemente do valor especificado pelo `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-478">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="d39f6-479">Se um status de notificação de coleta de lixo não será obtido antes de `millisecondsTimeout` vezes, esse método retorna <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-479">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="d39f6-480">Quando a enumeração retorna <xref:System.GCNotificationStatus.Succeeded>, você pode executar tarefas como impedindo objetos adicionais que está sendo alocado e induzindo uma coleção com o <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-480">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="d39f6-481">Observe que a notificação não garante que uma coleta de lixo completa ocorrerá, só que condições atingiu o limite são favorável para coleta de lixo completa ocorra.</span><span class="sxs-lookup"><span data-stu-id="d39f6-481">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="d39f6-482">Você pode chamar o <xref:System.GC.CancelFullGCNotification%2A> método quando não puder aguardar o tempo limite de espera.</span><span class="sxs-lookup"><span data-stu-id="d39f6-482">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="d39f6-483">Você deve seguir este método com uma chamada para o <xref:System.GC.WaitForFullGCComplete%2A> método para certificar-se de que você teve uma coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-483">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="d39f6-484">Chamar esse método somente faz com que os resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-484">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d39f6-485">
            <paramref name="millisecondsTimeout" /> deve ser não negativo ou menor ou igual a <see cref="F:System.Int32.MaxValue" /> ou -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-485">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-486">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-486">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-487">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-487">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-488">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-488">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-489">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-489">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-490">Retorna o status de uma notificação registrada para determinar se uma coleta completa de lixo de bloqueio realizada pelo Common Language Runtime foi concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-490">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-491">Retorna o status de uma notificação registrada para determinar se uma coleta completa de lixo de bloqueio realizada pelo Common Language Runtime foi concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-491">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-492">O status da notificação de coleta de lixo registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-492">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-493">Use a enumeração <xref:System.GCNotificationStatus> retornada por esse método para determinar o status da notificação de coleta de lixo atual que foi registrado usando-se o método <xref:System.GC.RegisterForFullGCNotification%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-493">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="d39f6-494">Você também pode usar o <xref:System.GC.WaitForFullGCApproach%2A> método para determinar se uma coleta de lixo completa é iminente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-494">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="d39f6-495">Quando a enumeração retorna <xref:System.GCNotificationStatus.Succeeded>, você pode executar tarefas como retomar o trabalho e obter uma contagem de coleção com o <xref:System.GC.CollectionCount%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d39f6-495">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="d39f6-496">Este método espera indefinidamente uma notificação de coleta de lixo ser obtido.</span><span class="sxs-lookup"><span data-stu-id="d39f6-496">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="d39f6-497">Se você deseja especificar um período de tempo limite para o método retornar se a notificação não pode ser obtida, use o <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="d39f6-497">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="d39f6-498">Se você chamar esse método sem especificar um tempo limite, você pode chamar o <xref:System.GC.CancelFullGCNotification%2A> método se você estiver esperando mais do que o preferencial.</span><span class="sxs-lookup"><span data-stu-id="d39f6-498">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="d39f6-499">Esta chamada de método deve ser precedida por uma chamada para o <xref:System.GC.WaitForFullGCApproach%2A> método para certificar-se de que você teve uma coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-499">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="d39f6-500">Chamar esse método somente pode produzir resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-500">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-501">O exemplo a seguir mostra como usar esse método para determinar se uma coleta de lixo completa foi concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-501">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="d39f6-502">Sempre que o status da notificação é <xref:System.GCNotificationStatus.Succeeded>, o método de usuário `OnFullGCCompletedNotify` é chamado para executar ações em resposta à coleção concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-502">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="d39f6-503">Este exemplo de código é parte de um exemplo maior fornecido para [notificações de coleta de lixo](~/docs/standard/garbage-collection/notifications.md) tópico.</span><span class="sxs-lookup"><span data-stu-id="d39f6-503">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-504">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-504">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-505">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-505">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-506">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-506">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-507">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-507">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d39f6-508">O período de espera antes que um status de notificação possa ser obtido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-508">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="d39f6-509">Especifique -1 para aguardar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-509">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d39f6-510">Retorna, em um período de tempo limite especificado, o status de uma notificação registrada para determinar se uma coleta de lixo de bloqueio completo executada pelo Common Language Runtime foi concluída.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-510">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d39f6-511">O status da notificação de coleta de lixo registrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-511">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-512">Use a enumeração <xref:System.GCNotificationStatus> retornada por esse método para determinar o status da notificação de coleta de lixo atual que foi registrado usando-se o método <xref:System.GC.RegisterForFullGCNotification%2A>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-512">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="d39f6-513">Você também pode usar o <xref:System.GC.WaitForFullGCApproach%2A> método para determinar se uma coleta de lixo completa é iminente.</span><span class="sxs-lookup"><span data-stu-id="d39f6-513">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="d39f6-514">Observe que esse método retorna imediatamente sempre que um status de notificação de coleta de lixo é obtido, independentemente do valor especificado pelo `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="d39f6-514">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="d39f6-515">Se um status de notificação de coleta de lixo não será obtido antes de `millisecondsTimeout` vezes, esse método retorna <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="d39f6-515">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="d39f6-516">Quando a enumeração retorna <xref:System.GCNotificationStatus.Succeeded>, você pode executar tarefas como retomar o trabalho e obter uma contagem de coleção com o <xref:System.GC.CollectionCount%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="d39f6-516">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="d39f6-517">Você pode chamar o <xref:System.GC.CancelFullGCNotification%2A> método quando não puder aguardar o tempo limite de espera.</span><span class="sxs-lookup"><span data-stu-id="d39f6-517">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="d39f6-518">Esta chamada de método deve ser precedida por uma chamada para o <xref:System.GC.WaitForFullGCApproach%2A> método para certificar-se de que você teve uma coleta de lixo completa.</span><span class="sxs-lookup"><span data-stu-id="d39f6-518">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="d39f6-519">Chamar esse método somente pode produzir resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="d39f6-519">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="d39f6-520">
            <paramref name="millisecondsTimeout" /> deve ser não negativo ou menor ou igual a <see cref="F:System.Int32.MaxValue" /> ou -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-520">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="d39f6-521">para confiança total do chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-521">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-522">Este membro não pode ser usado pelo código parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-522">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="d39f6-523">requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-523">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="d39f6-524">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-524">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="d39f6-525">Suspende o thread atual até que o thread que está processando a fila de finalizadores tenha esvaziado essa fila.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d39f6-525">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d39f6-526">Quando o coletor de lixo Localiza objetos que podem ser recuperados, ele verifica cada objeto para determinar os requisitos de finalização do objeto.</span><span class="sxs-lookup"><span data-stu-id="d39f6-526">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="d39f6-527">Se um objeto implementa um finalizador e não tiver desabilitado a finalização chamando <xref:System.GC.SuppressFinalize%2A>, o objeto é colocado em uma lista de objetos que são marcados como prontos para finalização.</span><span class="sxs-lookup"><span data-stu-id="d39f6-527">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="d39f6-528">O coletor de lixo chama o <xref:System.Object.Finalize%2A> métodos para os objetos nesta lista e remove as entradas da lista.</span><span class="sxs-lookup"><span data-stu-id="d39f6-528">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="d39f6-529">Blocos este método até que todos os finalizadores executou até a conclusão.</span><span class="sxs-lookup"><span data-stu-id="d39f6-529">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="d39f6-530">O thread no qual são executados os finalizadores não for especificado, portanto não há nenhuma garantia de que esse método será encerrado.</span><span class="sxs-lookup"><span data-stu-id="d39f6-530">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="d39f6-531">No entanto, esse thread pode ser interrompido por outro thread enquanto o <xref:System.GC.WaitForPendingFinalizers%2A> método está em andamento.</span><span class="sxs-lookup"><span data-stu-id="d39f6-531">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="d39f6-532">Por exemplo, você pode iniciar outro thread que espera por um período de tempo e, em seguida, interrompe esse thread se esse thread ainda estiver suspenso.</span><span class="sxs-lookup"><span data-stu-id="d39f6-532">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d39f6-533">O exemplo a seguir demonstra como usar o <xref:System.GC.WaitForPendingFinalizers%2A> método para suspender o thread atual até a finalização de todos os objetos coletados é concluída.</span><span class="sxs-lookup"><span data-stu-id="d39f6-533">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>