<Type Name="Math" FullName="System.Math">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a65abb2d011ed017c4b44637bd58cd80c56744be" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52365251" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Math" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Math extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Math" />
  <TypeSignature Language="VB.NET" Value="Public Class Math" />
  <TypeSignature Language="C++ CLI" Value="public ref class Math abstract sealed" />
  <TypeSignature Language="F#" Value="type Math = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Fornece constantes e métodos estáticos para trigonométricas, logarítmicas e outras funções matemáticas comuns.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa várias funções matemáticas e trigonométricas do <xref:System.Math> classe para calcular os ângulos internos de um polígono trapezoidal.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Abs">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o valor absoluto de um número especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static decimal Abs (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Abs(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Abs(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Abs : decimal -&gt; decimal" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior ou igual a <see cref="F:System.Decimal.MinValue" />, mas menor ou igual a <see cref="F:System.Decimal.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um número <see cref="T:System.Decimal" />.</summary>
        <returns>Um número decimal, x, tal que 0 ≤ x ≤ <see cref="F:System.Decimal.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Decimal> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 1.2 e -1,2 é 1.2.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Decimal%29> método para obter o valor absoluto de um número de <xref:System.Decimal> valores.  
  
 [!code-csharp[System.Math.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Math.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(double value);" />
      <MemberSignature Language="F#" Value="static member Abs : double -&gt; double" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior ou igual a <see cref="F:System.Double.MinValue" />, mas menor ou igual a <see cref="F:System.Double.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número de ponto flutuante de precisão dupla, x, tal que 0 ≤ x ≤ <see cref="F:System.Double.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Double> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 1.2e03 tanto - 1.2e03 é 1.2e03.  
  
 Se `value` é igual a <xref:System.Double.NegativeInfinity> ou <xref:System.Double.PositiveInfinity>, o valor retornado é <xref:System.Double.PositiveInfinity>. Se `value` é igual a <xref:System.Double.NaN>, o valor retornado é <xref:System.Double.NaN>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Double%29> método para obter o valor absoluto de um número de <xref:System.Double> valores.  
  
 [!code-csharp[System.Math.Abs#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs2.cs#2)]
 [!code-vb[System.Math.Abs#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static short Abs (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Abs(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Abs(short value);" />
      <MemberSignature Language="F#" Value="static member Abs : int16 -&gt; int16" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior que <see cref="F:System.Int16.MinValue" />, mas menor ou igual a <see cref="F:System.Int16.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um inteiro com sinal de 16 bits.</summary>
        <returns>Um inteiro com sinal de 16 bits, x, tal que 0 ≤ x ≤ <see cref="F:System.Int16.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Int16> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 123 e -123 é 123.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Int16%29> método para obter o valor absoluto de um número de <xref:System.Int16> valores.  
  
 [!code-csharp[System.Math.Abs#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs3.cs#3)]
 [!code-vb[System.Math.Abs#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é igual a <see cref="F:System.Int16.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static int Abs (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Abs(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Abs(int value);" />
      <MemberSignature Language="F#" Value="static member Abs : int -&gt; int" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior que <see cref="F:System.Int32.MinValue" />, mas menor ou igual a <see cref="F:System.Int32.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um inteiro com sinal de 32 bits.</summary>
        <returns>Um inteiro com sinal de 32 bits, x, tal que 0 ≤ x ≤ <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Int32> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 123 e -123 é 123.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Int32%29> método para obter o valor absoluto de um número de <xref:System.Int32> valores.  
  
 [!code-csharp[System.Math.Abs#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs4.cs#4)]
 [!code-vb[System.Math.Abs#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é igual a <see cref="F:System.Int32.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static long Abs (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Abs(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Abs(long value);" />
      <MemberSignature Language="F#" Value="static member Abs : int64 -&gt; int64" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior que <see cref="F:System.Int64.MinValue" />, mas menor ou igual a <see cref="F:System.Int64.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um inteiro com sinal de 64 bits.</summary>
        <returns>Um inteiro com sinal de 64 bits, x, tal que 0 ≤ x ≤ <see cref="F:System.Int64.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Int64> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 123 e -123 é 123.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Int64%29> método para obter o valor absoluto de um número de <xref:System.Int64> valores.  
  
 [!code-csharp[System.Math.Abs#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs5.cs#5)]
 [!code-vb[System.Math.Abs#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs5.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é igual a <see cref="F:System.Int64.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static sbyte Abs (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Abs(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Abs(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Abs : sbyte -&gt; sbyte" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior que <see cref="F:System.SByte.MinValue" />, mas menor ou igual a <see cref="F:System.SByte.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um inteiro com sinal de 8 bits.</summary>
        <returns>Um inteiro com sinal de 8 bits, x, tal que 0 ≤ x ≤ <see cref="F:System.SByte.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um byte com sinal é seu valor numérico sem sinal. Por exemplo, o valor absoluto de 12 e -12 é 12.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.SByte%29> método para obter o valor absoluto de um número de <xref:System.SByte> valores.  
  
 [!code-csharp[System.Math.Abs#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs6.cs#6)]
 [!code-vb[System.Math.Abs#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs6.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <paramref name="value" /> é igual a <see cref="F:System.SByte.MinValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static float Abs (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Abs(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Abs(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Abs(float value);" />
      <MemberSignature Language="F#" Value="static member Abs : single -&gt; single" Usage="System.Math.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um número maior ou igual a <see cref="F:System.Single.MinValue" />, mas menor ou igual a <see cref="F:System.Single.MaxValue" />.</param>
        <summary>Retorna o valor absoluto de um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número de ponto flutuante de precisão simples, x, tal que 0 ≤ x ≤ <see cref="F:System.Single.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor absoluto de um <xref:System.Single> é seu valor numérico sem sinal. Por exemplo, o valor absoluto de ambos os 1.2e-03 e - 1.2e03 é 1.2e03.  
  
 Se `value` é igual a <xref:System.Single.NegativeInfinity> ou <xref:System.Single.PositiveInfinity>, o valor retornado é <xref:System.Single.PositiveInfinity>. Se `value` é igual a <xref:System.Single.NaN>, o valor retornado é <xref:System.Single.NaN>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Abs%28System.Single%29> método para obter o valor absoluto de um número de <xref:System.Single> valores.  
  
 [!code-csharp[System.Math.Abs#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Abs/cs/abs7.cs#7)]
 [!code-vb[System.Math.Abs#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Abs/vb/abs7.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static double Acos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acos(double d);" />
      <MemberSignature Language="F#" Value="static member Acos : double -&gt; double" Usage="System.Math.Acos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número que representa um cosseno, em que <paramref name="d" /> deve ser maior ou igual a -1, mas menor ou igual a 1.</param>
        <summary>Retorna o ângulo cujo cosseno é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que 0 ≤ θ ≤ π 
- ou - 
 <see cref="F:System.Double.NaN" /> se <paramref name="d" /> &lt; -1 ou <paramref name="d" /> &gt; 1 ou <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multiplique o valor retornado por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Acos%2A> método para ajudá-lo na computação dos ângulos internas de um determinado Trapézio.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Acosh">
      <MemberSignature Language="C#" Value="public static double Acosh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Acosh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Acosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acosh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Acosh(double d);" />
      <MemberSignature Language="F#" Value="static member Acosh : double -&gt; double" Usage="System.Math.Acosh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static double Asin (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asin(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asin(double d);" />
      <MemberSignature Language="F#" Value="static member Asin : double -&gt; double" Usage="System.Math.Asin d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número que representa um seno, em que <paramref name="d" /> deve ser maior ou igual a -1, mas menor ou igual a 1.</param>
        <summary>Retorna o ângulo cujo seno é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -π/2 ≤ θ ≤ π/2 
- ou - 
 <see cref="F:System.Double.NaN" /> se <paramref name="d" /> &lt; -1 ou <paramref name="d" /> &gt; 1 ou <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de retorno positivo representa um ângulo no sentido anti-horário do eixo x; um valor de retorno negativo representa um ângulo no sentido horário.  
  
 Multiplique o valor retornado por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Asin%2A> para auxiliar na computação dos ângulos internas de um determinado Trapézio.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Asinh">
      <MemberSignature Language="C#" Value="public static double Asinh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Asinh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Asinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asinh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Asinh(double d);" />
      <MemberSignature Language="F#" Value="static member Asinh : double -&gt; double" Usage="System.Math.Asinh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static double Atan (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan(double d);" />
      <MemberSignature Language="F#" Value="static member Atan : double -&gt; double" Usage="System.Math.Atan d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número que representa uma tangente.</param>
        <summary>Retorna o ângulo cuja tangente é o número especificado.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que π/2 ≤ θ ≤ π/2.  
  
- ou - 
 <see cref="F:System.Double.NaN" /> se <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" />, -π/2 arrendondado para precisão dupla (-1,5707963267949) se <paramref name="d" /> for igual a <see cref="F:System.Double.NegativeInfinity" /> ou π/2 arrendondado para precisão dupla (1,5707963267949) se <paramref name="d" /> for igual a <see cref="F:System.Double.PositiveInfinity" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de retorno positivo representa um ângulo no sentido anti-horário do eixo x; um valor de retorno negativo representa um ângulo no sentido horário.  
  
 Multiplique o valor retornado por 180 /<xref:System.Math.PI?displayProperty=nameWithType> para converter de radianos em graus.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como calcular o arco tangente de um valor e exibi-lo no console.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atan2">
      <MemberSignature Language="C#" Value="public static double Atan2 (double y, double x);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atan2(float64 y, float64 x) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atan2(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan2 (y As Double, x As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atan2(double y, double x);" />
      <MemberSignature Language="F#" Value="static member Atan2 : double * double -&gt; double" Usage="System.Math.Atan2 (y, x)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="y" Type="System.Double" />
        <Parameter Name="x" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="y">A coordenada y de um ponto.</param>
        <param name="x">A coordenada x de um ponto.</param>
        <summary>Retorna o ângulo cuja tangente é o quociente de dois números especificados.</summary>
        <returns>Um ângulo, θ, medido em radianos, tal que -π ≤ θ ≤ π e tan(θ) = <paramref name="y" /> / <paramref name="x" />, em que (<paramref name="x" />, <paramref name="y" />) é um ponto no plano cartesiano. Observe o seguinte: 
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 1, 0 &lt; θ &lt; π/2.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 2, π/2 &lt; θ ≤ π.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 3, -π &lt; θ &lt; -π/2.  
  
-   Para (<paramref name="x" />, <paramref name="y" />) no quadrante 4, -π/2 &lt; θ &lt; 0.  
  
Para pontos em limites dos quadrantes, o valor retornado é o seguinte: 
-   Se y for 0 e x não for negativo, θ = 0.  
  
-   Se y for 0 e x for negativo, θ = π.  
  
-   Se y for positivo e x for 0, θ = π/2.  
  
-   Se y for negativo e x for 0, θ = - π/2.  
  
-   Se y for 0 e x for 0, θ = 0.  
  
Se <paramref name="x" /> ou <paramref name="y" /> for <see cref="F:System.Double.NaN" />, ou se <paramref name="x" /> e <paramref name="y" /> forem <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NegativeInfinity" />, o método retornará <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno é o ângulo no plano cartesiano formado pelo eixo x e um vetor inicial da origem, (0,0) e terminando no ponto (x, y).  
  
   
  
## Examples  
 O exemplo a seguir demonstra como calcular o arco tangente de um ângulo e um vetor. O valor resultante é exibido no console do.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Atanh">
      <MemberSignature Language="C#" Value="public static double Atanh (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Atanh(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Atanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atanh (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Atanh(double d);" />
      <MemberSignature Language="F#" Value="static member Atanh : double -&gt; double" Usage="System.Math.Atanh d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BigMul">
      <MemberSignature Language="C#" Value="public static long BigMul (int a, int b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 BigMul(int32 a, int32 b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.BigMul(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BigMul (a As Integer, b As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long BigMul(int a, int b);" />
      <MemberSignature Language="F#" Value="static member BigMul : int * int -&gt; int64" Usage="System.Math.BigMul (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="a">O primeiro número a multiplicar.</param>
        <param name="b">O segundo número a multiplicar.</param>
        <summary>Produz o produto completo de dois números de 32 bits.</summary>
        <returns>O número que contém o produto dos números especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra o uso do <xref:System.Math.BigMul%2A> método para calcular o produto dos dois valores inteiros.  
  
 [!code-cpp[math.bigmul#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.bigmul/CPP/bigmul.cpp#1)]
 [!code-csharp[math.bigmul#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.bigmul/CS/bigmul.cs#1)]
 [!code-vb[math.bigmul#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.bigmul/VB/bigmul.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cbrt">
      <MemberSignature Language="C#" Value="public static double Cbrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cbrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cbrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cbrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cbrt(double d);" />
      <MemberSignature Language="F#" Value="static member Cbrt : double -&gt; double" Usage="System.Math.Cbrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Ceiling">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o menor valor inteiro maior ou igual ao número especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para positivo infinito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static decimal Ceiling (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Ceiling(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Ceiling(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Ceiling : decimal -&gt; decimal" Usage="System.Math.Ceiling d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal.</param>
        <summary>Retorna o menor valor integral maior ou igual ao número decimal especificado.</summary>
        <returns>O menor valor integral maior ou igual a <paramref name="d" />. Observe que esse método retorna um <see cref="T:System.Decimal" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para positivo infinito. Em outras palavras, se `d` for positivo, a presença de qualquer componente fracionário causas `d` a ser arredondado para o próximo inteiro mais alto. Se `d` for negativo, a operação de arredondamento faz com que qualquer componente fracionário de `d` sejam descartadas. A operação desse método difere de <xref:System.Math.Floor%28System.Decimal%29> método, que dá suporte ao arredondamento para negativo infinito.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a <xref:System.Math.Ceiling%28System.Decimal%29?displayProperty=nameWithType> método e ele contrastes com o <xref:System.Math.Floor%28System.Decimal%29> método.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Ceiling">
      <MemberSignature Language="C#" Value="public static double Ceiling (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Ceiling(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Ceiling(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Ceiling (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Ceiling(double a);" />
      <MemberSignature Language="F#" Value="static member Ceiling : double -&gt; double" Usage="System.Math.Ceiling a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna o menor valor integral maior ou igual ao número de ponto flutuante de precisão dupla especificado.</summary>
        <returns>O menor valor integral maior ou igual a <paramref name="a" />. Se <paramref name="a" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse valor será retornado. Observe que esse método retorna um <see cref="T:System.Double" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para positivo infinito. Em outras palavras, se `a` for positivo, a presença de qualquer componente fracionário causas `a` a ser arredondado para o próximo inteiro mais alto. Se `a` for negativo, a operação de arredondamento faz com que qualquer componente fracionário de `a` sejam descartadas. A operação desse método difere de <xref:System.Math.Floor%28System.Double%29> método, que dá suporte ao arredondamento para negativo infinito.  
  
Começando com o Visual Basic 15,8, o desempenho da conversão de duplo para inteiro é otimizado se você passar o valor retornado pela `Ceiling` método para qualquer uma da [funções de conversão integral](~/docs/visual-basic/language-reference/functions/conversion-functions.md), ou se o valor duplo retornado por `Ceiling` é automaticamente convertido em um inteiro com [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) definida como desativada. Essa otimização permite que o código seja executado mais rapidamente – até duas vezes mais rápido para o código que faz um grande número de conversões para tipos de inteiro. O exemplo a seguir ilustra essas conversões otimizadas:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7969
```   

## Examples  
 O exemplo a seguir ilustra a <xref:System.Math.Ceiling%28System.Double%29?displayProperty=nameWithType> método e ele contrastes com o <xref:System.Math.Floor%28System.Double%29> método.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static byte Clamp (byte value, byte min, byte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Clamp(unsigned int8 value, unsigned int8 min, unsigned int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Byte,System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Byte, min As Byte, max As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Clamp(System::Byte value, System::Byte min, System::Byte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : byte * byte * byte -&gt; byte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
        <Parameter Name="min" Type="System.Byte" />
        <Parameter Name="max" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static decimal Clamp (decimal value, decimal min, decimal max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Clamp(valuetype System.Decimal value, valuetype System.Decimal min, valuetype System.Decimal max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Decimal,System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Decimal, min As Decimal, max As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Clamp(System::Decimal value, System::Decimal min, System::Decimal max);" />
      <MemberSignature Language="F#" Value="static member Clamp : decimal * decimal * decimal -&gt; decimal" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
        <Parameter Name="min" Type="System.Decimal" />
        <Parameter Name="max" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static double Clamp (double value, double min, double max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Clamp(float64 value, float64 min, float64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Double,System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Double, min As Double, max As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Clamp(double value, double min, double max);" />
      <MemberSignature Language="F#" Value="static member Clamp : double * double * double -&gt; double" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="min" Type="System.Double" />
        <Parameter Name="max" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static short Clamp (short value, short min, short max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Clamp(int16 value, int16 min, int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int16,System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Short, min As Short, max As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Clamp(short value, short min, short max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int16 * int16 * int16 -&gt; int16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
        <Parameter Name="min" Type="System.Int16" />
        <Parameter Name="max" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static int Clamp (int value, int min, int max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Clamp(int32 value, int32 min, int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Integer, min As Integer, max As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Clamp(int value, int min, int max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int * int * int -&gt; int" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
        <Parameter Name="min" Type="System.Int32" />
        <Parameter Name="max" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static long Clamp (long value, long min, long max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Clamp(int64 value, int64 min, int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Long, min As Long, max As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Clamp(long value, long min, long max);" />
      <MemberSignature Language="F#" Value="static member Clamp : int64 * int64 * int64 -&gt; int64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
        <Parameter Name="min" Type="System.Int64" />
        <Parameter Name="max" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static sbyte Clamp (sbyte value, sbyte min, sbyte max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Clamp(int8 value, int8 min, int8 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.SByte,System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As SByte, min As SByte, max As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Clamp(System::SByte value, System::SByte min, System::SByte max);" />
      <MemberSignature Language="F#" Value="static member Clamp : sbyte * sbyte * sbyte -&gt; sbyte" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
        <Parameter Name="min" Type="System.SByte" />
        <Parameter Name="max" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static float Clamp (float value, float min, float max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Clamp(float32 value, float32 min, float32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.Single,System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As Single, min As Single, max As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Clamp(float value, float min, float max);" />
      <MemberSignature Language="F#" Value="static member Clamp : single * single * single -&gt; single" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
        <Parameter Name="min" Type="System.Single" />
        <Parameter Name="max" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ushort Clamp (ushort value, ushort min, ushort max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Clamp(unsigned int16 value, unsigned int16 min, unsigned int16 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt16,System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UShort, min As UShort, max As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Clamp(System::UInt16 value, System::UInt16 min, System::UInt16 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint16 * uint16 * uint16 -&gt; uint16" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
        <Parameter Name="min" Type="System.UInt16" />
        <Parameter Name="max" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static uint Clamp (uint value, uint min, uint max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Clamp(unsigned int32 value, unsigned int32 min, unsigned int32 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt32,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As UInteger, min As UInteger, max As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Clamp(System::UInt32 value, System::UInt32 min, System::UInt32 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint32 * uint32 * uint32 -&gt; uint32" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
        <Parameter Name="min" Type="System.UInt32" />
        <Parameter Name="max" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clamp">
      <MemberSignature Language="C#" Value="public static ulong Clamp (ulong value, ulong min, ulong max);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Clamp(unsigned int64 value, unsigned int64 min, unsigned int64 max) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Clamp(System.UInt64,System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Clamp (value As ULong, min As ULong, max As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Clamp(System::UInt64 value, System::UInt64 min, System::UInt64 max);" />
      <MemberSignature Language="F#" Value="static member Clamp : uint64 * uint64 * uint64 -&gt; uint64" Usage="System.Math.Clamp (value, min, max)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
        <Parameter Name="min" Type="System.UInt64" />
        <Parameter Name="max" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="min">To be added.</param>
        <param name="max">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static double Cos (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cos(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cos(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cos(double d);" />
      <MemberSignature Language="F#" Value="static member Cos : double -&gt; double" Usage="System.Math.Cos d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um ângulo, medido em radianos.</param>
        <summary>Retorna o cosseno do ângulo especificado.</summary>
        <returns>O cosseno de <paramref name="d" />. Se <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse método retornará <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `d`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 Os valores aceitáveis de `d` variam de aproximadamente-9223372036854775295 a aproximadamente 9223372036854775295. Para obter valores fora desse intervalo, o <xref:System.Math.Cos%2A> retorno do método `d` inalterado ao invés de lançar uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Cos%2A> para avaliar determinadas identidades trigonométricas para ângulos selecionados.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static double Cosh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Cosh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Cosh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Cosh(double value);" />
      <MemberSignature Language="F#" Value="static member Cosh : double -&gt; double" Usage="System.Math.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um ângulo, medido em radianos.</param>
        <summary>Retorna o cosseno hiperbólico do ângulo especificado.</summary>
        <returns>O cosseno hiperbólico de <paramref name="value" />. Se <paramref name="value" /> for igual a <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> será retornado. Se <paramref name="value" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `value`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Cosh%2A> para avaliar determinadas identidades hiperbólicos para valores selecionados.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DivRem">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula o quociente de dois números e também retorna o restante em um parâmetro de saída.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static int DivRem (int a, int b, out int result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 DivRem(int32 a, int32 b, [out] int32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int32,System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Integer, b As Integer, ByRef result As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int DivRem(int a, int b, [Runtime::InteropServices::Out] int % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int * int *  -&gt; int" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int32" />
        <Parameter Name="b" Type="System.Int32" />
        <Parameter Name="result" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">O dividendo.</param>
        <param name="b">O divisor.</param>
        <param name="result">O restante.</param>
        <summary>Calcula o quociente de dois inteiros de 32 bits com sinal e também retorna o resto em um parâmetro de saída.</summary>
        <returns>O quociente dos números especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor restante é igual ao resultado do [operador de resto](~/docs/csharp/language-reference/operators/remainder-operator.md).  
   
## Examples  
 O exemplo a seguir demonstra o <xref:System.Math.DivRem%28System.Int32%2CSystem.Int32%2CSystem.Int32%40%29> método.  
  
 [!code-csharp[System.Math.DivRem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem1.cs#1)]
 [!code-vb[System.Math.DivRem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> é zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static long DivRem (long a, long b, out long result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 DivRem(int64 a, int64 b, [out] int64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.DivRem(System.Int64,System.Int64,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (a As Long, b As Long, ByRef result As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long DivRem(long a, long b, [Runtime::InteropServices::Out] long % result);" />
      <MemberSignature Language="F#" Value="static member DivRem : int64 * int64 *  -&gt; int64" Usage="System.Math.DivRem (a, b, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Int64" />
        <Parameter Name="b" Type="System.Int64" />
        <Parameter Name="result" Type="System.Int64" RefType="out" />
      </Parameters>
      <Docs>
        <param name="a">O dividendo.</param>
        <param name="b">O divisor.</param>
        <param name="result">O restante.</param>
        <summary>Calcula o quociente de dois inteiros com sinal de 64 bits e também retorna o restante em um parâmetro de saída.</summary>
        <returns>O quociente dos números especificados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor restante é igual ao resultado do [operador de resto](~/docs/csharp/language-reference/operators/remainder-operator.md).  
  
   
  
## Examples  
 O exemplo a seguir demonstra o <xref:System.Math.DivRem%28System.Int64%2CSystem.Int64%2CSystem.Int64%40%29> método.  
  
 [!code-csharp[System.Math.DivRem#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.divrem/cs/divrem2.cs#2)]
 [!code-vb[System.Math.DivRem#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.divrem/vb/divrem2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="b" /> é zero.</exception>
        <altmember cref="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="E">
      <MemberSignature Language="C#" Value="public const double E = 2.71828182845905;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 E = (2.71828182845905)" />
      <MemberSignature Language="DocId" Value="F:System.Math.E" />
      <MemberSignature Language="VB.NET" Value="Public Const E As Double  = 2.71828182845905" />
      <MemberSignature Language="C++ CLI" Value="public: double E = 2.71828182845905;" />
      <MemberSignature Language="F#" Value="val mutable E : double" Usage="System.Math.E" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>2.71828182845905</MemberValue>
      <Docs>
        <summary>Representa a base logarítmica natural, especificada pela constante <see langword="e" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor desse campo é 2.7182818284590452354.  
  
   
  
## Examples  
 O exemplo a seguir compara <xref:System.Math.E> com o valor calculado de uma série de energia.  
  
 [!code-cpp[System.Math.E#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.E/CPP/efield.cpp#1)]
 [!code-csharp[System.Math.E#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.E/CS/efield.cs#1)]
 [!code-vb[System.Math.E#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.E/VB/efield.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static double Exp (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Exp(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Exp(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Exp(double d);" />
      <MemberSignature Language="F#" Value="static member Exp : double -&gt; double" Usage="System.Math.Exp d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número que especifica uma potência.</param>
        <summary>Retorna <see langword="e" /> elevado à potência especificada.</summary>
        <returns>O número <see langword="e" /> elevado à potência <paramref name="d" />. Se <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse valor será retornado. Se <paramref name="d" /> for igual a <see cref="F:System.Double.NegativeInfinity" />, 0 será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `e` é uma constante matemática cujo valor é aproximadamente 2,71828.  
  
 Use o <xref:System.Math.Pow%2A> método para calcular potências de outras bases.  
  
 <xref:System.Math.Exp%2A> é o inverso de <xref:System.Math.Log%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Exp%2A> para avaliar determinadas identidades exponenciais e logarítmicas para valores selecionados.  
  
 [!code-cpp[System.Math.Exp#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Exp/CPP/exp.cpp#1)]
 [!code-csharp[System.Math.Exp#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Exp/CS/exp.cs#1)]
 [!code-vb[System.Math.Exp#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Exp/VB/exp.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
        <altmember cref="M:System.Math.Log(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Floor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o maior valor integral menor ou igual ao número especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para negativo infinito.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static decimal Floor (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Floor(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Floor(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Floor : decimal -&gt; decimal" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal.</param>
        <summary>Retorna o maior valor integral menor ou igual ao número decimal especificado.</summary>
        <returns>O maior valor integral menor ou igual a <paramref name="d" />.  Observe que o método retorna um valor integral do tipo <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para negativo infinito. Em outras palavras, se `d` for positivo, qualquer componente fracionária é truncada. Se `d` é negativo, a presença de qualquer componente fracionário faz com que ele seja arredondado para o menor inteiro. A operação desse método difere de <xref:System.Math.Ceiling%2A> método, que dá suporte ao arredondamento para positivo infinito.  
  
   
  
## Examples  
 O exemplo a seguir ilustra a <xref:System.Math.Floor%28System.Decimal%29?displayProperty=nameWithType> método e ele contrastes com o <xref:System.Math.Ceiling%28System.Decimal%29> método.  
  
 [!code-csharp[System.Math.Ceiling#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#1)]
 [!code-vb[System.Math.Ceiling#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Decimal.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Floor">
      <MemberSignature Language="C#" Value="public static double Floor (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Floor(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Floor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Floor (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Floor(double d);" />
      <MemberSignature Language="F#" Value="static member Floor : double -&gt; double" Usage="System.Math.Floor d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número de ponto flutuante de precisão dupla.</param>
        <summary>Retorna o maior valor integral menor ou igual ao número de ponto flutuante de precisão dupla especificado.</summary>
        <returns>O maior valor integral menor ou igual a <paramref name="d" />. Se <paramref name="d" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse valor será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O comportamento deste método segue o padrão IEEE 754, seção 4. Este tipo de arredondamento às vezes é chamado de arredondamento para negativo infinito. Em outras palavras, se `d` for positivo, qualquer componente fracionária é truncada. Se `d` é negativo, a presença de qualquer componente fracionário faz com que ele seja arredondado para o menor inteiro. A operação desse método difere de <xref:System.Math.Ceiling%2A> método, que dá suporte ao arredondamento para positivo infinito.  

Começando com o Visual Basic 15,8, o desempenho da conversão de duplo para inteiro é otimizado se você passar o valor retornado pela `Floor` método para qualquer uma da [funções de conversão integral](~/docs/visual-basic/language-reference/functions/conversion-functions.md), ou se o valor duplo retornado por `Floor` é automaticamente convertido em um inteiro com [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) definida como desativada. Essa otimização permite que o código seja executado mais rapidamente – até duas vezes mais rápido para o código que faz um grande número de conversões para tipos de inteiro. O exemplo a seguir ilustra essas conversões otimizadas:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1043

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

## Examples  
 O exemplo a seguir ilustra a <xref:System.Math.Floor%28System.Double%29?displayProperty=nameWithType> método e ele contrastes com o <xref:System.Math.Ceiling%28System.Double%29> método.  
  
 [!code-csharp[System.Math.Ceiling#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Ceiling/cs/Ceiling1.cs#2)]
 [!code-vb[System.Math.Ceiling#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Ceiling/vb/Ceiling1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="IEEERemainder">
      <MemberSignature Language="C#" Value="public static double IEEERemainder (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 IEEERemainder(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.IEEERemainder(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IEEERemainder (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double IEEERemainder(double x, double y);" />
      <MemberSignature Language="F#" Value="static member IEEERemainder : double * double -&gt; double" Usage="System.Math.IEEERemainder (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Um dividendo.</param>
        <param name="y">Um divisor.</param>
        <summary>Retorna o resultado restante da divisão de um número especificado por outro número especificado.</summary>
        <returns>Um número igual a <paramref name="x" /> - (<paramref name="y" /> Q), em que Q é o quociente de <paramref name="x" /> / <paramref name="y" /> arredondado para o inteiro mais próximo (se <paramref name="x" /> / <paramref name="y" /> ficar entre dois inteiros, o inteiro par será retornado).  
  
Se <paramref name="x" /> – (<paramref name="y" /> Q) for igual a zero, o valor +0 será retornado se <paramref name="x" /> for positivo ou -0 se <paramref name="x" /> for negativo.  
  
Se <paramref name="y" /> = 0, <see cref="F:System.Double.NaN" /> é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta operação está em conformidade com a operação remainder definida na seção 5.1 do ANSI/IEEE Std 754-1985; Padrão IEEE para aritmética de ponto flutuante binário; Institute of elétrica e Electronics Engineers, Inc; 1985.  
  
 O <xref:System.Math.IEEERemainder%2A> método não é igual a [operador de resto](~/docs/csharp/language-reference/operators/remainder-operator.md). Embora ambos retornem o resto após a divisão, as fórmulas que usam são diferentes. A fórmula para o <xref:System.Math.IEEERemainder%2A> método é:  
  
```  
IEEERemainder = dividend - (divisor * Math.Round(dividend / divisor))  
```  
  
 Por outro lado, a fórmula para o operador de restante é:  
  
```  
Remainder = (Math.Abs(dividend) - (Math.Abs(divisor) *   
            (Math.Floor(Math.Abs(dividend) / Math.Abs(divisor))))) *   
            Math.Sign(dividend)  
```  
  
   
  
## Examples  
 O exemplo a seguir compara o restante retornado pela <xref:System.Math.IEEERemainder%2A> método com o restante retornado pelo [operador de resto](~/docs/csharp/language-reference/operators/remainder-operator.md).  
  
 [!code-csharp[System.Math.IEEERemainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.ieeeremainder/cs/ieeeremainder1.cs#1)]
 [!code-vb[System.Math.IEEERemainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.ieeeremainder/vb/ieeeremainder1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o logaritmo de um número especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double d);" />
      <MemberSignature Language="F#" Value="static member Log : double -&gt; double" Usage="System.Math.Log d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">O número cujo logaritmo deve ser encontrado.</param>
        <summary>Retorna o logaritmo natural (de base <see langword="e" />) de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="d" /></term><description> Valor retornado 
 </description></listheader><item><term> Positivo 
 </term><description> O logaritmo natural de <paramref name="d" />; ou seja, ln <paramref name="d" /> ou log e <paramref name="d" /></description></item><item><term> Zero 
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negativo 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `d` é especificado como um número de base 10.  
  
   
  
## Examples  
 O exemplo a seguir ilustra o <xref:System.Math.Log%2A> método.  
  
 [!code-csharp[System.Math.Log_Overloads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/log1.cs#2)]
 [!code-vb[System.Math.Log_Overloads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/log1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Math.E" />
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (double a, double newBase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(float64 a, float64 newBase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (a As Double, newBase As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(double a, double newBase);" />
      <MemberSignature Language="F#" Value="static member Log : double * double -&gt; double" Usage="System.Math.Log (a, newBase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
        <Parameter Name="newBase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">O número cujo logaritmo deve ser encontrado.</param>
        <param name="newBase">A base do logaritmo.</param>
        <summary>Retorna o logaritmo de um número especificado em uma base especificada.</summary>
        <returns>Um dos valores na tabela a seguir. (+Infinito indica <see cref="F:System.Double.PositiveInfinity" />, -Infinito indica <see cref="F:System.Double.NegativeInfinity" /> e NaN indica <see cref="F:System.Double.NaN" />.) 
 <list type="table"><listheader><term><paramref name="a" /></term><description><paramref name="newBase" /></description><description> Valor retornado 
 </description></listheader><item><term><paramref name="a" />&gt; 0 
 </term><description> (0 &lt;<paramref name="newBase" />&lt; 1) -ou- (<paramref name="newBase" />&gt; 1) 
 </description><description> lognewBase(a) 
 </description></item><item><term><paramref name="a" />&lt; 0 
 </term><description> (nenhum valor) 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" />&lt; 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="a" /> != 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> NaN 
 </description></item><item><term><paramref name="a" /> != 1 
 </term><description><paramref name="newBase" /> = +Infinito 
 </description><description> NaN 
 </description></item><item><term><paramref name="a" /> = NaN 
 </term><description> (nenhum valor) 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" /> = NaN 
 </description><description> NaN 
 </description></item><item><term> (nenhum valor) 
 </term><description><paramref name="newBase" /> = 1 
 </description><description> NaN 
 </description></item><item><term><paramref name="a" /> = 0 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> +Infinito 
 </description></item><item><term><paramref name="a" /> = 0 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> -Infinito 
 </description></item><item><term><paramref name="a" /> = +Infinito 
 </term><description> 0 &lt;<paramref name="newBase" />&lt; 1 
 </description><description> -Infinito 
 </description></item><item><term><paramref name="a" /> = +Infinito 
 </term><description><paramref name="newBase" />&gt; 1 
 </description><description> +Infinito 
 </description></item><item><term><paramref name="a" /> = 1 
 </term><description><paramref name="newBase" /> = 0 
 </description><description> 0 
 </description></item><item><term><paramref name="a" /> = 1 
 </term><description><paramref name="newBase" /> = +Infinito 
 </description><description> 0 
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Log%2A> para avaliar determinadas identidades logarítmicas para valores selecionados.  
  
 [!code-cpp[System.Math.Log_Overloads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CPP/loggen.cpp#1)]
 [!code-csharp[System.Math.Log_Overloads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log_Overloads/CS/loggen.cs#1)]
 [!code-vb[System.Math.Log_Overloads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log_Overloads/VB/loggen.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Log10(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(double d);" />
      <MemberSignature Language="F#" Value="static member Log10 : double -&gt; double" Usage="System.Math.Log10 d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número cujo logaritmo deve ser localizado.</param>
        <summary>Retorna o logaritmo de base 10 de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="d" /></term><description> Valor retornado 
 </description></listheader><item><term> Positivo 
 </term><description> O log de base 10 de <paramref name="d" />; ou seja, log 10<paramref name="d" />.  
  
 </description></item><item><term> Zero 
 </term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Negativo 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> Igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Parâmetro `d` é especificado como um número de base 10.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Log10%2A> método para retornar o logaritmo de base 10 para os valores selecionados.  
  
 [!code-csharp[System.Math.Log10#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Log10/CS/log10.cs#1)]
 [!code-vb[System.Math.Log10#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Log10/VB/log10.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Max">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o maior dos dois números especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static byte Max (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Max(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Max(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Max : byte * byte -&gt; byte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro entre dois inteiros sem sinal de 8 bits a serem comparados.</param>
        <param name="val2">O segundo entre dois inteiros sem sinal de 8 bits a serem comparados.</param>
        <summary>Retorna o maior entre dois inteiros sem sinal de 8 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static decimal Max (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Max(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Max(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Max : decimal * decimal -&gt; decimal" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números decimais a ser comparado.</param>
        <param name="val2">O segundo dos dois números decimais a serem comparados.</param>
        <summary>Retorna o maior dos dois números decimais.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static double Max (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Max(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Max(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Max : double * double -&gt; double" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números de ponto flutuante de precisão dupla a ser comparado.</param>
        <param name="val2">O segundo dos dois números de ponto flutuante de precisão dupla a ser comparado.</param>
        <summary>Retorna o maior dos dois números de ponto flutuante de precisão dupla.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior. Se <paramref name="val1" />, <paramref name="val2" /> ou tanto <paramref name="val1" /> quanto <paramref name="val2" /> forem iguais a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static short Max (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Max(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Max(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Max : int16 * int16 -&gt; int16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 16 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 16 bits a serem comparados.</param>
        <summary>Retorna o maior dos dois inteiros com sinal de 16 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static int Max (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Max(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Max(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Max : int * int -&gt; int" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 32 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 32 bits a serem comparados.</param>
        <summary>Retorna o maior dos dois inteiros com sinal de 32 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static long Max (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Max(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Max(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Max : int64 * int64 -&gt; int64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 64 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 64 bits a serem comparados.</param>
        <summary>Retorna o maior dos dois inteiros com sinal de 64 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static sbyte Max (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Max(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Max(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Max : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 8 bits a serem comparados.</param>
        <param name="val2">O segundo dos dois inteiros com sinal de 8 bits a serem comparados.</param>
        <summary>Retorna o maior dos dois inteiros com sinal de 8 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static float Max (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Max(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Max(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Max : single * single -&gt; single" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="val2">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna o maior dos dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior. Se <paramref name="val1" />, <paramref name="val2" /> ou ambos <paramref name="val1" /> e <paramref name="val2" /> forem igual a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ushort Max (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Max(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Max(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint16 * uint16 -&gt; uint16" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros sem sinal de 16 bits para comparar.</param>
        <param name="val2">O segundo dos dois inteiros sem sinal de 16 bits para comparar.</param>
        <summary>Retorna o maior de dois inteiros sem sinal de 16 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static uint Max (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Max(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Max(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint32 * uint32 -&gt; uint32" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro de dois inteiros sem sinal de 32 bits a serem comparados.</param>
        <param name="val2">O segundo de dois inteiros sem sinal de 32 bits a serem comparados.</param>
        <summary>Retorna o maior de dois inteiros sem sinal de 32 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static ulong Max (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Max(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Max(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Max(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Max : uint64 * uint64 -&gt; uint64" Usage="System.Math.Max (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro de dois inteiros sem sinal de 64 bits a serem comparados.</param>
        <param name="val2">O segundo de dois inteiros sem sinal de 64 bits a serem comparados.</param>
        <summary>Retorna o maior entre dois inteiros sem sinal de 64 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for maior.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Max%2A> para retornar e exibir a maior de duas variáveis.  
  
 [!code-cpp[Math.Max#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.max/CPP/max.cpp#1)]
 [!code-csharp[Math.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.max/CS/max.cs#1)]
 [!code-vb[Math.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.max/VB/max.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Min">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o menor de dois números.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static byte Min (byte val1, byte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 Min(unsigned int8 val1, unsigned int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Byte,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Byte, val2 As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte Min(System::Byte val1, System::Byte val2);" />
      <MemberSignature Language="F#" Value="static member Min : byte * byte -&gt; byte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Byte" />
        <Parameter Name="val2" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro entre dois inteiros sem sinal de 8 bits a serem comparados.</param>
        <param name="val2">O segundo entre dois inteiros sem sinal de 8 bits a serem comparados.</param>
        <summary>Retorna o menor dos dois inteiros sem sinal de 8 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static decimal Min (decimal val1, decimal val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Min(valuetype System.Decimal val1, valuetype System.Decimal val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Decimal,System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Decimal, val2 As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Min(System::Decimal val1, System::Decimal val2);" />
      <MemberSignature Language="F#" Value="static member Min : decimal * decimal -&gt; decimal" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Decimal" />
        <Parameter Name="val2" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números decimais a ser comparado.</param>
        <param name="val2">O segundo dos dois números decimais a serem comparados.</param>
        <summary>Retorna o menor dos dois números decimais.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static double Min (double val1, double val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Min(float64 val1, float64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Double, val2 As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Min(double val1, double val2);" />
      <MemberSignature Language="F#" Value="static member Min : double * double -&gt; double" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Double" />
        <Parameter Name="val2" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números de ponto flutuante de precisão dupla a ser comparado.</param>
        <param name="val2">O segundo dos dois números de ponto flutuante de precisão dupla a ser comparado.</param>
        <summary>Retorna o menor dos dois números de ponto flutuante de precisão dupla.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor. Se <paramref name="val1" />, <paramref name="val2" /> ou tanto <paramref name="val1" /> quanto <paramref name="val2" /> forem iguais a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static short Min (short val1, short val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 Min(int16 val1, int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int16,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Short, val2 As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short Min(short val1, short val2);" />
      <MemberSignature Language="F#" Value="static member Min : int16 * int16 -&gt; int16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int16" />
        <Parameter Name="val2" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 16 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 16 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros com sinal de 16 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static int Min (int val1, int val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Min(int32 val1, int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Integer, val2 As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Min(int val1, int val2);" />
      <MemberSignature Language="F#" Value="static member Min : int * int -&gt; int" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int32" />
        <Parameter Name="val2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 32 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 32 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros com sinal de 32 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static long Min (long val1, long val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 Min(int64 val1, int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Long, val2 As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Min(long val1, long val2);" />
      <MemberSignature Language="F#" Value="static member Min : int64 * int64 -&gt; int64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Int64" />
        <Parameter Name="val2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 64 bits a ser comparado.</param>
        <param name="val2">O segundo de dois inteiros com sinal de 64 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros com sinal de 64 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static sbyte Min (sbyte val1, sbyte val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 Min(int8 val1, int8 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.SByte,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As SByte, val2 As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte Min(System::SByte val1, System::SByte val2);" />
      <MemberSignature Language="F#" Value="static member Min : sbyte * sbyte -&gt; sbyte" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.SByte" />
        <Parameter Name="val2" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros com sinal de 8 bits a serem comparados.</param>
        <param name="val2">O segundo dos dois inteiros com sinal de 8 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros com sinal de 8 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static float Min (float val1, float val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Min(float32 val1, float32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As Single, val2 As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Min(float val1, float val2);" />
      <MemberSignature Language="F#" Value="static member Min : single * single -&gt; single" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.Single" />
        <Parameter Name="val2" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <param name="val2">O segundo dos dois números de ponto flutuante de precisão simples a ser comparado.</param>
        <summary>Retorna o menor de dois números de ponto flutuante de precisão simples.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor. Se <paramref name="val1" />, <paramref name="val2" /> ou tanto <paramref name="val1" /> quanto <paramref name="val2" /> forem iguais a <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NaN" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ushort Min (ushort val1, ushort val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 Min(unsigned int16 val1, unsigned int16 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt16,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UShort, val2 As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 Min(System::UInt16 val1, System::UInt16 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint16 * uint16 -&gt; uint16" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt16" />
        <Parameter Name="val2" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro dos dois inteiros sem sinal de 16 bits para comparar.</param>
        <param name="val2">O segundo dos dois inteiros sem sinal de 16 bits para comparar.</param>
        <summary>Retorna o menor dos dois inteiros sem sinal de 16 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static uint Min (uint val1, uint val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 Min(unsigned int32 val1, unsigned int32 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As UInteger, val2 As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 Min(System::UInt32 val1, System::UInt32 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint32 * uint32 -&gt; uint32" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt32" />
        <Parameter Name="val2" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro de dois inteiros sem sinal de 32 bits a serem comparados.</param>
        <param name="val2">O segundo de dois inteiros sem sinal de 32 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros sem sinal de 32 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static ulong Min (ulong val1, ulong val2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 Min(unsigned int64 val1, unsigned int64 val2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Min(System.UInt64,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (val1 As ULong, val2 As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 Min(System::UInt64 val1, System::UInt64 val2);" />
      <MemberSignature Language="F#" Value="static member Min : uint64 * uint64 -&gt; uint64" Usage="System.Math.Min (val1, val2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="val1" Type="System.UInt64" />
        <Parameter Name="val2" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="val1">O primeiro de dois inteiros sem sinal de 64 bits a serem comparados.</param>
        <param name="val2">O segundo de dois inteiros sem sinal de 64 bits a serem comparados.</param>
        <summary>Retorna o menor de dois inteiros sem sinal de 64 bits.</summary>
        <returns>Parâmetro <paramref name="val1" /> ou <paramref name="val2" />, o que for menor.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o método <xref:System.Math.Min%2A> para retornar e exibir a menor de duas variáveis.  
  
 [!code-cpp[Math.Min#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.min/CPP/min.cpp#1)]
 [!code-csharp[Math.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.min/CS/min.cs#1)]
 [!code-vb[Math.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.min/VB/min.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PI">
      <MemberSignature Language="C#" Value="public const double PI = 3.14159265358979;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PI = (3.14159265358979)" />
      <MemberSignature Language="DocId" Value="F:System.Math.PI" />
      <MemberSignature Language="VB.NET" Value="Public Const PI As Double  = 3.14159265358979" />
      <MemberSignature Language="C++ CLI" Value="public: double PI = 3.14159265358979;" />
      <MemberSignature Language="F#" Value="val mutable PI : double" Usage="System.Math.PI" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>3.14159265358979</MemberValue>
      <Docs>
        <summary>Representa a razão entre a circunferência de um círculo e seu diâmetro, especificada pela constante π.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor desse campo é 3.14159265358979323846.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.PI> para auxiliar na computação dos ângulos internas de um determinado Trapézio.  
  
 [!code-cpp[MathSample#1](~/samples/snippets/cpp/VS_Snippets_CLR/MathSample/CPP/mathsample.cpp#1)]
 [!code-csharp[MathSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/MathSample/CS/mathsample.cs#1)]
 [!code-vb[MathSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MathSample/VB/mathsample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static double Pow (double x, double y);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Pow(float64 x, float64 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Pow(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (x As Double, y As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Pow(double x, double y);" />
      <MemberSignature Language="F#" Value="static member Pow : double * double -&gt; double" Usage="System.Math.Pow (x, y)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Double" />
        <Parameter Name="y" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="x">Um número de ponto flutuante de precisão dupla a ser elevado a uma potência.</param>
        <param name="y">Um número de ponto flutuante de precisão dupla que especifica uma potência.</param>
        <summary>Retorna um número especificado elevado à potência especificada.</summary>
        <returns>O número <paramref name="x" /> elevado à potência <paramref name="y" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir indica o valor de retorno quando vários valores ou intervalos de valores são especificados para o `x` e `y` parâmetros. Para obter mais informações, consulte <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> e <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
|Parâmetros|Valor retornado|  
|----------------|------------------|  
|`x` ou `y`  =  `NaN`.|`NaN`|  
|`x` = Qualquer valor exceto `NaN`; `y` = 0.|1|  
|`x` = `NegativeInfinity`; `y` < 0.|0|  
|`x` = `NegativeInfinity`; `y` é um número inteiro ímpar.|`NegativeInfinity`|  
|`x` = `NegativeInfinity`; `y` é positivo, mas não é um inteiro ímpar.|`PositiveInfinity`|  
|`x` < 0, mas não `NegativeInfinity`; `y` não é um inteiro `NegativeInfinity`, ou `PositiveInfinity`.|`NaN`|  
|`x` = -1; `y`  =  `NegativeInfinity` ou `PositiveInfinity`.|`NaN`|  
|-1 < `x` < 1; `y` = `NegativeInfinity`.|`PositiveInfinity`|  
|-1 < `x` < 1; `y` = `PositiveInfinity`.|0|  
|`x` < -1 ou `x` > 1; `y` = `NegativeInfinity`.|0|  
|`x` < -1 ou `x` > 1; `y` = `PositiveInfinity`.|`PositiveInfinity`|  
|`x` = 0; `y` < 0.|`PositiveInfinity`|  
|`x` = 0; `y` > 0.|0|  
|`x` = 1; `y` é qualquer valor exceto `NaN`.|1|  
|`x` = `PositiveInfinity`; `y` < 0.|0|  
|`x` = `PositiveInfinity`; `y` > 0.|`PositiveInfinity`|  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Math.Pow%2A> método para calcular o valor resultante da geração 2 a uma potência, variando de 0 a 32.  
  
 [!code-csharp[System.Math.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.pow/cs/pow1.cs#1)]
 [!code-vb[System.Math.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sqrt(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Round">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Arredonda um valor para o inteiro mais próximo ou para o número especificado de casas decimais.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nesta seção:  
  
 [Sintaxe de método sobrecarregada](#Syntax)   
 [Parâmetros](#Params)   
 [Valor de retorno](#Returns)   
 [Exceções](#Exceptions)   
 [Qual método chamar?](#Tasks)   
 [Valores de ponto médio e convenções arredondamento](#Midpoint)   
 [Arredondamento e precisão](#Precision)   
 [Valores de ponto flutuante de arredondamento e precisão simples](#Single)   
 Exemplos:   
 [Math.Round(Decimal)](#Round1_Example)  
 [Math.Round(Double)](#Round2_Example)  
 [Math.Round(Decimal, Int32)](#Round3_Example)  
 [Math.Round(Decimal, MidpointRounding)](#Round4_Example)  
 [Math. Round (Double, Int32)](#Round5_Example)  
 [Math. Round (Double, MidpointRounding)](#Round6_Example)  
 [Math.Round(Decimal, Int32, MidpointRounding)](#Round7_Example)  
 [Math. Round (Double, Int32, MidpointRounding)](#Round8_Example)  
[Informações de versão](#Round_Versions)  
  
<a name="Syntax"></a>   
## <a name="overloaded-method-syntax"></a>Sintaxe de método sobrecarregada  
 Para obter orientação adicional sobre como escolher uma sobrecarga, consulte [qual método devo chamar?](#Tasks)  
  
 `Decimal Math.Round(Decimal``d``)`  
 Arredonda um valor decimal para o inteiro mais próximo e Arredonda os valores de ponto médio para o número par mais próximo ([exemplo](#Round1_Example)).  
  
 `Double Math.Round(Double``a``)`  
 Arredonda um valor de ponto flutuante de precisão dupla para o inteiro mais próximo e Arredonda os valores de ponto médio para o número par mais próximo ([exemplo](#Round2_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `)`  
 Arredonda um valor decimal para um número especificado de dígitos fracionários e Arredonda os valores de ponto médio para o número par mais próximo ([exemplo](#Round3_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `)`  
 Arredonda um valor de ponto flutuante de precisão dupla para um número especificado de dígitos fracionários e Arredonda os valores de ponto médio para o número par mais próximo ([exemplo](#Round4_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, MidpointRounding`  `mode` `)`  
 Arredonda um valor decimal para o inteiro mais próximo e usa a convenção de arredondamento especificada para os valores de ponto médio ([exemplo](#Round5_Example)).  
  
 `Double Math.Round(Double` `value` `, MidpointRounding`  `mode` `)`  
 Arredonda um valor de ponto flutuante de precisão dupla para o inteiro mais próximo e usa a convenção de arredondamento especificada para os valores de ponto médio ([exemplo](#Round6_Example)).  
  
 `Decimal Math.Round(Decimal` `d` `, Int32`  `decimals` `, MidpointRounding`  `mode` `)`  
 Arredonda um valor decimal para um número especificado de dígitos fracionários e usa a convenção de arredondamento especificada para os valores de ponto médio ([exemplo](#Round7_Example)).  
  
 `Double Math.Round(Double` `value` `, Int32`  `digits` `, MidpointRounding`  `mode` `)`  
 Arredonda um valor de ponto flutuante de precisão dupla para um número especificado de dígitos fracionários e usa a convenção de arredondamento especificada para os valores de ponto médio ([exemplo](#Round8_Example)).  
  
<a name="Params"></a>   
## <a name="parameters"></a>Parâmetros  
 Esta é uma lista completa de parâmetros para o <xref:System.Math.Round%2A> método. Para os parâmetros usados por cada sobrecarga, consulte a sintaxe de sobrecarga acima.  
  
|Parâmetro|Tipo|Descrição|  
|---------------|----------|-----------------|  
|`d`|<xref:System.Decimal>|Um número a ser arredondado.|  
|`a`<br /><br /> - ou -<br /><br /> `value`|<xref:System.Double>|Um número de ponto flutuante de precisão dupla a ser arredondado.|  
|`decimals`<br /><br /> - ou -<br /><br /> `digits`|<xref:System.Int32>|O número de dígitos fracionários no valor de retorno. Para <xref:System.Decimal> valores, ele pode variar de 0 a 28. Para <xref:System.Double> valores, ele pode variar de 0 a 15. Observe que os 15 é o número máximo de dígitos integrais e fracionários compatíveis com o <xref:System.Double> tipo.<br /><br /> Valor padrão: 0, o que é arredondado para um número inteiro|  
|`mode`|<xref:System.MidpointRounding>|Um sinalizador que especifica a convenção a ser usada para o arredondamento de valores de ponto médio. Ver [valores de ponto médio e convenções arredondamento](#Midpoint).<br /><br /> Valor padrão: <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType>|  
  
<a name="Returns"></a>   
## <a name="return-value"></a>Valor retornado  
 Tipo: <xref:System.Decimal> ou <xref:System.Double>, dependendo do tipo do valor a ser arredondado.   
Um valor numérico do mesmo tipo como `d`, `a`, ou `value`, mas arredondado para um número inteiro ou para o número especificado de dígitos decimais. Ver [valores de ponto médio e convenções arredondamento](#Midpoint) para obter informações sobre números com valores de ponto médio de arredondamento.  
  
> [!WARNING]
>  Quando o arredondamento de valores de ponto médio, o algoritmo de arredondamento executa um teste de igualdade. Devido a problemas de representação binária e precisão no formato de ponto flutuante, o valor retornado pelo método pode ser inesperado. Para obter mais informações, consulte [arredondamento e precisão](#Precision).  
  
 Se uma sobrecarga com um <xref:System.Double> parâmetro é chamado com <xref:System.Double.NaN?displayProperty=nameWithType>, o método retorna <xref:System.Double.NaN?displayProperty=nameWithType>. Se ele for chamado com <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, o método retorna <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ou <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, respectivamente.  
  
<a name="Exceptions"></a>   
## <a name="exceptions"></a>Exceções  
  
|Exceção|Condição|Lançado por|  
|---------------|---------------|---------------|  
|<xref:System.OverflowException>|O resultado é fora do intervalo da <xref:System.Decimal> tipo.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentOutOfRangeException>|`decimals` é menor que 0 ou maior que 28.<br /><br /> - ou -<br /><br /> `digits` é menor que 0 ou maior que 15.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|<xref:System.ArgumentException>|`mode` não é um valor válido de <xref:System.MidpointRounding>.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
  
<a name="Tasks"></a>   
## <a name="which-method-do-i-call"></a>Qual método devo chamar?  
  
|Para|Call|  
|--------|----------|  
|Arredondar um número em um inteiro usando o arredondamento mais próximo convenção.|<xref:System.Math.Round%28System.Decimal%29><br /><br /> - ou -<br /><br /> <xref:System.Math.Round%28System.Double%29>|  
|Arredonda um número em um inteiro usando um arredondamento convenção.|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29><br /><br /> - ou -<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|  
|Arredondar um número para um número especificado de dígitos fracionários, usando o arredondamento mais próximo convenção.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29><br /><br /> - ou -<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|  
|Arredonda um número para um número especificado de dígitos fracionários usando um arredondamento convenção.|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29><br /><br /> - ou -<br /><br /> <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|  
|Round um <xref:System.Single> valor para um número especificado de dígitos fracionários usando uma convenção de arredondamento e especificados minimiza a perda de precisão.|Converter o <xref:System.Single> para um <xref:System.Decimal> e chame <xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>.|  
|Arredondar um número para um número especificado de dígitos fracionários, minimizando os problemas de precisão em valores de ponto médio de arredondamento.|Chame um método de arredondamento que implementa uma comparação "maior que ou aproximadamente igual a". Ver [arredondamento e precisão](#Precision).|  
|Arredondar um valor fracionário para um número inteiro que é maior que o valor fracionário. Por exemplo, arredonde 3.1 para 4.|<xref:System.Math.Ceiling%2A>|  
|Arredondar um valor fracionário para um número inteiro que é menor que o valor fracionário. Por exemplo, arredonde 3.9 a 3.|<xref:System.Math.Floor%2A>|  
  
<a name="Midpoint"></a>   
## <a name="midpoint-values-and-rounding-conventions"></a>Valores de ponto médio e convenções arredondamento  
 Arredondamento envolve a conversão de um valor numérico com uma precisão especificada para o valor mais próximo com menos precisão. Por exemplo, você pode usar o <xref:System.Math.Round%28System.Double%29> método para arredondar um valor de 3.4 a 3.0 e o <xref:System.Math.Round%28System.Double%2CSystem.Int32%29> método para arredondar um valor de 3.579 para 3,58.  
  
 Em um valor de ponto médio, o valor após os dígitos menos significativos no resultado é precisamente metade do caminho entre dois números. Por exemplo, 3.47500 é um valor de ponto médio se ele deve ser arredondado duas casas decimais e 7.500 é um valor de ponto médio, se for a ser arredondado para um número inteiro. Nesses casos, o valor mais próximo não pode ser identificado facilmente sem uma convenção de arredondamento.  
  
 O <xref:System.Math.Round%2A> método dá suporte a duas convenções arredondamento para lidar com valores de ponto médio:  
  
 **Arredondamento para cima**  
 Valores de ponto médio são arredondados para o próximo número diferente de zero. Por exemplo, 3,75 Arredonda para 3.8, 3.85 Arredonda para 3.9,-3.75 Arredonda para-3.8, e-3.85 Arredonda para-3.9. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding.AwayFromZero?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento para cima é a forma mais amplamente conhecida de arredondamento.  
  
 **Arredondamento mais próximo ou arredondamento bancário**  
 Valores de ponto médio são arredondados para o número par mais próximo. Por exemplo, 3,75 e 3,85 arredondar 3.8 e-3.75 e-3.85 arredondam-3.8. Essa forma de arredondamento é representada pelo <xref:System.MidpointRounding.ToEven?displayProperty=nameWithType> membro de enumeração.  
  
 Arredondamento mais próximo é o formulário padrão de arredondamento usados em operações financeiras e estatísticas. Ele segue o padrão IEEE 754, seção 4. Quando usado em várias operações de arredondamento, ele reduz o erro de arredondamento é causado por arredondar consistentemente os valores de ponto médio em uma única direção. Em alguns casos, esse erro de arredondamento pode ser significativo.  
  
 O exemplo a seguir ilustra a diferença que pode resultar de arredondar consistentemente os valores de ponto médio em uma única direção. O exemplo calcula a média real de uma matriz de <xref:System.Decimal> valores e, em seguida, calcula a média, quando os valores na matriz são arredondados, usando as convenções de dois. Neste exemplo, a média real e a média que resulta quando o arredondamento mais próximo são os mesmos. No entanto, a média que resulta quando o arredondamento para cima difere por.05 (ou por % 3.6) a média real.  
  
 [!code-csharp[System.Math.Round.Overload#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mean1.cs#2)]
 [!code-vb[System.Math.Round.Overload#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mean1.vb#2)]  
  
 Por padrão, o <xref:System.Math.Round%2A> método usa o arredondamento mais próximo convenção. A tabela a seguir lista as sobrecargas do <xref:System.Math.Round%2A> método e a convenção de arredondamento que cada uma usa.  
  
|Sobrecarga|Convenção de arredondamento|  
|--------------|-------------------------|  
|<xref:System.Math.Round%28System.Decimal%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%29>|<xref:System.MidpointRounding.ToEven>|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29>|Determinado pelo `mode` parâmetro.|  
|<xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29>|Determinado pelo parâmetro `mode`|  
|<xref:System.Math.Round%28System.Decimal%2CSystem.Int32%2CSystem.MidpointRounding%29>|Determinado pelo parâmetro `mode`|  
|<xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29>|Determinado pelo parâmetro `mode`|  
  
<a name="Precision"></a>   
## <a name="rounding-and-precision"></a>Arredondamento e precisão  
 Para determinar se uma operação de arredondamento envolve um valor de ponto médio, o <xref:System.Math.Round%2A> método multiplica o valor original deve ser arredondada por 10<sup>n</sup>, onde *n* é o número desejado de fracionários dígitos no valor de retorno e, em seguida, determina se a parte fracionária restante do valor é maior que ou igual para. 5. Essa é uma variação pequena em um teste de igualdade e, conforme discutido na seção "Teste de igualdade" o <xref:System.Double> tópico de referência, testa a igualdade com valores de ponto flutuante é problemáticas devido a problemas do formato de ponto flutuante com binário representação e precisão. Isso significa que qualquer parte fracionária de um número que é um pouco menor que.5 (devido a uma perda de precisão) não será arredondado para cima.  
  
 O exemplo a seguir ilustra o problema. Repetidamente, ele adiciona.1 para 11.0 e Arredonda o resultado para o inteiro mais próximo. Independentemente da convenção de arredondamento 11.5 devem ser arredondados para 12. No entanto, como a saída do exemplo mostra, isso não acontece. O exemplo usa o "R" [cadeia de caracteres de formato numérico padrão](~/docs/standard/base-types/standard-numeric-format-strings.md) para exibir o ponto flutuante do valor precisão total e mostra que o valor a ser arredondado perdeu a precisão durante adições repetidas e seu valor é, na verdade, 11.499999999999998. Como.499999999999998 é menor que.5, o valor não é arredondado até o próximo inteiro mais alto. Como o exemplo também mostra, esse problema não ocorrerá se simplesmente atribuímos o valor da constante 11.5 para um <xref:System.Double> variável.  
  
 [!code-csharp[System.Math.Round.Overload#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision1.cs#7)]
 [!code-vb[System.Math.Round.Overload#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision1.vb#7)]  
  
 Problemas de precisão na arredondamento de valores de ponto médio são mais probabilidade de ocorrer nas seguintes condições:  
  
-   Quando um valor fracionário não pode ser expressas com precisão em formato binário de ponto flutuante do tipo.  
  
-   Quando o valor a ser arredondado é calculado de uma ou mais operações de ponto flutuantes.  
  
-   Quando o valor a ser arredondado é uma <xref:System.Single> em vez de uma <xref:System.Double> ou <xref:System.Decimal>. Para obter mais informações, consulte a próxima seção, [arredondamento e valores de ponto flutuante de precisão simples](#Single).  
  
 Em casos em que a falta de precisão em operações de arredondamento é problemática, você pode fazer o seguinte:  
  
-   Se a operação de arredondamento chama uma sobrecarga que Arredonda um <xref:System.Double> valor, você pode alterar o <xref:System.Double> para um <xref:System.Decimal> de valor e chame uma sobrecarga que Arredonda um <xref:System.Decimal> valor em vez disso. Embora o <xref:System.Decimal> tipo de dados também tem problemas de representação e perda de precisão, esses problemas são muito menos comuns.  
  
-   Defina um algoritmo de arredondamento personalizado que executa um teste de "quase igual" para determinar se o valor a ser arredondado aceitável está perto de um valor de ponto médio. O exemplo a seguir define uma `RoundApproximate` método examina se um valor fracionário suficientemente está perto de um valor de ponto médio esteja sujeito a arredondamento de ponto médio. Como mostra a saída do exemplo, ele corrige o problema de arredondamento mostrado no exemplo anterior.  
  
     [!code-csharp[System.Math.Round.Overload#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/precision2.cs#8)]
     [!code-vb[System.Math.Round.Overload#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/precision2.vb#8)]  
  
<a name="Single"></a>   
## <a name="rounding-and-single-precision-floating-point-values"></a>Arredondamento e valores de ponto flutuante de precisão simples  
 O <xref:System.Math.Round%2A> sobrecargas que aceitam argumentos de tipo do método inclui <xref:System.Decimal> e <xref:System.Double>. Não há métodos que os valores do tipo ida e volta <xref:System.Single>. Se você passar uma <xref:System.Single> valor para uma das sobrecargas do <xref:System.Math.Round%2A> método, ele será convertido (em c#) ou convertido (no Visual Basic) em um <xref:System.Double>e o correspondente <xref:System.Math.Round%2A> sobrecarga com um <xref:System.Double> parâmetro é chamado. Embora essa seja uma conversão de ampliação, ele geralmente envolve uma perda de precisão, como mostra o exemplo a seguir. Quando um <xref:System.Single> valor 16.325 é passado para o <xref:System.Math.Round%2A> método e arredondado para duas casas decimais usando o arredondamento mais próximo convenção, o resultado é o resultado 16.33 e não o esperado da 16.32.  
  
 [!code-csharp[System.Math.Round.Overload#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/single1.cs#1)]
 [!code-vb[System.Math.Round.Overload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/single1.vb#1)]  
  
 Esse resultado inesperado é devido à perda de precisão na conversão do <xref:System.Single> de valor para um <xref:System.Double>. Porque resultante <xref:System.Double> valor 16.325000762939453 não é um valor de ponto médio e for maior que 16.325, ele sempre é arredondado para cima.  
  
 Em muitos casos, como mostra o exemplo, a perda de precisão pode ser minimizada ou eliminada por conversão de <xref:System.Single> de valor para um <xref:System.Decimal>. Observe que, como esta é uma conversão de restrição, ele requer usando um operador cast ou chamando um método de conversão.  
  
<a name="Round1_Example"></a>   
## <a name="mathrounddecimal-example"></a>Exemplo de Math.Round(Decimal)  
 O exemplo a seguir demonstra o <xref:System.Math.Round%28System.Decimal%29> método. Observe que o <xref:System.Decimal> Arredonda para o valor de 4,5 para 4 em vez de 5, porque essa sobrecarga usa o padrão <xref:System.MidpointRounding.ToEven> convenção.  
  
 [!code-csharp[System.Math.Round#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/rounddecimal1.cs#6)]
 [!code-vb[System.Math.Round#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/rounddecimal1.vb#6)]  
  
<a name="Round2_Example"></a>   
## <a name="mathrounddouble-example"></a>Exemplo de Math.Round(Double)  
 O exemplo a seguir demonstra o arredondamento para o valor inteiro mais próximo.  
  
 [!code-cpp[Classic Math.Round Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round Example/VB/source.vb#1)]  
  
<a name="Round3_Example"></a>   
## <a name="mathrounddecimal-int32-example"></a>Exemplo de Math.Round(Decimal, Int32)  
 O exemplo a seguir Arredonda valores decimais com dois dígitos fracionários a valores que têm um único dígito fracionário.  
  
 [!code-csharp[System.Math.Round.Overload#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/source.cs#3)]
 [!code-vb[System.Math.Round.Overload#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/source.vb#3)]  
  
<a name="Round4_Example"></a>   
## <a name="mathrounddouble-int32-example"></a>Exemplo de Math.Round(Double, Int32)  
 O exemplo a seguir Arredonda valores duplos com dois dígitos fracionários a duplos que têm um único dígito fracionário.  
  
 [!code-cpp[Classic Math.Round2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Math.Round2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Math.Round2 Example/CS/source.cs#1)]
 [!code-vb[Classic Math.Round2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Math.Round2 Example/VB/source.vb#1)]  
  
<a name="Round5_Example"></a>   
## <a name="mathrounddecimal-midpointrounding-example"></a>Exemplo de Math.Round(Decimal, MidpointRounding)  
 O exemplo a seguir exibe os valores retornados pela <xref:System.Math.Round%28System.Decimal%29> método, o <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método com um `mode` argumento da <xref:System.MidpointRounding.ToEven>e o <xref:System.Math.Round%28System.Decimal%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint1.cs#5)]
 [!code-vb[System.Math.Round.Overload#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint1.vb#5)]  
  
<a name="Round6_Example"></a>   
## <a name="mathrounddouble-midpointrounding-example"></a>Exemplo de Math.Round(Double, MidpointRounding)  
 O exemplo a seguir exibe os valores retornados pela <xref:System.Math.Round%28System.Double%29> método, o <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> método com um `mode` argumento da <xref:System.MidpointRounding.ToEven>e o <xref:System.Math.Round%28System.Double%2CSystem.MidpointRounding%29> método com um `mode` argumento de <xref:System.MidpointRounding.AwayFromZero>.  
  
 [!code-csharp[System.Math.Round.Overload#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/midpoint2.cs#6)]
 [!code-vb[System.Math.Round.Overload#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/midpoint2.vb#6)]  
  
<a name="Round7_Example"></a>   
## <a name="mathrounddecimal-int32-midpointrounding-example"></a>Exemplo de Math.Round(Decimal, Int32, MidpointRounding)  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Round%2A> método com o <xref:System.MidpointRounding> enumeração.  
  
 [!code-cpp[math.midpointrounding#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.midpointrounding/cpp/mpr.cpp#1)]
 [!code-csharp[math.midpointrounding#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.midpointrounding/CS/mpr.cs#1)]
 [!code-vb[math.midpointrounding#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.midpointrounding/VB/mpr.vb#1)]  
  
<a name="Round8_Example"></a>   
## <a name="mathrounddouble-int32-midpointrounding-example"></a>Exemplo de Math.Round(Double, Int32, MidpointRounding)  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29> método com o <xref:System.MidpointRounding> enumeração.  
  
 [!code-csharp[System.Math.Round.Overload#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round.overload/cs/mpr.cs#4)]
 [!code-vb[System.Math.Round.Overload#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round.overload/vb/mpr.vb#4)]  
  
<a name="Round_Versions"></a>   
## <a name="version-information"></a>Informações de versão  
 .NET Framework  
 Sobrecargas sem um <xref:System.MidpointRounding> parâmetro têm suporte em: 4.5, 4, 3.5, 3.0, 2.0, 1.1, 1.0  
Sobrecargas com um <xref:System.MidpointRounding> parâmetro têm suporte em: 4.5, 4, 3.5, 3.0 e 2.0  
  
 .NET Framework Client Profile  
 Todas as sobrecargas são suportadas em: 4, 3.5 SP1  
  
 Biblioteca de Classes Portátil  
 Todas as sobrecargas são suportadas  
  
 .NET para aplicativos da Windows Store  
 Todas as sobrecargas são suportadas em: Windows 8  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
        <altmember cref="M:System.Math.Truncate(System.Decimal)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Round : decimal -&gt; decimal" Usage="System.Math.Round d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <summary>Arredonda um valor decimal para o valor inteiro mais próximo.</summary>
        <returns>O parâmetro <paramref name="d" /> mais próximo do inteiro. Se o componente fracionário de <paramref name="d" /> estiver entre dois inteiros, sendo um deles par e o outro ímpar, o número par será retornado. Observe que esse método retorna um <see cref="T:System.Decimal" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">O resultado é fora do intervalo de um <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double a);" />
      <MemberSignature Language="F#" Value="static member Round : double -&gt; double" Usage="System.Math.Round a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Um número de ponto flutuante de precisão dupla a ser arredondado.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão dupla para o valor inteiro mais próximo.</summary>
        <returns>O inteiro mais próximo de <paramref name="a" />. Se o componente fracionário de <paramref name="a" /> estiver entre dois inteiros, sendo um deles par e o outro ímpar, o número par será retornado. Observe que esse método retorna um <see cref="T:System.Double" /> em vez de um tipo integral.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  

Começando com o Visual Basic 15,8, o desempenho da conversão de duplo para inteiro é otimizado se você passar o valor retornado pela `Round` método para qualquer uma da [funções de conversão integral](~/docs/visual-basic/language-reference/functions/conversion-functions.md), ou se o valor duplo retornado por `Round` é automaticamente convertido em um inteiro com [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) definida como desativada. Essa otimização permite que o código seja executado mais rapidamente – até duas vezes mais rápido para o código que faz um grande número de conversões para tipos de inteiro. O exemplo a seguir ilustra essas conversões otimizadas:
   
```vb
Dim d1 As Double = 1043.75133
Dim i1 As Integer = CInt(Math.Ceiling(d1))        ' Result: 1044

Dim d2 As Double = 7968.4136
Dim i2 As Integer = CInt(Math.Ceiling(d2))        ' Result: 7968
```

 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Devido à perda de precisão que pode resultar de que representam valores decimais como números de ponto flutuante ou executar operações aritméticas em valores de ponto flutuante, em alguns casos o <see cref="M:System.Math.Round(System.Double)" /> método não pode aparecer arredondar os valores de ponto médio para o inteiro par mais próximo. No exemplo a seguir, porque o valor de ponto flutuante.1 não tem nenhuma representação binária finita, a primeira chamada para o <see cref="M:System.Math.Round(System.Double)" /> método com um valor de 11,5 retorna 11 em vez de 12.  
  
[! código csharp[System.Math.Round#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round2.cs#1)] [! código vb[System.Math.Round#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round2.vb#1)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int -&gt; decimal" Usage="System.Math.Round (d, decimals)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="decimals">O número de casas decimais no valor retornado.</param>
        <summary>Arredonda um valor decimal para um número especificado de dígitos fracionários.</summary>
        <returns>O número mais próximo de <paramref name="d" /> que contém um número de dígitos fracionários igual a <paramref name="decimals" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> é menor que 0 ou maior que 28.</exception>
        <exception cref="T:System.OverflowException">O resultado é fora do intervalo de um <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="mode">Especificação de como arredondar <paramref name="d" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor decimal para o inteiro mais próximo. Um parâmetro especifica como arredondar o valor caso esteja entre dois números.</summary>
        <returns>O inteiro mais próximo de <paramref name="d" />. Se <paramref name="d" /> estiver entre dois números, sendo um deles par e o outro ímpar, <paramref name="mode" /> determinará qual dos dois será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">O resultado é fora do intervalo de um <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits);" />
      <MemberSignature Language="F#" Value="static member Round : double * int -&gt; double" Usage="System.Math.Round (value, digits)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão dupla a ser arredondado.</param>
        <param name="digits">O número de dígitos fracionários no valor de retorno.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão dupla para um número especificado de dígitos fracionários.</summary>
        <returns>O número mais próximo de <paramref name="value" /> que contém um número de dígitos fracionários igual a <paramref name="digits" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> é menor que 0 ou maior que 15.</exception>
        <block subset="none" type="usage">
          <para>Devido à perda de precisão que pode resultar de que representam valores decimais como números de ponto flutuante ou executar operações aritméticas em valores de ponto flutuante, em alguns casos o <see cref="M:System.Math.Round(System.Double,System.Int32)" /> método não pode aparecer arredondar os valores de ponto médio para o até mesmo valor em mais próximo a <paramref name="digits" /> posição decimal. Isso é ilustrado no exemplo a seguir, onde 2.135 é arredondado para 2.13, em vez de 2.14. Isso ocorre porque, internamente o método multiplica <paramref name="value" /> por 10<sup>dígitos</sup>, e a operação de multiplicação nesse caso sofre uma perda de precisão.  
  
[! código csharp[System.Math.Round#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round3.cs#2)] [! código vb[System.Math.Round#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round3.vb#2)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * MidpointRounding -&gt; double" Usage="System.Math.Round (value, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão dupla a ser arredondado.</param>
        <param name="mode">Especificação de como arredondar <paramref name="value" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão dupla para o inteiro mais próximo. Um parâmetro especifica como arredondar o valor caso esteja entre dois números.</summary>
        <returns>O inteiro mais próximo de <paramref name="value" />. Se <paramref name="value" /> estiver entre dois inteiros, sendo um deles par e o outro ímpar, <paramref name="mode" /> determinará qual dos dois será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Devido à perda de precisão que pode resultar de que representam valores decimais como números de ponto flutuante ou executar operações aritméticas em valores de ponto flutuante, em alguns casos o <see cref="M:System.Math.Round(System.Double,System.MidpointRounding)" /> método não pode aparecer arredondar os valores de ponto médio para o inteiro par mais próximo. No exemplo a seguir, porque o valor de ponto flutuante.1 não tem nenhuma representação binária finita, a primeira chamada para o <see cref="M:System.Math.Round(System.Double)" /> método com um valor de 11,5 retorna 11 em vez de 12.  
  
[! código csharp[System.Math.Round#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round5.cs#4)] [! código vb[System.Math.Round#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round5.vb#4)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static decimal Round (decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Round(valuetype System.Decimal d, int32 decimals, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (d As Decimal, decimals As Integer, mode As MidpointRounding) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Round(System::Decimal d, int decimals, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : decimal * int * MidpointRounding -&gt; decimal" Usage="System.Math.Round (d, decimals, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
        <Parameter Name="decimals" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="d">Um número decimal a ser arredondado.</param>
        <param name="decimals">O número de casas decimais no valor retornado.</param>
        <param name="mode">Especificação de como arredondar <paramref name="d" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor decimal para um número especificado de dígitos fracionários. Um parâmetro especifica como arredondar o valor caso esteja entre dois números.</summary>
        <returns>O número mais próximo de <paramref name="d" /> que contém um número de dígitos fracionários igual a <paramref name="decimals" />. Se <paramref name="d" /> tiver menos dígitos fracionários que <paramref name="decimals" />, <paramref name="d" /> será retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="decimals" /> é menor que 0 ou maior que 28.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <exception cref="T:System.OverflowException">O resultado é fora do intervalo de um <see cref="T:System.Decimal" />.</exception>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <Member MemberName="Round">
      <MemberSignature Language="C#" Value="public static double Round (double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Round(float64 value, int32 digits, valuetype System.MidpointRounding mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Round (value As Double, digits As Integer, mode As MidpointRounding) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Round(double value, int digits, MidpointRounding mode);" />
      <MemberSignature Language="F#" Value="static member Round : double * int * MidpointRounding -&gt; double" Usage="System.Math.Round (value, digits, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
        <Parameter Name="digits" Type="System.Int32" />
        <Parameter Name="mode" Type="System.MidpointRounding" />
      </Parameters>
      <Docs>
        <param name="value">Um número de ponto flutuante de precisão dupla a ser arredondado.</param>
        <param name="digits">O número de dígitos fracionários no valor de retorno.</param>
        <param name="mode">Especificação de como arredondar <paramref name="value" /> se o valor estiver entre dois outros números.</param>
        <summary>Arredonda um valor de ponto flutuante de precisão dupla para um número especificado de dígitos fracionários. Um parâmetro especifica como arredondar o valor caso esteja entre dois números.</summary>
        <returns>O número mais próximo de <paramref name="value" /> que tem um número de dígitos fracionários igual a <paramref name="digits" />. Se <paramref name="value" /> tiver menos dígitos fracionários que <paramref name="digits" />, <paramref name="value" /> será retornado inalterado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Para obter exemplos e informações de uso abrangentes sobre esta e outras sobrecargas do método `Round`, consulte a página de referência do <xref:System.Math.Round%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="digits" /> é menor que 0 ou maior que 15.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="mode" /> não é um valor válido de <see cref="T:System.MidpointRounding" />.</exception>
        <block subset="none" type="usage">
          <para>Devido à perda de precisão que pode resultar de que representam valores decimais como números de ponto flutuante ou executar operações aritméticas em valores de ponto flutuante, em alguns casos o <see cref="M:System.Math.Round(System.Double,System.Int32,System.MidpointRounding)" /> método não pode aparecer arredondar os valores de ponto médio conforme especificado pelo <paramref name="mode" /> parâmetro. Isso é ilustrado no exemplo a seguir, onde 2.135 é arredondado para 2.13, em vez de 2.14. Isso ocorre porque, internamente o método multiplica <paramref name="value" /> por 10<sup>dígitos</sup>, e a operação de multiplicação nesse caso sofre uma perda de precisão.  
  
[! código csharp[System.Math.Round#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.round/cs/round4.cs#3)] [! código vb[System.Math.Round#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.round/vb/round4.vb#3)]</para>
        </block>
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
        <altmember cref="M:System.Decimal.Round(System.Decimal,System.Int32,System.MidpointRounding)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sign">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um inteiro que indica o sinal de um número.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Decimal) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member Sign : decimal -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Um número decimal com sinal.</param>
        <summary>Retorna um inteiro que indica o sinal de um número decimal.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Decimal%29> método para determinar o sinal de um <xref:System.Decimal> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(double value);" />
      <MemberSignature Language="F#" Value="static member Sign : double -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um número de ponto flutuante de precisão dupla.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Double%29> método para determinar o sinal de um <xref:System.Double> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> é igual a <see cref="F:System.Double.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Short) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(short value);" />
      <MemberSignature Language="F#" Value="static member Sign : int16 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um inteiro com sinal de 16 bits.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Int16%29> método para determinar o sinal de um <xref:System.Int16> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(int value);" />
      <MemberSignature Language="F#" Value="static member Sign : int -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um inteiro com sinal de 32 bits.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Int32%29> método para determinar o sinal de um <xref:System.Int32> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(long value);" />
      <MemberSignature Language="F#" Value="static member Sign : int64 -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um inteiro com sinal de 64 bits.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Int64%29> método para determinar o sinal de um <xref:System.Int64> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As SByte) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member Sign : sbyte -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um inteiro com sinal de 8 bits.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.SByte%29> método para determinar o sinal de um <xref:System.SByte> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public static int Sign (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Sign(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sign(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sign (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Sign(float value);" />
      <MemberSignature Language="F#" Value="static member Sign : single -&gt; int" Usage="System.Math.Sign value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Um número assinado.</param>
        <summary>Retorna um inteiro que indica o sinal de um número de ponto flutuante de precisão simples.</summary>
        <returns>Um número que indica o sinal de <paramref name="value" />, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Significado 
 </description></listheader><item><term> -1 
 </term><description><paramref name="value" /> é menor que zero.  
  
 </description></item><item><term> 0 
 </term><description><paramref name="value" /> é igual a zero.  
  
 </description></item><item><term> 1 
 </term><description><paramref name="value" /> é maior que zero.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Math.Sign%28System.Single%29> método para determinar o sinal de um <xref:System.Single> de valor e exibi-lo no console.  
  
 [!code-cpp[Math.Sign#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.sign/CPP/sign.cpp#1)]
 [!code-csharp[Math.Sign#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.sign/CS/sign.cs#1)]
 [!code-vb[Math.Sign#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.sign/VB/sign.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArithmeticException">
          <paramref name="value" /> é igual a <see cref="F:System.Single.NaN" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static double Sin (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sin(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sin(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sin(double a);" />
      <MemberSignature Language="F#" Value="static member Sin : double -&gt; double" Usage="System.Math.Sin a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Um ângulo, medido em radianos.</param>
        <summary>Retorna o seno do ângulo especificado.</summary>
        <returns>O seno de <paramref name="a" />. Se <paramref name="a" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse método retornará <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `a`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
 Os valores aceitáveis de `a` variam de aproximadamente-9223372036854775295 a aproximadamente 9223372036854775295. Para obter valores fora desse intervalo, o <xref:System.Math.Sin%2A> método retorna `a` inalterado ao invés de lançar uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Sin%2A> para avaliar determinadas identidades trigonométricas para ângulos selecionados.  
  
 [!code-cpp[System.Math.SinCos#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinCos/CPP/sincos.cpp#1)]
 [!code-csharp[System.Math.SinCos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinCos/CS/sincos.cs#1)]
 [!code-vb[System.Math.SinCos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinCos/VB/sincos.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static double Sinh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sinh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sinh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sinh(double value);" />
      <MemberSignature Language="F#" Value="static member Sinh : double -&gt; double" Usage="System.Math.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um ângulo, medido em radianos.</param>
        <summary>Retorna o seno hiperbólico do ângulo especificado.</summary>
        <returns>O seno hiperbólico de <paramref name="value" />. Se <paramref name="value" /> for igual a <see cref="F:System.Double.NegativeInfinity" />, <see cref="F:System.Double.PositiveInfinity" /> ou <see cref="F:System.Double.NaN" />, o método retornará um <see cref="T:System.Double" /> igual a <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `value`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Sinh%2A> para avaliar determinadas identidades hiperbólicos para valores selecionados.  
  
 [!code-cpp[System.Math.SinhCosh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.SinhCosh/CPP/sinhcosh.cpp#1)]
 [!code-csharp[System.Math.SinhCosh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.SinhCosh/CS/sinhcosh.cs#1)]
 [!code-vb[System.Math.SinhCosh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.SinhCosh/VB/sinhcosh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static double Sqrt (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Sqrt(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Sqrt(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Sqrt(double d);" />
      <MemberSignature Language="F#" Value="static member Sqrt : double -&gt; double" Usage="System.Math.Sqrt d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">O número cuja raiz quadrada deve ser encontrada.</param>
        <summary>Retorna a raiz quadrada de um número especificado.</summary>
        <returns>Um dos valores na tabela a seguir.  
  
 <list type="table"><listheader><term>Parâmetro <paramref name="d" /></term><description> Valor retornado 
 </description></listheader><item><term> Zero ou positivo 
 </term><description> A raiz quadrada positiva de <paramref name="d" />.  
  
 </description></item><item><term> Negativo 
 </term><description><see cref="F:System.Double.NaN" /></description></item><item><term> É igual a <see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term> É igual a <see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 A raiz quadrada da área de um quadrado representa o comprimento de qualquer lado do quadrado. O exemplo a seguir exibe a área de algumas cidades dos Estados Unidos e oferece uma impressão de tamanho de cada cidade, se ele foi representado por um quadrado.  
  
 [!code-csharp[System.Math.Sqrt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.math.sqrt/cs/sqrt1.cs#1)]
 [!code-vb[System.Math.Sqrt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.math.sqrt/vb/sqrt1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Pow(System.Double,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static double Tan (double a);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tan(float64 a) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tan(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (a As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tan(double a);" />
      <MemberSignature Language="F#" Value="static member Tan : double -&gt; double" Usage="System.Math.Tan a" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="a">Um ângulo, medido em radianos.</param>
        <summary>Retorna a tangente do ângulo especificado.</summary>
        <returns>A tangente de <paramref name="a" />. Se <paramref name="a" /> for igual a <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> ou <see cref="F:System.Double.PositiveInfinity" />, esse método retornará <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `a`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como calcular a tangente de um ângulo e exibi-lo no console.  
  
 [!code-cpp[math.atanx#1](~/samples/snippets/cpp/VS_Snippets_CLR/math.atanx/CPP/atan.cpp#1)]
 [!code-csharp[math.atanx#1](~/samples/snippets/csharp/VS_Snippets_CLR/math.atanx/CS/atan.cs#1)]
 [!code-vb[math.atanx#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/math.atanx/VB/atan.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static double Tanh (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Tanh(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Tanh(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Tanh(double value);" />
      <MemberSignature Language="F#" Value="static member Tanh : double -&gt; double" Usage="System.Math.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Um ângulo, medido em radianos.</param>
        <summary>Retorna a tangente hiperbólica do ângulo especificado.</summary>
        <returns>A tangente hiperbólica de <paramref name="value" />. Se <paramref name="value" /> for igual a <see cref="F:System.Double.NegativeInfinity" />, esse método retornará -1. Se o valor for igual a <see cref="F:System.Double.PositiveInfinity" />, esse método retornará 1. Se <paramref name="value" /> for igual a <see cref="F:System.Double.NaN" />, esse método retornará <see cref="F:System.Double.NaN" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O ângulo, `value`, deve ser em radianos. Multiplique por <xref:System.Math.PI?displayProperty=nameWithType>/180 para converter graus em radianos.  
  
   
  
## Examples  
 O exemplo a seguir usa <xref:System.Math.Tanh%2A> para avaliar determinadas identidades de tangente hiperbólicos para valores selecionados.  
  
 [!code-cpp[System.Math.Tanh#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Math.Tanh/CPP/tanh.cpp#1)]
 [!code-csharp[System.Math.Tanh#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Tanh/CS/tanh.cs#1)]
 [!code-vb[System.Math.Tanh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Tanh/VB/tanh.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Truncate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Calcula a parte integral de um número.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número será arredondado para o inteiro mais próximo em direção a zero.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static decimal Truncate (decimal d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Decimal Truncate(valuetype System.Decimal d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Decimal) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Decimal Truncate(System::Decimal d);" />
      <MemberSignature Language="F#" Value="static member Truncate : decimal -&gt; decimal" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="d">Um número a ser truncado.</param>
        <summary>Calcula a parte integral de um número decimal especificado.</summary>
        <returns>A parte integral do <paramref name="d" />; ou seja, o número que permanece depois que os dígitos fracionários foram descartados.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Math.Truncate%2A> Arredonda `d` para o inteiro mais próximo em direção a zero.  
  
   
  
## Examples  
 A exemplo a seguir chama o <xref:System.Math.Truncate%28System.Decimal%29> método para truncar um positivo e negativo <xref:System.Decimal> valor.  
  
 [!code-csharp[System.Math.Truncate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#2)]
 [!code-vb[System.Math.Truncate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Decimal)" />
        <altmember cref="M:System.Math.Floor(System.Decimal)" />
      </Docs>
    </Member>
    <Member MemberName="Truncate">
      <MemberSignature Language="C#" Value="public static double Truncate (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Truncate(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Math.Truncate(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Truncate (d As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Truncate(double d);" />
      <MemberSignature Language="F#" Value="static member Truncate : double -&gt; double" Usage="System.Math.Truncate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Um número a ser truncado.</param>
        <summary>Calcula a parte integral de um número de ponto flutuante de precisão dupla especificado.</summary>
        <returns>A parte integral do <paramref name="d" />; ou seja, o número que permanece depois que os dígitos fracionários tiverem sido descartados ou um dos valores listados na tabela a seguir.  
  
 <list type="table"><listheader><term><paramref name="d" /></term><description> Valor retornado 
 </description></listheader><item><term><see cref="F:System.Double.NaN" /></term><description><see cref="F:System.Double.NaN" /></description></item><item><term><see cref="F:System.Double.NegativeInfinity" /></term><description><see cref="F:System.Double.NegativeInfinity" /></description></item><item><term><see cref="F:System.Double.PositiveInfinity" /></term><description><see cref="F:System.Double.PositiveInfinity" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<xref:System.Math.Truncate%2A> Arredonda `d` para o inteiro mais próximo em direção a zero.  
  
Começando com o Visual Basic 15,8, o desempenho da conversão de duplo para inteiro é otimizado se você passar o valor retornado pela `Truncate` método para qualquer uma da [funções de conversão integral](~/docs/visual-basic/language-reference/functions/conversion-functions.md), ou se o valor duplo retornado por `Truncate` é automaticamente convertido em um inteiro com [Option Strict](~/docs/visual-basic/language-reference/statements/option-strict-statement.md) definida como desativada. Essa otimização permite que o código seja executado mais rapidamente – até duas vezes mais rápido para o código que faz um grande número de conversões para tipos de inteiro. O exemplo a seguir ilustra uma conversão desse tipo otimizada:
   
```vb
Dim d As Double = 164.7194
Dim i As Integer = CInt(Math.Truncate(d))     ' Result: 164
```

## Examples  
 A exemplo a seguir chama o <xref:System.Math.Truncate%28System.Double%29> método para truncar um positivo e negativo <xref:System.Double> valor.  
  
 [!code-csharp[System.Math.Truncate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Math.Truncate/cs/Truncate1.cs#1)]
 [!code-vb[System.Math.Truncate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Math.Truncate/vb/Truncate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Math.Round" />
        <altmember cref="M:System.Math.Ceiling(System.Double)" />
        <altmember cref="M:System.Math.Floor(System.Double)" />
      </Docs>
    </Member>
  </Members>
</Type>