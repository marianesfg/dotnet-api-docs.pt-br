<Type Name="Uri" FullName="System.Uri">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f31f66dc7ef61083f857685fcdb50a85d836898f" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174373" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Uri : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Uri extends System.Object implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Uri" />
  <TypeSignature Language="VB.NET" Value="Public Class Uri&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Uri : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter(typeof(System.UriTypeConverter))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece uma representação de objeto de um URI (Uniform Resource Identifier) e fácil acesso às partes do URI.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um URI é uma representação compacta de um recurso disponível para seu aplicativo na intranet ou na Internet. O <xref:System.Uri> classe define as propriedades e métodos para lidar com URIs, incluindo análise, comparar e combinar. O <xref:System.Uri> propriedades de classe são somente leitura; para criar um objeto pode ser modificado, use o <xref:System.UriBuilder> classe.  
  
 URIs relativos (por exemplo, "/ new/index.htm") deve ser expandido em relação a um URI de base para que eles sejam absolutos. O <xref:System.Uri.MakeRelative%2A> método é fornecido para converter URIs absolutos para URIs relativos quando necessário.  
  
 O <xref:System.Uri> construtores não escapar cadeias de caracteres do URI se a cadeia de caracteres é um URI bem formado, incluindo um identificador do esquema.  
  
 O <xref:System.Uri> propriedades retornam uma representação de dados canônica em codificação com caracteres de escape, todos os caracteres com valores Unicode maiores que 127 substituído por seus equivalentes hexadecimais. Para colocar o URI em forma canônica, o <xref:System.Uri> construtor executa as seguintes etapas:  
  
-   Converte o esquema de URI em minúsculas.  
  
-   Converte o nome do host em minúsculas.  
  
-   Se o nome do host é um endereço IPv6, o endereço IPv6 canônico é usado. ScopeId e outros dados IPv6 opcionais são removidos.  
  
-   Remove o padrão e números de porta vazio.

-   Caracteres de escape (também conhecida como octetos codificados por percentual) que não têm uma finalidade reservada são decodificadas (também conhecido como sendo sem escape). Esses caracteres não reservadas incluem letras maiusculas e minúsculas (% % 41 5A e % 61% 7A), dígitos decimais (30-% 39), hífen (% 2D), o período (% 2E), sublinhado (% 5F) e til (% 7E).

-   Padroniza o caminho para URIs hierárquica pelas sequências de compactação como /., /... e / / (ou não a sequência é liberada). Observe que há alguns esquemas para o qual essas sequências não são compactadas.
  
-   Para URIs hierárquica, se o host não termina com uma barra invertida (/), um será adicionado.  
  
-   Por padrão, nenhum dos caracteres reservados no URI é escapados de acordo com RFC 2396. Este alterações de comportamento se identificadores de recurso ou o nome de domínio internacional análise está habilitada no qual casos caracteres reservados no URI são ignoradas acordo com RFC 3986 e RFC 3987.

 Como parte da conversão em formato canônico no construtor para alguns esquemas, segmentos de ponto e vazio (/., /... e / /) são compactadas (em outras palavras, eles serão removidos). Os esquemas para o qual o URI compactará essas sequências incluem http, https, tcp, NET. pipe e NET. TCP. Para alguns esquemas, essas sequências não são compactadas. Aqui está como essa compactação aparece na prática.
  
```  
var uri = new Uri("http://myUrl/../.."); // http scheme, unescaped
OR
var uri = new Uri("http://myUrl/%2E%2E/%2E%2E"); // http scheme, escaped
OR
var uri = new Uri("ftp://myUrl/../.."); // ftp scheme, unescaped
OR
var uri = new Uri("ftp://myUrl/%2E%2E/%2E%2E"); // ftp scheme, escaped

Console.WriteLine(uri.AbsoluteUri);  
Console.WriteLine(uri.PathAndQuery);  
```  
  
 Quando esse código é executado, ele retorna a saída a seguir, com as sequências de escape sem escape se necessário e, em seguida, compactado.

```  
http://myUrl/  
/  
```  
  
 Você pode transformar o conteúdo a <xref:System.Uri> classe a partir de uma referência URI de escape codificado como uma referência URI legível usando o <xref:System.Uri.ToString%2A> método. Observe que alguns caracteres reservados podem ainda ser substituídas na saída do <xref:System.Uri.ToString%2A> método. Isso é para dar suporte a ambígua reconstrução de um URI do valor retornado por <xref:System.Uri.ToString%2A>.  
  
 Alguns URIs incluem um identificador de fragmento ou uma consulta ou ambos. Um identificador do fragmento é qualquer texto que segue um sinal numérico (#), não incluindo o sinal de número; o texto do fragmento é armazenado no <xref:System.Uri.Fragment%2A> propriedade. Informações de consulta são qualquer texto que segue a um ponto de interrogação (?) no URI. o texto da consulta é armazenado no <xref:System.Uri.Query%2A> propriedade.  
  
 No .NET Framework versão 1.1, se a cadeia de caracteres especificada para um construtor contém um esquema desconhecido e "c:\\", as inserções de classe de Uri "/ /" após os dois-pontos. Por exemplo, o URI `xyz:c:\abc` é convertido em `xyz://c:/abc`. No .NET Framework versão 2.0, esse comportamento foi removido e a cadeia de caracteres de exemplo é convertida em `xyz:c:/abc`.  
  
> [!NOTE]
>  A classe URI oferece suporte ao uso de endereços IP em ambos os quad-notação protocolo IPv4 e hexadecimal com dois-pontos para o protocolo IPv6. Lembre-se de incluir o endereço IPv6 entre colchetes, como em http://[::1].  
  
## <a name="international-resource-identifier-support"></a>Suporte ao identificador do recurso internacional  
 Endereços da Web geralmente são expressos usando identificadores de recursos uniformes que consistem em um conjunto muito restrito de caracteres:  
  
-   Letras maiúsculas e minúsculas ASCII do alfabeto inglês.  
  
-   Dígitos de 0 a 9.  
  
-   Um pequeno número de outros símbolos ASCII.  
  
 As especificações de URIs estão documentadas na RFC 2396, RFC 2732, RFC 3986 e RFC 3987 publicados pelo Internet engenharia Task Force (IETF).  
  
 Com o crescimento da Internet, há uma necessidade crescente de identificar recursos com idiomas diferentes do inglês. Identificadores que facilitam a essa necessidade e permitem que os caracteres não ASCII (caracteres no conjunto de caracteres Unicode/ISO 10646) são conhecidos como IRIs (International Resource Identifiers). As especificações de IRIs estão documentadas na RFC 3987, publicado pela IETF. O uso de IRIs permite que uma URL contenha caracteres Unicode.  
  
 Existente <xref:System.Uri> classe foi estendida no .NET Framework v 3.5, 3.0 SP1, e 2.0 SP1 para oferecer suporte a IRI com base na RFC 3987. Os usuários de versões anteriores à versão 4.5 do .NET Framework não verão qualquer alteração no comportamento do .NET Framework 2.0, a menos que eles permitem especificamente IRI. Isso garante a compatibilidade do aplicativo com versões anteriores do .NET Framework.  
  
 Para habilitar o suporte para IRI, é necessária a seguinte alteração:  
  
-   Especifique se deseja que a análise de nome de domínio internacionalizado (IDN) aplicado ao nome de domínio e se as regras de análise de IRI deve ser aplicada. Isso pode ser feito *Machine. config* ou o *App. config* arquivo. Por exemplo, adicione o seguinte:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Os usuários do .NET Framework 4.5 e mais recente sempre ter IRI habilitado. A análise de IRI não pode ser alterada usando um *. config* arquivo.  
  
 Habilitar o IDN converterá todos os rótulos Unicode de um nome de domínio para seus equivalentes em Punycode. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--. A razão para isso é dar suporte a servidores DNS existentes na Internet, pois a maioria dos servidores DNS dá suporte somente a caracteres ASCII (consulte RFC 3940).  
  
 Habilitar IRI e IDN afeta o valor da propriedade <xref:System.Uri.DnsSafeHost%2A?displayProperty=nameWithType>. Habilitar IRI e IDN também pode alterar o comportamento dos métodos <xref:System.Uri.Equals%2A>, <xref:System.Uri.OriginalString%2A>, <xref:System.Uri.GetComponents%2A> e <xref:System.Uri.IsWellFormedOriginalString%2A>.  
  
 Há três valores possíveis para IDN dependendo os servidores DNS que são usados:  
  
-   IDN habilitado = All  
  
     Esse valor converterá todos os nomes de domínio Unicode em seus equivalentes do Punycode (nomes IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Esse valor serão convertidos em todos os nomes de domínio de Unicode não na Intranet local para usar os equivalentes de Punycode (nomes IDN). Nesse caso para lidar com nomes internacionais da intranet local, os servidores DNS que são usados para a Intranet devem dar suporte a resolução de nomes de Unicode.  
  
-   IDN habilitado = nenhum  
  
     Esse valor não converterá nenhum nome de domínio Unicode para usar o Punycode. Este é o valor padrão que é consistente com o comportamento do .NET Framework 2.0.  
  
 Quando a análise de IRI está habilitada (iriParsing habilitado = `true`) normalização e a verificação de caractere são feitas de acordo com as regras IRI mais recentes em RFC 3986 e RFC 3987. Quando a análise de IRI estiver desabilitada, normalização e a verificação de caractere são executadas de acordo com RFC 2396 e RFC 2732 (para literais IPv6).  Nas versões do .NET Framework antes da versão 4.5, o valor padrão é `false`. No .NET Framework versão 4.5 e mais recente, o valor padrão é `true`, e o estado habilitado da análise de IRI não pode ser modificado por configurações em um *. config* arquivo.  
  
 IRI e IDN processamento o <xref:System.Uri> classe também pode ser controlada usando o <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType>, <xref:System.Configuration.IdnElement?displayProperty=nameWithType>, e <xref:System.Configuration.UriSection?displayProperty=nameWithType> classes de configuração. A configuração <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> habilita ou desabilita o processamento de IRI na classe <xref:System.Uri>. A configuração <xref:System.Configuration.IdnElement?displayProperty=nameWithType> habilita ou desabilita o processamento de IDN na classe <xref:System.Uri>. A configuração <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> também controla indiretamente o IDN. O processamento de IRI deve estar habilitado para que o processamento de IDN seja possível. Se o processamento de IRI estiver desabilitado, o processamento de IDN será definido para a configuração padrão, na qual o comportamento do .NET Framework 2.0 será usado para fins de compatibilidade e nomes IDN não serão usados.  
  
 O parâmetro de configuração para o <xref:System.Configuration.IriParsingElement?displayProperty=nameWithType> e <xref:System.Configuration.IdnElement?displayProperty=nameWithType> serão lidos uma vez quando o primeiro <xref:System.Uri?displayProperty=nameWithType> classe é criada. Alterações nas configurações depois desse tempo serão ignoradas.  
  
 A classe <xref:System.GenericUriParser?displayProperty=nameWithType> também foi estendida para permitir a criação de um analisador personalizável que dá suporte a IRI e IDN. O comportamento de um objeto <xref:System.GenericUriParser?displayProperty=nameWithType> é especificado passando-se uma combinação bit a bit dos valores disponíveis na enumeração <xref:System.GenericUriParserOptions?displayProperty=nameWithType> para o construtor <xref:System.GenericUriParser?displayProperty=nameWithType>. O tipo <xref:System.GenericUriParserOptions.IriParsing?displayProperty=nameWithType> que indica que o analisador dá suporte às regras de análise especificadas na RFC 3987 para IRI (Identificadores de Recurso Internacional). Se IRI é usada é determinada pelos valores de configuração abordados anteriormente.  
  
 O tipo <xref:System.GenericUriParserOptions.Idn?displayProperty=nameWithType> indica que o analisador dá suporte à análise de IDN (Nome de Domínio Internacionalizado) dos nomes de host. Se IDN é usada é determinada pelos valores de configuração abordados anteriormente.  
  
## <a name="performance-considerations"></a>Considerações sobre desempenho  
 Se você usar um *Web.config * arquivo que contém URIs para inicializar o tempo de aplicativo, adicional é necessária para processar os URIs se seus identificadores de esquema não são padrão. Nesse caso, inicialize as partes afetadas do seu aplicativo quando os URIs são necessárias, não na hora de início.  
  
   
  
## Examples  
 O exemplo a seguir cria uma instância do <xref:System.Uri> classe e o usa para criar um <xref:System.Net.WebRequest> instância.  
  
 [!code-cpp[Classic Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="usage">
      <para>Devido a questões de segurança, seu aplicativo deve ter cuidado ao aceitar <see cref="T:System.Uri" /> instâncias de fontes não confiáveis e com <paramref name="dontEscape" /> definido como <see langword="true" />. Você pode verificar uma cadeia de caracteres URI para validade chamando o <see cref="M:System.Uri.IsWellFormedOriginalString" /> método.</para>
    </block>
    <altmember cref="T:System.Configuration.IdnElement" />
    <altmember cref="T:System.Configuration.IriParsingElement" />
    <altmember cref="T:System.Configuration.UriSection" />
    <altmember cref="P:System.Uri.DnsSafeHost" />
    <altmember cref="M:System.Uri.MakeRelative(System.Uri)" />
    <altmember cref="M:System.Uri.IsWellFormedOriginalString" />
    <altmember cref="T:System.UriBuilder" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com URI especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância de uma cadeia de caracteres do URI. Ele analisa o URI, coloca-o em formato canônico e faz qualquer codificações de escape exigido.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
 Este construtor supõe que o `string` parâmetro faz referência a um URI absoluto e é equivalente a chamar o <xref:System.Uri.%23ctor%2A> construtor com <xref:System.UriKind> definido como <xref:System.UriKind.Absolute>. Se o `string` parâmetro passado para o construtor é um URI relativo, este construtor lançará um <xref:System.UriFormatException>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância com o URI "http://www.contoso.com/".  
  
 [!code-cpp[Classic Uri.Uri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> está vazio.  -ou- O esquema especificado em <paramref name="uriString" /> não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  -ou- <paramref name="uriString" /> contém muitas barras "/".  -ou- A senha especificada em <paramref name="uriString" /> é inválida.  -ou- O nome do host especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de arquivo especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de usuário especificado em <paramref name="uriString" /> é inválido.  -ou- O nome do host ou da autoridade especificado em <paramref name="uriString" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado em <paramref name="uriString" /> é inválido ou não pode ser analisado.  -ou- O tamanho de <paramref name="uriString" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado em <paramref name="uriString" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida em <paramref name="uriString" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Uri (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Uri(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Uma instância da classe <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar a nova instância de <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Uma instância da classe <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem do fluxo serializado associado à nova instância de <see cref="T:System.Uri" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> das instâncias especificadas das classes <see cref="T:System.Runtime.Serialization.SerializationInfo" /> e <see cref="T:System.Runtime.Serialization.StreamingContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor implementa o <xref:System.Runtime.Serialization.ISerializable> a interface para o <xref:System.Uri> classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="serializationInfo" /> contém um URI <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">O parâmetro <paramref name="serializationInfo" /> contém um URI vazio.  -ou- O esquema especificado não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  -ou- O URI contém muitas barras "/".  -ou- A senha especificada no URI é inválida.  -ou- O nome do host especificado no URI é inválido.  -ou- O nome de arquivo especificado no URI é inválido.  -ou- O nome de usuário especificado no URI é inválido.  -ou- O nome do host ou da autoridade especificado no URI não pode terminar com barras invertidas.  -ou- O número da porta especificado no URI é inválido ou não pode ser analisado.  -ou- O tamanho do URI excede 65.519 caracteres.  -ou- O tamanho do esquema especificado no URI excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida no URI.  -ou- O caminho do MS-DOS especificado no URI precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (uriString As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, bool dontEscape);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> tiver escape completo, caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com o URI especificado, com controle explícito de escape de caractere.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância de uma cadeia de caracteres do URI. Ele analisa o URI e o coloca em formato canônico.  
  
 O `dontEscape` parâmetro controla se os caracteres reservados são convertidos em sequências de escape. Esse parâmetro deve ser definido como `true` somente se você tiver certeza de que todos os caracteres reservados no URI foi substituídos. Definir o valor como `true` para um URI que não foi totalmente escape pode causar um comportamento inesperado. É altamente recomendável que você sempre defina esse parâmetro para `false`.  
  
 Se `dontEscape` é definido como `false`, o construtor ignora os caracteres reservados, verificando se todas as ocorrências de porcentagem (%)) são seguidas por uma sequência de escape válida. Se a sequência de caracteres a seguir uma porcentagem não for válida, o percentual é substituído por % 25.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância para o URI http://www.contoso.com/Hello%20World.htm. Porque o URI independente completamente é ignorado e está no formato canônico, o `dontEscape` parâmetro pode ser definido como `true`.  
  
 [!code-cpp[Classic Uri.Uri1 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri1 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri1 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">A <paramref name="uriString" /> está vazia ou contém apenas espaços.  -ou- O esquema especificado em <paramref name="uriString" /> é inválido.  -ou- <paramref name="uriString" /> contém muitas barras "/".  -ou- A senha especificada em <paramref name="uriString" /> é inválida.  -ou- O nome do host especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de arquivo especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de usuário especificado em <paramref name="uriString" /> é inválido.  -ou- O nome do host ou da autoridade especificado em <paramref name="uriString" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado em <paramref name="uriString" /> é inválido ou não pode ser analisado.  -ou- O tamanho de <paramref name="uriString" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado em <paramref name="uriString" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida em <paramref name="uriString" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(System::String ^ uriString, UriKind uriKind);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">Uma cadeia de caracteres que identifica o recurso a ser representado pela instância de <see cref="T:System.Uri" />. Observe que um endereço IPv6 no formato de cadeia de caracteres deve estar entre colchetes. Por exemplo, "http://[2607:f8b0:400d:c06::69]".</param>
        <param name="uriKind">Especifica se a cadeia de caracteres do URI é um URI relativo, um URI absoluto ou indeterminado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com URI especificado. Este construtor permite que você especifique se a cadeia de caracteres do URI é um URI relativo, um URI absoluto ou indeterminado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 URIs relativas e absolutas têm diferentes restrições em seu formato. Por exemplo, um URI relativo não requer um esquema ou uma autoridade. O valor especificado em `uriKind` deve corresponder ao tipo de URI passada `uriString`. No entanto, se <xref:System.UriKind.RelativeOrAbsolute> for especificado, a cadeia de caracteres do URI pode ser relativo ou absoluto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="uriKind" /> é inválido.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uriString" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block>
          <paramref name="uriString" /> contém um URI relativo e <paramref name="uriKind" /> é <see cref="F:System.UriKind.Absolute" />.  ou <paramref name="uriString" /> contém um URI absoluto e <paramref name="uriKind" /> é <see cref="F:System.UriKind.Relative" />.  ou <paramref name="uriString" /> está vazio.  -ou- O esquema especificado em <paramref name="uriString" /> não está formado corretamente. Consulte <see cref="M:System.Uri.CheckSchemeName(System.String)" />.  -ou- <paramref name="uriString" /> contém muitas barras "/".  -ou- A senha especificada em <paramref name="uriString" /> é inválida.  -ou- O nome do host especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de arquivo especificado em <paramref name="uriString" /> é inválido.  -ou- O nome de usuário especificado em <paramref name="uriString" /> é inválido.  -ou- O nome do host ou da autoridade especificado em <paramref name="uriString" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado em <paramref name="uriString" /> é inválido ou não pode ser analisado.  -ou- O tamanho de <paramref name="uriString" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado em <paramref name="uriString" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida em <paramref name="uriString" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="baseUri">O URI de base.</param>
        <param name="relativeUri">O URI relativo a ser adicionado ao URI de base.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com base no URI base especificado e na cadeia de caracteres do URI relativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância combinando o `baseUri` e `relativeUri`. Se `relativeUri` é um URI absoluto (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
 
 Se o `baseUri` tem partes relativos (como `/api`), e em seguida, a parte relativa deve terminar com uma barra (como `/api/`), se a parte relativa do `baseUri` deve ser preservado no construído <xref:System.Uri>. 

 Além disso, se o `relativeUri` começa com uma barra, em seguida, ela substituirá qualquer parte relativo das `baseUri`

 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria uma nova instância do <xref:System.Uri> classe combinando os URIs relativos http://www.contoso.com e catalog/shownew.htm para formar o URI absoluto http://www.contoso.com/catalog/shownew.htm.  
  
 [!code-cpp[Classic Uri.Uri3 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri3 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri3 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block> O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  -ou- O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras "/".  -ou- A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválida.  -ou- O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido ou não pode ser analisado.  -ou- O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, Uri relativeUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, class System.Uri relativeUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, Uri ^ relativeUri);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="baseUri">Um <see cref="T:System.Uri" /> absoluto que é a base da nova instância de <see cref="T:System.Uri" />.</param>
        <param name="relativeUri">Uma instância de <see cref="T:System.Uri" /> relativa combinada com <c>baseUri</c>.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> com base na combinação de uma instância base de <see cref="T:System.Uri" /> especificada e uma instância de <see cref="T:System.Uri" /> relativa.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um novo <xref:System.Uri> instância combinando um absoluto <xref:System.Uri> instância, `baseUri`, com relativa <xref:System.Uri> instância, `relativeUri`. Se `relativeUri` é um absoluto <xref:System.Uri> instância (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
 
 Se o `baseUri` tem partes relativos (como `/api`), e em seguida, a parte relativa deve terminar com uma barra (como `/api/`), se a parte relativa do `baseUri` deve ser preservado no construído <xref:System.Uri>. 

 Além disso, se o `relativeUri` começa com uma barra, em seguida, ela substituirá qualquer parte relativo das `baseUri`
 
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 Este exemplo cria um absoluto <xref:System.Uri> instância, `absoluteUri`e relativo <xref:System.Uri> instância, `relativeUri`. Um novo <xref:System.Uri> instância, `combinedUri`, em seguida, é criada a partir dessas duas instâncias.  
  
 [!code-cpp[NCLUriEnhancements#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#2)]
 [!code-csharp[NCLUriEnhancements#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#2)]
 [!code-vb[NCLUriEnhancements#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block> O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  -ou- O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras "/".  -ou- A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválida.  -ou- O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido ou não pode ser analisado.  -ou- O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Uri (Uri baseUri, string relativeUri, bool dontEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Uri baseUri, string relativeUri, bool dontEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.#ctor(System.Uri,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (baseUri As Uri, relativeUri As String, dontEscape As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri(Uri ^ baseUri, System::String ^ relativeUri, bool dontEscape);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="dontEscape" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="baseUri">O URI de base.</param>
        <param name="relativeUri">O URI relativo a ser adicionado ao URI de base.</param>
        <param name="dontEscape">
          <see langword="true" /> se <c>uriString</c> tiver escape completo, caso contrário, <see langword="false" />.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Uri" /> baseada nos URIs de base e relativos especificados, com controle explícito de escape de caracteres.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor cria um <xref:System.Uri> instância combinando `baseUri` e `relativeUri`. Se o URI passado `relativeUri` é um URI absoluto (que contém um esquema, o nome de host e, opcionalmente, um número de porta), o <xref:System.Uri> instância é criada usando somente `relativeUri`.  
  
 O `dontEscape` parâmetro controla se os caracteres reservados são convertidos em sequências de escape. Esse parâmetro deve ser definido como `true` somente se você tiver certeza de que todos os caracteres reservados no URI foi substituídos. Definir o valor como `true` para um URI que não foi totalmente escape pode causar um comportamento inesperado. É altamente recomendável que você sempre defina esse parâmetro para `false`. Se `dontEscape` é definido como `false`, o construtor ignora os caracteres reservados, verificando se todas as ocorrências de porcentagem (%)) são seguidas por uma sequência de escape válida. Se a sequência de caracteres a seguir uma porcentagem não for válida, o percentual é substituído por % 25.  
  
 Este construtor não garante que o <xref:System.Uri> faça referência a um recurso acessível.  
  
   
  
## Examples  
 O exemplo a seguir cria uma nova instância do <xref:System.Uri> classe combinando os URIs relativos http://www.contoso.com e Hello%20World.htm para formar um URI absoluto.  
  
 [!code-cpp[Classic Uri.Uri4 Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Uri4 Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Uri4 Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Uri4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Uri4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="baseUri" /> não é uma instância de <see cref="T:System.Uri" /> absoluta.</exception>
        <exception cref="T:System.UriFormatException">O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> está vazio ou contém apenas espaços.  -ou- O esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> contém muitas barras "/".  -ou- A senha especificada no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválida.  -ou- O nome do host especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de arquivo especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome de usuário especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido.  -ou- O nome do host ou da autoridade especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> não pode terminar com barras invertidas.  -ou- O número da porta especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> é inválido ou não pode ser analisado.  -ou- O tamanho do URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 65.519 caracteres.  -ou- O tamanho do esquema especificado no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" /> excede 1.023 caracteres.  -ou- Há uma sequência de caracteres inválida no URI formado pela combinação de <paramref name="baseUri" /> e <paramref name="relativeUri" />.  -ou- O caminho do MS-DOS especificado em <paramref name="uriString" /> precisa começar com c:\\\\.</exception>
        <block subset="none" type="usage">
          <para>Devido a questões de segurança, seu aplicativo não deve o chamar este construtor com cadeias de caracteres do URI de fontes não confiáveis e com <paramref name="dontEscape" /> definido como <see langword="true" />. Como alternativa, você pode verificar uma cadeia de caracteres URI para validade chamando o <see cref="M:System.Uri.IsWellFormedOriginalString" /> método antes de chamar este construtor.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="AbsolutePath">
      <MemberSignature Language="C#" Value="public string AbsolutePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsolutePath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsolutePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsolutePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsolutePath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o caminho absoluto do URI.</summary>
        <value>Um <see cref="T:System.String" /> que contém o caminho absoluto para o recurso.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.AbsolutePath%2A> propriedade contém as informações de caminho que o servidor usa para resolver solicitações de informações. Geralmente é o caminho para as informações desejadas no sistema de arquivos do servidor, embora ele também pode indicar o aplicativo ou o servidor deve executar para fornecer as informações do script.  
  
 As informações de caminho não incluem o esquema, o nome de host ou a parte de consulta do URI.  
  
   
  
## Examples  
 O exemplo a seguir grava /catalog/shownew.htm o caminho para o console.  
  
 [!code-cpp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsolutePath Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsolutePath Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsolutePath Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsoluteUri">
      <MemberSignature Language="C#" Value="public string AbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.AbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AbsoluteUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ AbsoluteUri { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o URI absoluto.</summary>
        <value>Um <see cref="T:System.String" /> que contém o URI inteiro.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.AbsoluteUri%2A> propriedade inclui o URI todo armazenado na <xref:System.Uri> instância, incluindo todos os fragmentos e cadeias de caracteres de consulta.  
  
   
  
## Examples  
 O exemplo a seguir grava todo o conteúdo do <xref:System.Uri> instância para o console. No exemplo mostrado, http://www.contoso.com/catalog/shownew.htm?date=today é gravada no console.  
  
 [!code-cpp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.AbsoluteUri Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.AbsoluteUri Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Authority">
      <MemberSignature Language="C#" Value="public string Authority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Authority" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Authority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Authority As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Authority { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do host do DNS (Sistema de Nomes de Domínio) ou o endereço IP e o número da porta para um servidor.</summary>
        <value>Um <see cref="T:System.String" /> que contém o componente de autoridade do URI representado por essa instância.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Authority%2A> propriedade normalmente é um nome de host do servidor DNS ou endereço IP. Essa propriedade pode incluir o número da porta de serviço se for diferente da porta padrão para o URI. Se o <xref:System.Uri.Authority%2A> componente contém caracteres reservados, elas são ignoradas no valor de cadeia de caracteres retornado por esta propriedade.  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do host (www.contoso.com) e o número de porta (8080) do servidor para o console.  
  
 [!code-cpp[Classic Uri.Authority Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Authority Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Authority Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Authority Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Authority Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Authority Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Canonicalize">
      <MemberSignature Language="C#" Value="protected virtual void Canonicalize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Canonicalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Canonicalize" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Canonicalize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Canonicalize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte o URI armazenado internamente em forma canônica.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Armazena a versão canônica do URI internamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Essa instância representa um URI relativo e esse método é válido apenas para URIs absolutos.</exception>
        <exception cref="T:System.UriFormatException">O URI está formado incorretamente.</exception>
      </Docs>
    </Member>
    <Member MemberName="CheckHostName">
      <MemberSignature Language="C#" Value="public static UriHostNameType CheckHostName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.UriHostNameType CheckHostName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckHostName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckHostName (name As String) As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UriHostNameType CheckHostName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">O nome de host a ser validado. Isso pode ser um endereço IPv4 ou IPv6 ou um nome de host da Internet.</param>
        <summary>Determina se o nome de host especificado é um nome DNS válido.</summary>
        <returns>Um <see cref="T:System.UriHostNameType" /> que indica o tipo do nome do host. Se o tipo do nome do host não puder ser determinado ou se o nome do host for <see langword="null" /> ou uma cadeia de caracteres de tamanho zero, este método retornará <see cref="F:System.UriHostNameType.Unknown" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.CheckHostName%2A> método verifica se o nome do host fornecido atende aos requisitos de um nome de host da Internet. No entanto, ele não executa uma pesquisa de nome de host para verificar a existência do host.  
  
   
  
## Examples  
 O exemplo a seguir verifica se o nome do host é válido.  
  
 [!code-cpp[Classic Uri.CheckHostName Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.CheckHostName Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.CheckHostName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.CheckHostName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSchemeName">
      <MemberSignature Language="C#" Value="public static bool CheckSchemeName (string schemeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool CheckSchemeName(string schemeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSchemeName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CheckSchemeName (schemeName As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool CheckSchemeName(System::String ^ schemeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="schemeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="schemeName">O nome do esquema a ser validado.</param>
        <summary>Determina se o nome do esquema especificado é válido.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o nome do esquema for válido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método verifica o nome do esquema de validade de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, esse método verifica o nome do esquema de validade de acordo com RFC 3986. O nome do esquema deve começar com uma letra e deve conter apenas letras, dígitos e os caracteres ".", "+" ou "-".  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e verifica se o nome do esquema é válido.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CheckSecurity">
      <MemberSignature Language="C#" Value="protected virtual void CheckSecurity ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CheckSecurity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.CheckSecurity" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CheckSecurity ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CheckSecurity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Chamar esse método não tem nenhum efeito.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(class System.Uri uri1, class System.Uri uri2, valuetype System.UriComponents partsToCompare, valuetype System.UriFormat compareFormat, valuetype System.StringComparison comparisonType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Compare(System.Uri,System.Uri,System.UriComponents,System.UriFormat,System.StringComparison)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (uri1 As Uri, uri2 As Uri, partsToCompare As UriComponents, compareFormat As UriFormat, comparisonType As StringComparison) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(Uri ^ uri1, Uri ^ uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
        <Parameter Name="partsToCompare" Type="System.UriComponents" />
        <Parameter Name="compareFormat" Type="System.UriFormat" />
        <Parameter Name="comparisonType" Type="System.StringComparison" />
      </Parameters>
      <Docs>
        <param name="uri1">O primeiro <see cref="T:System.Uri" />.</param>
        <param name="uri2">O segundo <see cref="T:System.Uri" />.</param>
        <param name="partsToCompare">Uma combinação bit a bit dos valores <see cref="T:System.UriComponents" /> que especificam as partes de <c>uri1</c> e <c>uri2</c> a serem comparadas.</param>
        <param name="compareFormat">Um dos valores <see cref="T:System.UriFormat" /> que especificam o escape de caracteres utilizado quando os componentes do URI são comparados.</param>
        <param name="comparisonType">Um dos valores de <see cref="T:System.StringComparison" />.</param>
        <summary>Compara as partes especificadas de dois URIs usando as regras de comparação especificadas.</summary>
        <returns>Um valor <see cref="T:System.Int32" /> que indica a relação lexical entre os componentes <see cref="T:System.Uri" /> comparados.  
  
 <list type="table"><listheader><term> Valor </term><description> Significado </description></listheader><item><term> Menor que zero </term><description><paramref name="uri1" /> é menor que <paramref name="uri2" />.  </description></item><item><term> Zero </term><description><paramref name="uri1" /> é igual a <paramref name="uri2" />.  </description></item><item><term> Maior que zero </term><description><paramref name="uri1" /> é maior que <paramref name="uri2" />. </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se ambos os `uri1` e `uri2` são `null`, esse método retornará 0. Ao comparar valores URI, um URI relativo é sempre menor que um URI absoluto e um URI não nulo é sempre maior do que uma URI nula. Para casos onde ambos `uri1` e `uri2` não `null` e URIs relativos ou ambos os URIs absolutos, o <xref:System.String.Compare%28System.String%2CSystem.String%2CSystem.StringComparison%29?displayProperty=nameWithType> método executa a comparação.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="comparisonType" /> não é um valor <see cref="T:System.StringComparison" /> válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="DnsSafeHost">
      <MemberSignature Language="C#" Value="public string DnsSafeHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DnsSafeHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.DnsSafeHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DnsSafeHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DnsSafeHost { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um nome do host que, depois de não ser escapada, se necessário, é seguro para ser usado para a resolução de DNS.</summary>
        <value>Um <see cref="T:System.String" /> que contém a parte de host do URI em um formato adequado para resolução de DNS, ou a cadeia de caracteres original do host, se ele já é adequado para resolução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para endereços IPv6, os colchetes ([]) são removidos e o <xref:System.Net.IPAddress.ScopeId%2A> propriedade for definida, se tiver sido especificado quando esta instância foi construída.

Se você usou uma cadeia de caracteres de escape para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), DnsSafeHost, em seguida, retorna uma cadeia de caracteres de escape. Unescape qualquer cadeia de caracteres de escape retornada de `DnsSafeHost` antes de usar essa cadeia de caracteres para a resolução DNS (veja o exemplo). Se você usou uma cadeia de caracteres de escape inválida para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm"), DnsSafeHost, em seguida, retorna uma cadeia de caracteres de escape.
  
 O <xref:System.Uri.DnsSafeHost%2A> propriedade é dependente de definições de configuração, conforme discutido posteriormente neste tópico. As definições de configuração não podem ser alteradas por aplicativos da Windows Store, que podem levar a resultados inconsistentes quando usando <xref:System.Uri.DnsSafeHost%2A>. O <xref:System.Uri.IdnHost%2A> é fornecida como uma alternativa ao uso preferencial <xref:System.Uri.DnsSafeHost%2A>, pois <xref:System.Uri.IdnHost%2A> é garantido para ser sempre DNS seguro, não importa qual atual *App. config* configurações podem ser.  
  
 O <xref:System.Uri.DnsSafeHost%2A> propriedade tiver sido estendida no .NET Framework v 3.5, 3.0 SP1, e 2.0 SP1 para fornecer o identificador de recurso internacional (IRI) suporte com base na RFC 3987. Os usuários atuais não verão qualquer mudança do comportamento do .NET Framework 2.0, a menos que habilitem o IRI especificamente. Isso garante a compatibilidade do aplicativo com versões anteriores do .NET Framework.  
  
 Para habilitar o suporte para IRI, as alterações a seguir são necessárias:  
  
1.  Adicione a seguinte linha para o *Machine. config* arquivo no diretório do .NET Framework 2.0  
  
     \<section name="uri" type="System.Configuration.UriSection, System, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />  
  
2.  Especifique se deseja que a análise de nome de domínio internacionalizado (IDN) aplicado ao nome de domínio e se as regras de análise de IRI deve ser aplicada. Isso pode ser feito *Machine. config* ou o *App. config* arquivo. Por exemplo, adicione o seguinte:  
  
    ```xml  
    <configuration>  
      <uri>  
      <idn enabled="All" />  
      <iriParsing enabled="true" />  
      </uri>  
    </configuration>  
    ```  
  
 Habilitar o IDN converterá todos os rótulos Unicode de um nome de domínio para seus equivalentes em Punycode. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--. A razão para isso é dar suporte a servidores DNS existentes na Internet, pois a maioria dos servidores DNS dá suporte somente a caracteres ASCII (consulte RFC 3940).  
  
 A habilitação de IDN só afeta o valor da <xref:System.Uri.DnsSafeHost%2A> propriedade.  
  
 Há três valores possíveis para IDN dependendo os servidores DNS que são usados:  
  
-   IDN habilitado = All  
  
     Esse valor converterá todos os nomes de domínio Unicode em seus equivalentes do Punycode (nomes IDN).  
  
-   IDN habilitado = AllExceptIntranet  
  
     Esse valor converterá todos os nomes de domínio Unicode externos para usar os equivalentes do Punycode (nomes IDN). Nesse caso, para manipular nomes internacionais na Intranet local, os servidores DNS usados para a Intranet devem dar suporte a nomes Unicode.  
  
-   IDN habilitado = nenhum  
  
     Esse valor não converterá nenhum nome de domínio Unicode para usar o Punycode. Este é o valor padrão que é consistente com o comportamento do .NET Framework 2.0.  
  
 Habilitar a análise de IRI (iriParsing habilitado = `true`) fará a normalização e regras de verificação de acordo com a IRI mais recente de caractere em RFC 3987. O valor padrão é `false` e normalização e verificação de acordo com RFC 2396 e RFC 2732 de caracteres (para literais IPv6).  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.Host%2A>, que retorna o nome do host ou endereço especificado no URI e o valor retornado de <xref:System.Uri.DnsSafeHost%2A>, que retorna um endereço que é seguro usar na resolução de DNS.  
  
 [!code-cpp[NCLUriEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#4)]
 [!code-csharp[NCLUriEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#4)]
 [!code-vb[NCLUriEnhancements#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#4)]  

 Conforme explicado em comentários, unescape o nome do host antes de resolvê-lo. Você pode usar o <xref:System.Uri.UnescapeDataString%2A> método unescape o nome do host e você pode resolvê-lo ao chamar o <xref:System.Net.Dns.GetHostEntry%2A> método.

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object comparand);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object comparand) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (comparand As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ comparand);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparand" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="comparand">A instância de <see cref="T:System.Uri" /> ou um identificador de URI a ser comparado à instância atual.</param>
        <summary>Compara duas instâncias de <see cref="T:System.Uri" /> quanto à igualdade.</summary>
        <returns>Um valor de <see cref="T:System.Boolean" /> que é <see langword="true" /> se as duas instâncias representarem o mesmo URI. Caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Equals%2A> método compara as duas instâncias sem considerar as informações do usuário (<xref:System.Uri.UserInfo%2A>) e o fragmento (<xref:System.Uri.Fragment%2A>) partes que podem conter. Por exemplo, considerando os URIs http://www.contoso.com/index.htm#search e http://user:password@www.contoso.com/index.htm, o <xref:System.Uri.Equals%2A> método retornaria `true`.  
  
 Se um <xref:System.Uri> instância é formada com um nome de host de Unicode e `comparand` parâmetro contiver um <xref:System.Uri> instância ou um identificador que é formado com um nome de host que tem o nome de host Punycode equivalente, em seguida, <xref:System.Uri.Equals%2A> retorna `true` somente se o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) está habilitado. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, o <xref:System.Uri.Query%2A> também será ignorado.  
  
> [!NOTE]
>  O <xref:System.Uri.Equals%2A> método pode ser substituído em uma classe derivada; cuidado como uma entidade mal-intencionado poderia modificar o método. Você não deve usar esse método para executar verificações de segurança, a menos que você sabe que essa instância provenientes de uma fonte confiável.  
  
   
  
## Examples  
 Este exemplo cria dois <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `address1` e `address2` são os mesmos, pois o <xref:System.Uri.Fragment%2A> parte é ignorada para essa comparação. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriExamples#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#8)]
 [!code-csharp[NCLUriExamples#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#8)]
 [!code-vb[NCLUriExamples#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#8)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para impedir que o código parcialmente confiável derivando de <see cref="T:System.Uri" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Escape">
      <MemberSignature Language="C#" Value="protected virtual void Escape ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Escape() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Escape" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Escape ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Escape();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Converte caracteres reservados não seguros no componente de caminho para suas representações de caractere hexadecimal.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">O URI passado do construtor é inválido. Essa exceção poderá ocorrer se um URI tiver muitos caracteres ou for relativo.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeDataString">
      <MemberSignature Language="C#" Value="public static string EscapeDataString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeDataString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeDataString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeDataString(System::String ^ stringToEscape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">A cadeia de caracteres a ser escapada.</param>
        <summary>Converte uma cadeia de caracteres em sua representação de escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por padrão, o <xref:System.Uri.EscapeDataString%2A> método converte todos os caracteres, exceto caracteres de não reservados 2396 RFC em sua representação hexadecimal. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.EscapeDataString%2A> método converte todos os caracteres, exceto pelo RFC 3986 caracteres não reservados, em sua representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Este método assume que `stringToEscape` não exibe nenhuma sequência de escape.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987. Consulte esses RFCs para uma definição dos caracteres reservado e não reservado.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block> O tamanho de <paramref name="stringToEscape" /> excede 32.766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="EscapeString">
      <MemberSignature Language="C#" Value="protected static string EscapeString (string str);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig string EscapeString(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function EscapeString (str As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::String ^ EscapeString(System::String ^ str);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">A cadeia de caracteres a ser transformada em sua representação de escape.</param>
        <summary>Converte uma cadeia de caracteres em sua representação de escape.</summary>
        <returns>A representação de escape da cadeia de caracteres.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.EscapeString%2A> método RFC 2396 reservados e todos os caracteres com um valor de caractere maior que 127 converte a representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapeUriString">
      <MemberSignature Language="C#" Value="public static string EscapeUriString (string stringToEscape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string EscapeUriString(string stringToEscape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.EscapeUriString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EscapeUriString (stringToEscape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ EscapeUriString(System::String ^ stringToEscape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToEscape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToEscape">A cadeia de caracteres a ser escapada.</param>
        <summary>Converte uma cadeia de caracteres de URI para sua representação de escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação de escape de <paramref name="stringToEscape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use o <xref:System.Uri.EscapeUriString%2A> método para preparar uma cadeia de caracteres URI sem escape seja um parâmetro para o <xref:System.Uri.%23ctor%2A> construtor.  
  
 Por padrão, o <xref:System.Uri.EscapeUriString%2A> método converte todos os caracteres, exceto RFC 2396 não reservados caracteres em sua representação hexadecimal. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.EscapeUriString%2A> método converte todos os caracteres, exceto pelo RFC 3986 caracteres não reservados, em sua representação hexadecimal. Todos os caracteres Unicode são convertidos em formato UTF-8 antes que estão sendo substituídos.  
  
 Este método assume que `stringToEscape` não exibe nenhuma sequência de escape.  
  
 Por padrão, a cadeia de caracteres é escapada de acordo com RFC 2396. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é escapada de acordo com RFC 3986 e RFC 3987. Consulte esses RFCs para uma definição dos caracteres reservado e não reservado.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToEscape" /> é <see langword="null" />.</exception>
        <exception cref="T:System.UriFormatException">
          <block subset="none" type="note">
            <para>Nos [aplicativos .NET da Windows Store](http://go.microsoft.com/fwlink/?LinkID=247912) ou na [Biblioteca de Classes Portátil](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), capture a exceção de classe base, <see cref="T:System.FormatException" />.</para>
          </block> O tamanho de <paramref name="stringToEscape" /> excede 32.766 caracteres.</exception>
      </Docs>
    </Member>
    <Member MemberName="Fragment">
      <MemberSignature Language="C#" Value="public string Fragment { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Fragment" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Fragment" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Fragment As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Fragment { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o fragmento de URI de escape.</summary>
        <value>Um <see cref="T:System.String" /> que contém informações de fragmento do URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Fragment%2A> propriedade obtém qualquer texto após um marcador de fragmento (#) no URI, incluindo o marcador de fragmento em si. Dado o URI http://www.contoso.com/index.htm#main, o <xref:System.Uri.Fragment%2A> propriedade retornaria #main.  
  
 O <xref:System.Uri.Fragment%2A> propriedade não é considerada em qualquer <xref:System.Uri.Equals%2A> comparação.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava as informações de fragmento no console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="FromHex">
      <MemberSignature Language="C#" Value="public static int FromHex (char digit);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FromHex(char digit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.FromHex(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromHex (digit As Char) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FromHex(char digit);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="digit" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="digit">Os dígitos hexadecimais (0-9, a-f, A-F) a serem convertidos.</param>
        <summary>Obtém o valor decimal de um dígito hexadecimal.</summary>
        <returns>Um valor <see cref="T:System.Int32" /> que contém um número de 0 a 15 que corresponde ao dígito hexadecimal especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.FromHex%2A> método converte um caractere que representa um dígito hexadecimal (0-9, a-f, A-F) para seu valor decimal (0 a 15). Se `digit` não é um dígito hexadecimal válido, um <xref:System.ArgumentException> exceção será lançada.  
  
   
  
## Examples  
 O exemplo a seguir determina se um caractere é um caractere hexadecimal e, se for, grava o valor decimal correspondente para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="digit" /> não é um dígito hexadecimal válido (0-9, a-f, A-F).</exception>
      </Docs>
    </Member>
    <Member MemberName="GetComponents">
      <MemberSignature Language="C#" Value="public string GetComponents (UriComponents components, UriFormat format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetComponents(valuetype System.UriComponents components, valuetype System.UriFormat format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetComponents(System.UriComponents,System.UriFormat)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetComponents (components As UriComponents, format As UriFormat) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetComponents(UriComponents components, UriFormat format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="components" Type="System.UriComponents" />
        <Parameter Name="format" Type="System.UriFormat" />
      </Parameters>
      <Docs>
        <param name="components">Uma combinação bit a bit dos valores <see cref="T:System.UriComponents" /> que especificam quais partes da instância atual a se retornar para o chamador.</param>
        <param name="format">Um dos valores <see cref="T:System.UriFormat" /> que controlam como escapar caracteres especiais.</param>
        <summary>Obtém os componentes especificados da instância atual usando o escape especificado para caracteres especiais.</summary>
        <returns>Um <see cref="T:System.String" /> que contém os componentes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.UriComponents.Query>, <xref:System.UriComponents.Fragment>, <xref:System.UriComponents.Scheme>, <xref:System.UriComponents.UserInfo>, <xref:System.UriComponents.Host>, <xref:System.UriComponents.Port>, e <xref:System.UriComponents.Path> componentes não incluem o delimitador. Você pode combinar o <xref:System.UriComponents.KeepDelimiter> sinalizador (usando o operador OR bit a bit) com qualquer um desses valores para obter o valor com o delimitador. Para todos os outros <xref:System.UriComponents> valores e combinações de valores, os delimitadores são incluídos no valor retornado.  
  
 Os componentes são retornados na ordem em que aparecem no URI. Por exemplo, se <xref:System.UriComponents.Scheme> for especificado, ele aparece primeiro.  
  
 Quando o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) estiverem habilitadas, o número de caracteres retornados no <xref:System.String> aumenta. Nomes de Punycode usados para dar suporte a IRI contenham apenas caracteres ASCII e sempre começam com o prefixo xn-. Quando IRI e IDN estiverem habilitadas, os caracteres substitutos de Unicode são tratados corretamente pelo <xref:System.Uri.GetComponents%2A> método.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
> [!NOTE]
>  Se o <xref:System.Uri.GetComponents%2A> método for chamado com `format` definida como <xref:System.UriFormat.Unescaped> , você não pode usar o valor de retorno como um argumento para um <xref:System.Uri.%23ctor%2A> construtor para criar um equivalente <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="components" /> não é uma combinação de valores <see cref="T:System.UriComponents" /> válidos.</exception>
        <exception cref="T:System.InvalidOperationException">O <see cref="T:System.Uri" /> atual não é um URI absoluto. Não é possível usar os URIs relativos com este método.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o código hash do URI.</summary>
        <returns>Um <see cref="T:System.Int32" /> que contém o valor de hash gerado para este URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o código hash para o console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLeftPart">
      <MemberSignature Language="C#" Value="public string GetLeftPart (UriPartial part);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetLeftPart(valuetype System.UriPartial part) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetLeftPart(System.UriPartial)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLeftPart (part As UriPartial) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetLeftPart(UriPartial part);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="part" Type="System.UriPartial" />
      </Parameters>
      <Docs>
        <param name="part">Um dos valores de <see cref="T:System.UriPartial" /> que especifica o fim da parte do URI a ser retornada.</param>
        <summary>Obtém a parte especificada de uma instância de <see cref="T:System.Uri" />.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a parte especificada da instância de <see cref="T:System.Uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.GetLeftPart%2A> método retorna uma cadeia de caracteres que contém a parte mais à esquerda da cadeia de caracteres URI, terminando com a parte especificada pelo `part`.  
  
 <xref:System.Uri.GetLeftPart%2A> inclui delimitadores nos seguintes casos:  
  
-   <xref:System.UriPartial.Scheme> inclui o delimitador de esquema.  
  
-   <xref:System.UriPartial.Authority> não inclui o delimitador de caminho.  
  
-   <xref:System.UriPartial.Path> inclui qualquer delimitadores no URI original até o delimitador de consulta ou fragmento.  
  
-   <xref:System.UriPartial.Query> inclui o <xref:System.UriPartial.Path>, a consulta e o delimitador.  
  
 Os exemplos a seguir mostram um URI e os resultados da chamada <xref:System.Uri.GetLeftPart%2A> com <xref:System.UriPartial.Scheme>, <xref:System.UriPartial.Authority>, <xref:System.UriPartial.Path>, ou <xref:System.UriPartial.Query>.  
  
|URI|Esquema|Autoridade|Caminho|Consulta|  
|---------|------------|---------------|----------|-----------|  
|http://www.contoso.com/index.htm?date=today|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm?date=today|  
|http://www.contoso.com/index.htm#main|http://|http://www.contoso.com|http://www.contoso.com/index.htm|http://www.contoso.com/index.htm|  
|mailto:user@contoso.com?subject=uri|mailto:|mailto:user@contoso.com|mailto:user@contoso.com?subject=uri|\<Nenhum >|  
|nntp://news.contoso.com/123456@contoso.com|NNTP: / /|nntp://news.contoso.com|nntp://news.contoso.com/123456@contoso.com|nntp://news.contoso.com/123456@contoso.com|  
|news:123456@contoso.com|notícias:|news:123456@contoso.com|news:123456@contoso.com|\<Nenhum >|  
|file://server/filename.ext|file://|file://Server|file://server/filename.ext|file://server/filename.ext|  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o caminho para o console.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A atual instância de <see cref="T:System.Uri" /> não é uma instância absoluta.</exception>
        <exception cref="T:System.ArgumentException">O <paramref name="part" /> especificado não é válido.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="protected void GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Uri" />.</param>
        <summary>Retorna os dados necessários para serializar a instância atual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar os métodos de serialização. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="HexEscape">
      <MemberSignature Language="C#" Value="public static string HexEscape (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string HexEscape(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexEscape(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexEscape (character As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ HexEscape(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O caractere a ser convertido para a representação hexadecimal.</param>
        <summary>Converte um caractere especificado em seu equivalente hexadecimal.</summary>
        <returns>A representação hexadecimal do caractere especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir converte um caractere para seu equivalente hexadecimal e grava-o para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="character" /> é maior que 255.</exception>
      </Docs>
    </Member>
    <Member MemberName="HexUnescape">
      <MemberSignature Language="C#" Value="public static char HexUnescape (string pattern, ref int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig char HexUnescape(string pattern, int32&amp; index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.HexUnescape(System.String,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function HexUnescape (pattern As String, ByRef index As Integer) As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static char HexUnescape(System::String ^ pattern, int % index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="pattern">A representação hexadecimal de um caractere.</param>
        <param name="index">O local no <c>padrão</c> em que começa a representação hexadecimal de um caractere.</param>
        <summary>Converte uma representação hexadecimal especificada de um caractere no caractere.</summary>
        <returns>O caractere representado pela codificação hexadecimal na posição <paramref name="index" />. Se o caractere no <paramref name="index" /> não for codificado em hexadecimal, o caractere no <paramref name="index" /> será retornado. O valor de <paramref name="index" /> é incrementado para apontar para o caractere seguinte ao retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O exemplo de código a seguir determina se é um caractere hexadecimal codificado e, nesse caso, grava o caractere equivalente para o console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" /> é menor que 0 ou maior ou igual ao número de caracteres em <paramref name="pattern" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public string Host { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Host" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Host" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Host As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Host { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o componente de host desta instância.</summary>
        <value>Um <see cref="T:System.String" /> que contém o nome do host. Isso geralmente é o nome de host DNS ou endereço IP do servidor.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ao contrário do <xref:System.Uri.Authority%2A> propriedade, o valor da propriedade não inclui o número da porta.  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do host (www.contoso.com) do servidor no console.  
  
 [!code-cpp[Classic Uri.Host Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Host Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Host Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Host Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Host Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Host Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="HostNameType">
      <MemberSignature Language="C#" Value="public UriHostNameType HostNameType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.UriHostNameType HostNameType" />
      <MemberSignature Language="DocId" Value="P:System.Uri.HostNameType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HostNameType As UriHostNameType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property UriHostNameType HostNameType { UriHostNameType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UriHostNameType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tipo do nome de host especificado no URI.</summary>
        <value>Um membro da enumeração de <see cref="T:System.UriHostNameType" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e grava o <xref:System.Uri.HostNameType%2A> para o console.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IdnHost">
      <MemberSignature Language="C#" Value="public string IdnHost { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string IdnHost" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IdnHost" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IdnHost As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ IdnHost { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>O Nome de Domínio Internacional do host em conformidade com RFC 3490 usando Punycode conforme apropriado. Esta cadeia de caracteres, depois de não ser escapada, se necessário, é seguro para ser usado para a resolução de DNS.</summary>
        <value>Retorna o nome do host, formatado com Punycode de acordo com o padrão IDN<see cref="T:System.String" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é fornecida para o uso de protocolos de rede de nível inferior que exigem o nome de domínio no formato Punycode. Se seu código não precisar desse formato específico, use <xref:System.Uri.Host%2A> para o nome do host.  
  
 Preterido <xref:System.Uri.DnsSafeHost%2A> propriedade é dependente de *App. config* configurações, que não podem ser alteradas por aplicativos da Windows Store. IdnHost é fornecido como uma alternativa ao uso preferencial <xref:System.Uri.DnsSafeHost%2A>, pois <xref:System.Uri.IdnHost%2A> é garantido para ser sempre DNS seguro, não importa qual atual *App. config* configurações podem ser.  

 Se você usou uma cadeia de caracteres de escape para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%254]/temp/example.htm"), IdnHost, em seguida, retorna uma cadeia de caracteres de escape. Você deve unescape qualquer cadeia de caracteres de escape retornada de IdnHost antes de usar essa cadeia de caracteres para a resolução DNS. Lembre-se que, se você usou uma cadeia de caracteres de escape inválida para construir essa instância (por exemplo, "http://[fe80::200:39ff:fe36:1a2d%4]/temp/example.htm") e, em seguida, IdnHost retorna uma cadeia de caracteres de escape.


 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAbsoluteUri">
      <MemberSignature Language="C#" Value="public bool IsAbsoluteUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbsoluteUri" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsAbsoluteUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbsoluteUri As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbsoluteUri { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se a instância <see cref="T:System.Uri" /> é absoluta.</summary>
        <value>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o <see cref="T:System.Uri" /> instância é absoluto; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta propriedade é `true` se a cadeia de caracteres ou <xref:System.Uri> instância que foi passada para o construtor pode ser analisada como um absoluto <xref:System.Uri> instância, que contém um esquema, uma autoridade e um caminho. Caso contrário, o <xref:System.Uri> instância é tratada como relativa e pode omitir o esquema ou outros componentes do URI.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBadFileSystemCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsBadFileSystemCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsBadFileSystemCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBadFileSystemCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsBadFileSystemCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsBadFileSystemCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Determina se um caractere é inválido em um nome de sistema de arquivos.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se o caractere especificado é inválido, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O caractere é analisado de acordo com as regras para o sistema de arquivos NTFS.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBaseOf">
      <MemberSignature Language="C#" Value="public bool IsBaseOf (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsBaseOf(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsBaseOf(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsBaseOf(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">A instância <see cref="T:System.Uri" /> especificada a ser testada.</param>
        <summary>Determina se a instância <see cref="T:System.Uri" /> atual é uma base da instância <see cref="T:System.Uri" /> especificada.</summary>
        <returns>
          <see langword="true" /> se a instância <see cref="T:System.Uri" /> atual é uma base da <paramref name="uri" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsBaseOf%2A> é usado para comparar atual <xref:System.Uri> instância especificada <xref:System.Uri> para determinar se esse URI é uma base especificado <xref:System.Uri>. Ao comparar dois <xref:System.Uri> objetos para determinar uma relação de base, as informações do usuário (<xref:System.Uri.UserInfo%2A>) não será avaliada. Ao comparar dois URIs (uri1 e uri2), uri1 é a base de uri2 se, quando você ignorar tudo no uri2 após a última barra (/), os dois URIs são idênticos. Usando http://host/path/path/file?query como o URI de base, a tabela a seguir mostra se ele é uma base de outros URIs.  
  
|URI|http://host/path/path/file?query é a base de|  
|---------|------------------------------------------------------|  
|http://host/path/path/file/|sim|  
|http://host/path/path/#fragment|sim|  
|http://host/path/path/MoreDir/"|sim|  
|http://host/path/path/OtherFile?Query|sim|  
|http://host/path/path/|sim|  
|http://host/path/path/file|sim|  
|http://host/path/path|no|  
|http://host/path/path?query|no|  
|http://host/path/path#Fragment|no|  
|http://host/path/path2/|no|  
: //host/path/path2/MoreDir|no|  
|http://host/path/File|no|  
  
   
  
## Examples  
 Este exemplo cria um <xref:System.Uri> instância que representa uma base <xref:System.Uri> instância. Em seguida, cria um segundo <xref:System.Uri> instância de uma cadeia de caracteres. Ele chama <xref:System.Uri.IsBaseOf%2A> para determinar se a instância de base é a base da segunda instância. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#6)]
 [!code-csharp[NCLUriEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#6)]
 [!code-vb[NCLUriEnhancements#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsDefaultPort">
      <MemberSignature Language="C#" Value="public bool IsDefaultPort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefaultPort" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsDefaultPort" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDefaultPort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDefaultPort { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determina se o valor da porta do URI é o padrão para este esquema.</summary>
        <value>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se o valor de <see cref="P:System.Uri.Port" /> propriedade é o padrão porta para este esquema; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e verifica se ele usa a porta padrão.  
  
 [!code-cpp[NCLUriExamples#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#4)]
 [!code-csharp[NCLUriExamples#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#4)]
 [!code-vb[NCLUriExamples#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsExcludedCharacter">
      <MemberSignature Language="C#" Value="protected static bool IsExcludedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig bool IsExcludedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsExcludedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function IsExcludedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static bool IsExcludedCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Obtém se o caractere especificado deve ser escapado.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se o caractere especificado deve ser escapado, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFile">
      <MemberSignature Language="C#" Value="public bool IsFile { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFile" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsFile" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFile As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFile { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Uri" /> especificado é um URI de arquivo.</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se o <see cref="T:System.Uri" /> é um URI de arquivo; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsFile%2A> é de propriedade `true` quando o <xref:System.Uri.Scheme%2A> propriedade é igual a <xref:System.Uri.UriSchemeFile>.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele é um URI de arquivo.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsHexDigit">
      <MemberSignature Language="C#" Value="public static bool IsHexDigit (char character);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexDigit(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexDigit(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexDigit (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexDigit(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O caractere a ser validado.</param>
        <summary>Determina se um caractere especificado é um dígito hexadecimal válido.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" />, se o caractere for um dígito hexadecimal válido, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dígitos hexadecimais são os dígitos 0 a 9 e as letras A-F ou a-f.  
  
   
  
## Examples  
 O exemplo a seguir determina se um caractere é um caractere hexadecimal e, se for, grava o valor decimal correspondente para o console.  
  
 [!code-cpp[NCLUriExamples#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#1)]
 [!code-csharp[NCLUriExamples#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#1)]
 [!code-vb[NCLUriExamples#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHexEncoding">
      <MemberSignature Language="C#" Value="public static bool IsHexEncoding (string pattern, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsHexEncoding(string pattern, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsHexEncoding(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsHexEncoding (pattern As String, index As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsHexEncoding(System::String ^ pattern, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pattern" Type="System.String" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pattern">A cadeia de caracteres a ser verificada.</param>
        <param name="index">O local no <c>padrão</c> a ser verificado quanto à codificação hexadecimal.</param>
        <summary>Determina se um caractere em uma cadeia de caracteres é codificada em hexadecimal.</summary>
        <returns>Um <see cref="T:System.Boolean" /> valor que é <see langword="true" /> se <paramref name="pattern" /> é codificado em hexadecimal no local especificado, caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsHexEncoding%2A> método verifica para codificação hexadecimal que segue o padrão "% hexhex" em uma cadeia de caracteres, onde "hexadecimal" é um dígito de 0 a 9 ou uma letra de A-F (diferencia maiusculas de minúsculas).  
  
   
  
## Examples  
 O exemplo de código a seguir determina se é um caractere hexadecimal codificado e, nesse caso, grava o caractere equivalente para o console.  
  
 [!code-cpp[NCLUriExamples#2](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#2)]
 [!code-csharp[NCLUriExamples#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#2)]
 [!code-vb[NCLUriExamples#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoopback">
      <MemberSignature Language="C#" Value="public bool IsLoopback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsLoopback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoopback { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém se o <see cref="T:System.Uri" /> especificado faz referência ao host local.</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" />, se esse <see cref="T:System.Uri" /> fizer referência ao host local; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Uri.IsLoopback%2A> Retorna `true` se o URI especificado quando esta instância foi criada foi loopback, 127.0.0.1 ou localhost, ou se o URI não especificou hospeda informações (por exemplo, file:///c:Dir/file.txt). Todos os outros retorno URIs `false`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele faz referência a um host local.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsReservedCharacter">
      <MemberSignature Language="C#" Value="protected virtual bool IsReservedCharacter (char character);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsReservedCharacter(char character) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsReservedCharacter(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsReservedCharacter (character As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsReservedCharacter(char character);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="character" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="character">O <see cref="T:System.Char" /> a ser testado.</param>
        <summary>Obtém se o caractere especificado é um caractere reservado.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se o caractere especificado é um caractere reservado, caso contrário, <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnc">
      <MemberSignature Language="C#" Value="public bool IsUnc { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnc" />
      <MemberSignature Language="DocId" Value="P:System.Uri.IsUnc" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnc As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnc { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Identifica se o <see cref="T:System.Uri" /> especificado é um caminho UNC (Convenção de Nomenclatura Universal).</summary>
        <value>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se <see cref="T:System.Uri" /> for um caminho UNC; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.IsUnc%2A> é de propriedade `true` se especificado <xref:System.Uri> instância é um caminho UNC (como \\\server\folder ou file://server/folder). Essa propriedade sempre retorna `true` se o URI com o esquema file:// e especifica um componente do host.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele é um caminho UNC.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedOriginalString">
      <MemberSignature Language="C#" Value="public bool IsWellFormedOriginalString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsWellFormedOriginalString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedOriginalString" />
      <MemberSignature Language="VB.NET" Value="Public Function IsWellFormedOriginalString () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsWellFormedOriginalString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Indica se a cadeia de caracteres usada para construir essa <see cref="T:System.Uri" /> foi bem formada e não é necessário realizar o escape adicional.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se a cadeia de caracteres foi bem formada, caso contrário <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres é considerada bem formado de acordo com RFC 2396 e RFC 2732 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, a cadeia de caracteres é considerada bem formado de acordo com RFC 3986 e RFC 3987  
  
 A cadeia de caracteres é considerada mal formada, fazendo com que o método retornar falso, se ocorrer qualquer uma das condições a seguir.  
  
|Erro|Exemplo|  
|-----------|-------------|  
|A cadeia de caracteres não tem escape definida corretamente.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|A cadeia de caracteres é um absoluto <xref:System.Uri> que representa um arquivo implícita <xref:System.Uri>.|c:\\\directory\filename|  
|A cadeia de caracteres é um URI absoluto que não tem uma barra antes do caminho.|file://c:/Directory/filename|  
|A cadeia de caracteres contém barras invertidas de escape, mesmo se eles são tratados como barras.|http:\\\host/path/file|  
|A cadeia de caracteres representa um absoluto hierárquico <xref:System.Uri> e não contêm "://".|www.contoso.com/Path/File|  
|O analisador para o <xref:System.Uri.Scheme%2A?displayProperty=nameWithType> indica que a cadeia de caracteres original não foi bem formada.|O exemplo depende do esquema do URI.|  
  
 Por padrão, a cadeia de caracteres usado para construir esse <xref:System.Uri> são considerados bem formados no acordo com RFC 2396 e RFC 2732.  
  
 Quando o identificador de recurso internacional (IRI) e suporte de nome de domínio internacionalizado (IDN) estão habilitadas, a cadeia de caracteres usado para construir esse <xref:System.Uri> são considerados bem formados no acordo com RFC 3986 e RFC 3987. Nomes de Punycode usados para dar suporte a IRI contenham apenas caracteres ASCII e sempre começam com o prefixo xn-.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWellFormedUriString">
      <MemberSignature Language="C#" Value="public static bool IsWellFormedUriString (string uriString, UriKind uriKind);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsWellFormedUriString(string uriString, valuetype System.UriKind uriKind) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.IsWellFormedUriString(System.String,System.UriKind)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsWellFormedUriString(System::String ^ uriString, UriKind uriKind);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
      </Parameters>
      <Docs>
        <param name="uriString">A cadeia de caracteres usada na tentativa de construir um <see cref="T:System.Uri" />.</param>
        <param name="uriKind">O tipo do <see cref="T:System.Uri" /> em <c>uriString</c>.</param>
        <summary>Indica se a cadeia de caracteres é bem formada pela tentativa de construir um URI com a cadeia de caracteres e garante que a cadeia de caracteres não requer mais de escape.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se a cadeia de caracteres foi bem formada, caso contrário <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nas versões do .NET anteriores à versão 4.5, por padrão a cadeia de caracteres é considerada válido de acordo com RFC 2396 e RFC 2732. Se os identificadores de recurso (íris) ou o nome de domínio internacionalizado (IDN) de análise é habilitado, a cadeia de caracteres é considerada válido de acordo com RFC 3986 e RFC 3987.  
  
 A partir do .NET 4.5, cadeias de caracteres são sempre consideradas bem formados no acordo com RFC 3986 e RFC 3987, ou não IRI ou IDN estão habilitados. No entanto, observe que isso só é verdadeiro para aplicativos de destino .NET 4.5 ou posterior. Aplicativos que se destinam a .NET 4.0 invocar código de compatibilidade e o antigo comportamento de (pre-4.5).  
  
 A cadeia de caracteres é considerada mal formada, fazendo com que o método retornar falso, se ocorrer qualquer uma das condições a seguir  
  
|Erro|Exemplo|  
|-----------|-------------|  
|A cadeia de caracteres não tem escape definida corretamente.|[http://www.contoso.com/path???/file](http://www.contoso.com/path???/file) Nome|  
|A cadeia de caracteres é um absoluto <xref:System.Uri> que representa um arquivo implícita <xref:System.Uri>.|c:\\\directory\filename|  
|A cadeia de caracteres é um URI absoluto que não tem uma barra antes do caminho.|file://c:/Directory/filename|  
|A cadeia de caracteres contém barras invertidas de escape, mesmo se eles serão tratados como barras|http:\\\host/path/file|  
|A cadeia de caracteres representa um absoluto hierárquico <xref:System.Uri> e não contêm "://"|www.contoso.com/Path/File|  
|O analisador para o <xref:System.Uri.Scheme%2A> indica que a cadeia de caracteres original não foi bem formada.|O exemplo depende do esquema do URI.|  
|Começando com o .NET 4.5, relativo a URIs com dois-pontos (': ') no seu primeiro segmento não são considerados bem formado.|2013.05.29_14:33:41|  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalPath">
      <MemberSignature Language="C#" Value="public string LocalPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalPath" />
      <MemberSignature Language="DocId" Value="P:System.Uri.LocalPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ LocalPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma representação local do sistema operacional de um nome de arquivo.</summary>
        <value>Uma <see cref="T:System.String" /> que contém uma representação do sistema operacional de um nome de arquivo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade é sem escape. Se o caminho é reconhecido como um caminho de arquivo do Windows, todas as barras (/) são substituídas por invertidas (\\).  
  
 Para o URI `file://computer/file.ext`, o caminho absoluto é `/file.ext` e o caminho local é `\\computer\file.ext`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava o caminho local para o console.  
  
 [!code-cpp[NCLUriExamples#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#6)]
 [!code-csharp[NCLUriExamples#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#6)]
 [!code-vb[NCLUriExamples#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelative">
      <MemberSignature Language="C#" Value="public string MakeRelative (Uri toUri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string MakeRelative(class System.Uri toUri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelative(System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Function MakeRelative (toUri As Uri) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ MakeRelative(Uri ^ toUri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="toUri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="toUri">O URI a ser comparado com o URI atual.</param>
        <summary>Determina a diferença entre duas instâncias <see cref="T:System.Uri" />.</summary>
        <returns>Se o nome de host e o esquema dessa instância do URI e <paramref name="toUri" /> forem os mesmos, esse método retornará um <see cref="T:System.String" /> representando um URI relativo que, quando for anexado à instância atual do URI, gerará o parâmetro <paramref name="toUri" />.  Se o nome do host ou o esquema for diferente, esse método retornará um <see cref="T:System.String" /> que representa o parâmetro <paramref name="toUri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra a instância do URI, `toUri`e os resultados da chamada <xref:System.Uri.MakeRelative%2A>.  
  
|Instância atual do URI|`toUri`|Valor retornado|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Informações do usuário, se presente no URI, serão ignoradas.  
  
   
  
## Examples  
 O exemplo a seguir cria 2 <xref:System.Uri> instâncias. A diferença nas informações de caminho é gravada no console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="toUri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Essa instância representa um URI relativo e esse método é válido apenas para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeRelativeUri">
      <MemberSignature Language="C#" Value="public Uri MakeRelativeUri (Uri uri);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Uri MakeRelativeUri(class System.Uri uri) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.MakeRelativeUri(System.Uri)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Uri ^ MakeRelativeUri(Uri ^ uri);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri">O URI a ser comparado com o URI atual.</param>
        <summary>Determina a diferença entre duas instâncias <see cref="T:System.Uri" />.</summary>
        <returns>Se o nome de host e o esquema dessa instância do URI e <paramref name="uri" /> forem os mesmos, esse método retornará um <see cref="T:System.Uri" /> relativo que, quando for anexado à instância atual do URI, gerará <paramref name="uri" />.  Se o nome do host ou o esquema for diferente, esse método retornará um <see cref="T:System.Uri" /> que representa o parâmetro <paramref name="uri" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A tabela a seguir mostra a instância do URI, `toUri`e os resultados da chamada <xref:System.Uri.MakeRelativeUri%2A>.  
  
|Instância atual do URI|`toUri`|Valor retornado|  
|--------------------------|-------------|------------------|  
|http://www.contoso.com/|http://www.contoso.com/test/test.htm|Test/Test.htm|  
|http://www.contoso.com/test1/|http://www.contoso.com/|../|  
|http://www.contoso.com:8000/|http://www.contoso.com/test/test.htm|http://www.contoso.com/test/test.htm|  
|http://username@www.contoso.com/|http://www.contoso.com/test1/test1.txt|Test1/test1.txt|  
  
 Informações do usuário, se presente no URI, serão ignoradas.  
  
   
  
## Examples  
 O exemplo a seguir cria 2 <xref:System.Uri> instâncias. A diferença nas informações de caminho é gravada no console.  
  
 [!code-cpp[NCLUriExamples#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#3)]
 [!code-csharp[NCLUriExamples#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#3)]
 [!code-vb[NCLUriExamples#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="uri" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Equality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Uri ^ uri1, Uri ^ uri2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Uma instância <see cref="T:System.Uri" /> a ser comparada com <c>uri2</c>.</param>
        <param name="uri2">Uma instância <see cref="T:System.Uri" /> a ser comparada com <c>uri1</c>.</param>
        <summary>Determina se duas instâncias <see cref="T:System.Uri" /> têm o mesmo valor.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se as instâncias <see cref="T:System.Uri" /> forem equivalentes; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga usa o <xref:System.Uri.Equals%2A> método para determinar se os dois <xref:System.Uri> instâncias forem equivalentes. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> conteúdo será ignorado ao fazer essa comparação.  
  
   
  
## Examples  
 Este exemplo cria três <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `Address1` e `Address2` são os mesmos, pois o <xref:System.Uri.Fragment%2A> parte é ignorada para essa comparação. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Uri uri1, Uri uri2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Uri uri1, class System.Uri uri2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.op_Inequality(System.Uri,System.Uri)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (uri1 As Uri, uri2 As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Uri ^ uri1, Uri ^ uri2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri1" Type="System.Uri" />
        <Parameter Name="uri2" Type="System.Uri" />
      </Parameters>
      <Docs>
        <param name="uri1">Uma instância <see cref="T:System.Uri" /> a ser comparada com <c>uri2</c>.</param>
        <param name="uri2">Uma instância <see cref="T:System.Uri" /> a ser comparada com <c>uri1</c>.</param>
        <summary>Determina se duas instâncias de <see cref="T:System.Uri" /> não têm o mesmo valor.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que é <see langword="true" /> se as duas instâncias <see cref="T:System.Uri" /> não são iguais, caso contrário, <see langword="false" />. Se o parâmetro é <see langword="null" />, esse método retorna <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga usa o <xref:System.Uri.Equals%2A> método para determinar se os dois <xref:System.Uri> instâncias não são equivalentes. <xref:System.Uri.UserInfo%2A> e <xref:System.Uri.Fragment%2A> conteúdo será ignorado ao fazer essa comparação.  
  
   
  
## Examples  
 Este exemplo cria três <xref:System.Uri> instâncias de cadeias de caracteres e compara-as para determinar se eles representam o mesmo valor. `Address2` e `Address3` não são iguais porque `Address3` contém um <xref:System.Uri.Query%2A> que não foi encontrado no `Address2`. O resultado é gravado no console.  
  
 [!code-cpp[NCLUriEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#5)]
 [!code-csharp[NCLUriEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#5)]
 [!code-vb[NCLUriEnhancements#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OriginalString">
      <MemberSignature Language="C#" Value="public string OriginalString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OriginalString" />
      <MemberSignature Language="DocId" Value="P:System.Uri.OriginalString" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OriginalString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a cadeia de caracteres do URI original que foi passada para o construtor <see cref="T:System.Uri" />.</summary>
        <value>Um <see cref="T:System.String" /> que contém o URI exato especificado quando esta instância foi construída; caso contrário, <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o URI especificado para o construtor contiver espaços à direita ou, esses espaços são preservados.  
  
 O valor retornado por essa propriedade é diferente do <xref:System.Uri.ToString%2A> e <xref:System.Uri.AbsoluteUri%2A>. <xref:System.Uri.ToString%2A> Retorna o formulário canonicamente sem escape do URI. <xref:System.Uri.AbsoluteUri%2A> Retorna o formulário canonicamente com caracteres de escape do URI.  
  
 Quando o suporte a identificador de recurso internacional (IRI) e o nome de domínio internacionalizado (IDN) estiverem habilitadas, <xref:System.Uri.OriginalString%2A> retorna a cadeia de caracteres não normalizada original com o nome de host Punycode se estava sendo usado para inicializar o <xref:System.Uri> instância. Os nomes Punycode contêm apenas caracteres ASCII e sempre começam com o prefixo xn--.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
 Quando um <xref:System.Uri> o objeto é serializado, o <xref:System.Uri.OriginalString%2A> não é preservada. O processo de serialização usa o totalmente com caracteres de escape e a conversão em formato canônico <xref:System.Uri.AbsoluteUri%2A> propriedade ao serializar. Para uma <xref:System.Uri> que contém um endereço IPv6, o endereço IPv6 e a identificação de escopo são incluídos na serializada <xref:System.Uri> objeto.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.OriginalString%2A>, que retorna a cadeia de caracteres que foi passada para o construtor e de uma chamada para <xref:System.Uri.ToString%2A>, que retorna a forma canônica da cadeia de caracteres.  
  
 [!code-cpp[NCLUriEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriEnhancements/CPP/nclurienhancements.cpp#3)]
 [!code-csharp[NCLUriEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriEnhancements/CS/nclurienhancements.cs#3)]
 [!code-vb[NCLUriEnhancements#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriEnhancements/VB/nclurienhancements.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected virtual void Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Parse ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Parse();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analisa o URI da instância atual para garantir que contenha todas as partes necessárias para um URI válido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.UriFormatException">O URI passado do construtor é inválido.</exception>
      </Docs>
    </Member>
    <Member MemberName="PathAndQuery">
      <MemberSignature Language="C#" Value="public string PathAndQuery { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PathAndQuery" />
      <MemberSignature Language="DocId" Value="P:System.Uri.PathAndQuery" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PathAndQuery As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ PathAndQuery { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém as propriedades <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separadas por um ponto de interrogação (?).</summary>
        <value>Um <see cref="T:System.String" /> que contém as propriedades <see cref="P:System.Uri.AbsolutePath" /> e <see cref="P:System.Uri.Query" /> separadas por um ponto de interrogação (?).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.PathAndQuery%2A> propriedade contém o caminho absoluto no servidor e as informações de consulta enviada com a solicitação. Ele é idêntico ao concatenar a <xref:System.Uri.AbsolutePath%2A> e <xref:System.Uri.Query%2A> propriedades.  
  
 O <xref:System.Uri.PathAndQuery%2A> propriedade é escapada de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, o <xref:System.Uri.PathAndQuery%2A> propriedade é escapada de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir grava o caminho URI (/ catalog/shownew.htm) e a consulta (Data = hoje) informações para o console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.PathAndQuery Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.PathAndQuery Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Port">
      <MemberSignature Language="C#" Value="public int Port { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Port" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Port" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Port As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Port { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número da porta desse URI.</summary>
        <value>Um valor <see cref="T:System.Int32" /> que contém o número da porta para esse URI.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número da porta define a porta do protocolo usada para contatar o servidor referenciado no URI. Se uma porta não for especificada como parte do URI de <xref:System.Uri.Port%2A> propriedade retorna o valor padrão para o protocolo. Se não houver nenhum número de porta padrão, essa propriedade retornará -1.  
  
   
  
## Examples  
 O exemplo a seguir grava o número de porta URI para o console. Nesse caso, o valor é o número de porta padrão para HTTP, a porta 80.  
  
 [!code-cpp[Classic Uri.Port Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Port Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Port Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Port Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Port Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Port Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Query">
      <MemberSignature Language="C#" Value="public string Query { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Query" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Query" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Query As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Query { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém informações de consulta incluídas no URI especificado.</summary>
        <value>Um <see cref="T:System.String" /> que contém quaisquer informações de consulta incluídas no URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Query%2A> propriedade contém informações de consulta incluídas no URI. Informações de consulta são separadas das informações de caminho por um ponto de interrogação (?) e continua até o final do URI. As informações de consulta retornadas incluem o principal ponto de interrogação.  
  
 As informações de consulta são escapadas de acordo com RFC 2396 por padrão. Se os identificadores de recurso (íris) ou análise de nome de domínio internacionalizado (IDN) estiver habilitado, as informações de consulta são escapadas de acordo com RFC 3986 e RFC 3987.  
  
 Para obter mais informações sobre o suporte IRI, consulte a seção Comentários da classe <xref:System.Uri>.  
  
   
  
## Examples  
 O exemplo a seguir grava a consulta? data = hoje no console.  
  
 [!code-cpp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Uri.PathAndQuery Example#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/CS/source.cs#2)]
 [!code-vb[Classic Uri.PathAndQuery Example#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.PathAndQuery Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="Scheme">
      <MemberSignature Language="C#" Value="public string Scheme { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Scheme" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Scheme" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Scheme As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Scheme { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do esquema para esse URI.</summary>
        <value>Um <see cref="T:System.String" /> que contém o esquema para este URI, convertido em minúsculas.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Scheme%2A> propriedade retorna o esquema usado para inicializar o <xref:System.Uri> instância. Essa propriedade não indica que o esquema usado para inicializar o <xref:System.Uri> instância foi reconhecida.  
  
 A tabela a seguir mostra exemplos de algumas possíveis valores retornados pelo <xref:System.Uri.Scheme%2A> propriedade.  
  
|Esquema|Descrição|  
|------------|-----------------|  
|Arquivo |O recurso é um arquivo no computador local.|  
|FTP|O recurso é acessado por meio de FTP.|  
|gopher|O recurso é acessado por meio do protocolo de Gopher.|  
|HTTP|O recurso é acessado por meio de HTTP.|  
|HTTPS|O recurso é acessado por meio de HTTP criptografada por SSL.|  
|LDAP|O recurso é acessado por meio do protocolo LDAP.|  
|mailto|O recurso é um endereço de email e acessados por meio do protocolo SMTP.|  
|net.pipe|O recurso é acessado por meio de um pipe nomeado.|  
|net.tcp|O recurso é acessado de ponto de extremidade TCP.|  
|notícias|O recurso é acessado por meio do protocolo NNTP.|  
|NNTP|O recurso é acessado por meio do protocolo NNTP.|  
|telnet|O recurso é acessado por meio do protocolo TELNET.|  
|uuid|O recurso é acessado por meio de um nome de ponto de extremidade UUID exclusivo para se comunicar com um serviço.|  
  
   
  
## Examples  
 O exemplo a seguir grava o nome do esquema (http) para o console para o http://www.contoso.com/ URI.  
  
 [!code-cpp[Classic Uri.Scheme Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Uri.Scheme Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Uri.Scheme Example/CS/source.cs#1)]
 [!code-vb[Classic Uri.Scheme Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Uri.Scheme Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="SchemeDelimiter">
      <MemberSignature Language="C#" Value="public static readonly string SchemeDelimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string SchemeDelimiter" />
      <MemberSignature Language="DocId" Value="F:System.Uri.SchemeDelimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SchemeDelimiter As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ SchemeDelimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica os caracteres que separam o esquema de protocolo de comunicação da parte do endereço do URI. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria uma cadeia de caracteres de <xref:System.Uri.UriSchemeHttp>, <xref:System.Uri.SchemeDelimiter>e um endereço. Um <xref:System.Uri> instância é então criada usando a cadeia de caracteres.  
  
 [!code-cpp[NCLUriExamples#17](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#17)]
 [!code-csharp[NCLUriExamples#17](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#17)]
 [!code-vb[NCLUriExamples#17](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#17)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Segments">
      <MemberSignature Language="C#" Value="public string[] Segments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string[] Segments" />
      <MemberSignature Language="DocId" Value="P:System.Uri.Segments" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Segments As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::String ^&gt; ^ Segments { cli::array &lt;System::String ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém uma matriz contendo os segmentos de caminho que compõem o URI especificado.</summary>
        <value>Uma matriz de <see cref="T:System.String" /> contendo os segmentos de caminho que compõem o URI especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.Segments%2A> propriedade retorna uma matriz de cadeias de caracteres que contém os "segmentos" (subcadeias de caracteres) que formam o caminho absoluto do URI. O primeiro segmento é obtido ao analisar o caminho absoluto do seu primeiro caractere até alcançar uma barra (/) ou no final do caminho. Cada segmento adicional começa no primeiro caractere após o segmento anterior e termina com a próxima barra ou o final do caminho. (Caminho absoluto do URI contém tudo após o host e a porta e antes da consulta e o fragmento).  
  
 O exemplo a seguir mostra o caminho absoluto e segmentos para dois URIs. O segundo exemplo ilustra que o fragmento e a consulta não fazem parte do caminho absoluto e, portanto, não são segmentos.  
  
 URI absoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm  
  
 Caminho absoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 URI absoluto  
 http://www.contoso.com/Chapters/Chapter1/Sections/Section1.htm#page1?answer=NO  
  
 Caminho absoluto  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Segmentos  
 /Chapters/Chapter1/Sections/Section1.htm  
  
 Observe que, como o caminho absoluto inicia com um '/', o primeiro segmento contém e nada mais.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância com 3 segmentos e exibe os segmentos na tela.  
  
 [!code-cpp[NCLUriExamples#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#5)]
 [!code-csharp[NCLUriExamples#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#5)]
 [!code-vb[NCLUriExamples#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo serializationInfo, System.Runtime.Serialization.StreamingContext streamingContext);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo serializationInfo, valuetype System.Runtime.Serialization.StreamingContext streamingContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ serializationInfo, System::Runtime::Serialization::StreamingContext streamingContext) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationInfo" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="streamingContext" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="serializationInfo">Um objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contém as informações necessárias para serializar o <see cref="T:System.Uri" />.</param>
        <param name="streamingContext">Um objeto <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contém a origem e o destino do fluxo serializado associado a <see cref="T:System.Uri" />.</param>
        <summary>Retorna os dados necessários para serializar a instância atual.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para usar os métodos de serialização. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém uma representação de cadeia de caracteres canônica para a instância <see cref="T:System.Uri" /> especificada.</summary>
        <returns>Uma instância <see cref="T:System.String" /> que contém a representação canônica sem escape da instância <see cref="T:System.Uri" />. Todos os caracteres são sem escape exceto #,? e %.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres retornada por este método não contém informações de porta quando a porta é a porta padrão para o esquema.  
  
> [!NOTE]
>  A cadeia de caracteres retornada pelo <xref:System.Uri.ToString%2A> método pode conter caracteres de controle, que podem corromper o estado de um aplicativo de console. Você pode usar o <xref:System.Uri.GetComponents%2A> método com o <xref:System.UriFormat.SafeUnescaped?displayProperty=nameWithType> formato remover caracteres de controle de cadeia de caracteres retornada.  
  
   
  
## Examples  
 O exemplo a seguir cria um novo <xref:System.Uri> instância de uma cadeia de caracteres. Ele ilustra a diferença entre o valor retornado de <xref:System.Uri.OriginalString%2A>, que retorna a cadeia de caracteres que foi passada para o construtor e de uma chamada para <xref:System.Uri.ToString%2A>, que retorna a forma canônica da cadeia de caracteres.  
  
 [!code-cpp[NCLUriExamples#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#7)]
 [!code-csharp[NCLUriExamples#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#7)]
 [!code-vb[NCLUriExamples#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#7)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Para impedir que o código parcialmente confiável derivando de <see cref="T:System.Uri" />. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Infrastructure" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryCreate">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo <see cref="T:System.Uri" />. Não gera uma exceção se o <see cref="T:System.Uri" /> não pode ser criado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (string uriString, UriKind uriKind, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(string uriString, valuetype System.UriKind uriKind, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.String,System.UriKind,System.Uri@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(System::String ^ uriString, UriKind uriKind, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uriString" Type="System.String" />
        <Parameter Name="uriKind" Type="System.UriKind" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="uriString">O <see cref="T:System.String" /> que representa o <see cref="T:System.Uri" />.</param>
        <param name="uriKind">O tipo do URI.</param>
        <param name="result">Quando este método retorna, ele contém o <see cref="T:System.Uri" /> construído.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a instância <see cref="T:System.String" /> especificada e um <see cref="T:System.UriKind" />.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, string relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, string relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.String,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As String, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, System::String ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.String" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">O <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">O <see cref="T:System.Uri" /> relativo, representado como um <see cref="T:System.String" />, a ser adicionado ao <see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quando este método retorna, ele contém um <see cref="T:System.Uri" /> construído de <c>baseUri</c> e <c>relativeUri</c>. Este parâmetro é passado não inicializado.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a base especificada e as instâncias de <see cref="T:System.String" /> relativas.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCreate">
      <MemberSignature Language="C#" Value="public static bool TryCreate (Uri baseUri, Uri relativeUri, out Uri result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryCreate(class System.Uri baseUri, class System.Uri relativeUri, [out] class System.Uri&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.TryCreate(System.Uri,System.Uri,System.Uri@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryCreate (baseUri As Uri, relativeUri As Uri, ByRef result As Uri) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryCreate(Uri ^ baseUri, Uri ^ relativeUri, [Runtime::InteropServices::Out] Uri ^ % result);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseUri" Type="System.Uri" />
        <Parameter Name="relativeUri" Type="System.Uri" />
        <Parameter Name="result" Type="System.Uri&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="baseUri">O <see cref="T:System.Uri" /> de base.</param>
        <param name="relativeUri">O <see cref="T:System.Uri" /> relativo a ser adicionado ao <see cref="T:System.Uri" /> de base.</param>
        <param name="result">Quando este método retorna, ele contém um <see cref="T:System.Uri" /> construído de <c>baseUri</c> e <c>relativeUri</c>. Este parâmetro é passado não inicializado.</param>
        <summary>Cria um novo <see cref="T:System.Uri" /> usando a base especificada e as instâncias de <see cref="T:System.Uri" /> relativas.</summary>
        <returns>Um valor <see cref="T:System.Boolean" /> que será <see langword="true" /> se o <see cref="T:System.Uri" /> tiver sido criado com êxito; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se esse método retornar `true`, o novo <xref:System.Uri> está em `result`.  
  
 Esse método constrói o URI, coloca na forma canônica e valida. Se ocorrer uma exceção sem tratamento, esse método captura a ele. Se você quiser criar um <xref:System.Uri> e get exceções usam uma da <xref:System.Uri.%23ctor%2A> construtores.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="baseUri" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Unescape">
      <MemberSignature Language="C#" Value="protected virtual string Unescape (string path);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance string Unescape(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.Unescape(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Unescape (path As String) As String" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::String ^ Unescape(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">O <see cref="T:System.String" /> a ser convertido.</param>
        <summary>Converte a cadeia de caracteres especificada substituindo as sequências de escape por sua representação sem escape.</summary>
        <returns>A <see cref="T:System.String" /> que contém o valor sem escape do parâmetro <paramref name="path" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnescapeDataString">
      <MemberSignature Language="C#" Value="public static string UnescapeDataString (string stringToUnescape);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string UnescapeDataString(string stringToUnescape) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Uri.UnescapeDataString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnescapeDataString (stringToUnescape As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ UnescapeDataString(System::String ^ stringToUnescape);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stringToUnescape" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="stringToUnescape">A cadeia de caracteres para desfazer o escape.</param>
        <summary>Converte uma cadeia de caracteres em sua representação sem escape.</summary>
        <returns>Um <see cref="T:System.String" /> que contém a representação sem escape de <paramref name="stringToUnescape" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você deve usar esse método com cuidado. Unescaping uma cadeia de caracteres que tenha sido anteriormente sem escape pode resultar em ambiguidades e erros.  
  
 Muitos navegadores da Web de escape espaços dentro de URIs em adição caracteres ("+"); No entanto, o método UnescapeDataString não converte mais caracteres em espaços porque esse comportamento não seja padrão entre todos os esquemas URI.  
  
   
  
## Examples  
 O exemplo de código a seguir unescapes um URI e, em seguida, converte qualquer além de caracteres ("+") em espaços.  
  
 [!code-csharp[NCLUriExamples#19](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="stringToUnescape" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Uri.EscapeDataString(System.String)" />
        <altmember cref="M:System.Uri.EscapeUriString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFile">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFile;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFile" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFile" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFile As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFile;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um ponteiro para um arquivo. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No .NET Framework versão 1.1, um "`file:///path`"URI foi convertido em"`file:/path`". Isso foi corrigido para a versão 2.0.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeFile>.  
  
 [!code-cpp[NCLUriExamples#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#10)]
 [!code-csharp[NCLUriExamples#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#10)]
 [!code-vb[NCLUriExamples#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeFtp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeFtp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeFtp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeFtp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeFtp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeFtp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo FTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeFtp>.  
  
 [!code-cpp[NCLUriExamples#15](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#15)]
 [!code-csharp[NCLUriExamples#15](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#15)]
 [!code-vb[NCLUriExamples#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeGopher">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeGopher;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeGopher" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeGopher" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeGopher As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeGopher;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo Gopher. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeGopher>.  
  
 [!code-cpp[NCLUriExamples#14](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#14)]
 [!code-csharp[NCLUriExamples#14](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#14)]
 [!code-vb[NCLUriExamples#14](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do protocolo HTTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeHttp>.  
  
 [!code-cpp[NCLUriExamples#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#9)]
 [!code-csharp[NCLUriExamples#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#9)]
 [!code-vb[NCLUriExamples#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeHttps">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeHttps;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeHttps" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeHttps" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeHttps As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeHttps;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio de HTTPS (Secure Hypertext Transfer Protocol). Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeHttps>.  
  
 [!code-cpp[NCLUriExamples#16](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#16)]
 [!code-csharp[NCLUriExamples#16](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#16)]
 [!code-vb[NCLUriExamples#16](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeMailto">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeMailto;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeMailto" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeMailto" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeMailto As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeMailto;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um endereço de email e é acessado por meio do protocolo SMTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeMailto>.  
  
 [!code-cpp[NCLUriExamples#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#11)]
 [!code-csharp[NCLUriExamples#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#11)]
 [!code-vb[NCLUriExamples#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetPipe">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetPipe;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetPipe" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetPipe" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetPipe As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetPipe;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do esquema NetPipe usado pelo WCF (Windows Communication Foundation). Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNetTcp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNetTcp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNetTcp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNetTcp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNetTcp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNetTcp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é acessado por meio do esquema NetTcp usado pelo WCF (Windows Communication Foundation). Este campo é somente leitura.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNews">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNews;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNews" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNews" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNews As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNews;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um grupo de notícias da Internet e é acessado por meio do NNTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeNews>.  
  
 [!code-cpp[NCLUriExamples#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#12)]
 [!code-csharp[NCLUriExamples#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#12)]
 [!code-vb[NCLUriExamples#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UriSchemeNntp">
      <MemberSignature Language="C#" Value="public static readonly string UriSchemeNntp;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string UriSchemeNntp" />
      <MemberSignature Language="DocId" Value="F:System.Uri.UriSchemeNntp" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UriSchemeNntp As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ UriSchemeNntp;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica que o URI é um grupo de notícias da Internet e é acessado por meio do NNTP. Este campo é somente leitura.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O NNTP <xref:System.Uri> analisar erros no .NET Framework versão 1.1 foram corrigidos.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> instância e determina se o esquema é <xref:System.Uri.UriSchemeNntp>.  
  
 [!code-cpp[NCLUriExamples#13](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#13)]
 [!code-csharp[NCLUriExamples#13](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#13)]
 [!code-vb[NCLUriExamples#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserEscaped">
      <MemberSignature Language="C#" Value="public bool UserEscaped { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UserEscaped" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserEscaped" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserEscaped As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UserEscaped { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Indica que a cadeia de caracteres do URI sofreu escape completo antes que a instância de <see cref="T:System.Uri" /> fosse criada.</summary>
        <value>Um valor de <see cref="T:System.Boolean" /> que é <see langword="true" /> se o parâmetro <paramref name="dontEscape" /> tiver sido definido como <see langword="true" /> quando a instância de <see cref="T:System.Uri" /> foi criada; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Uri.UserEscaped%2A> está definida como `true` para indicar que a cadeia de caracteres usada para criar o <xref:System.Uri> instância foi totalmente escape antes que foi transmitido ao construtor, ou seja, o `dontEscape` parâmetro da chamada de construtor foi definido como `true`.  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e determina se ele foi totalmente escape quando ele foi criado.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserInfo">
      <MemberSignature Language="C#" Value="public string UserInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UserInfo" />
      <MemberSignature Language="DocId" Value="P:System.Uri.UserInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserInfo As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UserInfo { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome de usuário, a senha ou outras informações específicas do usuário associado com o URI especificado.</summary>
        <value>Um <see cref="T:System.String" /> que contém as informações de usuário associadas ao URI. O valor retornado não inclui o ' @' caractere reservado para a parte de informações de usuário do URI de delimitação.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade é geralmente no formato "nome_de_usuário".  
  
   
  
## Examples  
 O exemplo a seguir cria um <xref:System.Uri> de instância e grava as informações do usuário do console.  
  
 [!code-cpp[NCLUriExamples#18](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLUriExamples/CPP/uriexamples.cpp#18)]
 [!code-csharp[NCLUriExamples#18](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLUriExamples/CS/uriexamples.cs#18)]
 [!code-vb[NCLUriExamples#18](~/samples/snippets/visualbasic/VS_Snippets_Remoting/NCLUriExamples/VB/uriexamples.vb#18)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Esta instância representa uma URL relativa, e esta propriedade só é válida para URIs absolutos.</exception>
      </Docs>
    </Member>
  </Members>
</Type>