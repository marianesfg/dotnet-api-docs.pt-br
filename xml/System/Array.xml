<Type Name="Array" FullName="System.Array">
  <TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3d295-101">Fornece métodos para criar, manipular, pesquisar e classificar matrizes, servindo assim como a classe base para todas as matrizes no Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="3d295-101">Provides methods for creating, manipulating, searching, and sorting arrays, thereby serving as the base class for all arrays in the common language runtime.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-102">O <xref:System.Array> a classe não é parte do <xref:System.Collections> namespaces.</span><span class="sxs-lookup"><span data-stu-id="3d295-102">The <xref:System.Array> class is not part of the <xref:System.Collections> namespaces.</span></span> <span data-ttu-id="3d295-103">No entanto, ela ainda será considerada uma coleção porque ele se baseia o <xref:System.Collections.IList> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-103">However, it is still considered a collection because it is based on the <xref:System.Collections.IList> interface.</span></span>  
  
 <span data-ttu-id="3d295-104">O <xref:System.Array> classe é a classe base para implementações de linguagem que oferece suporte a matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-104">The <xref:System.Array> class is the base class for language implementations that support arrays.</span></span> <span data-ttu-id="3d295-105">No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="3d295-105">However, only the system and compilers can derive explicitly from the <xref:System.Array> class.</span></span> <span data-ttu-id="3d295-106">Os usuários devem empregar as construções de matriz fornecidas pela linguagem.</span><span class="sxs-lookup"><span data-stu-id="3d295-106">Users should employ the array constructs provided by the language.</span></span>  
  
 <span data-ttu-id="3d295-107">Um elemento é um valor em um <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-107">An element is a value in an <xref:System.Array>.</span></span> <span data-ttu-id="3d295-108">O comprimento de um <xref:System.Array> é o número total de elementos que ele pode conter.</span><span class="sxs-lookup"><span data-stu-id="3d295-108">The length of an <xref:System.Array> is the total number of elements it can contain.</span></span> <span data-ttu-id="3d295-109">O limite inferior de um <xref:System.Array> é o índice do seu primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-109">The lower bound of an <xref:System.Array> is the index of its first element.</span></span> <span data-ttu-id="3d295-110">Um <xref:System.Array> pode ter qualquer limite inferior, mas ele tem um limite inferior de zero por padrão.</span><span class="sxs-lookup"><span data-stu-id="3d295-110">An <xref:System.Array> can have any lower bound, but it has a lower bound of zero by default.</span></span> <span data-ttu-id="3d295-111">Um limite inferior diferente pode ser definido ao criar uma instância do <xref:System.Array> classe usando <xref:System.Array.CreateInstance%2A>. Um multidimensionais <xref:System.Array> pode ter limites diferentes para cada dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-111">A different lower bound can be defined when creating an instance of the <xref:System.Array> class using <xref:System.Array.CreateInstance%2A>.A multidimensional <xref:System.Array> can have different bounds for each dimension.</span></span> <span data-ttu-id="3d295-112">Uma matriz pode ter um máximo de 32 dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-112">An array can have a maximum of 32 dimensions.</span></span>  
  
 <span data-ttu-id="3d295-113">Ao contrário das classes no <xref:System.Collections> namespaces, <xref:System.Array> tem uma capacidade fixa.</span><span class="sxs-lookup"><span data-stu-id="3d295-113">Unlike the classes in the <xref:System.Collections> namespaces, <xref:System.Array> has a fixed capacity.</span></span> <span data-ttu-id="3d295-114">Para aumentar a capacidade, você deve criar um novo <xref:System.Array> de objeto com a capacidade necessária, copiar os elementos do antigo <xref:System.Array> do objeto para o novo e excluir o antigo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-114">To increase the capacity, you must create a new <xref:System.Array> object with the required capacity, copy the elements from the old <xref:System.Array> object to the new one, and delete the old <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-115">Por padrão, o tamanho máximo de um <xref:System.Array> é de 2 gigabytes (GB).</span><span class="sxs-lookup"><span data-stu-id="3d295-115">By default, the maximum size of an <xref:System.Array> is 2 gigabytes (GB).</span></span> <span data-ttu-id="3d295-116">Em um ambiente de 64 bits, você pode evitar a restrição de tamanho, definindo o `enabled` atributo o [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuração para `true` no ambiente de tempo de execução.</span><span class="sxs-lookup"><span data-stu-id="3d295-116">In a 64-bit environment, you can avoid the size restriction by setting the `enabled` attribute of the [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) configuration element to `true` in the run-time environment.</span></span> <span data-ttu-id="3d295-117">No entanto, a matriz ainda será limitada a um total de elementos de 4 bilhões e um índice máximo de 0X7FEFFFFF em uma determinada dimensão (0X7FFFFFC7 para matrizes de bytes e matrizes de estruturas de byte único).</span><span class="sxs-lookup"><span data-stu-id="3d295-117">However, the array will still be limited to a total of 4 billion elements, and to a maximum index of 0X7FEFFFFF in any given dimension (0X7FFFFFC7 for byte arrays and arrays of single-byte structures).</span></span>  
  
 <span data-ttu-id="3d295-118">Matrizes unidimensionais implementam o <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfaces genéricas.</span><span class="sxs-lookup"><span data-stu-id="3d295-118">Single-dimensional arrays implement the <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> and <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> generic interfaces.</span></span> <span data-ttu-id="3d295-119">As implementações são fornecidas para matrizes em tempo de execução, e como resultado, as interfaces genéricas não aparecem na sintaxe de declaração para o <xref:System.Array> classe.</span><span class="sxs-lookup"><span data-stu-id="3d295-119">The implementations are provided to arrays at run time, and as a result, the generic interfaces do not appear in the declaration syntax for the <xref:System.Array> class.</span></span> <span data-ttu-id="3d295-120">Além disso, não há nenhum tópicos de referência para os membros de interface que são acessíveis somente por conversão de uma matriz para o tipo de interface genérica (implementações explícitas da interface).</span><span class="sxs-lookup"><span data-stu-id="3d295-120">In addition,  there are no reference topics for interface members that are accessible only by casting an array to the generic interface type (explicit interface implementations).</span></span> <span data-ttu-id="3d295-121">O mais importante estar atento ao converter uma matriz para uma dessas interfaces é que os membros que adicionam, inserir ou remover elementos throw <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-121">The key thing to be aware of when you cast an array to one of these interfaces is that members which add, insert, or remove elements throw <xref:System.NotSupportedException>.</span></span>  
  
 <span data-ttu-id="3d295-122"><xref:System.Type> objetos fornecem informações sobre declarações de tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-122"><xref:System.Type> objects provide information about array type declarations.</span></span> <span data-ttu-id="3d295-123"><xref:System.Array> objetos com o mesmo tipo de matriz compartilham o mesmo <xref:System.Type> objeto.</span><span class="sxs-lookup"><span data-stu-id="3d295-123"><xref:System.Array> objects with the same array type share the same <xref:System.Type> object.</span></span>  
  
 <span data-ttu-id="3d295-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> e <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> podem não retornar os resultados esperados com <xref:System.Array> porque se uma matriz é convertida para o tipo <xref:System.Array>, o resultado é um objeto, não uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-124"><xref:System.Type.IsArray%2A?displayProperty=nameWithType> and <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> might not return the expected results with <xref:System.Array> because if an array is cast to the type <xref:System.Array>, the result is an object, not an array.</span></span> <span data-ttu-id="3d295-125">Ou seja, `typeof(System.Array).IsArray` retorna `false`, e `typeof(System.Array).GetElementType` retorna `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-125">That is, `typeof(System.Array).IsArray` returns `false`, and `typeof(System.Array).GetElementType` returns `null`.</span></span>  
  
 <span data-ttu-id="3d295-126">O <xref:System.Array.Copy%2A?displayProperty=nameWithType> método copia não apenas entre matrizes do mesmo tipo, mas também entre matrizes de padrão de tipos diferentes de elementos; ele trata automaticamente de conversão de tipos.</span><span class="sxs-lookup"><span data-stu-id="3d295-126">The <xref:System.Array.Copy%2A?displayProperty=nameWithType> method copies elements not only between arrays of the same type but also between standard arrays of different types; it handles type casting automatically.</span></span>  
  
 <span data-ttu-id="3d295-127">Alguns métodos, como <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, e <xref:System.Array.SetValue%2A>, fornecem sobrecargas que aceitam números inteiros de 64 bits como parâmetros para acomodar as matrizes de capacidade grande.</span><span class="sxs-lookup"><span data-stu-id="3d295-127">Some methods, such as <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, and <xref:System.Array.SetValue%2A>, provide overloads that accept 64-bit integers as parameters to accommodate large capacity arrays.</span></span> <span data-ttu-id="3d295-128"><xref:System.Array.LongLength%2A> e <xref:System.Array.GetLongLength%2A> retornam números inteiros de 64 bits que indica o comprimento da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-128"><xref:System.Array.LongLength%2A> and <xref:System.Array.GetLongLength%2A> return 64-bit integers indicating the length of the array.</span></span>  
  
 <span data-ttu-id="3d295-129">O <xref:System.Array> não é garantida a ser classificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-129">The <xref:System.Array> is not guaranteed to be sorted.</span></span>  <span data-ttu-id="3d295-130">Você deve classificar o <xref:System.Array> antes de executar operações (como <xref:System.Array.BinarySearch%2A>) que exigem o <xref:System.Array> a ser classificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-130">You must sort the <xref:System.Array> prior to performing operations (such as <xref:System.Array.BinarySearch%2A>) that require the <xref:System.Array> to be sorted.</span></span>  
  
 <span data-ttu-id="3d295-131">Usando um <xref:System.Array> objeto dos ponteiros em código nativo não é compatível e gerará um <xref:System.NotSupportedException> para vários métodos.</span><span class="sxs-lookup"><span data-stu-id="3d295-131">Using an <xref:System.Array> object of pointers in native code is not supported and will throw a <xref:System.NotSupportedException> for several methods.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-132">O seguinte exemplo de código mostra como <xref:System.Array.Copy%2A?displayProperty=nameWithType> copia os elementos entre uma matriz de tipo inteiro e uma matriz do tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3d295-132">The following code example shows how <xref:System.Array.Copy%2A?displayProperty=nameWithType> copies elements between an array of type integer and an array of type <xref:System.Object>.</span></span>  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 <span data-ttu-id="3d295-133">O exemplo de código a seguir cria e inicializa um <xref:System.Array> e exibe suas propriedades e seus elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-133">The following code example creates and initializes an <xref:System.Array> and displays its properties and its elements.</span></span>  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="3d295-134">Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe.</span><span class="sxs-lookup"><span data-stu-id="3d295-134">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span></span> <span data-ttu-id="3d295-135">Não há garantia de que qualquer membro de instância seja thread-safe.</span><span class="sxs-lookup"><span data-stu-id="3d295-135">Any instance members are not guaranteed to be thread safe.</span></span>  
  
 <span data-ttu-id="3d295-136">Esta implementação não oferece um sincronizado wrapper (thread-safe) para um <see cref="T:System.Array" />; no entanto, classes do .NET Framework com base em <see cref="T:System.Array" /> fornecer sua própria versão sincronizada de coleção usando o <see cref="P:System.Array.SyncRoot" /> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-136">This implementation does not provide a synchronized (thread safe) wrapper for an <see cref="T:System.Array" />; however, .NET Framework classes based on <see cref="T:System.Array" /> provide their own synchronized version of the collection using the <see cref="P:System.Array.SyncRoot" /> property.</span></span>  
  
 <span data-ttu-id="3d295-137">A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco.</span><span class="sxs-lookup"><span data-stu-id="3d295-137">Enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="3d295-138">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-138">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="3d295-139">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="3d295-139">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span></threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-140">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-141">A matriz unidimensional baseada em zero para encapsular em um wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-141">The one-dimensional, zero-based array to wrap in a read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper.</span></span></param>
        <summary><span data-ttu-id="3d295-142">Retorna um wrapper somente leitura para a matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-142">Returns a read-only wrapper for the specified array.</span></span></summary>
        <returns><span data-ttu-id="3d295-143">Um wrapper somente leitura <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> para a matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-143">A read-only <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> wrapper for the specified array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-144">Para evitar modificações para a matriz, expor a matriz apenas por esse wrapper.</span><span class="sxs-lookup"><span data-stu-id="3d295-144">To prevent any modifications to the array, expose the array only through this wrapper.</span></span>  
  
 <span data-ttu-id="3d295-145">Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.</span><span class="sxs-lookup"><span data-stu-id="3d295-145">A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</span></span>  
  
 <span data-ttu-id="3d295-146">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-146">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-147">O exemplo a seguir encapsula uma matriz em somente leitura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-147">The following example wraps an array in a read-only <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.</span></span>  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-148"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-148"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-149">Pesquisa um <see cref="T:System.Array" /> unidimensional classificado para um valor usando um algoritmo de pesquisa binária.</span><span class="sxs-lookup"><span data-stu-id="3d295-149">Searches a one-dimensional sorted <see cref="T:System.Array" /> for a value, using a binary search algorithm.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-150">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-150">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-151">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-151">The object to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-152">Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a <see cref="T:System.IComparable" /> interface implementada por cada elemento da matriz e o objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-152">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="3d295-153">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-153">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-154">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-154">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-155">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-155">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-156">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-156">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-157">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-157">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-158">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-158">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-159">Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-159">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-160">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-160">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-161">Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-161">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-162">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-162">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-163">O `value` ou cada elemento de `array` deve implementar o <xref:System.IComparable> interface, que é usada para comparações.</span><span class="sxs-lookup"><span data-stu-id="3d295-163">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="3d295-164">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-164">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-165">Se`value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-165">If`value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="3d295-166">Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-166">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="3d295-167">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-167">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-168">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-168">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-169">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-169">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-170">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-170">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-171">Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-171">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-172">Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-172">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-173">O exemplo de código a seguir mostra como usar <xref:System.Array.BinarySearch%2A> para localizar um objeto específico em um <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-173">The following code example shows how to use <xref:System.Array.BinarySearch%2A> to locate a specific object in an <xref:System.Array>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-174">A matriz é criada com seus elementos em ordem de classificação crescente.</span><span class="sxs-lookup"><span data-stu-id="3d295-174">The array is created with its elements in ascending sort order.</span></span> <span data-ttu-id="3d295-175">O <xref:System.Array.BinarySearch%2A> método requer que a matriz a ser classificada em ordem crescente.</span><span class="sxs-lookup"><span data-stu-id="3d295-175">The <xref:System.Array.BinarySearch%2A> method requires the array to be sorted in ascending order.</span></span>  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-176"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-176"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-177"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-177"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-178"><paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-178"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-179"><paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-179"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-180">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-180">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-181">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-181">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-182">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-182">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-183">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-183">-or-</span></span>  
  
 <span data-ttu-id="3d295-184"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-184"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-185">Pesquisa um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada em uma matriz classificada unidimensional inteira.</span><span class="sxs-lookup"><span data-stu-id="3d295-185">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="3d295-186">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-186">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-187">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-187">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-188">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-188">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-189">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-189">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-190">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-190">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-191">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-191">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-192">Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-192">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-193">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-193">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-194">Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-194">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-195">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-195">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-196">A comparação personaliza como os elementos são comparados.</span><span class="sxs-lookup"><span data-stu-id="3d295-196">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="3d295-197">Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-197">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="3d295-198">Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação.</span><span class="sxs-lookup"><span data-stu-id="3d295-198">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="3d295-199">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-199">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-200">Se`comparer` é `null`, a comparação é feita usando o <xref:System.IComparable> implementação fornecida pelo próprio elemento ou valor especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-200">If`comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="3d295-201">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-201">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-202">Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-202">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="3d295-203">Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-203">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="3d295-204">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-204">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-205">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-205">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-206">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-206">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-207">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-207">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-208">Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-208">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-209">Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-209">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-210"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-210"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-211"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-211"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-212"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-212"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-213"><paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-213"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-214">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-214">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-215">O índice inicial do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-215">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-216">O tamanho do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-216">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-217">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-217">The object to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-218">Pesquisa um intervalo de elementos em uma matriz unidimensional classificada para um valor, usando a interface <see cref="T:System.IComparable" /> implementada por cada elemento da matriz e pelo valor especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-218">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable" /> interface implemented by each element of the array and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="3d295-219">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-219">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-220">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-220">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-221">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-221">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-222">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-222">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-223">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-223">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-224">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-224">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-225">Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-225">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-226">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-226">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="3d295-227">Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-227">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-228">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-228">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-229">O `value` ou cada elemento de `array` deve implementar o <xref:System.IComparable> interface, que é usada para comparações.</span><span class="sxs-lookup"><span data-stu-id="3d295-229">Either `value` or every element of `array` must implement the <xref:System.IComparable> interface, which is used for comparisons.</span></span> <span data-ttu-id="3d295-230">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-230">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-231">Se `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-231">If `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="3d295-232">Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-232">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="3d295-233">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-233">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-234">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-234">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-235">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-235">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-236">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-236">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-237">Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-237">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-238">Este método é uma operação O(log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-238">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-239"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-239"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-240"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-240"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-241"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-241"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-242">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-242">-or-</span></span>  
  
 <span data-ttu-id="3d295-243"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-243"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-244"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-244"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-245">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-245">-or-</span></span>  
  
 <span data-ttu-id="3d295-246"><paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-246"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-247"><paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-247"><paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-248">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-248">The sorted one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-249">O índice inicial do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-249">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-250">O tamanho do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-250">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-251">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-251">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-252">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-252">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-253">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-253">-or-</span></span>  
  
 <span data-ttu-id="3d295-254"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-254"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-255">Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-255">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.IComparer" /> interface.</span></span></summary>
        <returns><span data-ttu-id="3d295-256">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-256">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-257">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-257">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-258">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-258">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-259">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-259">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-260">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-260">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-261">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-261">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-262">Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-262">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-263">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-263">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-264">Se esse índice é um maior que o limite superior da matriz, não existem elementos maior do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-264">If this index is one greater than the upper bound of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-265">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-265">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-266">A comparação personaliza como os elementos são comparados.</span><span class="sxs-lookup"><span data-stu-id="3d295-266">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="3d295-267">Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-267">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="3d295-268">Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação.</span><span class="sxs-lookup"><span data-stu-id="3d295-268">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.IComparer> implementation.</span></span> <span data-ttu-id="3d295-269">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-269">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-270">Caso `comparer` seja `null`, a comparação é feita usando-se a implementação de <xref:System.IComparable> fornecida pelo próprio elemento ou pelo valor especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-270">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable> implementation provided by the element itself or by the specified value.</span></span> <span data-ttu-id="3d295-271">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-271">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-272">Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable> de interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes de começa a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-272">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable> interface, the elements of `array` are not tested for <xref:System.IComparable> before the search begins.</span></span> <span data-ttu-id="3d295-273">Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-273">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable>.</span></span>  
  
 <span data-ttu-id="3d295-274">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-274">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-275">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-275">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-276">`null` sempre podem ser comparados com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-276">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-277">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-277">For every element tested, `value` is passed to the appropriate <xref:System.IComparable> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-278">Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-278">That is, the <xref:System.IComparable> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-279">Este método é uma operação O(log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-279">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-280"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-280"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-281"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-281"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-282"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-282"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-283">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-283">-or-</span></span>  
  
 <span data-ttu-id="3d295-284"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-284"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-285"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-285"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-286">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-286">-or-</span></span>  
  
 <span data-ttu-id="3d295-287"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-287"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-288"><paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-288"><paramref name="comparer" /> is <see langword="null" />, <paramref name="value" /> does not implement the <see cref="T:System.IComparable" /> interface, and the search encounters an element that does not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-289">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-289">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-290">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-290">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-291">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-291">The object to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-292">Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a interface <see cref="T:System.IComparable`1" /> genérica implementada por cada elemento da <see cref="T:System.Array" /> e o objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-292">Searches an entire one-dimensional sorted array for a specific element, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified object.</span></span></summary>
        <returns><span data-ttu-id="3d295-293">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-293">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-294">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-294">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-295">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-295">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-296">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-296">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-297">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-297">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-298">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-298">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-299">Se `array` não contém o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-299">If `array` does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-300">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-300">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-301">Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-301">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-302">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-302">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-303">`T` deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações.</span><span class="sxs-lookup"><span data-stu-id="3d295-303">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="3d295-304">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-304">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-305">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-305">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-306">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-306">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-307">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-307">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-308">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-308">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-309">Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-309">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-310">Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-310">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-311">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-311">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="3d295-312">Uma matriz de cadeias de caracteres é criada, em nenhuma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="3d295-312">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="3d295-313">A matriz é exibida, classificada e exibida novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-313">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="3d295-314">Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-314">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-315">As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-315">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-316">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-316">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="3d295-317">O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é.</span><span class="sxs-lookup"><span data-stu-id="3d295-317">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="3d295-318">A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-318">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="3d295-319">O índice é negativo se a cadeia de caracteres não estiver na matriz, portanto, o `ShowWhere` método usa o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor`-1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a pesquisa str ER.</span><span class="sxs-lookup"><span data-stu-id="3d295-319">The index is negative if the string is not in the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor`-1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-320"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-320"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-321"><paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-321"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-322">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-322">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-323">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-323">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-324">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-324">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-325">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-325">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-326">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-326">-or-</span></span>  
  
 <span data-ttu-id="3d295-327"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-327"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-328">Pesquisa uma matriz classificada unidimensional completa para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-328">Searches an entire one-dimensional sorted array for a value using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="3d295-329">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-329">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-330">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-330">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-331">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-331">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-332">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-332">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-333">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-333">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-334">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-334">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-335">Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-335">If the <xref:System.Array> does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-336">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-336">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result to produce an index.</span></span> <span data-ttu-id="3d295-337">Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-337">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-338">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-338">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-339">A comparação personaliza como os elementos são comparados.</span><span class="sxs-lookup"><span data-stu-id="3d295-339">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="3d295-340">Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-340">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="3d295-341">Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação de interface genérica.</span><span class="sxs-lookup"><span data-stu-id="3d295-341">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="3d295-342">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-342">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-343">Se `comparer` é `null`, a comparação é feita usando o <xref:System.IComparable%601> implementação de interface genérica fornecida pelo `T`.</span><span class="sxs-lookup"><span data-stu-id="3d295-343">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided by `T`.</span></span> <span data-ttu-id="3d295-344">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-344">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-345">Se `comparer` é `null` e `value` não implementa o <xref:System.IComparable%601> interface genérica, os elementos de `array` não são testadas para <xref:System.IComparable%601> antes de começa a pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-345">If `comparer` is `null` and `value` does not implement the <xref:System.IComparable%601> generic interface, the elements of `array` are not tested for <xref:System.IComparable%601> before the search begins.</span></span> <span data-ttu-id="3d295-346">Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-346">An exception is thrown if the search encounters an element that does not implement <xref:System.IComparable%601>.</span></span>  
  
 <span data-ttu-id="3d295-347">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-347">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-348">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-348">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-349">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-349">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-350">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-350">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-351">Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-351">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-352">Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-352">This method is an O(log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-353">O exemplo a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-353">The following example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="3d295-354">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-354">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-355">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-355">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-356">A matriz é exibida, classificada e exibida novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-356">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="3d295-357">Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-357">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-358">As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-358">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-359">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-359">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="3d295-360">O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é.</span><span class="sxs-lookup"><span data-stu-id="3d295-360">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="3d295-361">A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-361">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="3d295-362">O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-362">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-363"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-363"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-364"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-364"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-365">O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" /></span><span class="sxs-lookup"><span data-stu-id="3d295-365"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-366">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-366">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-367">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-367">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-368">O índice inicial do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-368">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-369">O tamanho do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-369">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-370">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-370">The object to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-371">Pesquisa um intervalo de elementos em uma matriz unidimensional classificada em busca de um valor, usando a interface genérica <see cref="T:System.IComparable`1" /> implementada por cada elemento do <see cref="T:System.Array" /> e pelo valor especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-371">Searches a range of elements in a one-dimensional sorted array for a value, using the <see cref="T:System.IComparable`1" /> generic interface implemented by each element of the <see cref="T:System.Array" /> and by the specified value.</span></span></summary>
        <returns><span data-ttu-id="3d295-372">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-372">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-373">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-373">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-374">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-374">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-375">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-375">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-376">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-376">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-377">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-377">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-378">Se a matriz não contém o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-378">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-379">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-379">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-380">Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-380">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-381">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-381">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-382">`T` deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações.</span><span class="sxs-lookup"><span data-stu-id="3d295-382">`T` must implement the <xref:System.IComparable%601> generic interface, which is used for comparisons.</span></span> <span data-ttu-id="3d295-383">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-383">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-384">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-384">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-385">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-385">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-386">`null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-386">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-387">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-387">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-388">Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-388">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-389">Este método é uma operação O(log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-389">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-390"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-390"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-391"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-391"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-392">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-392">-or-</span></span>  
  
 <span data-ttu-id="3d295-393"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-393"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-394"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-394"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-395">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-395">-or-</span></span>  
  
 <span data-ttu-id="3d295-396"><paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-396"><paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-397"><paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-397"><paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-398">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-398">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-399">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-399">The sorted one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-400">O índice inicial do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-400">The starting index of the range to search.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-401">O tamanho do intervalo a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-401">The length of the range to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-402">O objeto a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-402">The object to search for.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-403">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-403">The <see cref="T:System.Collections.Generic.IComparer`1" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-404">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-404">-or-</span></span>  
  
 <span data-ttu-id="3d295-405"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-405"><see langword="null" /> to use the <see cref="T:System.IComparable`1" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-406">Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-406">Searches a range of elements in a one-dimensional sorted array for a value, using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <returns><span data-ttu-id="3d295-407">O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-407">The index of the specified <paramref name="value" /> in the specified <paramref name="array" />, if <paramref name="value" /> is found; otherwise, a negative number.</span></span> <span data-ttu-id="3d295-408">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-408">If <paramref name="value" /> is not found and <paramref name="value" /> is less than one or more elements in <paramref name="array" />, the negative number returned is the bitwise complement of the index of the first element that is larger than <paramref name="value" />.</span></span> <span data-ttu-id="3d295-409">Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-409">If <paramref name="value" /> is not found and <paramref name="value" /> is greater than all elements in <paramref name="array" />, the negative number returned is the bitwise complement of (the index of the last element plus 1).</span></span> <span data-ttu-id="3d295-410">Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-410">If this method is called with a non-sorted <paramref name="array" />, the return value can be incorrect and a negative number could be returned, even if <paramref name="value" /> is present in <paramref name="array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-411">Este método não oferece suporte a matrizes de pesquisa que contêm índices negativos.</span><span class="sxs-lookup"><span data-stu-id="3d295-411">This method does not support searching arrays that contain negative indexes.</span></span> <span data-ttu-id="3d295-412">`array` deve ser classificada antes de chamar esse método.</span><span class="sxs-lookup"><span data-stu-id="3d295-412">`array` must be sorted before calling this method.</span></span>  
  
 <span data-ttu-id="3d295-413">Se a matriz não contém o valor especificado, o método retorna um inteiro negativo.</span><span class="sxs-lookup"><span data-stu-id="3d295-413">If the array does not contain the specified value, the method returns a negative integer.</span></span> <span data-ttu-id="3d295-414">Você pode aplicar o operador de complemento bit a bit (~ em c#, `Not` no Visual Basic) para o resultado negativo para produzir um índice.</span><span class="sxs-lookup"><span data-stu-id="3d295-414">You can apply the bitwise complement operator (~ in C#, `Not` in Visual Basic) to the negative result  to produce an index.</span></span> <span data-ttu-id="3d295-415">Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-415">If this index is equal to the size of the array, there are no elements larger than `value` in the array.</span></span> <span data-ttu-id="3d295-416">Do contrário, é o índice do primeiro elemento que é maior que `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-416">Otherwise, it is the index of the first element that is larger than `value`.</span></span>  
  
 <span data-ttu-id="3d295-417">A comparação personaliza como os elementos são comparados.</span><span class="sxs-lookup"><span data-stu-id="3d295-417">The comparer customizes how the elements are compared.</span></span> <span data-ttu-id="3d295-418">Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-418">For example, you can use a <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> as the comparer to perform case-insensitive string searches.</span></span>  
  
 <span data-ttu-id="3d295-419">Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação de interface genérica.</span><span class="sxs-lookup"><span data-stu-id="3d295-419">If `comparer` is not `null`, the elements of `array` are compared to the specified value using the specified <xref:System.Collections.Generic.IComparer%601> generic interface implementation.</span></span> <span data-ttu-id="3d295-420">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-420">The elements of `array` must already be sorted in increasing value according to the sort order defined by `comparer`; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-421">Se `comparer` é `null`, a comparação é feita usando o <xref:System.IComparable%601> fornecida para o tipo de implementação de interface genérica `T`.</span><span class="sxs-lookup"><span data-stu-id="3d295-421">If `comparer` is `null`, the comparison is done using the <xref:System.IComparable%601> generic interface implementation provided for type `T`.</span></span> <span data-ttu-id="3d295-422">Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.</span><span class="sxs-lookup"><span data-stu-id="3d295-422">The elements of `array` must already be sorted in increasing value according to the sort order defined by the <xref:System.IComparable%601> implementation; otherwise, the result might be incorrect.</span></span>  
  
 <span data-ttu-id="3d295-423">Os elementos duplicados são permitidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-423">Duplicate elements are allowed.</span></span> <span data-ttu-id="3d295-424">Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.</span><span class="sxs-lookup"><span data-stu-id="3d295-424">If the <xref:System.Array> contains more than one element equal to `value`, the method returns the index of only one of the occurrences, and not necessarily the first one.</span></span>  
  
 <span data-ttu-id="3d295-425">`null` sempre podem ser comparados com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-425">`null` can always be compared with any other reference type; therefore, comparisons with `null` do not generate an exception when using <xref:System.IComparable%601>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-426">Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-426">For every element tested, `value` is passed to the appropriate <xref:System.IComparable%601> implementation, even if `value` is `null`.</span></span> <span data-ttu-id="3d295-427">Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-427">That is, the <xref:System.IComparable%601> implementation determines how a given element compares to `null`.</span></span>  
  
 <span data-ttu-id="3d295-428">Este método é uma operação O(log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-428">This method is an O(log `n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-429"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-429"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-430"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-430"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-431">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-431">-or-</span></span>  
  
 <span data-ttu-id="3d295-432"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-432"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-433"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-433"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-434">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-434">-or-</span></span>  
  
 <span data-ttu-id="3d295-435"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-435"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="value" /> is of a type that is not compatible with the elements of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-436">O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-436"><paramref name="comparer" /> is <see langword="null" />, and <paramref name="T" /> does not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-437">A matriz cujos elementos precisam ser limpos.</span><span class="sxs-lookup"><span data-stu-id="3d295-437">The array whose elements need to be cleared.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-438">O índice inicial do intervalo de elementos a limpar.</span><span class="sxs-lookup"><span data-stu-id="3d295-438">The starting index of the range of elements to clear.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-439">O número de elementos a limpar.</span><span class="sxs-lookup"><span data-stu-id="3d295-439">The number of elements to clear.</span></span></param>
        <summary><span data-ttu-id="3d295-440">Define um intervalo de elementos em uma matriz como o valor padrão de cada tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-440">Sets a range of elements in an array to the default value of each element type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-441">Este método redefine cada elemento em uma matriz para o valor padrão do tipo de elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-441">This method resets each element in an array to the element type's default value.</span></span> <span data-ttu-id="3d295-442">Define elementos de tipos de referência (incluindo <xref:System.String> elementos) para `null`e define os elementos de tipos de valor para os valores padrão mostrados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-442">It sets elements of reference types (including <xref:System.String> elements) to `null`, and sets elements of value types to the default values shown in the following table.</span></span>  
  
|<span data-ttu-id="3d295-443">Tipo</span><span class="sxs-lookup"><span data-stu-id="3d295-443">Type</span></span>|<span data-ttu-id="3d295-444">Valor</span><span class="sxs-lookup"><span data-stu-id="3d295-444">Value</span></span>|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|<span data-ttu-id="3d295-445">Todos os tipos numéricos de ponto flutuante e integral</span><span class="sxs-lookup"><span data-stu-id="3d295-445">All integral and floating point numeric types</span></span>|<span data-ttu-id="3d295-446">0 (zero)</span><span class="sxs-lookup"><span data-stu-id="3d295-446">0 (zero)</span></span>|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|<span data-ttu-id="3d295-447">Outros tipos de valor</span><span class="sxs-lookup"><span data-stu-id="3d295-447">Other value types</span></span>|<span data-ttu-id="3d295-448">Valor padrão de campos do tipo</span><span class="sxs-lookup"><span data-stu-id="3d295-448">Default value of the type's fields</span></span>|  
  
 <span data-ttu-id="3d295-449">O intervalo de desmarcada elementos wrap a cada linha em uma matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-449">The range of cleared elements wrap from row to row in a multi-dimensional array.</span></span>  
  
 <span data-ttu-id="3d295-450">Esse método limpa somente os valores dos elementos; ele não exclui os próprios elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-450">This method only clears the values of the elements; it does not delete the elements themselves.</span></span> <span data-ttu-id="3d295-451">Uma matriz tem um tamanho fixo; Portanto, os elementos não podem ser adicionados ou removidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-451">An array has a fixed size; therefore, elements cannot be added or removed.</span></span>  
  
 <span data-ttu-id="3d295-452">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-452">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-453">O exemplo a seguir usa o <xref:System.Array.Clear%2A> método para redefinir valores inteiros em uma matriz unidimensional, bidimensional e tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-453">The following example uses the <xref:System.Array.Clear%2A> method to reset integer values in a one-dimensional, two-dimensional, and three-dimensional array.</span></span>  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 <span data-ttu-id="3d295-454">O exemplo a seguir define uma `TimeZoneTime` estrutura que inclui um <xref:System.TimeZoneInfo> campo e um <xref:System.DateTimeOffset> campo.</span><span class="sxs-lookup"><span data-stu-id="3d295-454">The following example defines a `TimeZoneTime` structure that includes a <xref:System.TimeZoneInfo> field and a <xref:System.DateTimeOffset> field.</span></span> <span data-ttu-id="3d295-455">Depois, ele chama o <xref:System.Array.Clear%2A> método para limpar um elemento em uma matriz de dois elementos de `TimeZoneTime` valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-455">It then calls the <xref:System.Array.Clear%2A> method to clear one element in a two-element array of `TimeZoneTime` values.</span></span> <span data-ttu-id="3d295-456">O método define o valor do elemento desmarcado para o valor padrão de um <xref:System.TimeZoneInfo> objeto, que é `null`e o valor padrão de um <xref:System.DateTimeOffset> objeto, que é <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-456">The method sets the value of the cleared element to the default value of a <xref:System.TimeZoneInfo> object, which is `null`, and the default value of a <xref:System.DateTimeOffset> object, which is <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-457"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-457"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-458"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-458"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-459">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-459">-or-</span></span>  
  
 <span data-ttu-id="3d295-460"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-460"><paramref name="length" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-461">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-461">-or-</span></span>  
  
 <span data-ttu-id="3d295-462">A soma de <paramref name="index" /> e <paramref name="length" /> é maior que o tamanho do <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-462">The sum of <paramref name="index" /> and <paramref name="length" /> is greater than the size of <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3d295-463">Cria uma cópia superficial do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-463">Creates a shallow copy of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-464">Uma cópia superficial do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-464">A shallow copy of the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-465">Uma cópia superficial de uma <xref:System.Array> copia somente os elementos do <xref:System.Array>, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que se referem as referências a.</span><span class="sxs-lookup"><span data-stu-id="3d295-465">A shallow copy of an <xref:System.Array> copies only the elements of the <xref:System.Array>, whether they are reference types or value types, but it does not copy the objects that the references refer to.</span></span> <span data-ttu-id="3d295-466">As referências no novo <xref:System.Array> apontam para o mesmo objetos que as referências no original <xref:System.Array> aponte para.</span><span class="sxs-lookup"><span data-stu-id="3d295-466">The references in the new <xref:System.Array> point to the same objects that the references in the original <xref:System.Array> point to.</span></span>  
  
 <span data-ttu-id="3d295-467">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-467">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-468">O clone é do mesmo <xref:System.Type> original <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-468">The clone is of the same <xref:System.Type> as the original <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-469">Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d295-469">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-470">O código a seguir exemplo clones um <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> de matriz e demonstra o comportamento de uma cópia superficial.</span><span class="sxs-lookup"><span data-stu-id="3d295-470">The following code example clones a <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> array and demonstrates the behavior of a shallow copy.</span></span>  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="3d295-471">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-471">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="3d295-472">Um inteiro de 32 bits que representa o índice em <c>sourceArray</c> em que a cópia é iniciada.</span><span class="sxs-lookup"><span data-stu-id="3d295-472">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="3d295-473">O <see cref="T:System.Array" /> que recebe os dados.</span><span class="sxs-lookup"><span data-stu-id="3d295-473">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="3d295-474">Um inteiro de 32 bits que representa o índice em <c>destinationArray</c> em que o armazenamento é iniciado.</span><span class="sxs-lookup"><span data-stu-id="3d295-474">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-475">Um inteiro de 32 bits que representa o número de elementos a se copiar.</span><span class="sxs-lookup"><span data-stu-id="3d295-475">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="3d295-476">Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-476">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span>  <span data-ttu-id="3d295-477">Garante que todas as alterações serão desfeitas se a cópia não foi bem-sucedida por completo.</span><span class="sxs-lookup"><span data-stu-id="3d295-477">Guarantees that all changes are undone if the copy does not succeed completely.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-478">Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-478">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span>  <span data-ttu-id="3d295-479">O `sourceArray` tipo deve ser igual ou derivado de `destinationArray` tipo; caso contrário, um <xref:System.ArrayTypeMismatchException> é gerada.</span><span class="sxs-lookup"><span data-stu-id="3d295-479">The `sourceArray` type must be the same as or derived from the `destinationArray` type; otherwise, an <xref:System.ArrayTypeMismatchException> is thrown.</span></span>  <span data-ttu-id="3d295-480">Ao contrário de <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifica a compatibilidade dos tipos de matriz antes de executar qualquer operação.</span><span class="sxs-lookup"><span data-stu-id="3d295-480">Unlike <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifies the compatibility of the array types before performing any operation.</span></span>  
  
 <span data-ttu-id="3d295-481">Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="3d295-481">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="3d295-482">Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).</span><span class="sxs-lookup"><span data-stu-id="3d295-482">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="3d295-483">Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.</span><span class="sxs-lookup"><span data-stu-id="3d295-483">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="3d295-484">Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.</span><span class="sxs-lookup"><span data-stu-id="3d295-484">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="3d295-485">[C++]</span><span class="sxs-lookup"><span data-stu-id="3d295-485">[C++]</span></span>  
  
 <span data-ttu-id="3d295-486">Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="3d295-486">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="3d295-487">As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-487">The arrays can be reference-type arrays or value-type arrays.</span></span>  <span data-ttu-id="3d295-488">Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada.</span><span class="sxs-lookup"><span data-stu-id="3d295-488">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="3d295-489">Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original.</span><span class="sxs-lookup"><span data-stu-id="3d295-489">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="3d295-490">Os próprios elementos ou nada referenciado pelos elementos não são copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-490">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="3d295-491">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-491">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-492">Se esse método lançará uma exceção durante a cópia, o `destinationArray` permanece inalterado; portanto, <xref:System.Array.ConstrainedCopy%2A> pode ser usado dentro de uma região de execução restrita (<xref:System.Runtime.ConstrainedExecution.Cer>).</span><span class="sxs-lookup"><span data-stu-id="3d295-492">If this method throws an exception while copying, the `destinationArray` remains unchanged; therefore, <xref:System.Array.ConstrainedCopy%2A> can be used within a constrained execution region (<xref:System.Runtime.ConstrainedExecution.Cer>).</span></span>  
  
 <span data-ttu-id="3d295-493">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-493">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-494"><paramref name="sourceArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-494"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-495">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-495">-or-</span></span>  
  
 <span data-ttu-id="3d295-496"><paramref name="destinationArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-496"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-497"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-497"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d295-498">O tipo <paramref name="sourceArray" /> não é igual nem derivado do tipo <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-498">The <paramref name="sourceArray" /> type is neither the same as nor derived from the <paramref name="destinationArray" /> type.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-499">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-499">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-500"><paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-500"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-501">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-501">-or-</span></span>  
  
 <span data-ttu-id="3d295-502"><paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-502"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="3d295-503">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-503">-or-</span></span>  
  
 <span data-ttu-id="3d295-504"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-504"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-505"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-505"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-506">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-506">-or-</span></span>  
  
 <span data-ttu-id="3d295-507"><paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-507"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput"><span data-ttu-id="3d295-508">O tipo dos elementos da matriz de origem.</span><span class="sxs-lookup"><span data-stu-id="3d295-508">The type of the elements of the source array.</span></span></typeparam>
        <typeparam name="TOutput"><span data-ttu-id="3d295-509">O tipo dos elementos da matriz de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-509">The type of the elements of the target array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-510">O <see cref="T:System.Array" /> unidimensional baseado em zero para converter para um tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-510">The one-dimensional, zero-based <see cref="T:System.Array" /> to convert to a target type.</span></span></param>
        <param name="converter"><span data-ttu-id="3d295-511">Um <see cref="T:System.Converter`2" /> que converte cada elemento de um tipo em outro tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-511">A <see cref="T:System.Converter`2" /> that converts each element from one type to another type.</span></span></param>
        <summary><span data-ttu-id="3d295-512">Converte uma matriz de um tipo para uma matriz de outro tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-512">Converts an array of one type to an array of another type.</span></span></summary>
        <returns><span data-ttu-id="3d295-513">Uma matriz do tipo de destino que contém os elementos convertidos da matriz de origem.</span><span class="sxs-lookup"><span data-stu-id="3d295-513">An array of the target type containing the converted elements from the source array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-514">O <xref:System.Converter%602> é um delegado para um método que converte um objeto para o tipo de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-514">The <xref:System.Converter%602> is a delegate to a method that converts an object to the target type.</span></span>  <span data-ttu-id="3d295-515">Os elementos de `array` individualmente são passados para o <xref:System.Converter%602>, e os elementos convertidos são salvos na nova matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-515">The elements of `array` are individually passed to the <xref:System.Converter%602>, and the converted elements are saved in the new array.</span></span>  
  
 <span data-ttu-id="3d295-516">A fonte `array` permanece inalterado.</span><span class="sxs-lookup"><span data-stu-id="3d295-516">The source `array` remains unchanged.</span></span>  
  
 <span data-ttu-id="3d295-517">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-517">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-518">O exemplo de código a seguir define um método chamado `PointFToPoint` que converte um <xref:System.Drawing.PointF> estrutura para um <xref:System.Drawing.Point> estrutura.</span><span class="sxs-lookup"><span data-stu-id="3d295-518">The following code example defines a method named `PointFToPoint` that converts a <xref:System.Drawing.PointF> structure to a <xref:System.Drawing.Point> structure.</span></span> <span data-ttu-id="3d295-519">O exemplo cria uma matriz de <xref:System.Drawing.PointF> estruturas, cria um `Converter<PointF, Point>` delegar (`Converter(Of PointF, Point)` no Visual Basic) para representar o `PointFToPoint` método e passa o delegado para o <xref:System.Array.ConvertAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-519">The example then creates an array of <xref:System.Drawing.PointF> structures, creates a `Converter<PointF, Point>` delegate (`Converter(Of PointF, Point)` in Visual Basic) to represent the `PointFToPoint` method, and passes the delegate to the <xref:System.Array.ConvertAll%2A> method.</span></span> <span data-ttu-id="3d295-520">O <xref:System.Array.ConvertAll%2A> método passa cada elemento da lista de entrada para o `PointFToPoint` método e coloca os elementos convertidos em uma nova lista de <xref:System.Drawing.Point> estruturas.</span><span class="sxs-lookup"><span data-stu-id="3d295-520">The <xref:System.Array.ConvertAll%2A> method passes each element of the input list to the `PointFToPoint` method and puts the converted elements into a new list of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="3d295-521">Ambas as listas são exibidas.</span><span class="sxs-lookup"><span data-stu-id="3d295-521">Both lists are displayed.</span></span>  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-522"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-522"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-523">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-523">-or-</span></span>  
  
 <span data-ttu-id="3d295-524"><paramref name="converter" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-524"><paramref name="converter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-525">Copia um intervalo de elementos em um <see cref="T:System.Array" /> para outro <see cref="T:System.Array" /> e executa a conversão de tipo de conversão e a conversão boxing conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="3d295-525">Copies a range of elements in one <see cref="T:System.Array" /> to another <see cref="T:System.Array" /> and performs type casting and boxing as required.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="3d295-526">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-526">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="3d295-527">O <see cref="T:System.Array" /> que recebe os dados.</span><span class="sxs-lookup"><span data-stu-id="3d295-527">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-528">Um inteiro de 32 bits que representa o número de elementos a se copiar.</span><span class="sxs-lookup"><span data-stu-id="3d295-528">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="3d295-529">Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-529">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="3d295-530">O comprimento é especificado como um inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-530">The length is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-531">Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-531">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="3d295-532">Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-532">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="3d295-533">Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="3d295-533">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="3d295-534">Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).</span><span class="sxs-lookup"><span data-stu-id="3d295-534">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="3d295-535">Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.</span><span class="sxs-lookup"><span data-stu-id="3d295-535">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="3d295-536">[C++]</span><span class="sxs-lookup"><span data-stu-id="3d295-536">[C++]</span></span>  
  
 <span data-ttu-id="3d295-537">Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="3d295-537">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="3d295-538">As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-538">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="3d295-539">O downcast de tipo é realizado, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="3d295-539">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="3d295-540">Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-540">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="3d295-541">Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-541">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="3d295-542">Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo.</span><span class="sxs-lookup"><span data-stu-id="3d295-542">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="3d295-543">Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-543">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="3d295-544">Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada.</span><span class="sxs-lookup"><span data-stu-id="3d295-544">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="3d295-545">Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original.</span><span class="sxs-lookup"><span data-stu-id="3d295-545">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="3d295-546">Os próprios elementos ou nada referenciado pelos elementos não são copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-546">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="3d295-547">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-547">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-548">Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-548">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="3d295-549">A compatibilidade de tipo é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-549">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="3d295-550">Um tipo é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-550">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="3d295-551">Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-551">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="3d295-552">Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-552">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="3d295-553">Os tipos desconectado não são compatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-553">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="3d295-554">Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação.</span><span class="sxs-lookup"><span data-stu-id="3d295-554">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="3d295-555">Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações.</span><span class="sxs-lookup"><span data-stu-id="3d295-555">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="3d295-556">Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução.</span><span class="sxs-lookup"><span data-stu-id="3d295-556">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="3d295-557">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-557">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="3d295-558">Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-558">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="3d295-559">Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d295-559">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="3d295-560">Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-560">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="3d295-561">Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-561">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-562">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-562">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-563"><paramref name="sourceArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-563"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-564">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-564">-or-</span></span>  
  
 <span data-ttu-id="3d295-565"><paramref name="destinationArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-565"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-566"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-566"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="3d295-567"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-567"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-568">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-568">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-569"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-569"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-570"><paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-570"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-571">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-571">-or-</span></span>  
  
 <span data-ttu-id="3d295-572"><paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-572"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="3d295-573">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-573">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="3d295-574">O <see cref="T:System.Array" /> que recebe os dados.</span><span class="sxs-lookup"><span data-stu-id="3d295-574">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-575">Um inteiro de 64 bits que representa o número de elementos a se copiar.</span><span class="sxs-lookup"><span data-stu-id="3d295-575">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="3d295-576">O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</span><span class="sxs-lookup"><span data-stu-id="3d295-576">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="3d295-577">Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-577">Copies a range of elements from an <see cref="T:System.Array" /> starting at the first element and pastes them into another <see cref="T:System.Array" /> starting at the first element.</span></span> <span data-ttu-id="3d295-578">O tamanho é especificado como um inteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-578">The length is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-579">Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-579">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="3d295-580">Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-580">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="3d295-581">Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="3d295-581">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end to end.</span></span> <span data-ttu-id="3d295-582">Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).</span><span class="sxs-lookup"><span data-stu-id="3d295-582">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span>  
  
 <span data-ttu-id="3d295-583">Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.</span><span class="sxs-lookup"><span data-stu-id="3d295-583">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="3d295-584">[C++]</span><span class="sxs-lookup"><span data-stu-id="3d295-584">[C++]</span></span>  
  
 <span data-ttu-id="3d295-585">Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="3d295-585">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="3d295-586">As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-586">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="3d295-587">O downcast de tipo é realizado, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="3d295-587">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="3d295-588">Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-588">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="3d295-589">Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-589">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="3d295-590">Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo.</span><span class="sxs-lookup"><span data-stu-id="3d295-590">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="3d295-591">Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-591">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="3d295-592">Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada.</span><span class="sxs-lookup"><span data-stu-id="3d295-592">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="3d295-593">Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original.</span><span class="sxs-lookup"><span data-stu-id="3d295-593">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="3d295-594">Os próprios elementos ou nada referenciado pelos elementos não são copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-594">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="3d295-595">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-595">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-596">Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-596">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="3d295-597">A compatibilidade de tipo é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-597">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="3d295-598">Um tipo é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-598">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="3d295-599">Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-599">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="3d295-600">Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-600">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="3d295-601">Os tipos desconectado não são compatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-601">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="3d295-602">Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação.</span><span class="sxs-lookup"><span data-stu-id="3d295-602">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="3d295-603">Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações.</span><span class="sxs-lookup"><span data-stu-id="3d295-603">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="3d295-604">Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução.</span><span class="sxs-lookup"><span data-stu-id="3d295-604">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="3d295-605">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-605">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="3d295-606">Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-606">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="3d295-607">Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d295-607">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="3d295-608">Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-608">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="3d295-609">Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-609">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-610">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-610">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-611"><paramref name="sourceArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-611"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-612">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-612">-or-</span></span>  
  
 <span data-ttu-id="3d295-613"><paramref name="destinationArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-613"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-614"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-614"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="3d295-615"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-615"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-616">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-616">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-617"><paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-617"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-618"><paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-618"><paramref name="length" /> is greater than the number of elements in <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-619">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-619">-or-</span></span>  
  
 <span data-ttu-id="3d295-620"><paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-620"><paramref name="length" /> is greater than the number of elements in <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="3d295-621">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-621">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="3d295-622">Um inteiro de 32 bits que representa o índice em <c>sourceArray</c> em que a cópia é iniciada.</span><span class="sxs-lookup"><span data-stu-id="3d295-622">A 32-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="3d295-623">O <see cref="T:System.Array" /> que recebe os dados.</span><span class="sxs-lookup"><span data-stu-id="3d295-623">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="3d295-624">Um inteiro de 32 bits que representa o índice em <c>destinationArray</c> em que o armazenamento é iniciado.</span><span class="sxs-lookup"><span data-stu-id="3d295-624">A 32-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-625">Um inteiro de 32 bits que representa o número de elementos a se copiar.</span><span class="sxs-lookup"><span data-stu-id="3d295-625">A 32-bit integer that represents the number of elements to copy.</span></span></param>
        <summary><span data-ttu-id="3d295-626">Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-626">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="3d295-627">A altura e os índices são especificados como inteiros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-627">The length and the indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-628">Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-628">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="3d295-629">Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-629">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="3d295-630">Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="3d295-630">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="3d295-631">Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).</span><span class="sxs-lookup"><span data-stu-id="3d295-631">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="3d295-632">Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.</span><span class="sxs-lookup"><span data-stu-id="3d295-632">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="3d295-633">Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.</span><span class="sxs-lookup"><span data-stu-id="3d295-633">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="3d295-634">[C++]</span><span class="sxs-lookup"><span data-stu-id="3d295-634">[C++]</span></span>  
  
 <span data-ttu-id="3d295-635">Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="3d295-635">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="3d295-636">As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-636">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="3d295-637">O downcast de tipo é realizado, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="3d295-637">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="3d295-638">Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-638">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="3d295-639">Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-639">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="3d295-640">Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo.</span><span class="sxs-lookup"><span data-stu-id="3d295-640">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="3d295-641">Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-641">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="3d295-642">Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada.</span><span class="sxs-lookup"><span data-stu-id="3d295-642">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="3d295-643">Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original.</span><span class="sxs-lookup"><span data-stu-id="3d295-643">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="3d295-644">Os próprios elementos ou nada referenciado pelos elementos não são copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-644">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="3d295-645">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-645">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-646">Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-646">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="3d295-647">A compatibilidade de tipo é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-647">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="3d295-648">Um tipo é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-648">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="3d295-649">Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-649">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="3d295-650">Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-650">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="3d295-651">Os tipos desconectado não são compatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-651">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="3d295-652">Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação.</span><span class="sxs-lookup"><span data-stu-id="3d295-652">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="3d295-653">Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações.</span><span class="sxs-lookup"><span data-stu-id="3d295-653">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="3d295-654">Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução.</span><span class="sxs-lookup"><span data-stu-id="3d295-654">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="3d295-655">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-655">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="3d295-656">Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-656">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="3d295-657">Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d295-657">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="3d295-658">Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-658">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="3d295-659">Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-659">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-660">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-660">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-661">O exemplo de código a seguir mostra como copiar um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.</span><span class="sxs-lookup"><span data-stu-id="3d295-661">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-662"><paramref name="sourceArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-662"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-663">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-663">-or-</span></span>  
  
 <span data-ttu-id="3d295-664"><paramref name="destinationArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-664"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-665"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-665"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="3d295-666"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-666"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-667">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-667">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-668"><paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-668"><paramref name="sourceIndex" /> is less than the lower bound of the first dimension of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-669">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-669">-or-</span></span>  
  
 <span data-ttu-id="3d295-670"><paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-670"><paramref name="destinationIndex" /> is less than the lower bound of the first dimension of <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="3d295-671">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-671">-or-</span></span>  
  
 <span data-ttu-id="3d295-672"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-672"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-673"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-673"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-674">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-674">-or-</span></span>  
  
 <span data-ttu-id="3d295-675"><paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-675"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray"><span data-ttu-id="3d295-676">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-676">The <see cref="T:System.Array" /> that contains the data to copy.</span></span></param>
        <param name="sourceIndex"><span data-ttu-id="3d295-677">Um inteiro de 64 bits que representa o índice em <c>sourceArray</c> em que a cópia é iniciada.</span><span class="sxs-lookup"><span data-stu-id="3d295-677">A 64-bit integer that represents the index in the <c>sourceArray</c> at which copying begins.</span></span></param>
        <param name="destinationArray"><span data-ttu-id="3d295-678">O <see cref="T:System.Array" /> que recebe os dados.</span><span class="sxs-lookup"><span data-stu-id="3d295-678">The <see cref="T:System.Array" /> that receives the data.</span></span></param>
        <param name="destinationIndex"><span data-ttu-id="3d295-679">Um inteiro de 64 bits que representa o índice em <c>destinationArray</c> em que o armazenamento é iniciado.</span><span class="sxs-lookup"><span data-stu-id="3d295-679">A 64-bit integer that represents the index in the <c>destinationArray</c> at which storing begins.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-680">Um inteiro de 64 bits que representa o número de elementos a se copiar.</span><span class="sxs-lookup"><span data-stu-id="3d295-680">A 64-bit integer that represents the number of elements to copy.</span></span> <span data-ttu-id="3d295-681">O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</span><span class="sxs-lookup"><span data-stu-id="3d295-681">The integer must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="3d295-682">Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-682">Copies a range of elements from an <see cref="T:System.Array" /> starting at the specified source index and pastes them to another <see cref="T:System.Array" /> starting at the specified destination index.</span></span> <span data-ttu-id="3d295-683">O tamanho e os índices são especificados como inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-683">The length and the indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-684">Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-684">The `sourceArray` and `destinationArray` parameters must have the same number of dimensions.</span></span> <span data-ttu-id="3d295-685">Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-685">In addition, `destinationArray` must already have been dimensioned and must have a sufficient number of elements starting from the `destinationIndex` position to accommodate the copied data.</span></span>  
  
 <span data-ttu-id="3d295-686">Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional de tempo em que as linhas (ou colunas) são conceitualmente organizadas de ponta a ponta.</span><span class="sxs-lookup"><span data-stu-id="3d295-686">When copying between multidimensional arrays, the array behaves like a long one-dimensional array, where the rows (or columns) are conceptually laid end-to-end.</span></span> <span data-ttu-id="3d295-687">Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).</span><span class="sxs-lookup"><span data-stu-id="3d295-687">For example, if an array has three rows (or columns) with four elements each, copying six elements from the beginning of the array would copy all four elements of the first row (or column) and the first two elements of the second row (or column).</span></span> <span data-ttu-id="3d295-688">Para iniciar a cópia do elemento da terceira linha (ou coluna), segunda `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o comprimento da segunda linha (ou coluna) e dois.</span><span class="sxs-lookup"><span data-stu-id="3d295-688">To start copying from the second element of the third row (or column), `sourceIndex` must be the upper bound of the first row (or column) plus the length of the second row (or column) plus two.</span></span>  
  
 <span data-ttu-id="3d295-689">Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.</span><span class="sxs-lookup"><span data-stu-id="3d295-689">If `sourceArray` and `destinationArray` overlap, this method behaves as if the original values of `sourceArray` were preserved in a temporary location before `destinationArray` is overwritten.</span></span>  
  
 <span data-ttu-id="3d295-690">[C++]</span><span class="sxs-lookup"><span data-stu-id="3d295-690">[C++]</span></span>  
  
 <span data-ttu-id="3d295-691">Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.</span><span class="sxs-lookup"><span data-stu-id="3d295-691">This method is equivalent to the standard C/C++ function `memmove`, not `memcpy`.</span></span>  
  
 <span data-ttu-id="3d295-692">As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-692">The arrays can be reference-type arrays or value-type arrays.</span></span> <span data-ttu-id="3d295-693">O downcast de tipo é realizado, conforme necessário.</span><span class="sxs-lookup"><span data-stu-id="3d295-693">Type downcasting is performed, as required.</span></span>  
  
-   <span data-ttu-id="3d295-694">Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-694">When copying from a reference-type array to a value-type array, each element is unboxed and then copied.</span></span> <span data-ttu-id="3d295-695">Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.</span><span class="sxs-lookup"><span data-stu-id="3d295-695">When copying from a value-type array to a reference-type array, each element is boxed and then copied.</span></span>  
  
-   <span data-ttu-id="3d295-696">Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo.</span><span class="sxs-lookup"><span data-stu-id="3d295-696">When copying from a reference-type or value-type array to an <xref:System.Object> array, an <xref:System.Object> is created to hold each value or reference and then copied.</span></span> <span data-ttu-id="3d295-697">Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-697">When copying from an <xref:System.Object> array to a reference-type or value-type array and the assignment is not possible, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
-   <span data-ttu-id="3d295-698">Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada.</span><span class="sxs-lookup"><span data-stu-id="3d295-698">If `sourceArray` and `destinationArray` are both reference-type arrays or are both arrays of type <xref:System.Object>, a shallow copy is performed.</span></span> <span data-ttu-id="3d295-699">Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original.</span><span class="sxs-lookup"><span data-stu-id="3d295-699">A shallow copy of an <xref:System.Array> is a new <xref:System.Array> containing references to the same elements as the original <xref:System.Array>.</span></span> <span data-ttu-id="3d295-700">Os próprios elementos ou nada referenciado pelos elementos não são copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-700">The elements themselves or anything referenced by the elements are not copied.</span></span> <span data-ttu-id="3d295-701">Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-701">In contrast, a deep copy of an <xref:System.Array> copies the elements and everything directly or indirectly referenced by the elements.</span></span>  
  
 <span data-ttu-id="3d295-702">Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-702">An <xref:System.ArrayTypeMismatchException> is thrown if the arrays are of incompatible types.</span></span> <span data-ttu-id="3d295-703">A compatibilidade de tipo é definida da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-703">Type compatibility is defined as follows:</span></span>  
  
-   <span data-ttu-id="3d295-704">Um tipo é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-704">A type is compatible with itself.</span></span>  
  
-   <span data-ttu-id="3d295-705">Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-705">A value type is compatible with <xref:System.Object> and with an interface type implemented by that value type.</span></span> <span data-ttu-id="3d295-706">Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-706">A value type is considered connected to an interface only if it implements that interface directly.</span></span> <span data-ttu-id="3d295-707">Os tipos desconectado não são compatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-707">Disconnected types are not compatible.</span></span>  
  
-   <span data-ttu-id="3d295-708">Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação.</span><span class="sxs-lookup"><span data-stu-id="3d295-708">Two intrinsic (predefined) value types are compatible if copying from the source type to the destination type is a widening conversion.</span></span> <span data-ttu-id="3d295-709">Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações.</span><span class="sxs-lookup"><span data-stu-id="3d295-709">A widening conversion never loses information, whereas a narrowing conversion can lose information.</span></span> <span data-ttu-id="3d295-710">Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução.</span><span class="sxs-lookup"><span data-stu-id="3d295-710">For example, converting a 32-bit signed integer to a 64-bit signed integer is a widening conversion, and converting a 64-bit signed integer to a 32-bit signed integer is a narrowing conversion.</span></span> <span data-ttu-id="3d295-711">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-711">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
-   <span data-ttu-id="3d295-712">Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-712">A nonintrinsic (user-defined) value type is compatible only with itself.</span></span>  
  
-   <span data-ttu-id="3d295-713">Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d295-713">Enumerations have an implicit conversion to <xref:System.Enum> and to their underlying type.</span></span>  
  
 <span data-ttu-id="3d295-714">Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.</span><span class="sxs-lookup"><span data-stu-id="3d295-714">If every element in `sourceArray` requires a downcast (for example, from a base class to a derived class or from an interface to an object) and one or more elements cannot be cast to the corresponding type in `destinationArray`, an <xref:System.InvalidCastException> is thrown.</span></span>  
  
 <span data-ttu-id="3d295-715">Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-715">If this method throws an exception while copying, the state of `destinationArray` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-716">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-716">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-717">O exemplo de código a seguir mostra como copiar um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.</span><span class="sxs-lookup"><span data-stu-id="3d295-717">The following code example shows how to copy from one <xref:System.Array> of type <xref:System.Object> to another <xref:System.Array> of type integer.</span></span>  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-718"><paramref name="sourceArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-718"><paramref name="sourceArray" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-719">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-719">-or-</span></span>  
  
 <span data-ttu-id="3d295-720"><paramref name="destinationArray" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-720"><paramref name="destinationArray" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-721"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-721"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> have different ranks.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException">
          <span data-ttu-id="3d295-722"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</span><span class="sxs-lookup"><span data-stu-id="3d295-722"><paramref name="sourceArray" /> and <paramref name="destinationArray" /> are of incompatible types.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-723">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-723">At least one element in <paramref name="sourceArray" /> cannot be cast to the type of <paramref name="destinationArray" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-724"><paramref name="sourceIndex" /> está fora do intervalo de índices válidos para o <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-724"><paramref name="sourceIndex" /> is outside the range of valid indexes for the <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-725">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-725">-or-</span></span>  
  
 <span data-ttu-id="3d295-726"><paramref name="destinationIndex" /> está fora do intervalo de índices válidos para o <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-726"><paramref name="destinationIndex" /> is outside the range of valid indexes for the <paramref name="destinationArray" />.</span></span>  
  
 <span data-ttu-id="3d295-727">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-727">-or-</span></span>  
  
 <span data-ttu-id="3d295-728"><paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-728"><paramref name="length" /> is less than 0 or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-729"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-729"><paramref name="length" /> is greater than the number of elements from <paramref name="sourceIndex" /> to the end of <paramref name="sourceArray" />.</span></span>  
  
 <span data-ttu-id="3d295-730">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-730">-or-</span></span>  
  
 <span data-ttu-id="3d295-731"><paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-731"><paramref name="length" /> is greater than the number of elements from <paramref name="destinationIndex" /> to the end of <paramref name="destinationArray" />.</span></span></exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-732">Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-732">Copies all the elements of the current one-dimensional array to the specified one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-733">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-733">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-734">Um inteiro de 32 bits que representa o índice na <c>matriz</c> em que a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="3d295-734">A 32-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="3d295-735">Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-735">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="3d295-736">O índice é especificado como um inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-736">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-737">Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`.</span><span class="sxs-lookup"><span data-stu-id="3d295-737">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="3d295-738">O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-738">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="3d295-739">Caso contrário, o método gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-739">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="3d295-740">Este método oferece suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-740">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="3d295-741">Se a implementação <xref:System.Collections.ICollection?displayProperty=nameWithType> é necessário não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma inversão de controle extra.</span><span class="sxs-lookup"><span data-stu-id="3d295-741">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="3d295-742">Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-742">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-743">Esse método é um O (`n`) operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa somente uma cópia superficial.</span><span class="sxs-lookup"><span data-stu-id="3d295-743">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-744">O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-744">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="3d295-745">O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-745">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="3d295-746">Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituem elementos existentes no destino <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-746">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-747"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-747"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-748"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-748"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-749"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-749"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-750">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-750">-or-</span></span>  
  
 <span data-ttu-id="3d295-751">O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-751">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d295-752">O tipo do <see cref="T:System.Array" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-752">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-753">A matriz de origem é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-753">The source array is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-754">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-754">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-755">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-755">The one-dimensional array that is the destination of the elements copied from the current array.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-756">Um inteiro de 64 bits que representa o índice na <c>matriz</c> em que a cópia começa.</span><span class="sxs-lookup"><span data-stu-id="3d295-756">A 64-bit integer that represents the index in <c>array</c> at which copying begins.</span></span></param>
        <summary><span data-ttu-id="3d295-757">Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-757">Copies all the elements of the current one-dimensional array to the specified one-dimensional array starting at the specified destination array index.</span></span> <span data-ttu-id="3d295-758">O índice é especificado como um inteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-758">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-759">Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`.</span><span class="sxs-lookup"><span data-stu-id="3d295-759">This method copies all the elements of the current array instance to the `array` destination array, starting at index `index`.</span></span> <span data-ttu-id="3d295-760">O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados.</span><span class="sxs-lookup"><span data-stu-id="3d295-760">The `array` destination array must already have been dimensioned and must have a sufficient number of elements to accommodate the copied elements.</span></span> <span data-ttu-id="3d295-761">Caso contrário, o método gera uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-761">Otherwise, the method throws an exception.</span></span>  
  
 <span data-ttu-id="3d295-762">Este método oferece suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-762">This method supports the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="3d295-763">Se a implementação <xref:System.Collections.ICollection?displayProperty=nameWithType> é necessário não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma inversão de controle extra.</span><span class="sxs-lookup"><span data-stu-id="3d295-763">If implementing <xref:System.Collections.ICollection?displayProperty=nameWithType> is not explicitly required, use <xref:System.Array.Copy%2A> to avoid an extra indirection.</span></span>  
  
 <span data-ttu-id="3d295-764">Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-764">If this method throws an exception while copying, the state of `array` is undefined.</span></span>  
  
 <span data-ttu-id="3d295-765">Esse método é um O (`n`) operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa somente uma cópia superficial.</span><span class="sxs-lookup"><span data-stu-id="3d295-765">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.It performs a shallow copy only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-766">O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-766">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 <span data-ttu-id="3d295-767">O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-767">The following code example shows how to copy an <xref:System.Array> to another <xref:System.Array> with a nonzero lower bound.</span></span> <span data-ttu-id="3d295-768">Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituem elementos existentes no destino <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-768">Note that the entire source <xref:System.Array> is copied, including empty elements that overwrite existing elements in the target <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-769"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-769"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-770"><paramref name="index" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-770"><paramref name="index" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-771"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-771"><paramref name="array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-772">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-772">-or-</span></span>  
  
 <span data-ttu-id="3d295-773">O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-773">The number of elements in the source array is greater than the available number of elements from <paramref name="index" /> to the end of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.ArrayTypeMismatchException"><span data-ttu-id="3d295-774">O tipo do <see cref="T:System.Array" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-774">The type of the source <see cref="T:System.Array" /> cannot be cast automatically to the type of the destination <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-775">A fonte <see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-775">The source <see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidCastException"><span data-ttu-id="3d295-776">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="3d295-776">At least one element in the source <see cref="T:System.Array" /> cannot be cast to the type of destination <paramref name="array" />.</span></span></exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-777">Inicializa uma nova instância da classe <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-777">Initializes a new instance of the <see cref="T:System.Array" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-778">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-778">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-779">O tamanho do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-779">The size of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="3d295-780">Cria um <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado e tamanho, com a indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-780">Creates a one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and length, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="3d295-781">Um novo <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado, usando a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-781">A new one-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-782">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-782">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-783">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-783">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-784">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-784">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-785">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-785">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-786">O exemplo de código a seguir mostra como criar e inicializar um unidimensional <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-786">The following code example shows how to create and initialize a one-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-787"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-787"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-788"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-788"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-789"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-789"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-790">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-790">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-791">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-791">-or-</span></span>  
  
 <span data-ttu-id="3d295-792"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-792"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-793"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-793"><paramref name="length" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-794">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-794">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="3d295-795">Uma matriz de inteiros de 32 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-795">An array of 32-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="3d295-796">Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-796">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="3d295-797">Os tamanhos da dimensão são especificados em uma matriz de inteiros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-797">The dimension lengths are specified in an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-798">Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-798">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-799">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-799">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-800">O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-800">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="3d295-801">Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-801">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-802">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-802">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-803">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-803">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-804">Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.</span><span class="sxs-lookup"><span data-stu-id="3d295-804">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-805">O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-805">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-806"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-806"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-807">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-807">-or-</span></span>  
  
 <span data-ttu-id="3d295-808"><paramref name="lengths" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-808"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-809"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-809"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="3d295-810">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-810">-or-</span></span>  
  
 <span data-ttu-id="3d295-811">A matriz <paramref name="lengths" /> contém menos de um elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-811">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-812"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-812"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-813">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-813">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-814">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-814">-or-</span></span>  
  
 <span data-ttu-id="3d295-815"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-815"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-816">Qualquer valor em <paramref name="lengths" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-816">Any value in <paramref name="lengths" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-817">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-817">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="3d295-818">Uma matriz de inteiros de 64 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-818">An array of 64-bit integers that represent the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span> <span data-ttu-id="3d295-819">Cada inteiro na matriz deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</span><span class="sxs-lookup"><span data-stu-id="3d295-819">Each integer in the array must be between zero and <see cref="F:System.Int32.MaxValue" />, inclusive.</span></span></param>
        <summary><span data-ttu-id="3d295-820">Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-820">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span> <span data-ttu-id="3d295-821">Os tamanhos da dimensão são especificados em uma matriz de inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-821">The dimension lengths are specified in an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-822">Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-822">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-823">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-823">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-824">O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-824">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span> <span data-ttu-id="3d295-825">Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-825">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-826">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-826">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-827">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-827">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-828">Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.</span><span class="sxs-lookup"><span data-stu-id="3d295-828">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-829">O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-829">The following code example shows how to create and initialize a multidimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-830"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-830"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-831">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-831">-or-</span></span>  
  
 <span data-ttu-id="3d295-832"><paramref name="lengths" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-832"><paramref name="lengths" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-833"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-833"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="3d295-834">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-834">-or-</span></span>  
  
 <span data-ttu-id="3d295-835">A matriz <paramref name="lengths" /> contém menos de um elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-835">The <paramref name="lengths" /> array contains less than one element.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-836"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-836"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-837">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-837">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-838">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-838">-or-</span></span>  
  
 <span data-ttu-id="3d295-839"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-839"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-840">Qualquer valor em <paramref name="lengths" /> é menor que zero ou maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-840">Any value in <paramref name="lengths" /> is less than zero or greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-841">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-841">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="3d295-842">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-842">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="3d295-843">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-843">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="3d295-844">Cria um <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-844">Creates a two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="3d295-845">Um novo <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação com base zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-845">A new two-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-846">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-846">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-847">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-847">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-848">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-848">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-849">Esse método é um O (`n`) operação, onde `n` é o produto de `length1` e `length2`.</span><span class="sxs-lookup"><span data-stu-id="3d295-849">This method is an O(`n`) operation, where `n` is the product of `length1` and `length2`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-850">O exemplo de código a seguir mostra como criar e inicializar um bidimensional <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-850">The following code example shows how to create and initialize a two-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-851"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-851"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-852"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-852"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-853"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-853"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-854">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-854">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-855">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-855">-or-</span></span>  
  
 <span data-ttu-id="3d295-856"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-856"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-857"><paramref name="length1" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-857"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-858">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-858">-or-</span></span>  
  
 <span data-ttu-id="3d295-859"><paramref name="length2" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-859"><paramref name="length2" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-860">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-860">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lengths"><span data-ttu-id="3d295-861">Uma matriz unidimensional que contém o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-861">A one-dimensional array that contains the size of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="lowerBounds"><span data-ttu-id="3d295-862">Uma matriz unidimensional que contém o limite inferior (índice inicial) de cada dimensão do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-862">A one-dimensional array that contains the lower bound (starting index) of each dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="3d295-863">Cria um <see cref="T:System.Array" /> multidimensional com o <see cref="T:System.Type" /> especificado e com os tamanhos da dimensão, com os limites inferiores especificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-863">Creates a multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with the specified lower bounds.</span></span></summary>
        <returns><span data-ttu-id="3d295-864">Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado e o limite inferior de cada dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-864">A new multidimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length and lower bound for each dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-865">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-865">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-866">O `lengths` e `lowerBounds` matrizes devem ter o mesmo número de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-866">The `lengths` and `lowerBounds` arrays must have the same number of elements.</span></span> <span data-ttu-id="3d295-867">O número de elementos de `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-867">The number of elements in the `lengths` array must equal the number of dimensions in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-868">Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-868">Each element of the `lengths` array must specify the length of the corresponding dimension in the new <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-869">Cada elemento do `lowerBounds` matriz deve especificar o limite inferior da dimensão correspondente no novo <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-869">Each element of the `lowerBounds` array must specify the lower bound of the corresponding dimension in the new <xref:System.Array>.</span></span> <span data-ttu-id="3d295-870">Em geral, a biblioteca de classes do .NET Framework e muitas linguagens de programação não lidar com limites inferiores do zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-870">Generally, the .NET Framework class library and many programming languages do not handle nonzero lower bounds.</span></span>  
  
 <span data-ttu-id="3d295-871">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-871">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-872">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-872">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-873">Esse método é um O (`n`) operação, onde `n` é o produto de todos os valores `lengths`.</span><span class="sxs-lookup"><span data-stu-id="3d295-873">This method is an O(`n`) operation, where `n` is the product of all values in `lengths`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-874">O exemplo de código a seguir mostra como criar e inicializar um multidimensionais <xref:System.Array> com limites inferiores do especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-874">The following code example shows how to create and initialize a multidimensional <xref:System.Array> with specified lower bounds.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-875"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-875"><paramref name="elementType" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-876">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-876">-or-</span></span>  
  
 <span data-ttu-id="3d295-877"><paramref name="lengths" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-877"><paramref name="lengths" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-878">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-878">-or-</span></span>  
  
 <span data-ttu-id="3d295-879"><paramref name="lowerBounds" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-879"><paramref name="lowerBounds" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-880"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-880"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span>  
  
 <span data-ttu-id="3d295-881">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-881">-or-</span></span>  
  
 <span data-ttu-id="3d295-882">A matriz <paramref name="lengths" /> contém menos de um elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-882">The <paramref name="lengths" /> array contains less than one element.</span></span>  
  
 <span data-ttu-id="3d295-883">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-883">-or-</span></span>  
  
 <span data-ttu-id="3d295-884">As matrizes <paramref name="lengths" /> e <paramref name="lowerBounds" /> não contêm o mesmo número de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-884">The <paramref name="lengths" /> and <paramref name="lowerBounds" /> arrays do not contain the same number of elements.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-885"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-885"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-886">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-886">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-887">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-887">-or-</span></span>  
  
 <span data-ttu-id="3d295-888"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-888"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-889">Qualquer valor em <paramref name="lengths" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-889">Any value in <paramref name="lengths" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-890">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-890">-or-</span></span>  
  
 <span data-ttu-id="3d295-891">Qualquer valor em <paramref name="lowerBounds" /> é muito grande, de modo que a soma do limite inferior e do tamanho de uma dimensão é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-891">Any value in <paramref name="lowerBounds" /> is very large, such that the sum of a dimension's lower bound and length is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType"><span data-ttu-id="3d295-892">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</span><span class="sxs-lookup"><span data-stu-id="3d295-892">The <see cref="T:System.Type" /> of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length1"><span data-ttu-id="3d295-893">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-893">The size of the first dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length2"><span data-ttu-id="3d295-894">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-894">The size of the second dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <param name="length3"><span data-ttu-id="3d295-895">O tamanho da terceira dimensão do <see cref="T:System.Array" /> a ser criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-895">The size of the third dimension of the <see cref="T:System.Array" /> to create.</span></span></param>
        <summary><span data-ttu-id="3d295-896">Cria um <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-896">Creates a three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> and dimension lengths, with zero-based indexing.</span></span></summary>
        <returns><span data-ttu-id="3d295-897">Um novo <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação baseada em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-897">A new three-dimensional <see cref="T:System.Array" /> of the specified <see cref="T:System.Type" /> with the specified length for each dimension, using zero-based indexing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-898">Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.</span><span class="sxs-lookup"><span data-stu-id="3d295-898">Unlike most classes, <xref:System.Array> provides the <xref:System.Array.CreateInstance%2A> method, instead of public constructors, to allow for late bound access.</span></span>  
  
 <span data-ttu-id="3d295-899">Elementos do tipo de referência são inicializados como `null`.</span><span class="sxs-lookup"><span data-stu-id="3d295-899">Reference-type elements are initialized to `null`.</span></span> <span data-ttu-id="3d295-900">Os elementos do tipo de valor são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-900">Value-type elements are initialized to zero.</span></span>  
  
 <span data-ttu-id="3d295-901">Esse método é um O (`n`) operação, onde `n` é o produto de `length1`, `length2`, e `length3`.</span><span class="sxs-lookup"><span data-stu-id="3d295-901">This method is an O(`n`) operation, where `n` is the product of `length1`, `length2`, and `length3`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-902">O exemplo de código a seguir mostra como criar e inicializar um tridimensional <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-902">The following code example shows how to create and initialize a three-dimensional <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-903"><paramref name="elementType" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-903"><paramref name="elementType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-904"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3d295-904"><paramref name="elementType" /> is not a valid <see cref="T:System.Type" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="3d295-905"><paramref name="elementType" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-905"><paramref name="elementType" /> is not supported.</span></span> <span data-ttu-id="3d295-906">Por exemplo, <see cref="T:System.Void" /> não é suportado.</span><span class="sxs-lookup"><span data-stu-id="3d295-906">For example, <see cref="T:System.Void" /> is not supported.</span></span>  
  
 <span data-ttu-id="3d295-907">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-907">-or-</span></span>  
  
 <span data-ttu-id="3d295-908"><paramref name="elementType" /> é um tipo genérico aberto.</span><span class="sxs-lookup"><span data-stu-id="3d295-908"><paramref name="elementType" /> is an open generic type.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-909"><paramref name="length1" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-909"><paramref name="length1" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-910">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-910">-or-</span></span>  
  
 <span data-ttu-id="3d295-911"><paramref name="length2" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-911"><paramref name="length2" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-912">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-912">-or-</span></span>  
  
 <span data-ttu-id="3d295-913"><paramref name="length3" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-913"><paramref name="length3" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-914">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-914">The type of the elements of the array.</span></span></typeparam>
        <summary><span data-ttu-id="3d295-915">Retorna uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-915">Returns an empty array.</span></span></summary>
        <returns><span data-ttu-id="3d295-916">Retorna um <see cref="T:System.Array" /> vazio.</span><span class="sxs-lookup"><span data-stu-id="3d295-916">Returns an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-917">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-917">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-918">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-918">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-919">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</span><span class="sxs-lookup"><span data-stu-id="3d295-919">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-920">Determina se a matriz especificada contém elementos que correspondem às condições definidas pelo predicado especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-920">Determines whether the specified array contains elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="3d295-921"><see langword="true" /> se <paramref name="array" /> contiver um ou mais elementos que correspondem às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-921"><see langword="true" /> if <paramref name="array" /> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-922">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-922">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-923">Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e o processamento será interrompido quando uma correspondência for encontrada.</span><span class="sxs-lookup"><span data-stu-id="3d295-923">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when a match is found.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-924">Em c# e Visual Basic, não é necessário criar a <xref:System.Predicate%601> delegar explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-924">In C# and Visual Basic, it is not necessary to create the <xref:System.Predicate%601> delegate explicitly.</span></span> <span data-ttu-id="3d295-925">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-925">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-926">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-926">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-927">O exemplo a seguir especifica as condições de correspondência para o <xref:System.Array.Exists%2A> expressões de usinglambda método para verificar se um planeta começa com uma letra determinada ou se o planeta está localizado na matriz fornecida.</span><span class="sxs-lookup"><span data-stu-id="3d295-927">The following example specifies the match conditions for the <xref:System.Array.Exists%2A> method usinglambda expressions to check whether a planet starts with a given letter or whether the planet is found on the given array.</span></span>  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 <span data-ttu-id="3d295-928">O exemplo a seguir usa o <xref:System.Array.Exists%2A> método para indicar se todos os nomes em uma matriz de cadeia de caracteres começam com um caractere especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-928">The following example uses the <xref:System.Array.Exists%2A> method to indicate whether any names in a string array begin with a specified character.</span></span> <span data-ttu-id="3d295-929">O exemplo cria um `StringSearcher` objeto passando a cadeia de caracteres para pesquisar para o construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="3d295-929">The example instantiates a `StringSearcher` object by passing the string to search for to its class constructor.</span></span> <span data-ttu-id="3d295-930">O `StringSearcher.StartsWith` método tem a mesma assinatura que o <xref:System.Predicate%601> delegate.</span><span class="sxs-lookup"><span data-stu-id="3d295-930">The `StringSearcher.StartsWith` method has same signature as the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="3d295-931">Quando o <xref:System.Array.Exists%2A> método é chamado, cada membro da matriz é passado para o representante até ele retornar `true` ou itera todos os elementos na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-931">When the <xref:System.Array.Exists%2A> method is called, each member of the array is passed to the delegate until it returns `true` or iterates all the elements in the array.</span></span>  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 <span data-ttu-id="3d295-932">Você pode também usar uma expressão lambda em vez de definir explicitamente um método cuja assinatura corresponde do delegado.</span><span class="sxs-lookup"><span data-stu-id="3d295-932">You can also use a lambda expression rather than explicitly define a method whose signature corresponds to that of the delegate.</span></span> <span data-ttu-id="3d295-933">O exemplo a seguir substitui o `StringSearcher` classe e seu `StartsWith` método com uma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="3d295-933">The following example replaces the `StringSearcher` class and its `StartsWith` method with a lambda expression.</span></span>  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-934"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-934"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-935">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-935">-or-</span></span>  
  
 <span data-ttu-id="3d295-936"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-936"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-937">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-937">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-938">A matriz unidimensional, baseada em zero, a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-938">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-939">O predicado que define as condições do elemento a ser pesquisado.</span><span class="sxs-lookup"><span data-stu-id="3d295-939">The predicate that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-940">Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-940">Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-941">O primeiro elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-941">The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-942">O <xref:System.Predicate%601> é um delegado para um método ou uma expressão lambda que retorna `true` se o objeto passado para ele corresponde às condições definidas no delegado ou expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="3d295-942">The <xref:System.Predicate%601> is a delegate to a method or a lambda expression that returns `true` if the object passed to it matches the conditions defined in the delegate or lambda expression.</span></span>  <span data-ttu-id="3d295-943">Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, começando com o primeiro elemento e terminando com o último elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-943">The elements of `array` are individually passed to the <xref:System.Predicate%601>, starting with the first element and ending with the last element.</span></span>  <span data-ttu-id="3d295-944">O processamento será interrompido quando uma correspondência for encontrada.</span><span class="sxs-lookup"><span data-stu-id="3d295-944">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="3d295-945">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-945">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-946">O exemplo a seguir usa uma <xref:System.Predicate%601> delegar com o <xref:System.Array.Find%2A> método genérico para pesquisar uma matriz de <xref:System.Drawing.Point> estruturas.</span><span class="sxs-lookup"><span data-stu-id="3d295-946">The following example uses a <xref:System.Predicate%601> delegate with the <xref:System.Array.Find%2A> generic method to search an array of <xref:System.Drawing.Point> structures.</span></span> <span data-ttu-id="3d295-947">O método que o delegado representa, `ProductGT10`, retorna `true` se o produto dos campos de X e Y é maior que 100.000.</span><span class="sxs-lookup"><span data-stu-id="3d295-947">The method the delegate represents, `ProductGT10`, returns `true` if the product of the X and Y fields is greater than 100,000.</span></span> <span data-ttu-id="3d295-948">O <xref:System.Array.Find%2A> método chama o representante para cada elemento da matriz, retornando o primeiro ponto que atende a condição de teste.</span><span class="sxs-lookup"><span data-stu-id="3d295-948">The <xref:System.Array.Find%2A> method calls the delegate for each element of the array, returning the first point that meets the test condition.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-949">Visual Basic e c# usuários é necessário criar o representante explicitamente ou especificar o argumento de tipo do método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-949">Visual Basic and C# users do not have to create the delegate explicitly or specify the type argument of the generic method.</span></span> <span data-ttu-id="3d295-950">Os compiladores determinam os tipos necessários dos argumentos de método que você fornecer.</span><span class="sxs-lookup"><span data-stu-id="3d295-950">The compilers determine the necessary types from the method arguments you supply.</span></span>  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 <span data-ttu-id="3d295-951">Em vez de definir explicitamente um método com a assinatura necessária, criando um <xref:System.Predicate%601> delegar e passando o delegado para o <xref:System.Array.Find%2A> método, é comum usar uma expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="3d295-951">Rather than explicitly defining a method with the necessary signature, instantiating a <xref:System.Predicate%601> delegate, and passing the delegate to the <xref:System.Array.Find%2A> method, it is customary to use a lambda expression.</span></span> <span data-ttu-id="3d295-952">O exemplo a seguir é idêntico ao anterior, exceto que ele usa uma expressão lambda como o `match` argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-952">The following example is identical to the previous one, except that it uses a lambda expression as the `match` argument.</span></span>  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-953"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-953"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-954">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-954">-or-</span></span>  
  
 <span data-ttu-id="3d295-955"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-955"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-956">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-956">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-957">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-957">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-958">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</span><span class="sxs-lookup"><span data-stu-id="3d295-958">The <see cref="T:System.Predicate`1" /> that defines the conditions of the elements to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-959">Recupera todos os elementos que correspondem às condições definidas pelo predicado especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-959">Retrieves all the elements that match the conditions defined by the specified predicate.</span></span></summary>
        <returns><span data-ttu-id="3d295-960">Um <see cref="T:System.Array" /> que contém todos os elementos que correspondem às condições definidas pelo predicado especificado, se encontrado; caso contrário, um <see cref="T:System.Array" /> vazio.</span><span class="sxs-lookup"><span data-stu-id="3d295-960">An <see cref="T:System.Array" /> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-961">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-961">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-962">Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e os elementos que correspondem às condições são salvos na matriz retornada.</span><span class="sxs-lookup"><span data-stu-id="3d295-962">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and the elements that match the conditions are saved in the returned array.</span></span>  
  
 <span data-ttu-id="3d295-963">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-963">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-964">O exemplo a seguir cria uma matriz de números aleatórios 50 com valores podem variar de 0 a 1.000.</span><span class="sxs-lookup"><span data-stu-id="3d295-964">The following example creates an array of 50 random numbers with values that can range from 0 to 1,000.</span></span> <span data-ttu-id="3d295-965">Depois, ele chama o <xref:System.Array.FindAll%2A> método com uma expressão lambda que retorna os valores que variam de 300 a 600.</span><span class="sxs-lookup"><span data-stu-id="3d295-965">It then calls the <xref:System.Array.FindAll%2A> method with a lambda expression that returns the values that range from 300 to 600.</span></span> <span data-ttu-id="3d295-966">Observe que a expressão lambda é passada um parâmetro denominado `x`;  Isso representa o membro de matriz individual que é passado para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-966">Note that the lambda expression is passed a parameter named `x`;  this represents the individual array member that is passed to the <xref:System.Predicate%601>.</span></span> <span data-ttu-id="3d295-967">Observe também que o local `lBound` e `uBound` variáveis são acessíveis dentro da expressão lambda.</span><span class="sxs-lookup"><span data-stu-id="3d295-967">Also note that the local `lBound` and `uBound` variables are accessible within the lambda expression.</span></span>  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 <span data-ttu-id="3d295-968">O exemplo de código a seguir demonstra o <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-968">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="3d295-969">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-969">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-970">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-970">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-971">O <xref:System.Array.Find%2A> método genérico atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-971">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-972">A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-972">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-973">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-973">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-974">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-974">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-975">O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final.</span><span class="sxs-lookup"><span data-stu-id="3d295-975">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="3d295-976">Ele localiza o elemento "Dilophosaurus" na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-976">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="3d295-977">O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-977">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="3d295-978">Os elementos são exibidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-978">The elements are displayed.</span></span>  
  
 <span data-ttu-id="3d295-979">O exemplo de código também demonstra o <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-979">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-980"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-980"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-981">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-981">-or-</span></span>  
  
 <span data-ttu-id="3d295-982"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-982"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-983">Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da primeira ocorrência em um <see cref="T:System.Array" /> ou parte dele.</span><span class="sxs-lookup"><span data-stu-id="3d295-983">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the first occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-984">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-984">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-985">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-985">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-986">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-986">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-987">Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência em toda a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-987">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-988">O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-988">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-989">O <xref:System.Array> é pesquisado forward iniciando no primeiro elemento e terminando no último elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-989">The <xref:System.Array> is searched forward starting at the first element and ending at the last element.</span></span>  
  
 <span data-ttu-id="3d295-990">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-990">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-991">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-991">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-992">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-992">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-993">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-993">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-994">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-994">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-995">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-995">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-996">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-996">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-997">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-997">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-998">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-998">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-999">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-999">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1000">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1000">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="3d295-1001">Localiza o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1001">It finds the element at position 5.</span></span> <span data-ttu-id="3d295-1002">Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2.</span><span class="sxs-lookup"><span data-stu-id="3d295-1002">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="3d295-1003">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1003">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1004"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1004"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1005">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1005">-or-</span></span>  
  
 <span data-ttu-id="3d295-1006"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1006"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1007">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1007">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1008">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1008">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1009">O índice inicial com base em zero da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1009">The zero-based starting index of the search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1010">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1010">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1011">Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do índice especificado ao último elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1011">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the specified index to the last element.</span></span></summary>
        <returns><span data-ttu-id="3d295-1012">O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1012">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1013">O <xref:System.Array> é pesquisado forward começando em `startIndex` e terminando no último elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1013">The <xref:System.Array> is searched forward starting at `startIndex` and ending at the last element.</span></span>  
  
 <span data-ttu-id="3d295-1014">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1014">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1015">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1015">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-1016">Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1016">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1017">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-1017">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-1018">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1018">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1019">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1019">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1020">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1020">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1021">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1021">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1022">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1022">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1023">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1023">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1024">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1024">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="3d295-1025">Localiza o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1025">It finds the element at position 5.</span></span> <span data-ttu-id="3d295-1026">Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2.</span><span class="sxs-lookup"><span data-stu-id="3d295-1026">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="3d295-1027">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1027">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1028"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1028"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1029">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1029">-or-</span></span>  
  
 <span data-ttu-id="3d295-1030"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1030"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1031"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1031"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1032">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1032">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1033">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1033">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1034">O índice inicial com base em zero da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1034">The zero-based starting index of the search.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1035">O número de elementos na seção a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1035">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1036">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1036">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1037">Pesquisa um elemento que coincida com as condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos na <see cref="T:System.Array" /> que começa no índice especificado e contém o número de elementos especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1037">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <see cref="T:System.Array" /> that starts at the specified index and contains the specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="3d295-1038">O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1038">The zero-based index of the first occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1039">O <xref:System.Array> é pesquisado forward começando em `startIndex` e final em `startIndex` mais `count` menos 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1039">The <xref:System.Array> is searched forward starting at `startIndex` and ending at `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="3d295-1040">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1040">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1041">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1041">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-1042">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1042">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1043">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-1043">The following code example demonstrates all three overloads of the <xref:System.Array.FindIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-1044">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1044">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1045">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1045">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1046">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1046">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1047">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1047">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 1.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1048">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1048">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1049">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1049">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1050">O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continua até o fim da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1050">The <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 2 and continuing to the end of the array.</span></span> <span data-ttu-id="3d295-1051">Localiza o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1051">It finds the element at position 5.</span></span> <span data-ttu-id="3d295-1052">Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2.</span><span class="sxs-lookup"><span data-stu-id="3d295-1052">Finally, the <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 2.</span></span> <span data-ttu-id="3d295-1053">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1053">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1054"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1054"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1055">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1055">-or-</span></span>  
  
 <span data-ttu-id="3d295-1056"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1056"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1057"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1057"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1058">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1058">-or-</span></span>  
  
 <span data-ttu-id="3d295-1059"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1059"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1060">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1060">-or-</span></span>  
  
 <span data-ttu-id="3d295-1061"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1061"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1062">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1062">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1063">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1063">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1064">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1064">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1065">Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1065">Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1066">O último elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1066">The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1067">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1067">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1068">Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, movendo para trás o <xref:System.Array>, começando com o último elemento e terminando com o primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1068">The elements of `array` are individually passed to the <xref:System.Predicate%601>, moving backward in the <xref:System.Array>, starting with the last element and ending with the first element.</span></span>  <span data-ttu-id="3d295-1069">O processamento será interrompido quando uma correspondência for encontrada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1069">Processing is stopped when a match is found.</span></span>  
  
 <span data-ttu-id="3d295-1070">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1070">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1071">O exemplo de código a seguir demonstra o <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1071">The following code example demonstrates the <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, and <xref:System.Array.FindAll%2A> generic methods.</span></span> <span data-ttu-id="3d295-1072">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1072">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1073">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1073">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1074">O <xref:System.Array.Find%2A> método genérico atravessa a matriz desde o início, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1074">The <xref:System.Array.Find%2A> generic method traverses the array from the beginning, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1075">A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1075">The search stops when the `EndsWithSaurus` method returns `true` for the element "Amargasaurus".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1076">Em c# e Visual Basic, não é necessário criar a`Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1076">In C# and Visual Basic, it is not necessary to create the`Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1077">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1077">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1078">O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final.</span><span class="sxs-lookup"><span data-stu-id="3d295-1078">The <xref:System.Array.FindLast%2A> generic method is used to search the array backward from the end.</span></span> <span data-ttu-id="3d295-1079">Ele localiza o elemento "Dilophosaurus" na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1079">It finds the element "Dilophosaurus" at position 5.</span></span> <span data-ttu-id="3d295-1080">O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1080">The <xref:System.Array.FindAll%2A> generic method is used to return an array containing all the elements that end in "saurus".</span></span> <span data-ttu-id="3d295-1081">Os elementos são exibidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1081">The elements are displayed.</span></span>  
  
 <span data-ttu-id="3d295-1082">O exemplo de código também demonstra o <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1082">The code example also demonstrates the <xref:System.Array.Exists%2A> and <xref:System.Array.TrueForAll%2A> generic methods.</span></span>  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1083"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1083"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1084">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1084">-or-</span></span>  
  
 <span data-ttu-id="3d295-1085"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1085"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1086">Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da última ocorrência em um <see cref="T:System.Array" /> ou parte dele.</span><span class="sxs-lookup"><span data-stu-id="3d295-1086">Searches for an element that matches the conditions defined by a specified predicate, and returns the zero-based index of the last occurrence within an <see cref="T:System.Array" /> or a portion of it.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1087">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1087">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1088">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1088">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1089">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1089">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1090">Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência em toda a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1090">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1091">O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1091">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1092">O <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1092">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1093">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1093">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1094">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1094">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-1095">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1095">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1096">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-1096">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-1097">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1097">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1098">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1098">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1099">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1099">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1100">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1100">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1101">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1101">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1102">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1102">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1103">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1103">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="3d295-1104">Localiza o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1104">It finds the element at position 1.</span></span> <span data-ttu-id="3d295-1105">Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="3d295-1105">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="3d295-1106">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1106">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1107"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1107"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1108">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1108">-or-</span></span>  
  
 <span data-ttu-id="3d295-1109"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1109"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1110">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1110">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1111">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1111">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1112">O índice inicial com base em zero da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1112">The zero-based starting index of the backward search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1113">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1113">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1114">Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do primeiro elemento ao índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1114">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1115">O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1115">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1116">O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1116">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1117">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1117">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1118">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1118">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-1119">Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1119">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1120">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-1120">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-1121">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1121">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1122">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1122">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1123">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1123">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1124">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1124">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1125">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1125">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1126">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1126">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1127">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1127">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="3d295-1128">Localiza o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1128">It finds the element at position 1.</span></span> <span data-ttu-id="3d295-1129">Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="3d295-1129">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="3d295-1130">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1130">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1131"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1132">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1132">-or-</span></span>  
  
 <span data-ttu-id="3d295-1133"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1133"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1134"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1134"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1135">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1135">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1136">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1136">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1137">O índice inicial com base em zero da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1137">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1138">O número de elementos na seção a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1138">The number of elements in the section to search.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-1139">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1139">The <see cref="T:System.Predicate`1" /> that defines the conditions of the element to search for.</span></span></param>
        <summary><span data-ttu-id="3d295-1140">Pesquisa por um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> que contém o número de elementos especificado e termina no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1140">Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1141">O índice baseado em zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1141">The zero-based index of the last occurrence of an element that matches the conditions defined by <paramref name="match" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1142">O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1142">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="3d295-1143">O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1143">The <xref:System.Predicate%601> is a delegate to a method that returns `true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-1144">Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1144">The elements of `array` are individually passed to the <xref:System.Predicate%601>.</span></span>  
  
 <span data-ttu-id="3d295-1145">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1145">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1146">O exemplo de código a seguir demonstra todos os três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-1146">The following code example demonstrates all three overloads of the <xref:System.Array.FindLastIndex%2A> generic method.</span></span> <span data-ttu-id="3d295-1147">Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1147">An array of strings is created, containing 8 dinosaur names, two of which (at positions 1 and 5) end with "saurus".</span></span> <span data-ttu-id="3d295-1148">O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1148">The code example also defines a search predicate method named `EndsWithSaurus`, which accepts a string parameter and returns a Boolean value indicating whether the input string ends in "saurus".</span></span>  
  
 <span data-ttu-id="3d295-1149">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método atravessa a matriz com versões anteriores do final, passando a cada elemento sucessivamente para o `EndsWithSaurus` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1149">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> method overload traverses the array backward from the end, passing each element in turn to the `EndsWithSaurus` method.</span></span> <span data-ttu-id="3d295-1150">A pesquisa é interrompida quando o `EndsWithSaurus` método retorna `true` para o elemento na posição 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1150">The search stops when the `EndsWithSaurus` method returns `true` for the element at position 5.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1151">No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1151">In C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-1152">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1152">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 <span data-ttu-id="3d295-1153">O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continuar para trás até o início da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1153">The <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the array beginning at position 4 and continuing backward to the beginning of the array.</span></span> <span data-ttu-id="3d295-1154">Localiza o elemento na posição 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1154">It finds the element at position 1.</span></span> <span data-ttu-id="3d295-1155">Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e funcionando (ou seja, 2, 3 e 4).</span><span class="sxs-lookup"><span data-stu-id="3d295-1155">Finally, the <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> method overload is used to search the range of three elements beginning at position 4 and working backward (that is, elements 4, 3, and 2).</span></span> <span data-ttu-id="3d295-1156">Ele retorna 1 – porque não há nenhum nome de dinossauro no intervalo que termina com "saurus".</span><span class="sxs-lookup"><span data-stu-id="3d295-1156">It returns –1 because there are no dinosaur names in that range that end with "saurus".</span></span>  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1157"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1157"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1158">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1158">-or-</span></span>  
  
 <span data-ttu-id="3d295-1159"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1159"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1160"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1160"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1161">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1161">-or-</span></span>  
  
 <span data-ttu-id="3d295-1162"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1162"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1163">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1163">-or-</span></span>  
  
 <span data-ttu-id="3d295-1164"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1164"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1165">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1165">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1166">O <see cref="T:System.Array" /> unidimensional baseado em zero em cujos elementos a ação deve ser executada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1166">The one-dimensional, zero-based <see cref="T:System.Array" /> on whose elements the action is to be performed.</span></span></param>
        <param name="action"><span data-ttu-id="3d295-1167">O <see cref="T:System.Action`1" /> a ser executado em cada elemento da <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1167">The <see cref="T:System.Action`1" /> to perform on each element of <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-1168">Executa a ação especificada em cada elemento da matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1168">Performs the specified action on each element of the specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1169">O <xref:System.Action%601> um delegado para um método que executa uma ação no objeto passado para ele.</span><span class="sxs-lookup"><span data-stu-id="3d295-1169">The <xref:System.Action%601> is a delegate to a method that performs an action on the object passed to it.</span></span>  <span data-ttu-id="3d295-1170">Os elementos de `array` são passados individualmente para o <xref:System.Action%601>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1170">The elements of `array` are individually passed to the <xref:System.Action%601>.</span></span>  
  
 <span data-ttu-id="3d295-1171">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1171">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1172">O exemplo a seguir mostra como usar <xref:System.Array.ForEach%2A> para exibir os quadrados de cada elemento em uma matriz de inteiros.</span><span class="sxs-lookup"><span data-stu-id="3d295-1172">The following example shows how to use <xref:System.Array.ForEach%2A> to display the squares of each element in an integer array.</span></span>  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1173"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1173"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-1174">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1174">-or-</span></span>  
  
 <span data-ttu-id="3d295-1175"><paramref name="action" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1175"><paramref name="action" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3d295-1176">Retorna um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1176">Returns an <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1177">Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1177">An <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1178">[Visual Basic, C#]</span><span class="sxs-lookup"><span data-stu-id="3d295-1178">[Visual Basic, C#]</span></span>  
  
 <span data-ttu-id="3d295-1179">A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores.</span><span class="sxs-lookup"><span data-stu-id="3d295-1179">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of the enumerators.</span></span> <span data-ttu-id="3d295-1180">Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.</span><span class="sxs-lookup"><span data-stu-id="3d295-1180">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="3d295-1181">Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.</span><span class="sxs-lookup"><span data-stu-id="3d295-1181">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="3d295-1182">Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-1182">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="3d295-1183"><xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.</span><span class="sxs-lookup"><span data-stu-id="3d295-1183"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="3d295-1184">Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1184">At this position, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="3d295-1185">Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1185">Therefore, you must call <xref:System.Collections.IEnumerator.MoveNext%2A> to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="3d295-1186"><xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1186"><xref:System.Collections.IEnumerator.Current%2A> returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="3d295-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1187"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="3d295-1188">Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1188">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="3d295-1189">Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1189">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="3d295-1190">Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1190">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="3d295-1191">Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1191">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="3d295-1192">Um enumerador permanece válido desde que a coleção continue inalterada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1192">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="3d295-1193">Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1193">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="3d295-1194">O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de segurança do thread.</span><span class="sxs-lookup"><span data-stu-id="3d295-1194">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread safe procedure.</span></span>  <span data-ttu-id="3d295-1195">Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.</span><span class="sxs-lookup"><span data-stu-id="3d295-1195">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="3d295-1196">Para permitir que a coleção a ser acessado por vários threads para leitura e gravação, você deve implementar sua sincronização.</span><span class="sxs-lookup"><span data-stu-id="3d295-1196">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="3d295-1197">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1197">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1198">O exemplo de código a seguir mostra como usar <xref:System.Array.GetEnumerator%2A> para listar os elementos de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1198">The following code example shows how to use <xref:System.Array.GetEnumerator%2A> to list the elements of an array.</span></span>  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="3d295-1199">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1199">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="3d295-1200">Obtém um inteiro de 32 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1200">Gets a 32-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1201">Um inteiro de 32 bits que representa o número de elementos na dimensão especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1201">A 32-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1202">Um exemplo de <xref:System.Array.GetLength%2A> é `GetLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1202">An example of <xref:System.Array.GetLength%2A> is `GetLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1203">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1203">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1204">O exemplo a seguir mostra como usar <xref:System.Array.GetLength%2A> para exibir as dimensões de duas matrizes com diferentes classificações.</span><span class="sxs-lookup"><span data-stu-id="3d295-1204">The following example shows how to use <xref:System.Array.GetLength%2A> to display the dimensions of two arrays with different ranks.</span></span>  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1205"><paramref name="dimension" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1205"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1206">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1206">-or-</span></span>  
  
 <span data-ttu-id="3d295-1207"><paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1207"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="3d295-1208">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1208">A zero-based dimension of the <see cref="T:System.Array" /> whose length needs to be determined.</span></span></param>
        <summary><span data-ttu-id="3d295-1209">Obtém um inteiro de 64 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1209">Gets a 64-bit integer that represents the number of elements in the specified dimension of the <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1210">Um inteiro de 64 bits que representa o número de elementos na dimensão especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1210">A 64-bit integer that represents the number of elements in the specified dimension.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1211">Um exemplo de <xref:System.Array.GetLongLength%2A> é `GetLongLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1211">An example of <xref:System.Array.GetLongLength%2A> is `GetLongLength(0)`, which returns the number of elements in the first dimension of the <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1212">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1212">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1213"><paramref name="dimension" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1213"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1214">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1214">-or-</span></span>  
  
 <span data-ttu-id="3d295-1215"><paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1215"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="3d295-1216">Uma dimensão com base em zero da matriz cujo índice inicial precisa ser determinado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1216">A zero-based dimension of the array whose starting index needs to be determined.</span></span></param>
        <summary><span data-ttu-id="3d295-1217">Obtém o índice do primeiro elemento da dimensão especificada na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1217">Gets the index of the first element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1218">O índice do primeiro elemento da dimensão especificada na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1218">The index of the first element of the specified dimension in the array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1219">`GetLowerBound(0)` Retorna o índice inicial da primeira dimensão da matriz, e `GetLowerBound(Rank - 1)` retorna o índice inicial da última dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1219">`GetLowerBound(0)` returns the starting index of the first dimension of the array, and `GetLowerBound(Rank - 1)` returns the starting index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="3d295-1220">O <xref:System.Array.GetLowerBound%2A> método sempre retorna um valor que indica o índice do que o limite inferior da matriz, mesmo se a matriz está vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1220">The <xref:System.Array.GetLowerBound%2A> method always returns a value that indicates the index of the lower bound of the array, even if the array is empty.</span></span>  
  
 <span data-ttu-id="3d295-1221">Observe que, embora a maioria das matrizes no .NET Framework são baseadas em zero (isto é, o <xref:System.Array.GetLowerBound%2A> método retorna zero para cada dimensão de uma matriz), o .NET Framework oferece suporte a matrizes que não são baseadas em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1221">Note that, although most arrays in the .NET Framework are zero-based (that is, the <xref:System.Array.GetLowerBound%2A> method returns zero for each dimension of an array), the .NET Framework does support arrays that are not zero-based.</span></span> <span data-ttu-id="3d295-1222">Essas matrizes podem ser criados com o <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> método e também podem ser retornados do código não gerenciado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1222">Such arrays can be created with the <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> method, and can also be returned from unmanaged code.</span></span>  
  
 <span data-ttu-id="3d295-1223">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1223">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1224">O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1224">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1225"><paramref name="dimension" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1225"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1226">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1226">-or-</span></span>  
  
 <span data-ttu-id="3d295-1227"><paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1227"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension"><span data-ttu-id="3d295-1228">Uma dimensão com base em zero da matriz cujo limite superior precisa ser determinado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1228">A zero-based dimension of the array whose upper bound needs to be determined.</span></span></param>
        <summary><span data-ttu-id="3d295-1229">Obtém o índice do último elemento da dimensão especificada na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1229">Gets the index of the last element of the specified dimension in the array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1230">O índice do último elemento da dimensão especificada na matriz, ou -1, se a dimensão especificada estiver vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1230">The index of the last element of the specified dimension in the array, or -1 if the specified dimension is empty.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1231">`GetUpperBound(0)` Retorna o último índice na primeira dimensão da matriz, e `GetUpperBound(Rank - 1)` retorna o último índice da última dimensão da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1231">`GetUpperBound(0)` returns the last index in the first dimension of the array, and `GetUpperBound(Rank - 1)` returns the last index of the last dimension of the array.</span></span>  
  
 <span data-ttu-id="3d295-1232">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1232">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1233">O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1233">The following example uses the <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods to display the bounds of a one-dimensional and two-dimensional array and to display the values of their array elements.</span></span>  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1234"><paramref name="dimension" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1234"><paramref name="dimension" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1235">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1235">-or-</span></span>  
  
 <span data-ttu-id="3d295-1236"><paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1236"><paramref name="dimension" /> is equal to or greater than <see cref="P:System.Array.Rank" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1237">Obtém o valor do elemento especificado no <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1237">Gets the value of the specified element in the current <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d295-1238">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1238">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1239">Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1239">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1240">O índice é especificado como um inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1240">The index is specified as a 32-bit integer.</span></span></summary>
        <returns><span data-ttu-id="3d295-1241">O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1241">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1242">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1242">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1243">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1243">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1244">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1244">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1245">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-1245">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1246"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1246"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="3d295-1247">Uma matriz unidimensional de inteiros de 32 bits que representa os índices especificando a posição do elemento <see cref="T:System.Array" /> a se obter.</span><span class="sxs-lookup"><span data-stu-id="3d295-1247">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1248">Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1248">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1249">Os índices são especificados como uma matriz de inteiros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1249">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1250">O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1250">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1251">O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1251">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="3d295-1252">Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1252">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1253">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1253">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1254">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1254">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1255">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1255">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1256"><paramref name="indices" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1256"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1257">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1257">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="3d295-1258">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1258">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d295-1259">Um inteiro de 64 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1259">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1260">Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1260">Gets the value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1261">O índice é especificado como um inteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1261">The index is specified as a 64-bit integer.</span></span></summary>
        <returns><span data-ttu-id="3d295-1262">O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1262">The value at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1263">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1263">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1264">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1264">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1265">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1265">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1266">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-1266">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1267"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1267"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices"><span data-ttu-id="3d295-1268">Uma matriz unidimensional de inteiros de 64 bits que representa os índices especificando a posição do elemento <see cref="T:System.Array" /> a se obter.</span><span class="sxs-lookup"><span data-stu-id="3d295-1268">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1269">Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1269">Gets the value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1270">Os índices são especificados como uma matriz de inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1270">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1271">O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1271">The value at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1272">O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1272">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="3d295-1273">Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1273">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1274">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1274">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1275">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1275">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1276">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1276">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1277"><paramref name="indices" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1277"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1278">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1278">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-1279">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1279">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="3d295-1280">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1280">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1281">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1281">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1282">Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1282">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1283">Os índices são especificados como inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1283">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1284">O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1284">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1285">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1285">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1286">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1286">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1287">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1287">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1288">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1288">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="3d295-1289">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1289">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="3d295-1290">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1290">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1291">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1291">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1292">Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1292">Gets the value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1293">Os índices são especificados como inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1293">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1294">O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1294">The value at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1295">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1295">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1296">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1296">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1297">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1297">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1298">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1298">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-1299">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1299">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="3d295-1300">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1300">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1301">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1301">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="3d295-1302">Um inteiro de 32 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1302">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1303">Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1303">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1304">Os índices são especificados como inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1304">The indexes are specified as 32-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1305">O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1305">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1306">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1306">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1307">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1307">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1308">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1308">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1309">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1309">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1310"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1310"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1"><span data-ttu-id="3d295-1311">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1311">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1312">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1312">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <param name="index3"><span data-ttu-id="3d295-1313">Um inteiro de 64 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1313">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to get.</span></span></param>
        <summary><span data-ttu-id="3d295-1314">Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1314">Gets the value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1315">Os índices são especificados como inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1315">The indexes are specified as 64-bit integers.</span></span></summary>
        <returns><span data-ttu-id="3d295-1316">O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1316">The value at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1317">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1317">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1318">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1318">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1319">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1319">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1320">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1320">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1321"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1321"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1322">Pesquisa o objeto especificado e retorna o índice da sua primeira ocorrência em uma matriz unidimensional ou em um intervalo de elementos na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1322">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array or in a range of elements in the array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1323">A matriz unidimensional a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1323">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1324">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1324">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-1325">Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1325">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1326">O índice da primeira ocorrência de <paramref name="value" /> no <paramref name="array" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1326">The index of the first occurrence of <paramref name="value" /> in <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1327">Este método pesquisa todos os elementos de um arrayfor unidimensional `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1327">This method searches all the elements of a one-dimensional arrayfor `value`.</span></span> <span data-ttu-id="3d295-1328">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade chamando cada elemento `Equals` método até encontrar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1328">To determine whether `value` exists in `array`, the method performs an equality comparison by calling each element's `Equals` method until it finds a match.</span></span> <span data-ttu-id="3d295-1329">Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1329">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1330">Como a maioria das matrizes têm um limite inferior de zero, este método geralmente retorna -1 se`value` não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1330">Because most arrays have a lower bound of zero, this method generally returns –1 if`value` isn’t found.</span></span> <span data-ttu-id="3d295-1331">No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="3d295-1331">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="3d295-1332">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1332">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1333">O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="3d295-1333">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="3d295-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1334"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1335"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1336"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1337"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1337"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1338"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1338"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1339">A matriz unidimensional a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1339">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1340">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1340">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1341">O índice inicial da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1341">The starting index of the search.</span></span> <span data-ttu-id="3d295-1342">0 (zero) é válido em uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1342">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="3d295-1343">Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1343">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d295-1344">O intervalo se estende de um índice especificado ao final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1344">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1345">O índice da primeira ocorrência de <paramref name="value" />, se encontrado, no intervalo de elementos em <paramref name="array" /> que se estende de <paramref name="startIndex" /> até o último elemento; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1345">The index of the first occurrence of <paramref name="value" />, if it’s found, within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1346">Este método pesquisa uma matriz unidimensional a partir do elemento no índice `startIndex` para o último elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1346">This method searches a one-dimensional array from the element at index `startIndex` to the last element.</span></span> <span data-ttu-id="3d295-1347">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `Equals` método de cada elemento até encontrar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1347">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="3d295-1348">Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1348">This means that if the element overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1349">Como a maioria das matrizes têm um limite inferior de zero, este método geralmente retorna -1 se `value` não for encontrado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1349">Because most arrays have a lower bound of zero, this method generally returns –1 if `value` isn’t found.</span></span> <span data-ttu-id="3d295-1350">No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="3d295-1350">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="3d295-1351">Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1351">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>,the method returns -1.</span></span> <span data-ttu-id="3d295-1352">Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1352">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="3d295-1353">Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1353">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1354">O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="3d295-1354">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="3d295-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1355"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1356"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1357"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1358"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1358"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1359"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1359"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1360"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1360"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1361">A matriz unidimensional a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1361">The one-dimensional array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1362">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1362">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1363">O índice inicial da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1363">The starting index of the search.</span></span> <span data-ttu-id="3d295-1364">0 (zero) é válido em uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1364">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1365">O número de elementos a serem pesquisados.</span><span class="sxs-lookup"><span data-stu-id="3d295-1365">The number of elements to search.</span></span></param>
        <summary><span data-ttu-id="3d295-1366">Pesquisa pelo objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1366">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of ifs first occurrence.</span></span> <span data-ttu-id="3d295-1367">O intervalo estende-se de um índice especificado a um número especificado de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1367">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="3d295-1368">O índice da primeira ocorrência de <paramref name="value" />, se for encontrado no <paramref name="array" /> do índice de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> -1; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1368">The index of the first occurrence of <paramref name="value" />, if it’s found in the <paramref name="array" /> from index <paramref name="startIndex" /> to <paramref name="startIndex" /> + <paramref name="count" /> - 1; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1369">Este método pesquisa os elementos de um unidimensional arrayfrom `startIndex` para `startIndex` mais `count` menos 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1369">This method searches the elements of a one-dimensional arrayfrom `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="3d295-1370">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `Equals` método de cada elemento até encontrar uma correspondência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1370">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `Equals` method of every element until it finds a match.</span></span> <span data-ttu-id="3d295-1371">Isso significa que, se o elemento substitui o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1371">This means that if the element overrides the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1372">Matrizes de Becausemost têm um limite inferior de zero, geralmente, esse método retorna-1 quando `value` não foi encontrada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1372">Becausemost arrays have a lower bound of zero, this method generally returns –1 when `value` isn’t found.</span></span> <span data-ttu-id="3d295-1373">No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) e `value` não for encontrado, este método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span><span class="sxs-lookup"><span data-stu-id="3d295-1373">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) and `value` isn’t found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).</span></span>  
  
 <span data-ttu-id="3d295-1374">Se `startindex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1374">If `startindex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span> <span data-ttu-id="3d295-1375">Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1375">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="3d295-1376">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1376">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1377">O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:</span><span class="sxs-lookup"><span data-stu-id="3d295-1377">The example calls the following three overloads of the <xref:System.Array.IndexOf%2A> method to find the index of a string in a string array:</span></span>  
  
-   <span data-ttu-id="3d295-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1378"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, to determine the first occurrence of the string "the" in a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1379"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in the fourth to the last elements of a string array.</span></span>  
  
-   <span data-ttu-id="3d295-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres de matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1380"><xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, to determine the first occurrence of the string "the" in a string array from the element that follows the last successful match to the end of the array.</span></span> <span data-ttu-id="3d295-1381">Para determinar o valor da `count` argumento, ele subtrai o limite superior da matriz do índice inicial e adiciona um.</span><span class="sxs-lookup"><span data-stu-id="3d295-1381">To determine the value of the `count` argument, it subtracts the upper bound of the array from the starting index and adds one.</span></span>  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1382"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1382"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1383"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1383"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1384">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1384">-or-</span></span>  
  
 <span data-ttu-id="3d295-1385"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1385"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1386">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1386">-or-</span></span>  
  
 <span data-ttu-id="3d295-1387"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1387"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1388"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1388"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1389">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1389">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1390">A matriz unidimensional, baseada em zero, a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1390">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1391">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1391">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-1392">Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1392">Searches for the specified object and returns the index of its first occurrence in a one-dimensional array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1393">O índice baseado em zero da primeira ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1393">The zero-based index of the first occurrence of <paramref name="value" /> in the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1394">Este método pesquisa todos os elementos de uma matriz unidimensional para `value`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1394">This method searches all the elements of a one-dimensional array for `value`.</span></span> <span data-ttu-id="3d295-1395">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1395">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="3d295-1396">Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1396">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1397">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1397">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1398">O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1398">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1399">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1399">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1400">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1400">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1401">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1401">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1402">Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1402">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1403"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1403"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1404">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1404">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1405">A matriz unidimensional, baseada em zero, a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1405">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1406">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1406">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1407">O índice inicial com base em zero da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1407">The zero-based starting index of the search.</span></span> <span data-ttu-id="3d295-1408">0 (zero) é válido em uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1408">0 (zero) is valid in an empty array.</span></span></param>
        <summary><span data-ttu-id="3d295-1409">Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1409">Searches for the specified object in a range of elements of a one dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d295-1410">O intervalo se estende de um índice especificado ao final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1410">The range extends from a specified index to the end of the array.</span></span></summary>
        <returns><span data-ttu-id="3d295-1411">O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos em <paramref name="array" /> que se estende de <paramref name="startIndex" /> ao último elemento, se encontrado; caso contrário, –1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1411">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from <paramref name="startIndex" /> to the last element, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1412">Este método pesquisa uma matriz unidimensional a partir do elemento em `startIndex` até o final da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1412">This method searches a one-dimensional array from the element at `startIndex` to the end of the array.</span></span> <span data-ttu-id="3d295-1413">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1413">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="3d295-1414">Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1414">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1415">Se `startIndex` é igual a <xref:System.Array.Length%2A>, o método retornará - 1.If `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1415">If `startIndex` equals <xref:System.Array.Length%2A>,the method returns -1.If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="3d295-1416">Esse método é um O (`n`) operação, onde `n` é o número de elementos do `startIndex` ao final da `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1416">This method is an O(`n`) operation, where `n` is the number of elements from `startIndex` to the end of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1417">O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1417">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1418">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1418">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1419">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1419">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1420">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1420">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1421">Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1421">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1422"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1422"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1423"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1423"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1424">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1424">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1425">A matriz unidimensional, baseada em zero, a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1425">The one-dimensional, zero-based array to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1426">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1426">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1427">O índice inicial com base em zero da pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1427">The zero-based starting index of the search.</span></span> <span data-ttu-id="3d295-1428">0 (zero) é válido em uma matriz vazia.</span><span class="sxs-lookup"><span data-stu-id="3d295-1428">0 (zero) is valid in an empty array.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1429">O número de elementos na seção a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1429">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="3d295-1430">Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1430">Searches for the specified object in a range of elements of a one-dimensional array, and returns the index of its first occurrence.</span></span> <span data-ttu-id="3d295-1431">O intervalo estende-se de um índice especificado a um número especificado de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1431">The range extends from a specified index for a specified number of elements.</span></span></summary>
        <returns><span data-ttu-id="3d295-1432">O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que começa em <paramref name="startIndex" /> e que contém o número de elementos especificados no <paramref name="count" />, se encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1432">The zero-based index of the first occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that starts at <paramref name="startIndex" /> and contains the number of elements specified in <paramref name="count" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1433">Elementos de searchesthe esse método de uma matriz unidimensional de `startIndex` para `startIndex` mais `count` menos 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1433">This method searchesthe elements of a one-dimensional array from `startIndex` to `startIndex` plus `count` minus 1, if `count` is greater than 0.</span></span> <span data-ttu-id="3d295-1434">Para determinar se `value` existe em `array`, o método executa uma comparação de igualdade ao chamar o `T.Equals` método em cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1434">To determine whether `value` exists in `array`, the method performs an equality comparison by calling the `T.Equals` method on every element.</span></span> <span data-ttu-id="3d295-1435">Isso significa que se `T` substitui o <xref:System.Object.Equals%2A> método, essa substituição é chamada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1435">This means that if `T` overrides the <xref:System.Object.Equals%2A> method, that override is called.</span></span>  
  
 <span data-ttu-id="3d295-1436">Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1436">If `startIndex` equals <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method returns -1.</span></span>  <span data-ttu-id="3d295-1437">Se `startIndex` é maior do que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método gera uma <xref:System.ArgumentOutOfRangeException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1437">If `startIndex` is greater than <xref:System.Array.Length%2A?displayProperty=nameWithType>, the method throws an <xref:System.ArgumentOutOfRangeException>.</span></span>  
  
 <span data-ttu-id="3d295-1438">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1438">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1439">O exemplo a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1439">The following example demonstrates all three generic overloads of the <xref:System.Array.IndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1440">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1440">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1441">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1441">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the array from the beginning, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1442">O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início da matriz com o local de índice 3 e continua até o fim da matriz e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1442">The <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array beginning with index location 3 and continuing to the end of the array, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1443">Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retorna -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1443">Finally, the <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of two entries, beginning at index location two; it returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1444"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1444"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1445"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1445"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1446">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1446">-or-</span></span>  
  
 <span data-ttu-id="3d295-1447"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1447"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1448">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1448">-or-</span></span>  
  
 <span data-ttu-id="3d295-1449"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1449"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3d295-1450">Inicializa todos os elementos do tipo de valor <see cref="T:System.Array" /> chamando o construtor padrão do tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="3d295-1450">Initializes every element of the value-type <see cref="T:System.Array" /> by calling the default constructor of the value type.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1451">Este método é projetado para ajudar a compiladores oferece suporte a matrizes de tipo de valor; a maioria dos usuários não é necessário para este método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1451">This method is designed to help compilers support value-type arrays; most users do not need this method.</span></span> <span data-ttu-id="3d295-1452">Ele não deve ser usado em matrizes de tipo de referência.</span><span class="sxs-lookup"><span data-stu-id="3d295-1452">It must not be used on reference-type arrays.</span></span>  
  
 <span data-ttu-id="3d295-1453">Se o <xref:System.Array> não é um tipo de valor <xref:System.Array> ou se o tipo de valor não tem um construtor padrão, o <xref:System.Array> não é modificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1453">If the <xref:System.Array> is not a value-type <xref:System.Array> or if the value type does not have a default constructor, the <xref:System.Array> is not modified.</span></span>  
  
 <span data-ttu-id="3d295-1454">O tipo de valor <xref:System.Array> pode ter qualquer limite inferior e qualquer número de dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1454">The value-type <xref:System.Array> can have any lower bound and any number of dimensions.</span></span>  
  
 <span data-ttu-id="3d295-1455">Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1455">This method is an O(`n`) operation, where `n` is <xref:System.Array.Length%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3d295-1456">Você pode usar esse método somente nos tipos de valor que tem construtores; No entanto, os tipos de valor são nativos em c# não tem construtores.</span><span class="sxs-lookup"><span data-stu-id="3d295-1456">You can use this method only on value types that have constructors; however, value types that are native to C# do not have constructors.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1457">Obtém um valor que indica se o <see cref="T:System.Array" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1457">Gets a value indicating whether the <see cref="T:System.Array" /> has a fixed size.</span></span></summary>
        <value><span data-ttu-id="3d295-1458">Esta propriedade é sempre <see langword="true" /> para todas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-1458">This property is always <see langword="true" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1459"><xref:System.Array> implementa o <xref:System.Array.IsFixedSize%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-1459"><xref:System.Array> implements the <xref:System.Array.IsFixedSize%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="3d295-1460">Uma matriz com um tamanho fixo não permite a adição ou remoção de elementos depois que a matriz é criada, mas permite a modificação de elementos existentes.</span><span class="sxs-lookup"><span data-stu-id="3d295-1460">An array with a fixed size does not allow the addition or removal of elements after the array is created, but it allows the modification of existing elements.</span></span>  
  
 <span data-ttu-id="3d295-1461">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1461">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1462">Obtém um valor que indica se o <see cref="T:System.Array" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-1462">Gets a value indicating whether the <see cref="T:System.Array" /> is read-only.</span></span></summary>
        <value><span data-ttu-id="3d295-1463">Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-1463">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1464"><xref:System.Array> implementa o <xref:System.Array.IsReadOnly%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-1464"><xref:System.Array> implements the <xref:System.Array.IsReadOnly%2A> property because it is required by the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span> <span data-ttu-id="3d295-1465">Uma matriz que é somente leitura não permite a adição, remoção ou modificação de elementos depois que a matriz é criada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1465">An array that is read-only does not allow the addition, removal, or modification of elements after the array is created.</span></span>  
  
 <span data-ttu-id="3d295-1466">Se você precisar de uma coleção somente leitura, use um <xref:System.Collections> classe que implementa o <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-1466">If you require a read-only collection, use a <xref:System.Collections> class that implements the <xref:System.Collections.IList?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="3d295-1467">Se você converter ou converter uma matriz para um <xref:System.Collections.IList> objeto de interface, o <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propriedade retorna `false`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1467">If you cast or convert an array to an <xref:System.Collections.IList> interface object, the <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> property returns `false`.</span></span> <span data-ttu-id="3d295-1468">No entanto, se você converter ou converter uma matriz para um <xref:System.Collections.Generic.IList%601> interface, o `IsReadOnly` propriedade retorna `true`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1468">However, if you cast or convert an array to a <xref:System.Collections.Generic.IList%601> interface, the `IsReadOnly` property returns `true`.</span></span>  
  
 <span data-ttu-id="3d295-1469">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1469">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1470">Obtém um valor que indica se o acesso à <see cref="T:System.Array" /> é sincronizado (thread-safe).</span><span class="sxs-lookup"><span data-stu-id="3d295-1470">Gets a value indicating whether access to the <see cref="T:System.Array" /> is synchronized (thread safe).</span></span></summary>
        <value><span data-ttu-id="3d295-1471">Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-1471">This property is always <see langword="false" /> for all arrays.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1472"><xref:System.Array> implementa o <xref:System.Array.IsSynchronized%2A> propriedade porque ele é necessário para o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-1472"><xref:System.Array> implements the <xref:System.Array.IsSynchronized%2A> property because it is required by the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="3d295-1473">Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada de coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-1473">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="3d295-1474">Classes que usam matrizes também podem implementar seus próprios sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-1474">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="3d295-1475">O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-1475">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="3d295-1476">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1476">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="3d295-1477">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificar a coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-1477">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="3d295-1478">Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.</span><span class="sxs-lookup"><span data-stu-id="3d295-1478">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="3d295-1479">Enumerar através de uma coleção intrinsecamente não é um procedimento de segurança do thread.</span><span class="sxs-lookup"><span data-stu-id="3d295-1479">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="3d295-1480">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-1480">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="3d295-1481">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="3d295-1481">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="3d295-1482">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1482">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1483">O exemplo de código a seguir mostra como uma matriz de bloqueio durante toda a enumeração usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-1483">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1484">Retorna o índice da última ocorrência de um valor em um <see cref="T:System.Array" /> unidimensional ou em uma parte do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1484">Returns the index of the last occurrence of a value in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1485">O <see cref="T:System.Array" /> unidimensional a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1485">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1486">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1486">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-1487">Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1487">Searches for the specified object and returns the index of the last occurrence within the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1488">O índice da última ocorrência de <paramref name="value" /> na <paramref name="array" /> inteira, se encontrado; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1488">The index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1489">O unidimensional <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1489">The one-dimensional <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1490">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1490">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1491">Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1491">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1492">Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1492">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="3d295-1493">No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1493">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="3d295-1494">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1494">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="3d295-1495">No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe.</span><span class="sxs-lookup"><span data-stu-id="3d295-1495">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="3d295-1496">Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1496">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
 <span data-ttu-id="3d295-1497"><xref:System.IComparable.CompareTo%2A> métodos do `item` parâmetro nos objetos na coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-1497"><xref:System.IComparable.CompareTo%2A> methods of the `item` parameter on the objects in the collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1498">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1498">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1499"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1499"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1500"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1500"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1501">O <see cref="T:System.Array" /> unidimensional a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1501">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1502">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1502">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1503">O índice inicial da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1503">The starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="3d295-1504">Procura o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> unidimensional que se estende do primeiro elemento ao índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1504">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1505">O índice da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que se estende do primeiro elemento a <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1505">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1506">O unidimensional <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1506">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1507">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1507">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1508">Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1508">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1509">Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1509">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="3d295-1510">No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1510">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="3d295-1511">Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1511">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
 <span data-ttu-id="3d295-1512">No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe.</span><span class="sxs-lookup"><span data-stu-id="3d295-1512">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="3d295-1513">Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1513">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1514">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1514">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1515"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1515"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1516"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1516"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1517"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1517"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1518">O <see cref="T:System.Array" /> unidimensional a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1518">The one-dimensional <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1519">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1519">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1520">O índice inicial da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1520">The starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1521">O número de elementos na seção a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1521">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="3d295-1522">Pesquisa o objeto especificado e retorna o índice da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> unidimensional que contém o número de elementos especificado e termina no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1522">Searches for the specified object and returns the index of the last occurrence within the range of elements in the one-dimensional <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1523">O índice da última ocorrência de <paramref name="value" /> no intervalo de elementos em <paramref name="array" /> que contém o número de elementos especificado em <paramref name="count" /> e termina em <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1523">The index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, the lower bound of the array minus 1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1524">O unidimensional <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1524">The one-dimensional <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="3d295-1525">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1525">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1526">Se o tipo de elemento é um tipo não intrínsecas (definido pelo usuário), o`Equals` implementação desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1526">If the element type is a nonintrinsic (user-defined) type, the`Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1527">Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria –1 quando `value` não fosse encontrado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1527">Since most arrays will have a lower bound of zero, this method would generally return –1 when `value` is not found.</span></span> <span data-ttu-id="3d295-1528">No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1528">In the rare case that the lower bound of the array is equal to <xref:System.Int32.MinValue?displayProperty=nameWithType> and `value` is not found, this method returns <xref:System.Int32.MaxValue?displayProperty=nameWithType>, which is `System.Int32.MinValue - 1`.</span></span>  
  
 <span data-ttu-id="3d295-1529">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1529">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 <span data-ttu-id="3d295-1530">No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe.</span><span class="sxs-lookup"><span data-stu-id="3d295-1530">In the .NET Framework version 2.0, this method uses the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the <xref:System.Array> to determine whether the <xref:System.Object> specified by the `value` parameter exists.</span></span> <span data-ttu-id="3d295-1531">Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1531">In the earlier versions of the .NET Framework, this determination was made by using the <xref:System.Object.Equals%2A> and <xref:System.IComparable.CompareTo%2A> methods of the `value`<xref:System.Object> itself.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1532">O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1532">The following code example shows how to determine the index of the last occurrence of a specified element in an array.</span></span> <span data-ttu-id="3d295-1533">Observe que o <xref:System.Array.LastIndexOf%2A> método é uma pesquisa para trás; portanto, `count` deve ser menor ou igual a (`startIndex` menos o limite inferior da matriz de mais de 1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1533">Note that the <xref:System.Array.LastIndexOf%2A> method is a backward search; therefore, `count` must be less than or equal to (`startIndex` minus the lower bound of the array plus 1).</span></span>  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1534"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1534"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1535"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1535"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1536">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1536">-or-</span></span>  
  
 <span data-ttu-id="3d295-1537"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1537"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1538">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1538">-or-</span></span>  
  
 <span data-ttu-id="3d295-1539"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1539"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1540"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1540"><paramref name="array" /> is multidimensional.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1541">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1541">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1542">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1542">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1543">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1543">The object to locate in <c>array</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-1544">Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1544">Searches for the specified object and returns the index of the last occurrence within the entire <see cref="T:System.Array" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-1545">O índice de base zero da última ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se localizado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1545">The zero-based index of the last occurrence of <paramref name="value" /> within the entire <paramref name="array" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1546">O <xref:System.Array> é pesquisado para trás, começando no último elemento e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1546">The <xref:System.Array> is searched backward starting at the last element and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1547">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1547">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1548">Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1548">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1549">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1549">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1550">O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1550">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1551">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1551">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1552">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1552">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1553">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1553">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1554">Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1554">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1555"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1555"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1556">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1556">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1557">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1557">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1558">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1558">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1559">O índice inicial com base em zero da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1559">The zero-based starting index of the backward search.</span></span></param>
        <summary><span data-ttu-id="3d295-1560">Procura o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos em <see cref="T:System.Array" /> que se estende do primeiro elemento ao índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1560">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that extends from the first element to the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1561">O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos em <paramref name="array" /> que se estende do primeiro elemento a <paramref name="startIndex" />, se encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1561">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that extends from the first element to <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1562">O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1562">The <xref:System.Array> is searched backward starting at `startIndex` and ending at the first element.</span></span>  
  
 <span data-ttu-id="3d295-1563">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1563">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1564">Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1564">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1565">Esse método é um O (`n`) operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1565">This method is an O(`n`) operation, where `n` is the number of elements from the beginning of `array` to `startIndex`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1566">O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1566">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1567">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1567">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1568">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1568">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1569">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1569">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1570">Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1570">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1571"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1571"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1572"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1572"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1573">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1573">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1574">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1574">The one-dimensional, zero-based <see cref="T:System.Array" /> to search.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-1575">O objeto a ser localizado na <c>matriz</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1575">The object to locate in <c>array</c>.</span></span></param>
        <param name="startIndex"><span data-ttu-id="3d295-1576">O índice inicial com base em zero da pesquisa inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-1576">The zero-based starting index of the backward search.</span></span></param>
        <param name="count"><span data-ttu-id="3d295-1577">O número de elementos na seção a ser pesquisada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1577">The number of elements in the section to search.</span></span></param>
        <summary><span data-ttu-id="3d295-1578">Pesquisa o objeto especificado e retorna o índice da última ocorrência no intervalo de elementos na <see cref="T:System.Array" /> que contém o número de elementos especificado e termina no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1578">Searches for the specified object and returns the index of the last occurrence within the range of elements in the <see cref="T:System.Array" /> that contains the specified number of elements and ends at the specified index.</span></span></summary>
        <returns><span data-ttu-id="3d295-1579">O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que contém o número de elementos especificado em <paramref name="count" /> e termina no <paramref name="startIndex" />, se encontrado; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1579">The zero-based index of the last occurrence of <paramref name="value" /> within the range of elements in <paramref name="array" /> that contains the number of elements specified in <paramref name="count" /> and ends at <paramref name="startIndex" />, if found; otherwise, –1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1580">O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e final em `startIndex` menos `count` mais 1, se `count` for maior que 0.</span><span class="sxs-lookup"><span data-stu-id="3d295-1580">The <xref:System.Array> is searched backward starting at `startIndex` and ending at `startIndex` minus `count` plus 1, if `count` is greater than 0.</span></span>  
  
 <span data-ttu-id="3d295-1581">Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1581">The elements are compared to the specified value using the <xref:System.Object.Equals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="3d295-1582">Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1582">If the element type is a nonintrinsic (user-defined) type, the `Equals` implementation of that type is used.</span></span>  
  
 <span data-ttu-id="3d295-1583">Este método é uma operação O(`n`), em que `n` é `count`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1583">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1584">O exemplo de código a seguir demonstra todos os três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-1584">The following code example demonstrates all three generic overloads of the <xref:System.Array.LastIndexOf%2A> method.</span></span> <span data-ttu-id="3d295-1585">Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5.</span><span class="sxs-lookup"><span data-stu-id="3d295-1585">An array of strings is created, with one entry that appears twice, at index location 0 and index location 5.</span></span> <span data-ttu-id="3d295-1586">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método de pesquisa a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1586">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> method overload searches the entire array from the end, and finds the second occurrence of the string.</span></span> <span data-ttu-id="3d295-1587">O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar o início de matriz com versões anteriores com o local de índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-1587">The <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> method overload is used to search the array backward beginning with index location 3 and continuing to the beginning of the array, and finds the first occurrence of the string.</span></span> <span data-ttu-id="3d295-1588">Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estendendo para trás (ou seja, ele procura os itens nos locais 4, 3, 2 e 1); a pesquisa retorna -1 porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1588">Finally, the <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> method overload is used to search a range of four entries, beginning at index location 4 and extending backward (that is, it searches the items at locations 4, 3, 2, and 1); this search returns –1 because there are no instances of the search string in that range.</span></span>  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1589"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1589"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1590"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1590"><paramref name="startIndex" /> is outside the range of valid indexes for <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1591">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1591">-or-</span></span>  
  
 <span data-ttu-id="3d295-1592"><paramref name="count" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1592"><paramref name="count" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-1593">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1593">-or-</span></span>  
  
 <span data-ttu-id="3d295-1594"><paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1594"><paramref name="startIndex" /> and <paramref name="count" /> do not specify a valid section in <paramref name="array" />.</span></span></exception>
        <altmember cref="Overload:System.Array.IndexOf" />
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1595">Obtém o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1595">Gets the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="3d295-1596">O número total de elementos em todas as dimensões do <see cref="T:System.Array" />; zero se não houver elementos na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1596">The total number of elements in all the dimensions of the <see cref="T:System.Array" />; zero if there are no elements in the array.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1597">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1597">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1598">O exemplo a seguir usa o <xref:System.Array.Length%2A> propriedade para obter o número total de elementos em uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1598">The following example uses the                                 <xref:System.Array.Length%2A> property to get the total number of elements in an array.</span></span> <span data-ttu-id="3d295-1599">Ele também usa o <xref:System.Array.GetUpperBound%2A> método para determinar o número de elementos em cada dimensão de uma matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1599">It also uses the                                 <xref:System.Array.GetUpperBound%2A> method to determine the number of elements in each dimension of a multidimensional array.</span></span>  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="3d295-1600">A matriz é multidimensional e contém mais de <see cref="F:System.Int32.MaxValue" /> elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1600">The array is multidimensional and contains more than <see cref="F:System.Int32.MaxValue" /> elements.</span></span></exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1601">Obtém um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1601">Gets a 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="3d295-1602">Um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1602">A 64-bit integer that represents the total number of elements in all the dimensions of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1603">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1603">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-1604">Obtém a classificação (número de dimensões) do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1604">Gets the rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1605">Por exemplo, uma matriz unidimensional retorna 1, uma matriz bidimensional retorna 2 e assim por diante.</span><span class="sxs-lookup"><span data-stu-id="3d295-1605">For example, a one-dimensional array returns 1, a two-dimensional array returns 2, and so on.</span></span></summary>
        <value><span data-ttu-id="3d295-1606">A classificação (número de dimensões) do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1606">The rank (number of dimensions) of the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1607">Por exemplo, o código do Visual Basic</span><span class="sxs-lookup"><span data-stu-id="3d295-1607">For example, the Visual Basic code</span></span>  
  
```  
Dim TDArray(0,0,0) As Integer  
```  
  
 <span data-ttu-id="3d295-1608">e o código c#</span><span class="sxs-lookup"><span data-stu-id="3d295-1608">and the C# code</span></span>  
  
```  
int[,,] TDArray = new int[1,1,1];  
```  
  
 <span data-ttu-id="3d295-1609">Crie uma matriz de três dimensões com um <xref:System.Array.Rank%2A> propriedade cujo valor é 3.</span><span class="sxs-lookup"><span data-stu-id="3d295-1609">create an array of three dimensions with a <xref:System.Array.Rank%2A> property whose value is 3.</span></span>  
  
 <span data-ttu-id="3d295-1610">Uma matriz denteada (uma matriz de matrizes) é uma matriz unidimensional; o valor de seu <xref:System.Array.Rank%2A> propriedade é 1.</span><span class="sxs-lookup"><span data-stu-id="3d295-1610">A jagged array (an array of arrays) is a one-dimensional array; the value of its <xref:System.Array.Rank%2A> property is 1.</span></span>  
  
 <span data-ttu-id="3d295-1611">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1611">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1612">O exemplo a seguir inicializa uma matriz unidimensional, uma matriz bidimensional e uma matriz denteada e recupera o <xref:System.Array.Rank%2A> propriedade de cada um.</span><span class="sxs-lookup"><span data-stu-id="3d295-1612">The following example initializes a one-dimensional array, a two-dimensional array, and a jagged array, and retrieves the <xref:System.Array.Rank%2A> property of each.</span></span>  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]&amp;" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-1613">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1613">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-1614">A matriz unidimensional baseada em zero a ser redimensionada, ou <see langword="null" /> para criar uma nova matriz com o tamanho especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1614">The one-dimensional, zero-based array to resize, or <see langword="null" /> to create a new array with the specified size.</span></span></param>
        <param name="newSize"><span data-ttu-id="3d295-1615">O tamanho da nova matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1615">The size of the new array.</span></span></param>
        <summary><span data-ttu-id="3d295-1616">Altera o número de elementos de uma matriz unidimensional para o novo tamanho especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1616">Changes the number of elements of a one-dimensional array to the specified new size.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1617">Esse método aloca uma nova matriz com o tamanho especificado, copia os elementos da matriz antiga para o novo e, em seguida, substitui o array antigo pelo novo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1617">This method allocates a new array with the specified size, copies elements from the old array to the new one, and then replaces the old array with the new one.</span></span> <span data-ttu-id="3d295-1618">`array` deve ser uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1618">`array` must be a one-dimensional array.</span></span>  
  
 <span data-ttu-id="3d295-1619">Se `array` é `null`, esse método cria uma nova matriz com o tamanho especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1619">If `array` is `null`, this method creates a new array with the specified size.</span></span>  
  
 <span data-ttu-id="3d295-1620">Se `newSize` é maior do que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz é alocada e todos os elementos são copiados da matriz antiga para o novo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1620">If `newSize` is greater than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and all the elements are copied from the old array to the new one.</span></span>  <span data-ttu-id="3d295-1621">Se `newSize` é menor do que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz é alocada e elementos copiados da matriz antiga para o novo até que o novo nome é preenchido; o restante dos elementos na matriz antigo são ignorados.</span><span class="sxs-lookup"><span data-stu-id="3d295-1621">If `newSize` is less than the <xref:System.Array.Length%2A> of the old array, a new array is allocated and elements are copied from the old array to the new one until the new one is filled; the rest of the elements in the old array are ignored.</span></span>  <span data-ttu-id="3d295-1622">Se `newSize` é igual de <xref:System.Array.Length%2A> da matriz antiga, esse método não fará nada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1622">If `newSize` is equal to the <xref:System.Array.Length%2A> of the old array, this method does nothing.</span></span>  
  
 <span data-ttu-id="3d295-1623">Este método é uma operação O(`n`), em que `n` é `newSize`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1623">This method is an O(`n`) operation, where `n` is `newSize`.</span></span>  
  
 <span data-ttu-id="3d295-1624">O <xref:System.Array.Resize%2A> método redimensiona apenas uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1624">The <xref:System.Array.Resize%2A> method resizes a one-dimensional array only.</span></span> <span data-ttu-id="3d295-1625">O <xref:System.Array> classe não tem um método de redimensionamento de matrizes multidimensionais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1625">The <xref:System.Array> class does not include a method for resizing multi-dimensional arrays.</span></span> <span data-ttu-id="3d295-1626">Para fazer isso, você deve fornecer seu próprio código ou chamar um método especial em uma biblioteca de terceiros.</span><span class="sxs-lookup"><span data-stu-id="3d295-1626">To do this, you must either provide your own code or call a special-purpose method in a third-party library.</span></span> <span data-ttu-id="3d295-1627">O código a seguir ilustra uma possível implementação de um método que redimensiona uma matriz de *n* dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1627">The following code illustrates one possible implementation for a method that resizes an array of *n* dimensions.</span></span>  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1628">O exemplo a seguir mostra como redimensionar afeta a matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-1628">The following example shows how resizing affects the array.</span></span>  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1629"><paramref name="newSize" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1629"><paramref name="newSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1630">Inverte a ordem dos elementos em um <see cref="T:System.Array" /> unidimensional ou em uma parte do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1630">Reverses the order of the elements in a one-dimensional <see cref="T:System.Array" /> or in a portion of the <see cref="T:System.Array" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1631">O <see cref="T:System.Array" /> unidimensional a ser invertido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1631">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <summary><span data-ttu-id="3d295-1632">Inverte a sequência dos elementos em todo o <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1632">Reverses the sequence of the elements in the entire one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1633">Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` qualquer índice na matriz, move para `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1633">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="3d295-1634">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1634">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="3d295-1635">Como mostra o exemplo a seguir, o <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1635">As the following example shows, the <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span> <span data-ttu-id="3d295-1636">Inicializa uma matriz denteada com um elemento para cada mês do ano atual no calendário da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1636">It initializes a jagged array with one element for each month of the current year in the current culture's calendar.</span></span> <span data-ttu-id="3d295-1637">Cada elemento contém uma matriz com elementos desse mês tem dias.</span><span class="sxs-lookup"><span data-stu-id="3d295-1637">Each element contains an array with as many elements as that month has days.</span></span> <span data-ttu-id="3d295-1638">O exemplo exibe o conteúdo da matriz, chama o <xref:System.Array.Reverse%2A> método e, em seguida, exibe o conteúdo da matriz invertida.</span><span class="sxs-lookup"><span data-stu-id="3d295-1638">The example displays the contents of the array, calls the <xref:System.Array.Reverse%2A> method, and then displays the contents of the reversed array.</span></span>  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1639">O exemplo de código a seguir mostra como reverter a classificação dos valores em um <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1639">The following code example shows how to reverse the sort of the values in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1640"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1640"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1641"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1641"><paramref name="array" /> is multidimensional.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1642">O <see cref="T:System.Array" /> unidimensional a ser invertido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1642">The one-dimensional <see cref="T:System.Array" /> to reverse.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1643">O índice inicial da seção a ser invertido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1643">The starting index of the section to reverse.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-1644">O número de elementos na seção a ser invertida.</span><span class="sxs-lookup"><span data-stu-id="3d295-1644">The number of elements in the section to reverse.</span></span></param>
        <summary><span data-ttu-id="3d295-1645">Inverte a sequência dos elementos em toda gama de elementos no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1645">Reverses the sequence of the elements in a range of elements in the one-dimensional <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1646">Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` qualquer índice na matriz, move para `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1646">After a call to this method, the element at `myArray[i]`, where `i` is any index in the array, moves to `myArray[j]`, where `j` equals `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.</span></span>  
  
 <span data-ttu-id="3d295-1647">O <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1647">The <xref:System.Array.Reverse%2A> method can be used to reverse a jagged array.</span></span>  
  
 <span data-ttu-id="3d295-1648">Este método é uma operação O(`n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1648">This method is an O(`n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1649">O exemplo de código a seguir mostra como reverter a classificação dos valores em um intervalo de elementos em um <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1649">The following code example shows how to reverse the sort of the values in a range of elements in an <xref:System.Array>.</span></span>  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1650"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1650"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1651"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1651"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1652"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1652"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1653">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1653">-or-</span></span>  
  
 <span data-ttu-id="3d295-1654"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1654"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1655"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1655"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1656">Define o elemento especificado no <see cref="T:System.Array" /> atual para o valor especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1656">Sets the specified element in the current <see cref="T:System.Array" /> to the specified value.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1657">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1657">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1658">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1658">A 32-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1659">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1659">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1660">O índice é especificado como um inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1660">The index is specified as a 32-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1661">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1661">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1662">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1662">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1663">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1663">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1664">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1664">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1665">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1665">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1666">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1666">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1667">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-1667">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1668"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1668"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1669"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1669"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1670">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1670">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="3d295-1671">Uma matriz unidimensional de inteiros de 32 bits que representam os índices que especificam a posição do elemento a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1671">A one-dimensional array of 32-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1672">Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1672">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1673">Os índices são especificados como uma matriz de inteiros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1673">The indexes are specified as an array of 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1674">O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1674">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="3d295-1675">Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1675">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1676">O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1676">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1677">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1677">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1678">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1678">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1679">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1679">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1680">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1680">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1681">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1681">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1682"><paramref name="indices" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1682"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1683">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1683">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1684"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1684"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="3d295-1685">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1685">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1686">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1686">The new value for the specified element.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1687">Um inteiro de 64 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1687">A 64-bit integer that represents the position of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1688">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1688">Sets a value to the element at the specified position in the one-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1689">O índice é especificado como um inteiro de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1689">The index is specified as a 64-bit integer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1690">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1690">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether the value of `index` is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1691">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1691">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1692">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1692">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1693">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1693">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1694">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1694">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1695">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1695">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1696">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-1696">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1697"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1697"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1698"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1698"><paramref name="index" /> is outside the range of valid indexes for the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1699">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1699">The new value for the specified element.</span></span></param>
        <param name="indices"><span data-ttu-id="3d295-1700">Uma matriz unidimensional de inteiros de 64 bits que representam os índices que especificam a posição do elemento a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1700">A one-dimensional array of 64-bit integers that represent the indexes specifying the position of the element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1701">Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1701">Sets a value to the element at the specified position in the multidimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1702">Os índices são especificados como uma matriz de inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1702">The indexes are specified as an array of 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1703">O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1703">The number of elements in `indices` must equal the number of dimensions in the <xref:System.Array>.</span></span> <span data-ttu-id="3d295-1704">Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1704">All elements in the `indices` array must collectively specify the position of the desired element in the multidimensional <xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1705">O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1705">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the values in the `indices` array is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1706">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1706">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1707">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1707">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1708">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1708">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1709">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1709">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1710">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1710">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1711"><paramref name="indices" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1711"><paramref name="indices" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1712">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1712">The number of dimensions in the current <see cref="T:System.Array" /> is not equal to the number of elements in <paramref name="indices" />.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1713"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1713"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-1714">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1714">Any element in <paramref name="indices" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1715">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1715">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="3d295-1716">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1716">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1717">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1717">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1718">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1718">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1719">Os índices são especificados como inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1719">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1720">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1720">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1721">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1721">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1722">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1722">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1723">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1723">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1724">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1724">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1725">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1725">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1726">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1726">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1727"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1727"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="3d295-1728">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1728">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1729">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1729">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="3d295-1730">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1730">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1731">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1731">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1732">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1732">Sets a value to the element at the specified position in the two-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1733">Os índices são especificados como inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1733">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1734">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1734">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1735">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1735">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1736">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1736">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1737">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1737">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1738">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1738">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1739">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1739">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1740">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1740">The current <see cref="T:System.Array" /> does not have exactly two dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1741"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1741"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-1742">
          <paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1742">Either <paramref name="index1" /> or <paramref name="index2" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1743">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1743">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="3d295-1744">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1744">A 32-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1745">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1745">A 32-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="3d295-1746">Um inteiro de 32 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1746">A 32-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1747">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1747">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1748">Os índices são especificados como inteiro de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1748">The indexes are specified as 32-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1749">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1749">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1750">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1750">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1751">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1751">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1752">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1752">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1753">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1753">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1754">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1754">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1755">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1755">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1756"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1756"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="3d295-1757"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1757"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-1758">O novo valor do elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1758">The new value for the specified element.</span></span></param>
        <param name="index1"><span data-ttu-id="3d295-1759">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1759">A 64-bit integer that represents the first-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index2"><span data-ttu-id="3d295-1760">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1760">A 64-bit integer that represents the second-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <param name="index3"><span data-ttu-id="3d295-1761">Um inteiro de 64 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1761">A 64-bit integer that represents the third-dimension index of the <see cref="T:System.Array" /> element to set.</span></span></param>
        <summary><span data-ttu-id="3d295-1762">Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> tridimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1762">Sets a value to the element at the specified position in the three-dimensional <see cref="T:System.Array" />.</span></span> <span data-ttu-id="3d295-1763">Os índices são especificados como inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="3d295-1763">The indexes are specified as 64-bit integers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1764">Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.</span><span class="sxs-lookup"><span data-stu-id="3d295-1764">The <xref:System.Array.GetLowerBound%2A> and <xref:System.Array.GetUpperBound%2A> methods can determine whether any of the indexes is out of bounds.</span></span>  
  
 <span data-ttu-id="3d295-1765">Para obter mais informações sobre conversões, consulte <xref:System.Convert>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1765">For more information about conversions, see <xref:System.Convert>.</span></span>  
  
 <span data-ttu-id="3d295-1766">Este método é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-1766">This method is an O(1) operation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-1767">Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1767">If <xref:System.Array.SetValue%2A> is used to assign `null` to an element of an array of value types, all fields of the element are initialized to zero.</span></span> <span data-ttu-id="3d295-1768">O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-1768">The value of the element is not a null reference, and cannot be found by searching for a null reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1769">O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1769">The following code example demonstrates how to set and get a specific value in a one-dimensional or multidimensional array.</span></span>  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1770">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</span><span class="sxs-lookup"><span data-stu-id="3d295-1770">The current <see cref="T:System.Array" /> does not have exactly three dimensions.</span></span></exception>
        <exception cref="T:System.InvalidCastException">
          <span data-ttu-id="3d295-1771"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1771"><paramref name="value" /> cannot be cast to the element type of the current <see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1772"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1772"><paramref name="index1" /> or <paramref name="index2" /> or <paramref name="index3" /> is outside the range of valid indexes for the corresponding dimension of the current <see cref="T:System.Array" />.</span></span></exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3d295-1773">Classifica os elementos em uma matriz unidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1773">Sorts the elements in a one-dimensional array.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1774">O <see cref="T:System.Array" /> unidimensional a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1774">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-1775">Classifica os elementos em todo um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1775">Sorts the elements in an entire one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1776">Cada elemento de `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1776">Each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-1777">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1777">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1778">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1778">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1779">Se o tamanho da partição é menos do que 16 elementos, ele usa um[classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1779">If the partition size is fewer than 16 elements, it uses an[insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1780">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1780">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1781">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1781">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1782">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1782">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1783">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1783">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1784">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1784">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1785">O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1785">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1786">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1786">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1787"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1787"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1788"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1788"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-1789">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1789">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="3d295-1790">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1790">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-1791">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves em <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1791">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-1792">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1792">-or-</span></span>  
  
 <span data-ttu-id="3d295-1793"><see langword="null" /> para classificar apenas as <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1793"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <summary><span data-ttu-id="3d295-1794">Classifica um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</span><span class="sxs-lookup"><span data-stu-id="3d295-1794">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1795">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1795">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-1796">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-1796">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-1797">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1797">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1798">Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-1798">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-1799">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-1799">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-1800">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1800">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-1801">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1801">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1802">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1802">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1803">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1803">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1804">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1804">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1805">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1805">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1806">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1806">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1807">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1807">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1808">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1808">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1809">O exemplo a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-1809">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="3d295-1810">As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1810">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1811">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1811">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1812"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1812"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-1813">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1813">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-1814">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1814">-or-</span></span>  
  
 <span data-ttu-id="3d295-1815">O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1815">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1816"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1816"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-1817">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1817">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1818">A matriz unidimensional a ser classificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1818">The one-dimensional array to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-1819">A implementação a ser usada ao comparar elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1819">The implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-1820">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1820">-or-</span></span>  
  
 <span data-ttu-id="3d295-1821"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1821"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-1822">Classifica os elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1822">Sorts the elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1823">Se `comparer` é `null`, cada elemento do `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1823">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-1824">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1824">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1825">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1825">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1826">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1826">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1827">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1827">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1828">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1828">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1829">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1829">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1830">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1830">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1831">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1831">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
 <span data-ttu-id="3d295-1832">O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-1832">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="3d295-1833">Implementação</span><span class="sxs-lookup"><span data-stu-id="3d295-1833">Implementation</span></span>|<span data-ttu-id="3d295-1834">Descrição</span><span class="sxs-lookup"><span data-stu-id="3d295-1834">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="3d295-1835">Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1835">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="3d295-1836">Compara dois objetos usando as convenções de classificação da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1836">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="3d295-1837">Compara dois objetos usando as convenções de classificação da cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="3d295-1837">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="3d295-1838">Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1838">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="3d295-1839">Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="3d295-1839">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="3d295-1840">O exemplo faz isso definindo uma `ReverseComparer` classe inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1840">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1841">O exemplo a seguir classifica os valores em um arrayby de cadeia de caracteres usando o comparador padrão.</span><span class="sxs-lookup"><span data-stu-id="3d295-1841">The following example sorts the values in a string arrayby using the default comparer.</span></span> <span data-ttu-id="3d295-1842">Ele também define um personalizado <xref:System.Collections.IComparer> implementação denominada `ReverseComparer` que inverte a ordem de classificação padrão de um objeto ao executar uma comparação de cadeia de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1842">It also defines a custom <xref:System.Collections.IComparer> implementation named `ReverseComparer` that reverses an object's default sort order while performing a case-insensitive string comparison.</span></span> <span data-ttu-id="3d295-1843">Observe que a saída pode variar dependendo da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1843">Note that the output might vary depending on the current culture.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1844"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1844"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1845"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1845"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-1846"><paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1846"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-1847">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1847">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-1848">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-1848">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-1849">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-1849">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-1850">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-1850">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-1851">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-1851">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-1852">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1852">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="3d295-1853">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1853">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-1854">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves em <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1854">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-1855">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1855">-or-</span></span>  
  
 <span data-ttu-id="3d295-1856"><see langword="null" /> para classificar apenas as <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1856"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-1857">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1857">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-1858">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1858">-or-</span></span>  
  
 <span data-ttu-id="3d295-1859"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1859"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-1860">Classifica um par objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1860">Sorts a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1861">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1861">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-1862">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-1862">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-1863">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1863">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1864">Se `comparer` é `null`, cada chave no `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-1864">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-1865">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-1865">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-1866">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1866">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-1867">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1867">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1868">O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-1868">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="3d295-1869">Implementação</span><span class="sxs-lookup"><span data-stu-id="3d295-1869">Implementation</span></span>|<span data-ttu-id="3d295-1870">Descrição</span><span class="sxs-lookup"><span data-stu-id="3d295-1870">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="3d295-1871">Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1871">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="3d295-1872">Compara dois objetos usando as convenções de classificação da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1872">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="3d295-1873">Compara dois objetos usando as convenções de classificação da cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="3d295-1873">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="3d295-1874">Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1874">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="3d295-1875">Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="3d295-1875">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="3d295-1876">O exemplo faz isso definindo uma <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1876">The example does this by defining an <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="3d295-1877">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1877">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1878">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1878">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1879">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1879">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1880">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1880">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1881">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1881">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1882">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1882">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1883">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1883">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `keys`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1884">O exemplo a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-1884">The following example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="3d295-1885">As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1885">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1886">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1886">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1887"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1887"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-1888">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1888">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-1889">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1889">-or-</span></span>  
  
 <span data-ttu-id="3d295-1890">O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1890">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1891"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1891"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-1892">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1892">-or-</span></span>  
  
 <span data-ttu-id="3d295-1893">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1893">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-1894">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-1894">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-1895"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1895"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-1896">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-1896">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-1897">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-1897">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-1898">Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que previouslythrew <see cref="T:System.ArgumentException" /> não gerará uma exceção, porque os algoritmos de classificação e heapsort de inserção não detectam um comparador inválido.</span><span class="sxs-lookup"><span data-stu-id="3d295-1898">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previouslythrew <see cref="T:System.ArgumentException" /> will not throw an exception, becausethe insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-1899">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1899">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1900">O <see cref="T:System.Array" /> unidimensional a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1900">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1901">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1901">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-1902">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1902">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-1903">Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1903">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1904">Cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1904">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-1905">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1905">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1906">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1906">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1907">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1907">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1908">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1908">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1909">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1909">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1910">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1910">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1911">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1911">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1912">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1912">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1913">O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1913">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1914">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1914">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1915"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1915"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1916"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1916"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1917"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1917"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1918">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1918">-or-</span></span>  
  
 <span data-ttu-id="3d295-1919"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1919"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1920"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1920"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-1921">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1921">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="3d295-1922">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1922">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-1923">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves em <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1923">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-1924">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1924">-or-</span></span>  
  
 <span data-ttu-id="3d295-1925"><see langword="null" /> para classificar apenas as <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1925"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1926">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1926">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-1927">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1927">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-1928">Classifica um intervalo de elementos em um par de objetos <see cref="T:System.Array" /> unidirecionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</span><span class="sxs-lookup"><span data-stu-id="3d295-1928">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable" /> implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1929">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1929">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-1930">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-1930">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-1931">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1931">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-1932">Cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-1932">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-1933">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-1933">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-1934">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-1934">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-1935">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1935">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1936">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1936">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1937">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1937">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1938">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1938">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1939">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1939">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1940">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1940">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1941">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1941">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1942">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1942">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1943">O exemplo de código a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-1943">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="3d295-1944">As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1944">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1945">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1945">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1946"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1946"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-1947">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1947">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-1948">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1948">-or-</span></span>  
  
 <span data-ttu-id="3d295-1949">O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1949">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1950"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1950"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="3d295-1951">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1951">-or-</span></span>  
  
 <span data-ttu-id="3d295-1952"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1952"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1953"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1953"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-1954">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1954">-or-</span></span>  
  
 <span data-ttu-id="3d295-1955"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1955"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-1956">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1956">-or-</span></span>  
  
 <span data-ttu-id="3d295-1957"><paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1957"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-1958">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1958">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="3d295-1959">O <see cref="T:System.Array" /> unidimensional a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1959">The one-dimensional <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-1960">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1960">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-1961">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1961">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-1962">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1962">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-1963">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1963">-or-</span></span>  
  
 <span data-ttu-id="3d295-1964"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-1964"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-1965">Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-1965">Sorts the elements in a range of elements in a one-dimensional <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-1966">Se `comparer` é `null`, cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable> devem ser capazes de comparações com todos os outros elementos da interface de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1966">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable> interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-1967">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1967">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-1968">O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-1968">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="3d295-1969">Implementação</span><span class="sxs-lookup"><span data-stu-id="3d295-1969">Implementation</span></span>|<span data-ttu-id="3d295-1970">Descrição</span><span class="sxs-lookup"><span data-stu-id="3d295-1970">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="3d295-1971">Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1971">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="3d295-1972">Compara dois objetos usando as convenções de classificação da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1972">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="3d295-1973">Compara dois objetos usando as convenções de classificação da cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="3d295-1973">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="3d295-1974">Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1974">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="3d295-1975">Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="3d295-1975">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="3d295-1976">O exemplo faz isso definindo uma `ReverseComparer` classe inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-1976">The example does this by defining a `ReverseComparer` class that reverses the default sort order for instances of a type and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="3d295-1977">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-1977">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-1978">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1978">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1979">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1979">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-1980">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-1980">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-1981">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-1981">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-1982">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-1982">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-1983">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-1983">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-1984">O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1984">The following code example shows how to sort the values in an <xref:System.Array> using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-1985">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-1985">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-1986"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1986"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException">
          <span data-ttu-id="3d295-1987"><paramref name="array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-1987"><paramref name="array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-1988"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1988"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1989">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1989">-or-</span></span>  
  
 <span data-ttu-id="3d295-1990"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-1990"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-1991"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1991"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-1992">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-1992">-or-</span></span>  
  
 <span data-ttu-id="3d295-1993">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-1993">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-1994">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-1994">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-1995"><paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-1995"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-1996">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-1996">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-1997">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-1997">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-1998">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-1998">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-1999">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-1999">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys"><span data-ttu-id="3d295-2000">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2000">The one-dimensional <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-2001">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves em <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2001">The one-dimensional <see cref="T:System.Array" /> that contains the items that correspond to each of the keys in the <c>keys</c><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2002">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2002">-or-</span></span>  
  
 <span data-ttu-id="3d295-2003"><see langword="null" /> para classificar apenas as <c>chaves</c><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2003"><see langword="null" /> to sort only the <c>keys</c><see cref="T:System.Array" />.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-2004">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2004">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-2005">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2005">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2006">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2006">The <see cref="T:System.Collections.IComparer" /> implementation to use when comparing elements.</span></span>  
  
 <span data-ttu-id="3d295-2007">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2007">-or-</span></span>  
  
 <span data-ttu-id="3d295-2008"><see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2008"><see langword="null" /> to use the <see cref="T:System.IComparable" /> implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-2009">Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2009">Sorts a range of elements in a pair of one-dimensional <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.IComparer" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2010">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2010">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-2011">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-2011">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-2012">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2012">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-2013">Se `comparer` é `null`, cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-2013">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable> interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-2014">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-2014">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-2015">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2015">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-2016">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2016">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2017">O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-2017">The .NET Framework includes predefined <xref:System.Collections.IComparer> implementations listed in the following table.</span></span>  
  
|<span data-ttu-id="3d295-2018">Implementação</span><span class="sxs-lookup"><span data-stu-id="3d295-2018">Implementation</span></span>|<span data-ttu-id="3d295-2019">Descrição</span><span class="sxs-lookup"><span data-stu-id="3d295-2019">Description</span></span>|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|<span data-ttu-id="3d295-2020">Compara dois objetos, mas executa uma comparação de cadeias de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2020">Compares any two objects, but performs a case-insensitive comparison of strings.</span></span>|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|<span data-ttu-id="3d295-2021">Compara dois objetos usando as convenções de classificação da cultura atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2021">Compares any two objects by using the sorting conventions of the current culture.</span></span>|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|<span data-ttu-id="3d295-2022">Compara dois objetos usando as convenções de classificação da cultura invariável.</span><span class="sxs-lookup"><span data-stu-id="3d295-2022">Compares any two objects by using the sorting conventions of the invariant culture.</span></span>|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|<span data-ttu-id="3d295-2023">Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2023">Compares two objects of type `T` by using the type's default sort order.</span></span>|  
  
 <span data-ttu-id="3d295-2024">Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="3d295-2024">You can also support custom comparisons by providing an instance of your own <xref:System.Collections.IComparer> implementation to the `comparer` parameter.</span></span> <span data-ttu-id="3d295-2025">O exemplo faz isso definindo um personalizado <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres de maiusculas e minúsculas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2025">The example does this by defining a custom <xref:System.Collections.IComparer> implementation that reverses the default sort order and performs case-insensitive string comparison.</span></span>  
  
 <span data-ttu-id="3d295-2026">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2026">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2027">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2027">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2028">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2028">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2029">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2029">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2030">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2030">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2031">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2031">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2032">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2032">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2033">O exemplo de código a seguir mostra como classificar duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-2033">The following code example shows how to sort two associated arrays where the first array contains the keys and the second array contains the values.</span></span> <span data-ttu-id="3d295-2034">As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2034">Sorts are done using the default comparer and a custom comparer that reverses the sort order.</span></span> <span data-ttu-id="3d295-2035">Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2035">Note that the result might vary depending on the current <xref:System.Globalization.CultureInfo>.</span></span>  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2036"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2036"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.RankException"><span data-ttu-id="3d295-2037">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-2037">The <paramref name="keys" /><see cref="T:System.Array" /> is multidimensional.</span></span>  
  
 <span data-ttu-id="3d295-2038">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2038">-or-</span></span>  
  
 <span data-ttu-id="3d295-2039">O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</span><span class="sxs-lookup"><span data-stu-id="3d295-2039">The <paramref name="items" /><see cref="T:System.Array" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2040"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2040"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="3d295-2041">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2041">-or-</span></span>  
  
 <span data-ttu-id="3d295-2042"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2042"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2043"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2043"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2044">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2044">-or-</span></span>  
  
 <span data-ttu-id="3d295-2045"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2045"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2046">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2046">-or-</span></span>  
  
 <span data-ttu-id="3d295-2047"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2047"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2048">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2048">-or-</span></span>  
  
 <span data-ttu-id="3d295-2049"><paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2049"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2050">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2050">-or-</span></span>  
  
 <span data-ttu-id="3d295-2051">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2051">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2052">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2052">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-2053"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2053"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable" /> interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2054">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2054">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2055">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2055">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2056">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2056">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2057">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2057">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2058">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2058">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2059">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2059">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-2060">Classifica os elementos em todo um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2060">Sorts the elements in an entire <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2061">Cada elemento de `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2061">Each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-2062">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2062">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2063">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2063">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2064">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2064">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2065">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2065">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2066">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2066">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2067">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2067">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2068">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2068">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2069">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2069">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2070">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-2070">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload.</span></span> <span data-ttu-id="3d295-2071">Uma matriz de cadeias de caracteres é criada, em nenhuma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="3d295-2071">An array of strings is created, in no particular order.</span></span>  
  
 <span data-ttu-id="3d295-2072">A matriz é exibida, classificada e exibida novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2072">The array is displayed, sorted, and displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2073">As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2073">The calls to the <xref:System.Array.Sort%2A> and <xref:System.Array.BinarySearch%2A> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-2074">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2074">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="3d295-2075">O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é.</span><span class="sxs-lookup"><span data-stu-id="3d295-2075">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="3d295-2076">A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2076">The array and the return value of the <xref:System.Array.BinarySearch%2A> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="3d295-2077">O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2077">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2078"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2078"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-2079">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2079">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2080">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2080">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2081">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</span><span class="sxs-lookup"><span data-stu-id="3d295-2081">The one-dimensional, zero-base <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2082">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2082">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-2083">Classifica os elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2083">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2084">Se `comparer` é `null`, cada elemento do `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2084">If `comparer` is `null`, each element of `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-2085">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2085">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2086">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2086">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2087">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2087">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2088">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2088">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2089">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2089">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2090">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2090">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2091">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2091">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2092">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2092">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2093">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico.</span><span class="sxs-lookup"><span data-stu-id="3d295-2093">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload and the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload.</span></span>  
  
 <span data-ttu-id="3d295-2094">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2094">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2095">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2095">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2096">A matriz é exibida, classificada e exibida novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2096">The array is displayed, sorted, and displayed again.</span></span> <span data-ttu-id="3d295-2097">Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3d295-2097">Arrays must be sorted in order to use the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2098">As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2098">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-2099">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2099">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 <span data-ttu-id="3d295-2100">O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada para procurar por duas cadeias de caracteres, um que não esteja na matriz e um que é.</span><span class="sxs-lookup"><span data-stu-id="3d295-2100">The <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is then used to search for two strings, one that is not in the array and one that is.</span></span> <span data-ttu-id="3d295-2101">A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice se encontra-se a cadeia de caracteres e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2101">The array and the return value of the <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> method are passed to the `ShowWhere` generic method, which displays the index value if the string is found, and otherwise the elements the search string would fall between if it were in the array.</span></span> <span data-ttu-id="3d295-2102">O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2102">The index is negative if the string is not n the array, so the `ShowWhere` method takes the bitwise complement (the ~ operator in C# and Visual C++, `Xor` -1 in Visual Basic) to obtain the index of the first element in the list that is larger than the search string.</span></span>  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2103"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2103"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-2104"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2104"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-2105">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2105">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2106">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2106">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2107">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2107">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2108">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2108">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2109">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2109">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2110">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2110">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2111">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2111">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2112">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</span><span class="sxs-lookup"><span data-stu-id="3d295-2112">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="comparison"><span data-ttu-id="3d295-2113">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2113">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</span></span></param>
        <summary><span data-ttu-id="3d295-2114">Classifica os elementos em um <see cref="T:System.Array" /> usando o <see cref="T:System.Comparison`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2114">Sorts the elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Comparison`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2115">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2115">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2116">Esse método usa o algoritmo de classificação introspectiva (introsort) da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="3d295-2116">This method uses introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2117">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2117">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2118">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2118">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2119">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2119">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2120">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2120">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2121">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2121">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2122">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2122">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2123">O exemplo de código a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="3d295-2123">The following code example demonstrates the <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> method overload.</span></span>  
  
 <span data-ttu-id="3d295-2124">O exemplo de código define um método alternativo de comparação para cadeias de caracteres, denominado `CompareDinosByLength`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2124">The code example defines an alternative comparison method for strings, named `CompareDinosByLength`.</span></span> <span data-ttu-id="3d295-2125">Esse método funciona da seguinte maneira: primeiro, o comparandsare testado para`null`, e uma referência nula é tratada como menor que não null.</span><span class="sxs-lookup"><span data-stu-id="3d295-2125">This method works as follows: First, the comparandsare tested for`null`, and a null reference is treated as less than a non-null.</span></span> <span data-ttu-id="3d295-2126">Segundo, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais longa é considerada maior.</span><span class="sxs-lookup"><span data-stu-id="3d295-2126">Second, the string lengths are compared, and the longer string is deemed to be greater.</span></span> <span data-ttu-id="3d295-2127">Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2127">Third, if the lengths are equal, ordinary string comparison is used.</span></span>  
  
 <span data-ttu-id="3d295-2128">Uma matriz de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, em nenhuma ordem específica.</span><span class="sxs-lookup"><span data-stu-id="3d295-2128">A array of strings is created and populated with four strings, in no particular order.</span></span> <span data-ttu-id="3d295-2129">A lista também inclui uma cadeia de caracteres vazia e uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="3d295-2129">The list also includes an empty string and a null reference.</span></span> <span data-ttu-id="3d295-2130">A lista é exibida, classificados usando um <xref:System.Comparison%601> delegado genérico que representa o `CompareDinosByLength` método e exibida novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2130">The list is displayed, sorted using a <xref:System.Comparison%601> generic delegate representing the `CompareDinosByLength` method, and displayed again.</span></span>  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2131"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2131"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-2132">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2132">-or-</span></span>  
  
 <span data-ttu-id="3d295-2133"><paramref name="comparison" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2133"><paramref name="comparison" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-2134">A implementação de <paramref name="comparison" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2134">The implementation of <paramref name="comparison" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2135">Por exemplo, <paramref name="comparison" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2135">For example, <paramref name="comparison" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2136">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2136">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2137">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2137">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2138">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2138">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2139">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2139">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2140">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2140">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2141">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</span><span class="sxs-lookup"><span data-stu-id="3d295-2141">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort</span></span></param>
        <param name="index"><span data-ttu-id="3d295-2142">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2142">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-2143">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2143">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-2144">Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2144">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each element of the <see cref="T:System.Array" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2145">Cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2145">Each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-2146">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2146">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2147">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2147">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2148">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2148">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2149">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2149">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2150">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2150">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2151">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2151">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2152">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2152">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2153">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2153">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2154">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2154">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="3d295-2155">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2155">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2156">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2156">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2157">O exemplo de código cria e exibe uma matriz de nomes de dinossauro, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso).</span><span class="sxs-lookup"><span data-stu-id="3d295-2157">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="3d295-2158">O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico é usada para classificar os três últimos elementos da matriz, que é exibido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2158">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="3d295-2159">O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada com `ReverseCompare` para classificar os três últimos elementos na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2159">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="3d295-2160">Dinossauros completamente confundidos são exibidos novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2160">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2161">As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2161">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-2162">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2162">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2163"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2163"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2164"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2164"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-2165">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2165">-or-</span></span>  
  
 <span data-ttu-id="3d295-2166"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2166"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2167"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2167"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-2168">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2168">One or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2169">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2169">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2170">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2170">The one-dimensional, zero-based <see cref="T:System.Array" /> to sort.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-2171">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2171">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-2172">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2172">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2173">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2173">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-2174">Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2174">Sorts the elements in a range of elements in an <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2175">Se `comparer` é `null`, cada elemento dentro do intervalo especificado de elementos em `array` deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2175">If `comparer` is `null`, each element within the specified range of elements in `array` must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other element in `array`.</span></span>  
  
 <span data-ttu-id="3d295-2176">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2176">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2177">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2177">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2178">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2178">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2179">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2179">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2180">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2180">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2181">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2181">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2182">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2182">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2183">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2183">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2184">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2184">The following code example demonstrates the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload and the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload for sorting a range in an array.</span></span>  
  
 <span data-ttu-id="3d295-2185">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2185">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2186">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2186">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2187">O exemplo de código cria e exibe uma matriz de nomes de dinossauro, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso).</span><span class="sxs-lookup"><span data-stu-id="3d295-2187">The code example creates and displays an array of dinosaur names, consisting of three herbivores followed by three carnivores (tyrannosaurids, to be precise).</span></span> <span data-ttu-id="3d295-2188">O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método genérico é usada para classificar os três últimos elementos da matriz, que é exibido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2188">The <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> generic method overload is used to sort the last three elements of the array, which is then displayed.</span></span> <span data-ttu-id="3d295-2189">O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga do método genérico é usada com `ReverseCompare` para classificar os três últimos elementos na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2189">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overload is used with `ReverseCompare` to sort the last three elements in reverse order.</span></span> <span data-ttu-id="3d295-2190">Dinossauros completamente confundidos são exibidos novamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2190">The thoroughly confused dinosaurs are displayed again.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2191">As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2191">The calls to the <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> and <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first argument.</span></span> <span data-ttu-id="3d295-2192">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2192">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2193"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2193"><paramref name="array" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2194"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2194"><paramref name="index" /> is less than the lower bound of <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-2195">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2195">-or-</span></span>  
  
 <span data-ttu-id="3d295-2196"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2196"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2197"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2197"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in <paramref name="array" />.</span></span>  
  
 <span data-ttu-id="3d295-2198">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2198">-or-</span></span>  
  
 <span data-ttu-id="3d295-2199">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2199">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2200">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2200">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-2201"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2201"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in <paramref name="array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2202">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2202">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2203">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2203">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2204">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2204">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2205">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2205">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="3d295-2206">O tipo dos elementos da matriz principal.</span><span class="sxs-lookup"><span data-stu-id="3d295-2206">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="3d295-2207">O tipo dos elementos da matriz de itens.</span><span class="sxs-lookup"><span data-stu-id="3d295-2207">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="3d295-2208">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2208">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-2209">O <see cref="T:System.Array" /> unidimensional baseado em zero que contém os itens correspondentes às chaves em <c>chaves</c> ou <see langword="null" /> para classificar somente as <c>chaves</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2209">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-2210">Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</span><span class="sxs-lookup"><span data-stu-id="3d295-2210">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2211">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2211">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-2212">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-2212">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-2213">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2213">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-2214">Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-2214">Each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-2215">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-2215">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-2216">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2216">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-2217">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2217">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2218">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2218">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2219">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2219">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2220">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2220">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2221">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2221">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2222">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2222">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2223">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2223">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2224">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2224">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2225">O exemplo de código a seguir demonstra as sobrecargas de método genérico <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> para pares de matrizes de classificação que representam chaves e valores.</span><span class="sxs-lookup"><span data-stu-id="3d295-2225">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="3d295-2226">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2226">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2227">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2227">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2228">O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores).</span><span class="sxs-lookup"><span data-stu-id="3d295-2228">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="3d295-2229">Em seguida, as matrizes são classificadas e exibidas várias vezes:</span><span class="sxs-lookup"><span data-stu-id="3d295-2229">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="3d295-2230">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2230">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="3d295-2231">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2231">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2232">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-2232">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2233">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2233">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2234">As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2234">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="3d295-2235">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2235">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2236"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2236"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2237"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2237"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2238">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2238">-or-</span></span>  
  
 <span data-ttu-id="3d295-2239"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2239"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-2240">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2240">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="3d295-2241">O tipo dos elementos da matriz principal.</span><span class="sxs-lookup"><span data-stu-id="3d295-2241">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="3d295-2242">O tipo dos elementos da matriz de itens.</span><span class="sxs-lookup"><span data-stu-id="3d295-2242">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="3d295-2243">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2243">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-2244">O <see cref="T:System.Array" /> unidimensional baseado em zero que contém os itens correspondentes às chaves em <c>chaves</c> ou <see langword="null" /> para classificar somente as <c>chaves</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2244">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2245">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2245">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-2246">Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2246">Sorts a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2247">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2247">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-2248">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-2248">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-2249">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2249">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-2250">Se `comparer` é `null`, cada chave no `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-2250">If `comparer` is `null`, each key in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-2251">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-2251">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-2252">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2252">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-2253">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2253">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2254">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2254">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2255">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2255">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2256">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2256">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2257">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2257">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2258">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2258">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2259">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2259">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2260">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2260">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2261">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2261">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="3d295-2262">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2262">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2263">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2263">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2264">O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores).</span><span class="sxs-lookup"><span data-stu-id="3d295-2264">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="3d295-2265">Em seguida, as matrizes são classificadas e exibidas várias vezes:</span><span class="sxs-lookup"><span data-stu-id="3d295-2265">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="3d295-2266">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2266">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="3d295-2267">O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga e uma instância de `ReverseCompare` são usados para inverter a ordem de classificação das matrizes emparelhadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2267">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2268">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-2268">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2269">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2269">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2270">As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2270">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="3d295-2271">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2271">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2272"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2272"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2273"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2273"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2274">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2274">-or-</span></span>  
  
 <span data-ttu-id="3d295-2275"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2275"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2276">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2276">-or-</span></span>  
  
 <span data-ttu-id="3d295-2277">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2277">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2278">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2278">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-2279"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2279"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2280">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2280">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2281">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2281">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2282">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2282">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2283">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2283">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="3d295-2284">O tipo dos elementos da matriz principal.</span><span class="sxs-lookup"><span data-stu-id="3d295-2284">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="3d295-2285">O tipo dos elementos da matriz de itens.</span><span class="sxs-lookup"><span data-stu-id="3d295-2285">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="3d295-2286">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2286">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-2287">O <see cref="T:System.Array" /> unidimensional baseado em zero que contém os itens correspondentes às chaves em <c>chaves</c> ou <see langword="null" /> para classificar somente as <c>chaves</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2287">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-2288">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2288">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-2289">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2289">The number of elements in the range to sort.</span></span></param>
        <summary><span data-ttu-id="3d295-2290">Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</span><span class="sxs-lookup"><span data-stu-id="3d295-2290">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the <see cref="T:System.IComparable`1" /> generic interface implementation of each key.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2291">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2291">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-2292">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-2292">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-2293">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2293">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-2294">Cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-2294">Each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-2295">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-2295">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-2296">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2296">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-2297">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2297">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2298">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2298">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2299">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2299">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2300">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2300">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2301">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2301">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2302">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2302">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2303">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2303">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2304">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2304">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2305">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico, para pares de matrizes que representam as chaves e valores de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2305">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="3d295-2306">O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++).</span><span class="sxs-lookup"><span data-stu-id="3d295-2306">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>` (`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2307">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2307">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2308">O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores).</span><span class="sxs-lookup"><span data-stu-id="3d295-2308">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="3d295-2309">Em seguida, as matrizes são classificadas e exibidas várias vezes:</span><span class="sxs-lookup"><span data-stu-id="3d295-2309">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="3d295-2310">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2310">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="3d295-2311">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2311">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2312">O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > sobrecarga é usada para classificar os três últimos elementos de matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-2312">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2313">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2313">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2314">As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2314">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="3d295-2315">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2315">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2316"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2316"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2317"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2317"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="3d295-2318">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2318">-or-</span></span>  
  
 <span data-ttu-id="3d295-2319"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2319"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2320"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2320"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2321">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2321">-or-</span></span>  
  
 <span data-ttu-id="3d295-2322"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2322"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2323">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2323">-or-</span></span>  
  
 <span data-ttu-id="3d295-2324"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2324"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2325">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2325">-or-</span></span>  
  
 <span data-ttu-id="3d295-2326"><paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2326"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3d295-2327">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2327">One or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey"><span data-ttu-id="3d295-2328">O tipo dos elementos da matriz principal.</span><span class="sxs-lookup"><span data-stu-id="3d295-2328">The type of the elements of the key array.</span></span></typeparam>
        <typeparam name="TValue"><span data-ttu-id="3d295-2329">O tipo dos elementos da matriz de itens.</span><span class="sxs-lookup"><span data-stu-id="3d295-2329">The type of the elements of the items array.</span></span></typeparam>
        <param name="keys"><span data-ttu-id="3d295-2330">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2330">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the keys to sort.</span></span></param>
        <param name="items"><span data-ttu-id="3d295-2331">O <see cref="T:System.Array" /> unidimensional baseado em zero que contém os itens correspondentes às chaves em <c>chaves</c> ou <see langword="null" /> para classificar somente as <c>chaves</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2331">The one-dimensional, zero-based <see cref="T:System.Array" /> that contains the items that correspond to the keys in <c>keys</c>, or <see langword="null" /> to sort only <c>keys</c>.</span></span></param>
        <param name="index"><span data-ttu-id="3d295-2332">O índice inicial do intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2332">The starting index of the range to sort.</span></span></param>
        <param name="length"><span data-ttu-id="3d295-2333">O número de elementos no intervalo a ser classificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2333">The number of elements in the range to sort.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2334">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2334">The <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface implementation to use when comparing elements, or <see langword="null" /> to use the <see cref="T:System.IComparable`1" /> generic interface implementation of each element.</span></span></param>
        <summary><span data-ttu-id="3d295-2335">Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2335">Sorts a range of elements in a pair of <see cref="T:System.Array" /> objects (one contains the keys and the other contains the corresponding items) based on the keys in the first <see cref="T:System.Array" /> using the specified <see cref="T:System.Collections.Generic.IComparer`1" /> generic interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2336">Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2336">Each key in the `keys`<xref:System.Array> has a corresponding item in the `items`<xref:System.Array>.</span></span> <span data-ttu-id="3d295-2337">Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma.</span><span class="sxs-lookup"><span data-stu-id="3d295-2337">When a key is repositioned during the sorting, the corresponding item in the `items`<xref:System.Array> is similarly repositioned.</span></span> <span data-ttu-id="3d295-2338">Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2338">Therefore, the `items`<xref:System.Array> is sorted according to the arrangement of the corresponding keys in the `keys`<xref:System.Array>.</span></span>  
  
 <span data-ttu-id="3d295-2339">Se `comparer` é `null`, cada chave dentro do intervalo especificado de elementos de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.</span><span class="sxs-lookup"><span data-stu-id="3d295-2339">If `comparer` is `null`, each key within the specified range of elements in the `keys`<xref:System.Array> must implement the <xref:System.IComparable%601> generic interface to be capable of comparisons with every other key.</span></span>  
  
 <span data-ttu-id="3d295-2340">É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados.</span><span class="sxs-lookup"><span data-stu-id="3d295-2340">You can sort if there are more items than keys, but the items that have no corresponding keys will not be sorted.</span></span> <span data-ttu-id="3d295-2341">Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2341">You cannot sort if there are more keys than items; doing this throws an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="3d295-2342">Caso a classificação não seja concluída com êxito, os resultados são indefinidos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2342">If the sort is not successfully completed, the results are undefined.</span></span>  
  
 <span data-ttu-id="3d295-2343">Este método usa o algoritmo introspective sort (introsort) da seguinte forma:</span><span class="sxs-lookup"><span data-stu-id="3d295-2343">This method uses the introspective sort (introsort) algorithm as follows:</span></span>  
  
-   <span data-ttu-id="3d295-2344">Se o tamanho da partição é menos do que 16 elementos, ele usa um [classificação de inserção](http://en.wikipedia.org/wiki/Insertion_sort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2344">If the partition size is fewer than 16 elements, it uses an [insertion sort](http://en.wikipedia.org/wiki/Insertion_sort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2345">Se o número de partições exceder 2 \* Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2345">If the number of partitions exceeds 2 \* Log<sup>N</sup>, where  *N* is the range of the input array, it uses a [Heapsort](http://en.wikipedia.org/wiki/Heapsort) algorithm.</span></span>  
  
-   <span data-ttu-id="3d295-2346">Caso contrário, ele usa um [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algoritmo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2346">Otherwise, it uses a [Quicksort](http://en.wikipedia.org/wiki/Quicksort) algorithm.</span></span>  
  
 <span data-ttu-id="3d295-2347">Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada.</span><span class="sxs-lookup"><span data-stu-id="3d295-2347">This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</span></span> <span data-ttu-id="3d295-2348">Por outro lado, uma classificação estável preserva a ordem de elementos iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2348">In contrast, a stable sort preserves the order of elements that are equal.</span></span>  
  
 <span data-ttu-id="3d295-2349">Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2349">For arrays that are sorted by using the Heapsort and Quicksort algorithms, in the worst case, this method is an O(`n` log `n`) operation, where `n` is `length`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2350">O exemplo de código a seguir demonstra o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7d%29 > sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2350">The following code example demonstrates the <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, and [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> generic method overloads, for sorting pairs of arrays that represent keys and values.</span></span>  
  
 <span data-ttu-id="3d295-2351">O exemplo de código define um comparador alternativo para cadeias de caracteres, denominado `ReverseCompare`, que implementa o `IComparer<string>`(`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica.</span><span class="sxs-lookup"><span data-stu-id="3d295-2351">The code example defines an alternative comparer for strings, named `ReverseCompare`, which implements the `IComparer<string>`(`IComparer(Of String)` in Visual Basic, `IComparer<String^>` in Visual C++) generic interface.</span></span> <span data-ttu-id="3d295-2352">A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.</span><span class="sxs-lookup"><span data-stu-id="3d295-2352">The comparer calls the <xref:System.String.CompareTo%28System.String%29> method, reversing the order of the comparands so that the strings sort high-to-low instead of low-to-high.</span></span>  
  
 <span data-ttu-id="3d295-2353">O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores).</span><span class="sxs-lookup"><span data-stu-id="3d295-2353">The code example creates and displays an array of dinosaur names (the keys) and an array of integers representing the maximum length of each dinosaur in meters (the values).</span></span> <span data-ttu-id="3d295-2354">Em seguida, as matrizes são classificadas e exibidas várias vezes:</span><span class="sxs-lookup"><span data-stu-id="3d295-2354">The arrays are then sorted and displayed several times:</span></span>  
  
-   <span data-ttu-id="3d295-2355">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2355">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> overload is used to sort both arrays in order of the dinosaur names in the first array.</span></span>  
  
-   <span data-ttu-id="3d295-2356">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.</span><span class="sxs-lookup"><span data-stu-id="3d295-2356">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload and an instance of `ReverseCompare` are used to reverse the sort order of the paired arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2357">A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.</span><span class="sxs-lookup"><span data-stu-id="3d295-2357">The <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> overload is used to sort the last three elements of both arrays.</span></span>  
  
-   <span data-ttu-id="3d295-2358">O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga é usada para classificar os três últimos elementos de ambos matrizes na ordem inversa.</span><span class="sxs-lookup"><span data-stu-id="3d295-2358">The [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> overload is used to sort the last three elements of both arrays in reverse order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2359">As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2359">The calls to the generic methods do not look any different from calls to their nongeneric counterparts, because Visual Basic, C#, and C++ infer the type of the generic type parameter from the type of the first two arguments.</span></span> <span data-ttu-id="3d295-2360">Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que estão sendo chamados os métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2360">If you use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine the Microsoft intermediate language (MSIL), you can see that the generic methods are being called.</span></span>  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2361"><paramref name="keys" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2361"><paramref name="keys" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2362"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2362"><paramref name="index" /> is less than the lower bound of <paramref name="keys" />.</span></span>  
  
 <span data-ttu-id="3d295-2363">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2363">-or-</span></span>  
  
 <span data-ttu-id="3d295-2364"><paramref name="length" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2364"><paramref name="length" /> is less than zero.</span></span></exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="3d295-2365"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2365"><paramref name="items" /> is not <see langword="null" />, and the lower bound of <paramref name="keys" /> does not match the lower bound of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2366">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2366">-or-</span></span>  
  
 <span data-ttu-id="3d295-2367"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2367"><paramref name="items" /> is not <see langword="null" />, and the length of <paramref name="keys" /> is greater than the length of <paramref name="items" />.</span></span>  
  
 <span data-ttu-id="3d295-2368">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2368">-or-</span></span>  
  
 <span data-ttu-id="3d295-2369"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2369"><paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="keys" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2370">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2370">-or-</span></span>  
  
 <span data-ttu-id="3d295-2371"><paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2371"><paramref name="items" /> is not <see langword="null" />, and <paramref name="index" /> and <paramref name="length" /> do not specify a valid range in the <paramref name="items" /><see cref="T:System.Array" />.</span></span>  
  
 <span data-ttu-id="3d295-2372">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2372">-or-</span></span>  
  
 <span data-ttu-id="3d295-2373">A implementação de <paramref name="comparer" /> causou um erro durante a classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2373">The implementation of <paramref name="comparer" /> caused an error during the sort.</span></span> <span data-ttu-id="3d295-2374">Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</span><span class="sxs-lookup"><span data-stu-id="3d295-2374">For example, <paramref name="comparer" /> might not return 0 when comparing an item with itself.</span></span></exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="3d295-2375"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2375"><paramref name="comparer" /> is <see langword="null" />, and one or more elements in the <paramref name="keys" /><see cref="T:System.Array" /> do not implement the <see cref="T:System.IComparable`1" /> generic interface.</span></span></exception>
        <block subset="none" type="usage">
          <para><span data-ttu-id="3d295-2376">O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort.</span><span class="sxs-lookup"><span data-stu-id="3d295-2376">The .NET Framework 4 and earlier versions used only the Quicksort algorithm.</span></span> <span data-ttu-id="3d295-2377">Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador.</span><span class="sxs-lookup"><span data-stu-id="3d295-2377">Quicksort identifies invalid comparers in some situations in which the sorting operation throws an <see cref="T:System.IndexOutOfRangeException" /> exception, and throws an <see cref="T:System.ArgumentException" /> exception to the caller.</span></span> <span data-ttu-id="3d295-2378">Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida.</span><span class="sxs-lookup"><span data-stu-id="3d295-2378">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], it is possible that sorting operations that previously threw <see cref="T:System.ArgumentException" /> will not throw an exception, because the insertion sort and heapsort algorithms do not detect an invalid comparer.</span></span> <span data-ttu-id="3d295-2379">Geralmente, isso se aplica a matrizes com menos de 16 elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2379">For the most part, this applies to arrays with fewer than 16 elements.</span></span></para>
        </block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-2380">Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2380">Gets an object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="3d295-2381">Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2381">An object that can be used to synchronize access to the <see cref="T:System.Array" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2382">Essa propriedade implementa o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span><span class="sxs-lookup"><span data-stu-id="3d295-2382">This property implements the <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.</span></span>  
  
 <span data-ttu-id="3d295-2383">Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada de coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-2383">.NET Framework classes based on <xref:System.Array> provide their own synchronized version of the collection using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 <span data-ttu-id="3d295-2384">Classes que usam matrizes também podem implementar seus próprios sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-2384">Classes that use arrays can also implement their own synchronization using the <xref:System.Array.SyncRoot%2A> property.</span></span> <span data-ttu-id="3d295-2385">O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2385">The synchronizing code must perform operations on the `SyncRoot` of the collection, not directly on the collection.</span></span> <span data-ttu-id="3d295-2386">Isso garante a operação apropriada das coleções que são derivadas de outros objetos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2386">This ensures proper operation of collections that are derived from other objects.</span></span> <span data-ttu-id="3d295-2387">Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificar a coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2387">Specifically, it maintains proper synchronization with other threads that might be simultaneously modifying the collection.</span></span> <span data-ttu-id="3d295-2388">Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.</span><span class="sxs-lookup"><span data-stu-id="3d295-2388">Note that some implementations of <xref:System.Array.SyncRoot%2A> might return the <xref:System.Array> itself.</span></span>  
  
 <span data-ttu-id="3d295-2389">Enumerar através de uma coleção intrinsecamente não é um procedimento de segurança do thread.</span><span class="sxs-lookup"><span data-stu-id="3d295-2389">Enumerating through a collection is intrinsically not a thread safe procedure.</span></span> <span data-ttu-id="3d295-2390">Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2390">Even when a collection is synchronized, other threads can still modify the collection, which causes the enumerator to throw an exception.</span></span> <span data-ttu-id="3d295-2391">Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</span><span class="sxs-lookup"><span data-stu-id="3d295-2391">To guarantee thread safety during enumeration, you can either lock the collection during the entire enumeration or catch the exceptions resulting from changes made by other threads.</span></span>  
  
 <span data-ttu-id="3d295-2392">A recuperação do valor dessa propriedade é uma operação O(1).</span><span class="sxs-lookup"><span data-stu-id="3d295-2392">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2393">O exemplo de código a seguir mostra como uma matriz de bloqueio durante toda a enumeração usando o <xref:System.Array.SyncRoot%2A> propriedade.</span><span class="sxs-lookup"><span data-stu-id="3d295-2393">The following code example shows how to lock an array during the entire enumeration by using the <xref:System.Array.SyncRoot%2A> property.</span></span>  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System.Collections.ICollection.Count { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d295-2394">Obtém o número de elementos contidos no <see cref="T:System.Array" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2394">Gets the number of elements contained in the <see cref="T:System.Array" />.</span></span></summary>
        <value><span data-ttu-id="3d295-2395">O número de elementos contidos na coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2395">The number of elements contained in the collection.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2396">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2396">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2397">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.ICollection>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2397">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.ICollection> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.ICollection.IsSynchronized { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.ICollection.SyncRoot { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-2398">O objeto a ser adicionado ao <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2398">The object to be added to the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="3d295-2399">A chamada desse método sempre gera uma exceção <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2399">Calling this method always throws a <see cref="T:System.NotSupportedException" /> exception.</span></span></summary>
        <returns><span data-ttu-id="3d295-2400">Não há suporte à adição de um valor a uma matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2400">Adding a value to an array is not supported.</span></span> <span data-ttu-id="3d295-2401">Nenhum valor é retornado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2401">No value is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2402">Em geral, um <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementação adiciona um membro a uma coleção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2402">Ordinarily, an <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementation adds a member to a collection.</span></span> <span data-ttu-id="3d295-2403">No entanto, como matrizes têm um tamanho fixo (o <xref:System.Array.IsFixedSize%2A> propriedade sempre retorna `true`), esse método sempre gerará um <xref:System.NotSupportedException> exceção.</span><span class="sxs-lookup"><span data-stu-id="3d295-2403">However, because arrays have a fixed size (the <xref:System.Array.IsFixedSize%2A> property always returns `true`), this method always throws a <xref:System.NotSupportedException> exception.</span></span>  
  
 <span data-ttu-id="3d295-2404">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2404">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2405">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2405">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3d295-2406">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2406">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3d295-2407">Remove todos os itens do <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2407">Removes all items from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2408">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2408">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2409">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2409">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3d295-2410">O <see cref="T:System.Collections.IList" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-2410">The <see cref="T:System.Collections.IList" /> is read-only.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-2411">O objeto a ser localizado na lista atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2411">The object to locate in the current list.</span></span> <span data-ttu-id="3d295-2412">O elemento a ser localizado pode ser <see langword="null" /> para tipos de referência.</span><span class="sxs-lookup"><span data-stu-id="3d295-2412">The element to locate can be <see langword="null" /> for reference types.</span></span></param>
        <summary><span data-ttu-id="3d295-2413">Determina se um elemento está no <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2413">Determines whether an element is in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns>
          <span data-ttu-id="3d295-2414"><see langword="true" /> se <paramref name="value" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2414"><see langword="true" /> if <paramref name="value" /> is found in the <see cref="T:System.Collections.IList" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2415">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2415">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2416">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2416">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-2417">O objeto a ser localizado na lista atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2417">The object to locate in the current list.</span></span></param>
        <summary><span data-ttu-id="3d295-2418">Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2418">Determines the index of a specific item in the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <returns><span data-ttu-id="3d295-2419">O índice do valor se encontrado na lista; caso contrário, -1.</span><span class="sxs-lookup"><span data-stu-id="3d295-2419">The index of value if found in the list; otherwise, -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2420">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2420">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2421">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2421">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d295-2422">O índice no qual o <c>valor</c> deve ser inserido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2422">The index at which <c>value</c> should be inserted.</span></span></param>
        <param name="value"><span data-ttu-id="3d295-2423">O objeto a ser inserido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2423">The object to insert.</span></span></param>
        <summary><span data-ttu-id="3d295-2424">Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2424">Inserts an item to the <see cref="T:System.Collections.IList" /> at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2425">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2425">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2426">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2426">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2427"><paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2427"><paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3d295-2428">O <see cref="T:System.Collections.IList" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-2428">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="3d295-2429">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2429">-or-</span></span>  
  
 <span data-ttu-id="3d295-2430">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2430">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="3d295-2431"><paramref name="value" /> é uma referência nula no <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2431"><paramref name="value" /> is null reference in the <see cref="T:System.Collections.IList" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsFixedSize { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System.Collections.IList.IsReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System.Collections.IList.Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d295-2432">O índice do elemento a ser obtido ou definido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2432">The index of the element to get or set.</span></span></param>
        <summary><span data-ttu-id="3d295-2433">Obtém ou define o elemento no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2433">Gets or sets the element at the specified index.</span></span></summary>
        <value><span data-ttu-id="3d295-2434">O elemento no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2434">The element at the specified index.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2435">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2435">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2436">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2436">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="3d295-2437"><paramref name="index" /> é menor que zero.</span><span class="sxs-lookup"><span data-stu-id="3d295-2437"><paramref name="index" /> is less than zero.</span></span>  
  
 <span data-ttu-id="3d295-2438">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2438">-or-</span></span>  
  
 <span data-ttu-id="3d295-2439"><paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.ICollection.Count" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2439"><paramref name="index" /> is equal to or greater than <see cref="P:System.Collections.ICollection.Count" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3d295-2440">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</span><span class="sxs-lookup"><span data-stu-id="3d295-2440">The current <see cref="T:System.Array" /> does not have exactly one dimension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="3d295-2441">O objeto a remover do <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2441">The object to remove from the <see cref="T:System.Collections.IList" />.</span></span></param>
        <summary><span data-ttu-id="3d295-2442">Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2442">Removes the first occurrence of a specific object from the <see cref="T:System.Collections.IList" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2443">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2443">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2444">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2444">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3d295-2445">O <see cref="T:System.Collections.IList" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-2445">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="3d295-2446">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2446">-or-</span></span>  
  
 <span data-ttu-id="3d295-2447">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2447">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d295-2448">O índice do elemento a ser removido.</span><span class="sxs-lookup"><span data-stu-id="3d295-2448">The index of the element to remove.</span></span></param>
        <summary><span data-ttu-id="3d295-2449">Remove o item <see cref="T:System.Collections.IList" /> no índice especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2449">Removes the <see cref="T:System.Collections.IList" /> item at the specified index.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2450">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2450">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2451">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2451">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IList> interface.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3d295-2452">não é um índice válido no <see cref="T:System.Collections.IList" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2452">index is not a valid index in the <see cref="T:System.Collections.IList" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="3d295-2453">O <see cref="T:System.Collections.IList" /> é somente leitura.</span><span class="sxs-lookup"><span data-stu-id="3d295-2453">The <see cref="T:System.Collections.IList" /> is read-only.</span></span>  
  
 <span data-ttu-id="3d295-2454">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2454">-or-</span></span>  
  
 <span data-ttu-id="3d295-2455">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</span><span class="sxs-lookup"><span data-stu-id="3d295-2455">The <see cref="T:System.Collections.IList" /> has a fixed size.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="3d295-2456">O objeto a ser comparado com a instância atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2456">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2457">Um objeto que compara o objeto atual e <c>outro</c>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2457">An object that compares the current object and <c>other</c>.</span></span></param>
        <summary><span data-ttu-id="3d295-2458">Determina se o objeto da coleção atual precede, ocorre na mesma posição ou segue a outro objeto na ordem de classificação.</span><span class="sxs-lookup"><span data-stu-id="3d295-2458">Determines whether the current collection object precedes, occurs in the same position as, or follows another object in the sort order.</span></span></summary>
        <returns><span data-ttu-id="3d295-2459">Um inteiro que indica a relação do objeto da coleção atual para outro, conforme mostrado na tabela a seguir.</span><span class="sxs-lookup"><span data-stu-id="3d295-2459">An integer that indicates the relationship of the current collection object to other, as shown in the following table.</span></span>  
  
 <span data-ttu-id="3d295-2460"><list type="table"><listheader><term> Valor retornado</span><span class="sxs-lookup"><span data-stu-id="3d295-2460"><list type="table"><listheader><term> Return value</span></span>  
  
 <span data-ttu-id="3d295-2461"></term><description> Descrição</span><span class="sxs-lookup"><span data-stu-id="3d295-2461"></term><description> Description</span></span>  
  
 <span data-ttu-id="3d295-2462"></description></listheader><item><term> -1</span><span class="sxs-lookup"><span data-stu-id="3d295-2462"></description></listheader><item><term> -1</span></span>  
  
 <span data-ttu-id="3d295-2463"></term><description> A instância atual precede <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2463"></term><description> The current instance precedes <paramref name="other" />.</span></span>  
  
 <span data-ttu-id="3d295-2464"></description></item><item><term> 0</span><span class="sxs-lookup"><span data-stu-id="3d295-2464"></description></item><item><term> 0</span></span>  
  
 <span data-ttu-id="3d295-2465"></term><description> A instância atual e <paramref name="other" /> são iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2465"></term><description> The current instance and <paramref name="other" /> are equal.</span></span>  
  
 <span data-ttu-id="3d295-2466"></description></item><item><term> 1</span><span class="sxs-lookup"><span data-stu-id="3d295-2466"></description></item><item><term> 1</span></span>  
  
 <span data-ttu-id="3d295-2467"></term><description> A instância atual segue <paramref name="other" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2467"></term><description> The current instance follows <paramref name="other" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2468">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2468">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2469">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralComparable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2469">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralComparable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="3d295-2470">O objeto a ser comparado com a instância atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2470">The object to compare with the current instance.</span></span></param>
        <param name="comparer"><span data-ttu-id="3d295-2471">Um objeto que determina se a instância atual e <c>other</c> são iguais.</span><span class="sxs-lookup"><span data-stu-id="3d295-2471">An object that determines whether the current instance and <c>other</c> are equal.</span></span></param>
        <summary><span data-ttu-id="3d295-2472">Determina se um objeto é igual à instância atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2472">Determines whether an object is equal to the current instance.</span></span></summary>
        <returns>
          <span data-ttu-id="3d295-2473"><see langword="true" /> se os dois objetos forem iguais; do contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2473"><see langword="true" /> if the two objects are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2474">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2474">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2475">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2475">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer"><span data-ttu-id="3d295-2476">Um objeto que calcula o código hash do objeto atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2476">An object that computes the hash code of the current object.</span></span></param>
        <summary><span data-ttu-id="3d295-2477">Retorna um código hash para a instância atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2477">Returns a hash code for the current instance.</span></span></summary>
        <returns><span data-ttu-id="3d295-2478">O código hash da instância atual.</span><span class="sxs-lookup"><span data-stu-id="3d295-2478">The hash code for the current instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2479">Este membro é uma implementação do membro de interface explícita.</span><span class="sxs-lookup"><span data-stu-id="3d295-2479">This member is an explicit interface member implementation.</span></span> <span data-ttu-id="3d295-2480">Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.</span><span class="sxs-lookup"><span data-stu-id="3d295-2480">It can be used only when the <xref:System.Array> instance is cast to an <xref:System.Collections.IStructuralEquatable> interface.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="3d295-2481">O tipo dos elementos da matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2481">The type of the elements of the array.</span></span></typeparam>
        <param name="array"><span data-ttu-id="3d295-2482">O <see cref="T:System.Array" /> unidimensional, com base em zero a ser verificado em relação às condições.</span><span class="sxs-lookup"><span data-stu-id="3d295-2482">The one-dimensional, zero-based <see cref="T:System.Array" /> to check against the conditions.</span></span></param>
        <param name="match"><span data-ttu-id="3d295-2483">O predicado que define as condições a serem verificadas nos elementos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2483">The predicate that defines the conditions to check against the elements.</span></span></param>
        <summary><span data-ttu-id="3d295-2484">Determina se cada elemento na matriz corresponde às condições definidas pelo predicado especificado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2484">Determines whether every element in the array matches the conditions defined by the specified predicate.</span></span></summary>
        <returns>
          <span data-ttu-id="3d295-2485"><see langword="true" /> se cada elemento no <paramref name="array" /> corresponder às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2485"><see langword="true" /> if every element in <paramref name="array" /> matches the conditions defined by the specified predicate; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="3d295-2486">Se não houver nenhum elemento na matriz, o valor retornado será <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2486">If there are no elements in the array, the return value is <see langword="true" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3d295-2487">O <xref:System.Predicate%601> é um delegado para um método que retorna`true` se o objeto passado para ele corresponde às condições definidas no delegado.</span><span class="sxs-lookup"><span data-stu-id="3d295-2487">The <xref:System.Predicate%601> is a delegate to a method that returns`true` if the object passed to it matches the conditions defined in the delegate.</span></span>  <span data-ttu-id="3d295-2488">Os elementos de `array` individualmente são passados para o <xref:System.Predicate%601>, e o processamento será interrompido quando o delegado retorna `false` para qualquer elemento.</span><span class="sxs-lookup"><span data-stu-id="3d295-2488">The elements of `array` are individually passed to the <xref:System.Predicate%601>, and processing is stopped when the delegate returns `false` for any element.</span></span>  
  
 <span data-ttu-id="3d295-2489">Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.</span><span class="sxs-lookup"><span data-stu-id="3d295-2489">This method is an O(`n`) operation, where `n` is the <xref:System.Array.Length%2A> of `array`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3d295-2490">O exemplo a seguir determina se o último caractere de cada elemento em uma matriz de cadeia de caracteres é um número.</span><span class="sxs-lookup"><span data-stu-id="3d295-2490">The following example determines whether the last character of each element in a string array is a number.</span></span> <span data-ttu-id="3d295-2491">Ele cria duas matrizes de cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="3d295-2491">It creates two string arrays.</span></span> <span data-ttu-id="3d295-2492">A primeira arrayincludes cadeias de caracteres que terminam com caracteres alfabéticos e cadeias de caracteres que terminam com caracteres numéricos. A segunda matriz consiste apenas em cadeias de caracteres que terminam com caracteres numéricos.</span><span class="sxs-lookup"><span data-stu-id="3d295-2492">The first arrayincludes both strings that end with alphabetic characters and strings that end with numeric characters.The second array consists only of strings that end with numeric characters.</span></span> <span data-ttu-id="3d295-2493">O exemplo também define um `EndWithANumber` método cuja assinatura coincide com o <xref:System.Predicate%601> delegate.</span><span class="sxs-lookup"><span data-stu-id="3d295-2493">The example also defines an `EndWithANumber` method whose signature matches the <xref:System.Predicate%601> delegate.</span></span> <span data-ttu-id="3d295-2494">O exemplo passa cada matriz para o <xref:System.Array.TrueForAll%2A> método junto com um delegado que representa o `EndsWithANumber` método.</span><span class="sxs-lookup"><span data-stu-id="3d295-2494">The example passes each array to the <xref:System.Array.TrueForAll%2A> method along with a delegate that represents the `EndsWithANumber` method.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 <span data-ttu-id="3d295-2495">O exemplo a seguir é semelhante ao primeiro, exceto que ele passa a matriz de cadeia de caracteres para o <xref:System.Array.TrueForAll%2A> método junto com uma expressão lambda que determina se um elemento de matriz específico termina com a representação de cadeia de caracteres de um número.</span><span class="sxs-lookup"><span data-stu-id="3d295-2495">The following example is similar to the first, except that it passes the string array to the <xref:System.Array.TrueForAll%2A> method along with  a lambda expression that determines whether a particular array element ends with the string representation of a number.</span></span>  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 <span data-ttu-id="3d295-2496">Em ambos os casos, o <xref:System.Array.TrueForAll%2A> método retorna `false` assim que encontrar o primeiro elemento da matriz que não terminam em um número.</span><span class="sxs-lookup"><span data-stu-id="3d295-2496">In both cases, the <xref:System.Array.TrueForAll%2A> method returns `false` as soon as it encounters the first array element that does not end in a number.</span></span> <span data-ttu-id="3d295-2497">Caso contrário, retornará `true` após a iteração de todos os elementos na matriz.</span><span class="sxs-lookup"><span data-stu-id="3d295-2497">Otherwise, it returns `true` after iterating all the elements in the array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3d295-2498">Como ambos os exemplos mostram, em c# e Visual Basic, não é necessário criar o `Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2498">As both examples show, in C# and Visual Basic, it is not necessary to create the `Predicate<string>` delegate (`Predicate(Of String)` in Visual Basic) explicitly.</span></span> <span data-ttu-id="3d295-2499">Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.</span><span class="sxs-lookup"><span data-stu-id="3d295-2499">These languages infer the correct delegate from context and create it automatically.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="3d295-2500"><paramref name="array" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2500"><paramref name="array" /> is <see langword="null" />.</span></span>  
  
 <span data-ttu-id="3d295-2501">- ou -</span><span class="sxs-lookup"><span data-stu-id="3d295-2501">-or-</span></span>  
  
 <span data-ttu-id="3d295-2502"><paramref name="match" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3d295-2502"><paramref name="match" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>