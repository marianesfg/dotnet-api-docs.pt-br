<Type Name="Array" FullName="System.Array">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d7e1b2a77494f5284724dfe8b36d5a696726579e" /><Meta Name="ms.sourcegitcommit" Value="d8bd5d494445ce3fcad1321267cb87548d23a45b" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="12/15/2018" /><Meta Name="ms.locfileid" Value="53450289" /></Metadata><TypeSignature Language="C#" Value="public abstract class Array : ICloneable, System.Collections.IList, System.Collections.IStructuralComparable, System.Collections.IStructuralEquatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Array extends System.Object implements class System.Collections.ICollection, class System.Collections.IEnumerable, class System.Collections.IList, class System.Collections.IStructuralComparable, class System.Collections.IStructuralEquatable, class System.ICloneable" />
  <TypeSignature Language="DocId" Value="T:System.Array" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Array&#xA;Implements ICloneable, IList, IStructuralComparable, IStructuralEquatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Array abstract : ICloneable, System::Collections::IList, System::Collections::IStructuralComparable, System::Collections::IStructuralEquatable" />
  <TypeSignature Language="F#" Value="type Array = class&#xA;    interface ICloneable&#xA;    interface ICollection&#xA;    interface IList&#xA;    interface IEnumerable&#xA;    interface IStructuralComparable&#xA;    interface IStructuralEquatable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.ICollection</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IList</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IStructuralEquatable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece métodos para criar, manipular, pesquisar e classificar matrizes, servindo assim como a classe base para todas as matrizes no Common Language Runtime.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> classe não é parte do <xref:System.Collections> namespaces. No entanto, ela ainda será considerada uma coleção porque ele se baseia o <xref:System.Collections.IList> interface.  
  
 O <xref:System.Array> classe é a classe base para implementações de linguagem que dão suporte a matrizes. No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Array> classe. Os usuários devem empregar as construções de matriz fornecidas pela linguagem.  
  
 Um elemento é um valor em um <xref:System.Array>. O comprimento de um <xref:System.Array> é o número total de elementos que ele pode conter. O limite inferior de um <xref:System.Array> é o índice do seu primeiro elemento. Um <xref:System.Array> pode ter qualquer limite inferior, mas ele tem um limite inferior de zero por padrão. Um limite inferior diferente pode ser definido ao criar uma instância das <xref:System.Array> classe usando <xref:System.Array.CreateInstance%2A>. Um multidimensional <xref:System.Array> pode ter diferentes limites de cada dimensão. Uma matriz pode ter um máximo de 32 dimensões.  
  
 Ao contrário das classes na <xref:System.Collections> namespaces, <xref:System.Array> tem uma capacidade fixa. Para aumentar a capacidade, você deve criar um novo <xref:System.Array> de objeto com a capacidade necessária, copiar os elementos do ambiente antigo <xref:System.Array> do objeto para o novo e excluir o antigo <xref:System.Array>.  
  
 Por padrão, o tamanho máximo de um <xref:System.Array> é de 2 gigabytes (GB). Em um ambiente de 64 bits, você pode evitar a restrição de tamanho, definindo o `enabled` atributo o [gcAllowVeryLargeObjects](~/docs/framework/configure-apps/file-schema/runtime/gcallowverylargeobjects-element.md) elemento de configuração para `true` no ambiente de tempo de execução. No entanto, a matriz ainda estará limitada a um total de 4 bilhões de elementos e a um índice máximo de 0X7FEFFFFF em qualquer determinada dimensão (0X7FFFFFC7 para matrizes de bytes e matrizes de estruturas de byte único).  
  
 Matrizes unidimensionais implementam o <xref:System.Collections.Generic.IList%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.ICollection%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IEnumerable%601?displayProperty=nameWithType>, <xref:System.Collections.Generic.IReadOnlyList%601?displayProperty=nameWithType> e <xref:System.Collections.Generic.IReadOnlyCollection%601?displayProperty=nameWithType> interfaces genéricas. As implementações são fornecidas para matrizes em tempo de execução e como resultado, as interfaces genéricas não aparecem na sintaxe de declaração para o <xref:System.Array> classe. Além disso, não há nenhum tópicos de referência para os membros de interface que são acessíveis apenas ao converter uma matriz para o tipo de interface genérica (implementações explícitas da interface). O que é importante estar atento ao converter uma matriz para uma dessas interfaces é que os membros que adicionar, inserir ou remover elementos throw <xref:System.NotSupportedException>.  
  
 <xref:System.Type> objetos fornecem informações sobre declarações de tipo de matriz. <xref:System.Array> objetos com o mesmo tipo de matriz compartilham o mesmo <xref:System.Type> objeto.  
  
 <xref:System.Type.IsArray%2A?displayProperty=nameWithType> e <xref:System.Type.GetElementType%2A?displayProperty=nameWithType> podem não retornar os resultados esperados com <xref:System.Array> porque se uma matriz é convertida para o tipo <xref:System.Array>, o resultado é um objeto, não é uma matriz. Ou seja, `typeof(System.Array).IsArray` retorna `false`, e `typeof(System.Array).GetElementType` retorna `null`.  
  
 O <xref:System.Array.Copy%2A?displayProperty=nameWithType> método copia não apenas entre matrizes do mesmo tipo, mas também entre matrizes de padrão de tipos diferentes de elementos; ele trata automaticamente de conversão de tipo.  
  
 Alguns métodos, tais como <xref:System.Array.CreateInstance%2A>, <xref:System.Array.Copy%2A>, <xref:System.Array.CopyTo%2A>, <xref:System.Array.GetValue%2A>, e <xref:System.Array.SetValue%2A>, fornecem sobrecargas que aceitam números inteiros de 64 bits como parâmetros para acomodar as matrizes de grande capacidade. <xref:System.Array.LongLength%2A> e <xref:System.Array.GetLongLength%2A> retornam inteiros de 64 bits que indica o comprimento da matriz.  
  
 O <xref:System.Array> não é garantida a serem classificados.  Você deve classificar as <xref:System.Array> antes de executar operações (como <xref:System.Array.BinarySearch%2A>) que exigem o <xref:System.Array> a serem classificados.  
  
 Usando um <xref:System.Array> objeto de ponteiros em código nativo não é compatível e gerará um <xref:System.NotSupportedException> para vários métodos.  
  
   
  
## Examples  
 O seguinte exemplo de código mostra como <xref:System.Array.Copy%2A?displayProperty=nameWithType> copia os elementos entre uma matriz do tipo inteiro e uma matriz do tipo <xref:System.Object>.  
  
 [!code-cpp[Classic Array Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source.cs#1)]
 [!code-vb[Classic Array Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir cria e inicializa um <xref:System.Array> e exibe suas propriedades e seus elementos.  
  
 [!code-cpp[Classic Array Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array Example/CPP/source3.cpp#2)]
 [!code-csharp[Classic Array Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array Example/CS/source3.cs#2)]
 [!code-vb[Classic Array Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array Example/VB/source3.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Os membros estáticos públicos (<see langword="Shared" /> no Visual Basic) desse são thread-safe. Não há garantia de que qualquer membro de instância seja thread-safe.  
  
Essa implementação não oferece um sincronizada wrapper (thread-safe) para um <see cref="T:System.Array" />; no entanto, classes do .NET Framework com base no <see cref="T:System.Array" /> fornecer sua própria versão sincronizada da coleção usando o <see cref="P:System.Array.SyncRoot" /> propriedade.  
  
A enumeração por meio de uma coleção não é um procedimento thread-safe intrínseco. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.</threadsafe>
    <altmember cref="T:System.Object" />
    <altmember cref="T:System.Type" />
    <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
    <related type="Article" href="~/docs/csharp/programming-guide/arrays/index.md">Matrizes (Guia de Programação em C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/arrays/index.md">Matrizes no Visual Basic</related>
  </Docs>
  <Members>
    <Member MemberName="AsReadOnly&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt; AsReadOnly&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;!!T&gt; AsReadOnly&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.AsReadOnly``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AsReadOnly(Of T) (array As T()) As ReadOnlyCollection(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static System::Collections::ObjectModel::ReadOnlyCollection&lt;T&gt; ^ AsReadOnly(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member AsReadOnly : 'T[] -&gt; System.Collections.ObjectModel.ReadOnlyCollection&lt;'T&gt;" Usage="System.Array.AsReadOnly array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyCollection&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional baseada em zero para encapsular em um wrapper <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> somente leitura.</param>
        <summary>Retorna um wrapper somente leitura para a matriz especificada.</summary>
        <returns>Um wrapper somente leitura <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> para a matriz especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para evitar modificações para a matriz, expor a matriz por meio desse wrapper.  
  
 Uma coleção somente leitura é apenas uma coleção com um wrapper que impede a modificação da coleção; por isso, caso as alterações sejam feitas na coleção subjacente, a coleção somente leitura reflete as alterações.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir encapsula uma matriz em somente leitura <xref:System.Collections.ObjectModel.ReadOnlyCollection%601>.  
  
 [!code-cpp[System.Array.AsReadOnly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CPP/arrayasreadonly.cpp#1)]
 [!code-csharp[System.Array.AsReadOnly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.AsReadOnly/CS/arrayasreadonly.cs#1)]
 [!code-vb[System.Array.AsReadOnly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.AsReadOnly/VB/arrayasreadonly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BinarySearch">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa um <see cref="T:System.Array" /> unidimensional classificado para um valor usando um algoritmo de pesquisa binária.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a <see cref="T:System.IComparable" /> interface implementada por cada elemento da matriz e o objeto especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é uma maior que o limite superior da matriz, há nenhum elemento maior que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 Tanto `value` ou todos os elementos da `array` deve implementar o <xref:System.IComparable> interface, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se`value` não implementa o <xref:System.IComparable> interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes que a pesquisa começa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar <xref:System.Array.BinarySearch%2A> para localizar um objeto específico em um <xref:System.Array>.  
  
> [!NOTE]
>  A matriz é criada com seus elementos em ordem de classificação crescente. O <xref:System.Array.BinarySearch%2A> método requer que a matriz seja classificada em ordem crescente.  
  
 [!code-cpp[Classic Array.BinarySearch Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.BinarySearch Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/CS/source.cs#1)]
 [!code-vb[Classic Array.BinarySearch Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.BinarySearch Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Pesquisa um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada em uma matriz classificada unidimensional inteira.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é uma maior que o limite superior da matriz, há nenhum elemento maior que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se`comparer` está `null`, a comparação é feita usando o <xref:System.IComparable> implementação fornecida pelo próprio elemento ou pelo valor especificado. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` está `null` e `value` não implementa o <xref:System.IComparable> interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes que a pesquisa começa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa um intervalo de elementos em uma matriz unidimensional classificada para um valor, usando a interface <see cref="T:System.IComparable" /> implementada por cada elemento da matriz e pelo valor especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é uma maior que o limite superior da matriz, há nenhum elemento maior que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 Tanto `value` ou todos os elementos da `array` deve implementar o <xref:System.IComparable> interface, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `value` não implementa o <xref:System.IComparable> interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes que a pesquisa começa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
 <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch">
      <MemberSignature Language="C#" Value="public static int BinarySearch (Array array, int index, int length, object value, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch(class System.Array array, int32 index, int32 length, object value, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch(System.Array,System.Int32,System.Int32,System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int BinarySearch(Array ^ array, int index, int length, System::Object ^ value, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : Array * int * int * obj * System.Collections.IComparer -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface <see cref="T:System.Collections.IComparer" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é uma maior que o limite superior da matriz, há nenhum elemento maior que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.IComparer> implementação. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Caso `comparer` seja `null`, a comparação é feita usando-se a implementação de <xref:System.IComparable> fornecida pelo próprio elemento ou pelo valor especificado. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` está `null` e `value` não implementa o <xref:System.IComparable> interface, os elementos de `array` não são testadas para <xref:System.IComparable> antes que a pesquisa começa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable>.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
 <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" />, <paramref name="value" /> não implementa a interface <see cref="T:System.IComparable" /> e a pesquisa encontra um elemento que não implementa a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T -&gt; int" Usage="System.Array.BinarySearch (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa uma matriz unidimensional inteira classificada por um elemento específico, usando a interface <see cref="T:System.IComparable`1" /> genérica implementada por cada elemento da <see cref="T:System.Array" /> e o objeto especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Se `array` não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 `T` deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga de método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga de método genérico. Uma matriz de cadeias de caracteres é criada, sem nenhuma ordem específica.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga de método genérico, em seguida, é usada para pesquisar cadeias de caracteres de dois, que não está na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice, se a cadeia de caracteres for encontrada e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo se a cadeia de caracteres não está na matriz, portanto, o `ShowWhere` método utiliza o complemento bit a bit (o ~ operador em c# e Visual C++, `Xor`-1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a pesquisa str ING.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Pesquisa uma matriz classificada unidimensional completa para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Caso o <xref:System.Array> não contenha o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação da interface genérica. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se `comparer` está `null`, a comparação é feita usando o <xref:System.IComparable%601> implementação da interface genérica fornecida pelo `T`. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
> [!NOTE]
>  Se `comparer` está `null` e `value` não implementa o <xref:System.IComparable%601> interface genérica, os elementos de `array` não são testadas para <xref:System.IComparable%601> antes que a pesquisa começa. Uma exceção será lançada se a pesquisa encontrar um elemento que não implementa <xref:System.IComparable%601>.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico, em seguida, é usada para pesquisar cadeias de caracteres de dois, que não está na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice, se a cadeia de caracteres for encontrada e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" /></exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <summary>Pesquisa um intervalo de elementos em uma matriz unidimensional classificada em busca de um valor, usando a interface genérica <see cref="T:System.IComparable`1" /> implementada por cada elemento do <see cref="T:System.Array" /> e pelo valor especificado.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Se a matriz não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 `T` deve implementar o <xref:System.IComparable%601> interface genérica, que é usado para comparações. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; por isso, comparações com `null` não geram uma exceção.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
 <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="T" /> não implementa a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="BinarySearch&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int BinarySearch&lt;T&gt; (T[] array, int index, int length, T value, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 BinarySearch&lt;T&gt;(!!T[] array, int32 index, int32 length, !!T value, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.BinarySearch``1(``0[],System.Int32,System.Int32,``0,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BinarySearch(Of T) (array As T(), index As Integer, length As Integer, value As T, comparer As IComparer(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int BinarySearch(cli::array &lt;T&gt; ^ array, int index, int length, T value, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member BinarySearch : 'T[] * int * int * 'T * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; int" Usage="System.Array.BinarySearch (array, index, length, value, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, classificado a ser procurado.</param>
        <param name="index">O índice inicial do intervalo a ser procurado.</param>
        <param name="length">O tamanho do intervalo a ser procurado.</param>
        <param name="value">O objeto a ser procurado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Pesquisa uma variedade de elementos em uma matriz classificada unidimensional para um valor usando a interface genérica de <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <returns>O índice do <paramref name="value" /> especificado no <paramref name="array" /> especificado, caso <paramref name="value" /> seja encontrado; caso contrário, um número negativo. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja menor que um ou mais elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit do índice do primeiro elemento maior que <paramref name="value" />. Caso <paramref name="value" /> não seja encontrado e <paramref name="value" /> seja maior que todos os elementos no <paramref name="array" />, o número negativo retornado será o complemento bit a bit (do índice do último elemento mais 1). Se esse método for chamado com <paramref name="array" /> não classificado, o valor retornado poderá estar incorreto e um número negativo pode ser retornado, mesmo se <paramref name="value" /> estiver presente no <paramref name="array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método não dá suporte a matrizes de pesquisa que contenham índices negativos. `array` deve ser classificada antes de chamar esse método.  
  
 Se a matriz não contém o valor especificado, o método retorna um inteiro negativo. Você pode aplicar o operador de complemento bit a bit (~ no c#, `Not` no Visual Basic) ao resultado negativo para produzir um índice. Se esse índice é igual ao tamanho da matriz, não há elementos são maiores do que `value` na matriz. Do contrário, é o índice do primeiro elemento que é maior que `value`.  
  
 A comparação personaliza como os elementos são comparados. Por exemplo, é possível usar um <xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType> como a comparação para realizar pesquisas de cadeia de caracteres que não diferenciam maiúsculas de minúsculas.  
  
 Se `comparer` não é `null`, os elementos de `array` são comparados com o valor especificado usando especificado <xref:System.Collections.Generic.IComparer%601> implementação da interface genérica. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida por `comparer`; do contrário, o resultado pode estar incorreto.  
  
 Se `comparer` está `null`, a comparação é feita usando o <xref:System.IComparable%601> fornecida para o tipo de implementação de interface genérica `T`. Os elementos de `array` já devem ser classificados em valor crescente de acordo com a ordem de classificação definida pela implementação de <xref:System.IComparable%601>; do contrário, o resultado pode estar incorreto.  
  
 Os elementos duplicados são permitidos. Caso o <xref:System.Array> contenha mais de um elemento igual a `value`, o método retorna o índice de apenas uma das ocorrências, e não necessariamente da primeira.  
  
 `null` sempre pode ser comparado com qualquer outro tipo de referência; Portanto, as comparações com `null` não geram uma exceção ao usar <xref:System.IComparable%601>.  
  
> [!NOTE]
>  Para cada elemento testado, `value` é passado para a implementação apropriada de <xref:System.IComparable%601>, mesmo se `value` for `null`. Ou seja, a implementação de <xref:System.IComparable%601> determina como um determinado elemento se compara com `null`.  
  
 Este método é uma operação O(log `n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
 <paramref name="comparer" /> é <see langword="null" />, e <paramref name="value" /> é de um tipo que não é compatível com os elementos de <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">O <paramref name="comparer" /> é <see langword="null" /> e <paramref name="T" /> não implementa a interface genérica de <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.Sort" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clear(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Clear : Array * int * int -&gt; unit" Usage="System.Array.Clear (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz cujos elementos precisam ser limpos.</param>
        <param name="index">O índice inicial do intervalo de elementos a limpar.</param>
        <param name="length">O número de elementos a limpar.</param>
        <summary>Define um intervalo de elementos em uma matriz como o valor padrão de cada tipo de elemento.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método redefine cada elemento em uma matriz com valor de padrão do tipo de elemento. Ele define os elementos de tipos de referência (incluindo <xref:System.String> elementos) para `null`e define os elementos de tipos de valor para os valores padrão mostrados na tabela a seguir.  
  
|Tipo|Valor|  
|----------|-----------|  
|<xref:System.Boolean>|`false`|  
|Todos os tipos numéricos de ponto flutuante e integral|0 (zero)|  
|<xref:System.DateTime>|<xref:System.DateTime.MinValue?displayProperty=nameWithType>|  
|Outros tipos de valor|Valor padrão de campos do tipo|  
  
 O intervalo de limpo encapsulamento de elementos de uma linha para outra em uma matriz multidimensional.  
  
 Esse método só limpa os valores dos elementos; ele não exclui os próprios elementos. Uma matriz tem um tamanho fixo; Portanto, os elementos não podem ser adicionados ou removidos.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.Clear%2A> método para redefinir valores inteiros em uma matriz unidimensional, bidimensional e tridimensional.  
  
 [!code-csharp[System.Array.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/example.cs#1)]
 [!code-vb[System.Array.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/example.vb#1)]  
  
 O exemplo a seguir define uma `TimeZoneTime` estrutura que inclui um <xref:System.TimeZoneInfo> campo e um <xref:System.DateTimeOffset> campo. Em seguida, ele chama o <xref:System.Array.Clear%2A> método para limpar um elemento em uma matriz de dois elementos de `TimeZoneTime` valores. O método define o valor do elemento desmarcado como o valor padrão de um <xref:System.TimeZoneInfo> objeto, que é `null`e o valor padrão de uma <xref:System.DateTimeOffset> objeto, que é <xref:System.DateTimeOffset.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Array.Clear#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clear/cs/clearstruct1.cs#2)]
 [!code-vb[System.Array.Clear#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clear/vb/clearstruct1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.  
  
- ou - 
A soma de <paramref name="index" /> e <paramref name="length" /> é maior que o tamanho do <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="array.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial do <see cref="T:System.Array" />.</summary>
        <returns>Uma cópia superficial do <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma cópia superficial de um <xref:System.Array> copia apenas os elementos do <xref:System.Array>, se eles são tipos de referência ou tipos de valor, mas não copia os objetos que referenciam as referências. As referências no novo <xref:System.Array> apontam para o mesmo objetos que as referências no original <xref:System.Array> aponte para.  
  
 Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 O clone é do mesmo <xref:System.Type> que o original <xref:System.Array>.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.  
  
   
  
## Examples  
 O código a seguir exemplo clones um <xref:System.Globalization.CultureInfo?displayProperty=nameWithType> de matriz e demonstra o comportamento de uma cópia superficial.  
  
 [!code-cpp[System.Array.Clone#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Clone/CPP/arrayclone.cpp#1)]
 [!code-csharp[System.Array.Clone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Clone/CS/arrayclone.cs#1)]
 [!code-vb[System.Array.Clone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Clone/VB/arrayclone.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ConstrainedCopy">
      <MemberSignature Language="C#" Value="public static void ConstrainedCopy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ConstrainedCopy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ConstrainedCopy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ConstrainedCopy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member ConstrainedCopy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.ConstrainedCopy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 32 bits que representa o índice no <paramref name="sourceArray" /> no qual a cópia é iniciada.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 32 bits que representa o índice no <paramref name="destinationArray" /> no qual o armazenamento é iniciado.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado.  Garante que todas as alterações serão desfeitas se a cópia não foi bem-sucedida por completo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões.  O `sourceArray` tipo deve ser igual ou derivada do `destinationArray` de tipo; caso contrário, um <xref:System.ArrayTypeMismatchException> é gerada.  Diferentemente <xref:System.Array.Copy%2A>, <xref:System.Array.ConstrainedCopy%2A> verifica a compatibilidade dos tipos de matriz antes de executar qualquer operação.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional longa, em que as linhas (ou colunas) são conceitualmente apresentadas ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para começar a copiar o segundo elemento da terceira linha (ou coluna), `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o tamanho da segunda linha (ou coluna) mais dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor.  Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Se esse método lançará uma exceção durante a cópia, o `destinationArray` permanece inalterado; portanto, <xref:System.Array.ConstrainedCopy%2A> pode ser usado dentro de uma região de execução restrita (<xref:System.Runtime.ConstrainedExecution.Cer>).  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo <paramref name="sourceArray" /> não é igual nem derivado do tipo <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
        <altmember cref="Overload:System.Array.Copy" />
        <altmember cref="M:System.Array.Clone" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute" />
        <altmember cref="T:System.Runtime.ConstrainedExecution.Cer" />
      </Docs>
    </Member>
    <Member MemberName="ConvertAll&lt;TInput,TOutput&gt;">
      <MemberSignature Language="C#" Value="public static TOutput[] ConvertAll&lt;TInput,TOutput&gt; (TInput[] array, Converter&lt;TInput,TOutput&gt; converter);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!TOutput[] ConvertAll&lt;TInput, TOutput&gt;(!!TInput[] array, class System.Converter`2&lt;!!TInput, !!TOutput&gt; converter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ConvertAll``2(``0[],System.Converter{``0,``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConvertAll(Of TInput, TOutput) (array As TInput(), converter As Converter(Of TInput, TOutput)) As TOutput()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TInput, typename TOutput&gt;&#xA; static cli::array &lt;TOutput&gt; ^ ConvertAll(cli::array &lt;TInput&gt; ^ array, Converter&lt;TInput, TOutput&gt; ^ converter);" />
      <MemberSignature Language="F#" Value="static member ConvertAll : 'Input[] * Converter&lt;'Input, 'Output&gt; -&gt; 'Output[]" Usage="System.Array.ConvertAll (array, converter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>TOutput[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TInput" />
        <TypeParameter Name="TOutput" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="TInput[]" />
        <Parameter Name="converter" Type="System.Converter&lt;TInput,TOutput&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TInput">O tipo dos elementos da matriz de origem.</typeparam>
        <typeparam name="TOutput">O tipo dos elementos da matriz de destino.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero para converter para um tipo de destino.</param>
        <param name="converter">Um <see cref="T:System.Converter`2" /> que converte cada elemento de um tipo em outro tipo.</param>
        <summary>Converte uma matriz de um tipo para uma matriz de outro tipo.</summary>
        <returns>Uma matriz do tipo de destino que contém os elementos convertidos da matriz de origem.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Converter%602> é um delegado para um método que converte um objeto para o tipo de destino.  Os elementos de `array` são passados individualmente para o <xref:System.Converter%602>, e os elementos convertidos são salvos na nova matriz.  
  
 A fonte `array` permanece inalterado.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir define um método chamado `PointFToPoint` que converte um <xref:System.Drawing.PointF> estrutura para um <xref:System.Drawing.Point> estrutura. O exemplo cria uma matriz de <xref:System.Drawing.PointF> estruturas, cria um `Converter<PointF, Point>` delegar (`Converter(Of PointF, Point)` no Visual Basic) para representar o `PointFToPoint` método e passa o delegado para o <xref:System.Array.ConvertAll%2A> método. O <xref:System.Array.ConvertAll%2A> método passa cada elemento da lista de entrada para o `PointFToPoint` método e coloca os elementos convertidos em uma nova lista de <xref:System.Drawing.Point> estruturas. Ambas as listas são exibidas.  
  
 [!code-cpp[Array_ConvertAll#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_ConvertAll/cpp/source.cpp#1)]
 [!code-csharp[Array_ConvertAll#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_ConvertAll/cs/source.cs#1)]
 [!code-vb[Array_ConvertAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_ConvertAll/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="converter" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Converter`2" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Copy">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia um intervalo de elementos em um <see cref="T:System.Array" /> para outro <see cref="T:System.Array" /> e executa a conversão de tipo de conversão e a conversão boxing conforme necessário.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento. O comprimento é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional longa, em que as linhas (ou colunas) são conceitualmente apresentadas ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, Array destinationArray, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, class System.Array destinationArray, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, destinationArray As Array, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, Array ^ destinationArray, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * Array * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, destinationArray, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="length">Um inteiro de 64 bits que representa o número de elementos a se copiar. O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copia um intervalo de elementos de uma <see cref="T:System.Array" /> iniciando no primeiro elemento e cola-o em outro <see cref="T:System.Array" />, iniciando no primeiro elemento. O tamanho é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional longa, em que as linhas (ou colunas) são conceitualmente apresentadas ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna).  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> é maior que o número de elementos em <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="length" /> é maior que o número de elementos em <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int32 sourceIndex, class System.Array destinationArray, int32 destinationIndex, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Integer, destinationArray As Array, destinationIndex As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, int sourceIndex, Array ^ destinationArray, int destinationIndex, int length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int * Array * int * int -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int32" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 32 bits que representa o índice no <paramref name="sourceArray" /> no qual a cópia é iniciada.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 32 bits que representa o índice no <paramref name="destinationArray" /> no qual o armazenamento é iniciado.</param>
        <param name="length">Um inteiro de 32 bits que representa o número de elementos a se copiar.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado. A altura e os índices são especificados como inteiros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional longa, em que as linhas (ou colunas) são conceitualmente apresentadas ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para começar a copiar o segundo elemento da terceira linha (ou coluna), `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o tamanho da segunda linha (ou coluna) mais dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar de um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="destinationIndex" /> é menor que o limite inferior da primeira dimensão de <paramref name="destinationArray" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public static void Copy (Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Copy(class System.Array sourceArray, int64 sourceIndex, class System.Array destinationArray, int64 destinationIndex, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Copy(System.Array,System.Int64,System.Array,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Copy (sourceArray As Array, sourceIndex As Long, destinationArray As Array, destinationIndex As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Copy(Array ^ sourceArray, long sourceIndex, Array ^ destinationArray, long destinationIndex, long length);" />
      <MemberSignature Language="F#" Value="static member Copy : Array * int64 * Array * int64 * int64 -&gt; unit" Usage="System.Array.Copy (sourceArray, sourceIndex, destinationArray, destinationIndex, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceArray" Type="System.Array" />
        <Parameter Name="sourceIndex" Type="System.Int64" />
        <Parameter Name="destinationArray" Type="System.Array" />
        <Parameter Name="destinationIndex" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="sourceArray">O <see cref="T:System.Array" /> que contém os dados a serem copiados.</param>
        <param name="sourceIndex">Um inteiro de 64 bits que representa o índice no <paramref name="sourceArray" /> no qual a cópia é iniciada.</param>
        <param name="destinationArray">O <see cref="T:System.Array" /> que recebe os dados.</param>
        <param name="destinationIndex">Um inteiro de 64 bits que representa o índice no <paramref name="destinationArray" /> no qual o armazenamento é iniciado.</param>
        <param name="length">Um inteiro de 64 bits que representa o número de elementos a se copiar. O inteiro deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Copia um intervalo de elementos de um <see cref="T:System.Array" /> a partir do índice de origem especificado e cola-os em outro <see cref="T:System.Array" /> a partir do índice de destino especificado. O tamanho e os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os parâmetros `sourceArray` e `destinationArray` devem ter o mesmo número de dimensões. Além disso, `destinationArray` já deve ter sido dimensionada e deve ter um número suficiente de elementos desde o `destinationIndex` posição para acomodar os dados copiados.  
  
 Ao copiar entre matrizes multidimensionais, a matriz se comporta como uma matriz unidimensional longa, em que as linhas (ou colunas) são conceitualmente apresentadas ponta a ponta. Por exemplo, se uma matriz tivesse três linhas (ou colunas) com quatro elementos cada, a cópia de seis elementos do início da matriz copiaria todos os quatro elementos da primeira linha (ou coluna) e os dois primeiros elementos da segunda linha (ou coluna). Para começar a copiar o segundo elemento da terceira linha (ou coluna), `sourceIndex` deve ser o limite superior da primeira linha (ou coluna) mais o tamanho da segunda linha (ou coluna) mais dois.  
  
 Caso `sourceArray` e `destinationArray` se sobreponham, este método se comporta como se os valores originais de `sourceArray` foram preservados em um local temporário antes de `destinationArray` ser substituído.  
  
 [C++]  
  
 Este método é equivalente à função padrão do C/C++ `memmove`, e não a `memcpy`.  
  
 As matrizes podem ser matrizes do tipo referência ou matrizes do tipo valor. O downcast de tipo é realizado, conforme necessário.  
  
-   Durante a cópia de uma matriz do tipo de referência para uma matriz do tipo de valor, cada elemento é convertido e, em seguida, copiado. Durante a cópia de uma matriz do tipo de valor para uma matriz do tipo de referência, cada elemento é convertido e, em seguida, copiado.  
  
-   Durante a cópia de uma matriz do tipo de referência ou do tipo de valor para um <xref:System.Object>, um <xref:System.Object> é criado para manter cada valor ou referência e, em seguida, copiá-lo. Durante a cópia de uma matriz <xref:System.Object> para uma matriz do tipo de referência ou matriz do tipo de valor e a atribuição não é possível, <xref:System.InvalidCastException> é lançado.  
  
-   Caso `sourceArray` e `destinationArray` sejam matrizes do tipo de referência ou ambas as matrizes do tipo <xref:System.Object>, uma cópia superficial é realizada. Uma cópia superficial de um <xref:System.Array> é um novo <xref:System.Array> contendo referências aos mesmos elementos do <xref:System.Array>original. Os próprios elementos ou nada referenciado pelos elementos não são copiados. Por outro lado, uma cópia em profundidade de um <xref:System.Array> copia os elementos e tudo direta ou indiretamente referenciado pelos elementos.  
  
 Um <xref:System.ArrayTypeMismatchException> será lançado se as matrizes forem de tipos incompatíveis. A compatibilidade de tipo é definida da seguinte forma:  
  
-   Um tipo é compatível com ele próprio.  
  
-   Um tipo de valor é compatível com <xref:System.Object> e com um tipo de interface implementado por esse tipo de valor. Um tipo de valor só é considerado conectado a uma interface caso implemente essa interface diretamente. Os tipos desconectado não são compatíveis.  
  
-   Dois tipos de valor intrínseco (predefinido) são compatíveis caso a cópia do tipo de fonte para o tipo de destino seja uma conversão de ampliação. Uma conversão de ampliação jamais perde informações, e uma conversão de redução pode perder informações. Por exemplo, a conversão de um inteiro assinado de 32 bits em um inteiro assinado de 64 bits é uma conversão de ampliação, e a conversão de um inteiro assinado de 64 bits em um inteiro assinado de 32 bits é uma conversão de redução. Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
-   Um tipo de valor não intrínseco (definido pelo usuário) só é compatível com ele próprio.  
  
-   Enumerações têm uma conversão implícita em <xref:System.Enum> e no tipo subjacente.  
  
 Caso cada elemento em `sourceArray` exija um downcast (por exemplo, uma classe base para uma classe derivada ou de uma interface para um objeto) e um ou mais elementos não possam ser convertidos no tipo correspondente em `destinationArray`, <xref:System.InvalidCastException> é lançado.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `destinationArray` é indefinido.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar de um <xref:System.Array> do tipo <xref:System.Object> para outro <xref:System.Array> do tipo inteiro.  
  
 [!code-cpp[Classic Array.Copy1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Copy1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Copy1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Copy1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="sourceArray" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="destinationArray" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> têm classificações diferentes.</exception>
        <exception cref="T:System.ArrayTypeMismatchException"><paramref name="sourceArray" /> e <paramref name="destinationArray" /> são de tipos incompatíveis.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento em <paramref name="sourceArray" /> não pode ser convertido no tipo de <paramref name="destinationArray" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sourceIndex" /> está fora do intervalo de índices válidos para o <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="destinationIndex" /> está fora do intervalo de índices válidos para o <paramref name="destinationArray" />.  
  
- ou - 
 <paramref name="length" /> é menor que 0 ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="length" /> é maior que o número de elementos do <paramref name="sourceIndex" /> até o final do <paramref name="sourceArray" />.  
  
- ou - 
 <paramref name="length" /> é maior que o número de elementos do <paramref name="destinationIndex" /> até o final do <paramref name="destinationArray" />.</exception>
        <altmember cref="M:System.Array.ConstrainedCopy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)" />
        <altmember cref="M:System.Array.Clone" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(class System.Array array, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(Array ^ array, int index);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : Array * int -&gt; unit&#xA;override this.CopyTo : Array * int -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.ICollection.CopyTo(System.Array,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</param>
        <param name="index">Um inteiro de 32 bits que representa o índice no <paramref name="array" /> no qual a cópia é iniciada.</param>
        <summary>Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado. O índice é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`. O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados. Caso contrário, o método gera uma exceção.  
  
 Este método dá suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Se implementando <xref:System.Collections.ICollection?displayProperty=nameWithType> é obrigatório não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma indireção extra.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.  
  
 Esse método é um O (`n`) a operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa apenas uma cópia superficial.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero. Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituição os elementos existentes no destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> é multidimensional.  
  
- ou - 
O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo do <see cref="T:System.Array" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">A matriz de origem é multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Array array, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(class System.Array array, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CopyTo(System.Array,System.Int64)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Array ^ array, long index);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Array * int64 -&gt; unit" Usage="array.CopyTo (array, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional que é o destino dos elementos copiados da matriz atual.</param>
        <param name="index">Um inteiro de 64 bits que representa o índice no <paramref name="array" /> em que a cópia é iniciada.</param>
        <summary>Copia todos os elementos da matriz unidimensional atual para a matriz unidimensional especificada começando no índice de matriz de destino especificado. O índice é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método copia todos os elementos da instância atual de matriz para o `array` matriz de destino, começando no índice `index`. O `array` a matriz de destino já deve ter sido dimensionada e deve ter um número suficiente de elementos para acomodar os elementos copiados. Caso contrário, o método gera uma exceção.  
  
 Este método dá suporte a <xref:System.Collections.ICollection?displayProperty=nameWithType> interface. Se implementando <xref:System.Collections.ICollection?displayProperty=nameWithType> é obrigatório não foi explicitamente, use <xref:System.Array.Copy%2A> para evitar uma indireção extra.  
  
 Caso esse método lance uma exceção durante a cópia, o estado de `array` é indefinido.  
  
 Esse método é um O (`n`) a operação, onde `n` é <xref:System.Array.Length%2A>. Ele executa apenas uma cópia superficial.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CopyTo Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CopyTo Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#1)]  
  
 O exemplo de código a seguir mostra como copiar um <xref:System.Array> para outro <xref:System.Array> com um limite inferior diferente de zero. Observe que toda a origem <xref:System.Array> é copiado, incluindo elementos vazios que substituição os elementos existentes no destino <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CopyTo Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Array.CopyTo Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/CS/source.cs#2)]
 [!code-vb[Classic Array.CopyTo Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CopyTo Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="array" /> é multidimensional.  
  
- ou - 
O número de elementos na matriz de origem é maior do que o número de elementos disponível de <paramref name="index" /> até o final do <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.ArrayTypeMismatchException">O tipo do <see cref="T:System.Array" /> de origem não pode ser automaticamente convertido para o tipo de <paramref name="array" /> de destino.</exception>
        <exception cref="T:System.RankException">A fonte <see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidCastException">Pelo menos um elemento no <see cref="T:System.Array" /> de origem não pode ser convertido no tipo de <paramref name="array" /> de destino.</exception>
        <altmember cref="T:System.Collections.ICollection" />
        <altmember cref="M:System.Array.Copy(System.Array,System.Array,System.Int64)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length">O tamanho do <see cref="T:System.Array" /> a ser criado.</param>
        <summary>Cria um <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado e tamanho, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> unidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um unidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params int[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;int&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz de inteiros de 32 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero. Os tamanhos da dimensão são especificados em uma matriz de inteiros de 32 bits.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O número de elementos na `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>. Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) a operação, onde `n` é o produto de todos os valores em `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
- ou - 
A matriz <paramref name="lengths" /> contém menos de um elemento.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, params long[] lengths);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int64[] lengths) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, ParamArray lengths As Long()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, ... cli::array &lt;long&gt; ^ lengths);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int64[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz de inteiros de 64 bits que representa o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criada. Cada inteiro na matriz deve estar entre zero e <see cref="F:System.Int32.MaxValue" />, inclusive.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base zero. Os tamanhos da dimensão são especificados em uma matriz de inteiros de 64 bits.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> e comprimentos especificados para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O número de elementos na `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>. Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) a operação, onde `n` é o produto de todos os valores em `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance3 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
- ou - 
A matriz <paramref name="lengths" /> contém menos de um elemento.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero ou maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length1">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length2">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> bidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação com base zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) a operação, onde `n` é o produto dos `length1` e `length2`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um bidimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> é menor que zero.  
  
- ou - 
 <paramref name="length2" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int[] lengths, int[] lowerBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32[] lengths, int32[] lowerBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32[],System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, lengths As Integer(), lowerBounds As Integer()) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, cli::array &lt;int&gt; ^ lengths, cli::array &lt;int&gt; ^ lowerBounds);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int[] * int[] -&gt; Array" Usage="System.Array.CreateInstance (elementType, lengths, lowerBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="lengths" Type="System.Int32[]" />
        <Parameter Name="lowerBounds" Type="System.Int32[]" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lengths">Uma matriz unidimensional que contém o tamanho de cada dimensão do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="lowerBounds">Uma matriz unidimensional que contém o limite inferior (índice inicial) de cada dimensão do <see cref="T:System.Array" /> a ser criado.</param>
        <summary>Cria um <see cref="T:System.Array" /> multidimensional com o <see cref="T:System.Type" /> especificado e com os tamanhos da dimensão, com os limites inferiores especificados.</summary>
        <returns>Um novo <see cref="T:System.Array" /> multidimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado e o limite inferior de cada dimensão.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 O `lengths` e `lowerBounds` matrizes devem ter o mesmo número de elementos. O número de elementos na `lengths` matriz deve ser igual ao número de dimensões no novo <xref:System.Array>.  
  
 Cada elemento do `lengths` matriz deve especificar o comprimento da dimensão correspondente no novo <xref:System.Array>.  
  
 Cada elemento do `lowerBounds` matriz deve especificar o limite inferior da dimensão correspondente no novo <xref:System.Array>. Em geral, a biblioteca de classes do .NET Framework e várias linguagens de programação não lidam com limites inferiores do diferente de zero.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) a operação, onde `n` é o produto de todos os valores em `lengths`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um multidimensional <xref:System.Array> com limites inferiores especificados.  
  
 [!code-cpp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance4 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="lengths" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="lowerBounds" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.  
  
- ou - 
A matriz <paramref name="lengths" /> contém menos de um elemento.  
  
- ou - 
As matrizes <paramref name="lengths" /> e <paramref name="lowerBounds" /> não contêm o mesmo número de elementos.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer valor em <paramref name="lengths" /> é menor que zero.  
  
- ou - 
Qualquer valor em <paramref name="lowerBounds" /> é muito grande, de modo que a soma do limite inferior e do tamanho de uma dimensão é maior que <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static Array CreateInstance (Type elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Array CreateInstance(class System.Type elementType, int32 length1, int32 length2, int32 length3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.CreateInstance(System.Type,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (elementType As Type, length1 As Integer, length2 As Integer, length3 As Integer) As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Array ^ CreateInstance(Type ^ elementType, int length1, int length2, int length3);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * int * int * int -&gt; Array" Usage="System.Array.CreateInstance (elementType, length1, length2, length3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementType" Type="System.Type" />
        <Parameter Name="length1" Type="System.Int32" />
        <Parameter Name="length2" Type="System.Int32" />
        <Parameter Name="length3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="elementType">O <see cref="T:System.Type" /> do <see cref="T:System.Array" /> a ser criado.</param>
        <param name="length1">O tamanho da primeira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length2">O tamanho da segunda dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <param name="length3">O tamanho da terceira dimensão do <see cref="T:System.Array" /> a ser criada.</param>
        <summary>Cria um <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> e comprimentos de dimensão especificados, com a indexação com base em zero.</summary>
        <returns>Um novo <see cref="T:System.Array" /> tridimensional do <see cref="T:System.Type" /> especificado com o tamanho especificado para cada dimensão, usando a indexação baseada em zero.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diferentemente da maioria das classes, <xref:System.Array> fornece o método <xref:System.Array.CreateInstance%2A>, em vez dos construtores públicos, para permitir o acesso com associação tardia.  
  
 Elementos do tipo de referência são inicializados como `null`. Os elementos do tipo de valor são inicializados em zero.  
  
 Esse método é um O (`n`) a operação, onde `n` é o produto dos `length1`, `length2`, e `length3`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como criar e inicializar um tridimensional <xref:System.Array>.  
  
 [!code-cpp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.CreateInstance2 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.CreateInstance2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.CreateInstance2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="elementType" /> não é um <see cref="T:System.Type" /> válido.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="elementType" /> não é suportado. Por exemplo, <see cref="T:System.Void" /> não é suportado.  
  
- ou - 
 <paramref name="elementType" /> é um tipo genérico aberto.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length1" /> é menor que zero.  
  
- ou - 
 <paramref name="length2" /> é menor que zero.  
  
- ou - 
 <paramref name="length3" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <Member MemberName="Empty&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] Empty&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] Empty&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Empty``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Empty(Of T) () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ Empty();" />
      <MemberSignature Language="F#" Value="static member Empty : unit -&gt; 'T[]" Usage="System.Array.Empty " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <summary>Retorna uma matriz vazia.</summary>
        <returns>Uma matriz vazia.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exists&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool Exists&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Exists&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exists(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool Exists(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Exists : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.Exists (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Determina se a matriz especificada contém elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns><see langword="true" /> se <paramref name="array" /> contiver um ou mais elementos que correspondem às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>, e o processamento é interrompido quando uma correspondência for encontrada.  
  
> [!NOTE]
>  Em c# e Visual Basic, não é necessário criar o <xref:System.Predicate%601> delegado explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir especifica as condições de correspondência para o <xref:System.Array.Exists%2A> expressões de usinglambda de método para verificar se um planeta começa com determinada letra ou se o planeta for encontrado na matriz fornecida.  
  
 [!code-csharp[System.Array.Exists#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists3.cs#3)]
 [!code-vb[System.Array.Exists#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists3.vb#3)]  
  
 O exemplo a seguir usa o <xref:System.Array.Exists%2A> método para indicar se todos os nomes em uma matriz de cadeia de caracteres começam com um caractere especificado. O exemplo instancia um `StringSearcher` objeto, passando a cadeia de caracteres a ser pesquisado para o construtor de classe. O `StringSearcher.StartsWith` método tem a mesma assinatura que o <xref:System.Predicate%601> delegar. Quando o <xref:System.Array.Exists%2A> método é chamado, cada membro da matriz é passado para o delegado até ele retornar `true` ou itera todos os elementos na matriz.  
  
 [!code-csharp[System.Array.Exists#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists1.cs#1)]
 [!code-vb[System.Array.Exists#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists1.vb#1)]  
  
 Você pode também usar uma expressão lambda em vez de definir explicitamente um método cuja assinatura corresponde do representante. O exemplo a seguir substitui o `StringSearcher` classe e seu `StartsWith` método com uma expressão lambda.  
  
 [!code-csharp[System.Array.Exists#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.exists/cs/exists2.cs#2)]
 [!code-vb[System.Array.Exists#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.exists/vb/exists2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
        <related type="Article" href="~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md">Expressões lambda (Guia de Programação em C#)</related>
        <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md">Expressões lambda (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T -&gt; unit" Usage="System.Array.Fill (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Fill&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Fill&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Fill&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Fill``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Fill(Of T) (array As T(), value As T, startIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Fill(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member Fill : 'T[] * 'T * int * int -&gt; unit" Usage="System.Array.Fill (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="value">To be added.</param>
        <param name="startIndex">To be added.</param>
        <param name="count">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Find&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T Find&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T Find&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Find(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T Find(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member Find : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.Find (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="match">O predicado que define as condições do elemento a ser pesquisado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O primeiro elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um delegado para um método ou uma expressão lambda que retorna `true` se o objeto passado para ele corresponda às condições definidas na expressão de delegado ou lambda.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>, começando com o primeiro elemento e terminando com o último elemento.  O processamento é interrompido quando uma correspondência for encontrada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir usa uma <xref:System.Predicate%601> delegado com o <xref:System.Array.Find%2A> método genérico para pesquisar uma matriz de <xref:System.Drawing.Point> estruturas. O método que o delegado representa, `ProductGT10`, retorna `true` se o produto dos campos X e Y for maior que 100.000. O <xref:System.Array.Find%2A> método chama o delegado para cada elemento da matriz, retornando o primeiro ponto que atenda à condição de teste.  
  
> [!NOTE]
>  Visual Basic e c# que os usuários não é necessário que criar o delegado explicitamente ou especificar o argumento de tipo do método genérico. Os compiladores de determinam os tipos necessários dos argumentos de método que você fornecer.  
  
 [!code-csharp[System.Array.Find#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/source.cs#1)]
 [!code-vb[System.Array.Find#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/source.vb#1)]  
  
 Em vez de definir explicitamente um método com a assinatura necessária, criando uma instância de um <xref:System.Predicate%601> delegar e passando o delegado para o <xref:System.Array.Find%2A> método, é comum usar uma expressão lambda. O exemplo a seguir é idêntico ao anterior, exceto que ele usa uma expressão lambda como o `match` argumento.  
  
 [!code-csharp[System.Array.Find#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.find/cs/lambda.cs#2)]
 [!code-vb[System.Array.Find#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.find/vb/lambda.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T[] FindAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T[] FindAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindAll(Of T) (array As T(), match As Predicate(Of T)) As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static cli::array &lt;T&gt; ^ FindAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindAll : 'T[] * Predicate&lt;'T&gt; -&gt; 'T[]" Usage="System.Array.FindAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições dos elementos a serem pesquisados.</param>
        <summary>Recupera todos os elementos que correspondem às condições definidas pelo predicado especificado.</summary>
        <returns>Um <see cref="T:System.Array" /> que contém todos os elementos que correspondem às condições definidas pelo predicado especificado, se encontrado; caso contrário, um <see cref="T:System.Array" /> vazio.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>, e os elementos que correspondem às condições são salvos na matriz retornada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir cria uma matriz de números aleatórios 50 com valores que podem variar de 0 a 1.000. Em seguida, ele chama o <xref:System.Array.FindAll%2A> método com uma expressão lambda que retorna os valores que variam de 300 a 600. Observe que a expressão lambda é passada um parâmetro chamado `x`;  Isso representa o membro individuais da matriz que é passado para o <xref:System.Predicate%601>. Observe também que o local `lBound` e `uBound` variáveis são acessíveis dentro da expressão lambda.  
  
 [!code-csharp[System.Array.FindAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.findall/cs/findall.cs#1)]
 [!code-vb[System.Array.FindAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.findall/vb/findall.vb#1)]  
  
 O exemplo de código a seguir demonstra a <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.Find%2A> método genérico percorre a matriz desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final. Ele localiza o elemento "Dilophosaurus" na posição 5. O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam com "saurus". Os elementos são exibidos.  
  
 O exemplo de código também demonstra a <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da primeira ocorrência em um <see cref="T:System.Array" /> ou parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para frente, começando no primeiro elemento e termina no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continuando até o final da matriz. Ele localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do índice especificado ao último elemento.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para frente, começando em `startIndex` e terminando no último elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos da `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continuando até o final da matriz. Ele localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que coincida com as condições definidas pelo predicado especificado e retorna o índice baseado em zero da primeira ocorrência dentro do intervalo de elementos na <see cref="T:System.Array" /> que começa no índice especificado e contém o número de elementos especificado.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para frente, começando em `startIndex` e termina em `startIndex` plus `count` menos 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 1.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 2 e continuando até o final da matriz. Ele localiza o elemento na posição 5. Por fim, o <xref:System.Array.FindIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos, começando na posição 2. Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindIndex/cs/source.cs#1)]
 [!code-vb[Array_FindIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLast&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T FindLast&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T FindLast&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLast(Of T) (array As T(), match As Predicate(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T FindLast(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLast : 'T[] * Predicate&lt;'T&gt; -&gt; 'T" Usage="System.Array.FindLast (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponda às condições definidas pelo predicado especificado e retorna a primeira ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O último elemento que corresponde às condições definidas pelo predicado especificado, se encontrado; caso contrário, o valor padrão para o tipo <paramref name="T" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>, movendo para trás no <xref:System.Array>, começando com o último elemento e terminando com o primeiro elemento.  O processamento é interrompido quando uma correspondência for encontrada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Find%2A>, <xref:System.Array.FindLast%2A>, e <xref:System.Array.FindAll%2A> métodos genéricos. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.Find%2A> método genérico percorre a matriz desde o início, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa para quando o método `EndsWithSaurus` retorna `true` para o elemento "Amargasaurus".  
  
> [!NOTE]
>  Em c# e Visual Basic, não é necessário criar a`Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLast%2A> método genérico é usado para pesquisar a matriz com versões anteriores do final. Ele localiza o elemento "Dilophosaurus" na posição 5. O <xref:System.Array.FindAll%2A> método genérico é usado para retornar uma matriz que contém todos os elementos que terminam com "saurus". Os elementos são exibidos.  
  
 O exemplo de código também demonstra a <xref:System.Array.Exists%2A> e <xref:System.Array.TrueForAll%2A> métodos genéricos.  
  
 [!code-cpp[Array_FindEtAl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindEtAl/cpp/source.cpp#1)]
 [!code-csharp[Array_FindEtAl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindEtAl/cs/source.cs#1)]
 [!code-vb[Array_FindEtAl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindEtAl/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <MemberGroup MemberName="FindLastIndex&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa um elemento que corresponda às condições definidas por um predicado especificado e retorna o índice baseado em zero da última ocorrência em um <see cref="T:System.Array" /> ou parte dele.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência em toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice de base zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para trás começando no último elemento e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz com versões anteriores do final, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continua para trás até o início da matriz. Ele localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e trabalhando para trás (ou seja, elementos 2, 3 e 4). Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa um elemento que corresponde às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice de base zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz com versões anteriores do final, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continua para trás até o início da matriz. Ele localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e trabalhando para trás (ou seja, elementos 2, 3 e 4). Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="FindLastIndex&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int FindLastIndex&lt;T&gt; (T[] array, int startIndex, int count, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 FindLastIndex&lt;T&gt;(!!T[] array, int32 startIndex, int32 count, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.FindLastIndex``1(``0[],System.Int32,System.Int32,System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FindLastIndex(Of T) (array As T(), startIndex As Integer, count As Integer, match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int FindLastIndex(cli::array &lt;T&gt; ^ array, int startIndex, int count, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member FindLastIndex : 'T[] * int * int * Predicate&lt;'T&gt; -&gt; int" Usage="System.Array.FindLastIndex (array, startIndex, count, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <param name="match">O <see cref="T:System.Predicate`1" /> que define as condições do elemento a ser procurado.</param>
        <summary>Pesquisa por um elemento que corresponda às condições definidas pelo predicado especificado e retorna o índice baseado em zero da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice de base zero da última ocorrência de um elemento que corresponde às condições definidas por <paramref name="match" />, se for encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada com versões anteriores começando `startIndex` e termina em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 O <xref:System.Predicate%601> é um representante para um método que retorna `true` caso o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas do <xref:System.Array.FindLastIndex%2A> método genérico. Uma matriz de cadeias de caracteres é criada, contendo 8 nomes de dinossauro, dois dos quais (nas posições 1 e 5) terminam com "saurus". O exemplo de código também define um método de predicado chamado `EndsWithSaurus`, que aceita um parâmetro de cadeia de caracteres e retorna um valor booliano que indica se a cadeia de caracteres de entrada termina em "saurus".  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método percorre a matriz com versões anteriores do final, passando cada elemento por sua vez para o `EndsWithSaurus` método. A pesquisa é interrompida quando o `EndsWithSaurus` retorno do método `true` para o elemento na posição 5.  
  
> [!NOTE]
>  No C# e no Visual Basic, não é necessário criar o representante `Predicate<string>` (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 O <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar a matriz, começando na posição 4 e continua para trás até o início da matriz. Ele localiza o elemento na posição 1. Por fim, o <xref:System.Array.FindLastIndex%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Predicate%7B%60%600%7D%29> sobrecarga do método é usada para pesquisar o intervalo de três elementos começando na posição 4 e trabalhando para trás (ou seja, elementos 2, 3 e 4). Ele retornará -1, porque não há nenhum nome de dinossauro no intervalo que terminam com "saurus".  
  
 [!code-cpp[Array_FindLastIndex#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_FindLastIndex/cpp/source.cpp#1)]
 [!code-csharp[Array_FindLastIndex#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_FindLastIndex/cs/source.cs#1)]
 [!code-vb[Array_FindLastIndex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_FindLastIndex/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.Find``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindLast``1(``0[],System.Predicate{``0})" />
        <altmember cref="M:System.Array.FindAll``1(``0[],System.Predicate{``0})" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="Overload:System.Array.IndexOf" />
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void ForEach&lt;T&gt; (T[] array, Action&lt;T&gt; action);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ForEach&lt;T&gt;(!!T[] array, class System.Action`1&lt;!!T&gt; action) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.ForEach``1(``0[],System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ForEach(Of T) (array As T(), action As Action(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void ForEach(cli::array &lt;T&gt; ^ array, Action&lt;T&gt; ^ action);" />
      <MemberSignature Language="F#" Value="static member ForEach : 'T[] * Action&lt;'T&gt; -&gt; unit" Usage="System.Array.ForEach (array, action)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="action" Type="System.Action&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero em cujos elementos a ação deve ser executada.</param>
        <param name="action">O <see cref="T:System.Action`1" /> a ser executado em cada elemento do <paramref name="array" />.</param>
        <summary>Executa a ação especificada em cada elemento da matriz especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Action%601> é um delegado para um método que executa uma ação no objeto passado para ele.  Os elementos de `array` são passados individualmente para o <xref:System.Action%601>.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.Array.ForEach%2A> para exibir os quadrados de cada elemento em uma matriz de inteiros.  
  
 [!code-cpp[System.Array.ForEach#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.foreach/cpp/source.cpp#1)]
 [!code-csharp[System.Array.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.foreach/cs/source.cs#1)]
 [!code-vb[System.Array.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.foreach/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="action" /> é <see langword="null" />.</exception>
        <altmember cref="T:System.Action`1" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.IEnumerator&#xA;override this.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="array.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</summary>
        <returns>Um <see cref="T:System.Collections.IEnumerator" /> para o <see cref="T:System.Array" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 [Visual Basic, C#]  
  
 A instrução `foreach` da linguagem C# (`for each` no C++, `For Each` no Visual Basic) oculta a complexidade dos enumeradores. Portanto, o uso de `foreach` é recomendado, em vez de manipular diretamente o enumerador.  
  
 Os enumeradores podem ser usados para ler os dados na coleção, mas não podem ser usados para modificar a coleção subjacente.  
  
 Inicialmente, o enumerador é posicionado antes do primeiro elemento da coleção. <xref:System.Collections.IEnumerator.Reset%2A> também traz o enumerador de volta para essa posição.  Nesta posição, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Por isso, você deve chamar <xref:System.Collections.IEnumerator.MoveNext%2A> para avançar o enumerador até o primeiro elemento da coleção antes de ler o valor de <xref:System.Collections.IEnumerator.Current%2A>.  
  
 <xref:System.Collections.IEnumerator.Current%2A> retorna o mesmo objeto até <xref:System.Collections.IEnumerator.MoveNext%2A> ou <xref:System.Collections.IEnumerator.Reset%2A> ser chamado. <xref:System.Collections.IEnumerator.MoveNext%2A> define <xref:System.Collections.IEnumerator.Current%2A> como o próximo elemento.  
  
 Caso <xref:System.Collections.IEnumerator.MoveNext%2A> passe o final da coleção, o enumerador é posicionado após o último elemento na coleção e <xref:System.Collections.IEnumerator.MoveNext%2A> retorna `false`. Quando o enumerador está nessa posição, as chamadas subsequentes para <xref:System.Collections.IEnumerator.MoveNext%2A> também retornam `false`. Caso a última chamada para <xref:System.Collections.IEnumerator.MoveNext%2A> tenha retornado `false`, <xref:System.Collections.IEnumerator.Current%2A> está indefinido. Para definir <xref:System.Collections.IEnumerator.Current%2A> como o primeiro elemento da coleção novamente, é possível chamar <xref:System.Collections.IEnumerator.Reset%2A> seguido de <xref:System.Collections.IEnumerator.MoveNext%2A>.  
  
 Um enumerador permanece válido desde que a coleção continue inalterada. Se forem feitas alterações na coleção, como adicionar, modificar ou excluir elementos, o enumerador será invalidado de maneira irrevogável e seu comportamento permanecerá indefinido.  
  
 O enumerador não tem acesso exclusivo à coleção; Portanto, enumerando através de uma coleção intrinsecamente não é um procedimento de thread-safe.  Para garantir acesso thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração.  Para permitir que a coleção seja acessada por vários threads para leitura e gravação, você deve implementar sua própria sincronização.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como usar <xref:System.Array.GetEnumerator%2A> para listar os elementos de uma matriz.  
  
 [!code-cpp[System.Array_GetEnumerator#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CPP/array_getenumerator.cpp#1)]
 [!code-csharp[System.Array_GetEnumerator#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetEnumerator/CS/array_getenumerator.cs#1)]
 [!code-vb[System.Array_GetEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetEnumerator/VB/array_getenumerator.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLength">
      <MemberSignature Language="C#" Value="public int GetLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLength (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLength : int -&gt; int" Usage="array.GetLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</param>
        <summary>Obtém um inteiro de 32 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</summary>
        <returns>Um inteiro de 32 bits que representa o número de elementos na dimensão especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um exemplo de <xref:System.Array.GetLength%2A> está `GetLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar <xref:System.Array.GetLength%2A> para exibir as dimensões de duas matrizes com diferentes classificações.  
  
 [!code-cpp[System.Array.GetLength#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getlength/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetLength#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getlength/cs/source.cs#1)]
 [!code-vb[System.Array.GetLength#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getlength/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> é menor que zero.  
  
- ou - 
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLongLength">
      <MemberSignature Language="C#" Value="public long GetLongLength (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLongLength(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLongLength(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLongLength (dimension As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long GetLongLength(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLongLength : int -&gt; int64" Usage="array.GetLongLength dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero do <see cref="T:System.Array" /> cujo comprimento precisa ser determinado.</param>
        <summary>Obtém um inteiro de 64 bits que representa o número de elementos na dimensão especificada do <see cref="T:System.Array" />.</summary>
        <returns>Um inteiro de 64 bits que representa o número de elementos na dimensão especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um exemplo de <xref:System.Array.GetLongLength%2A> está `GetLongLength(0)`, que retorna o número de elementos na primeira dimensão do <xref:System.Array>.  
  
 Este método é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> é menor que zero.  
  
- ou - 
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetLowerBound">
      <MemberSignature Language="C#" Value="public int GetLowerBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetLowerBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetLowerBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLowerBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetLowerBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetLowerBound : int -&gt; int" Usage="array.GetLowerBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero da matriz cujo índice inicial precisa ser determinado.</param>
        <summary>Obtém o índice do primeiro elemento da dimensão especificada na matriz.</summary>
        <returns>O índice do primeiro elemento da dimensão especificada na matriz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetLowerBound(0)` Retorna o índice inicial da primeira dimensão da matriz, e `GetLowerBound(Rank - 1)` retorna o índice inicial da última dimensão da matriz.  
  
 O <xref:System.Array.GetLowerBound%2A> método sempre retorna um valor que indica o índice do limite inferior da matriz, mesmo se a matriz está vazia.  
  
 Observe que, embora a maioria das matrizes no .NET Framework são baseados em zero (ou seja, o <xref:System.Array.GetLowerBound%2A> método retorna zero para cada dimensão de uma matriz), o .NET Framework oferece suporte a matrizes que não são baseados em zero. Essas matrizes podem ser criados com o <xref:System.Array.CreateInstance%28System.Type%2CSystem.Int32%5B%5D%2CSystem.Int32%5B%5D%29> método e também pode ser retornado do código não gerenciado.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> é menor que zero.  
  
- ou - 
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetUpperBound">
      <MemberSignature Language="C#" Value="public int GetUpperBound (int dimension);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetUpperBound(int32 dimension) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetUpperBound(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetUpperBound (dimension As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetUpperBound(int dimension);" />
      <MemberSignature Language="F#" Value="member this.GetUpperBound : int -&gt; int" Usage="array.GetUpperBound dimension" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dimension" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dimension">Uma dimensão com base em zero da matriz cujo limite superior precisa ser determinado.</param>
        <summary>Obtém o índice do último elemento da dimensão especificada na matriz.</summary>
        <returns>O índice do último elemento da dimensão especificada na matriz, ou -1, se a dimensão especificada estiver vazia.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `GetUpperBound(0)` Retorna o último índice na primeira dimensão da matriz, e `GetUpperBound(Rank - 1)` retorna o último índice da última dimensão da matriz.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos para exibir os limites de uma matriz unidimensional e bidimensional e exibir os valores de seus elementos de matriz.  
  
 [!code-cpp[System.Array.GetUpperBound#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.array.getupperbound/cpp/source.cpp#1)]
 [!code-csharp[System.Array.GetUpperBound#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.getupperbound/cs/source.cs#1)]
 [!code-vb[System.Array.GetUpperBound#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.getupperbound/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="dimension" /> é menor que zero.  
  
- ou - 
 <paramref name="dimension" /> é igual a ou maior que <see cref="P:System.Array.Rank" />.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém o valor do elemento especificado no <see cref="T:System.Array" /> atual.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Integer()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Uma matriz unidimensional de inteiros de 32 bits que representa os índices especificando a posição do elemento <see cref="T:System.Array" /> a se obter.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 -&gt; obj" Usage="array.GetValue index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index">Um inteiro de 64 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> unidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (ParamArray indices As Long()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64[] -&gt; obj" Usage="array.GetValue indices" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="indices">Uma matriz unidimensional de inteiros de 64 bits que representa os índices especificando a posição do elemento <see cref="T:System.Array" /> a se obter.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> multidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> bidimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Integer, index2 As Integer, index3 As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int * int * int -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index3">Um inteiro de 32 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.GetValue(System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (index1 As Long, index2 As Long, index3 As Long) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.GetValue : int64 * int64 * int64 -&gt; obj" Usage="array.GetValue (index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <param name="index3">Um inteiro de 64 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser obtido.</param>
        <summary>Obtém o valor na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <returns>O valor na posição especificada no <see cref="T:System.Array" /> tridimensional.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Este método é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.SetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="IndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Pesquisa o objeto especificado e retorna o índice da sua primeira ocorrência em uma matriz unidimensional ou em um intervalo de elementos na matriz.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" /> no <paramref name="array" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa todos os elementos de um unidimensional arrayfor `value`. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando cada elemento `Equals` método até que ele encontra uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, que a substituição é chamada.  
  
 Como a maioria das matrizes têm um limite inferior de zero, esse método geralmente retorna -1 se`value` não for encontrado. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, esse método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres da matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo se estende de um índice especificado ao final da matriz.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" />, se encontrado, no intervalo de elementos em <paramref name="array" /> que se estende de <paramref name="startIndex" /> até o último elemento; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa uma matriz unidimensional a partir do elemento no índice `startIndex` ao último elemento. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando o `Equals` método de todos os elementos até encontrar uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> método, que a substituição é chamada.  
  
 Como a maioria das matrizes têm um limite inferior de zero, esse método geralmente retorna -1 se `value` não for encontrado. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType>(0x80000000) e `value` não for encontrado, esse método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1. Se `startIndex` é maior que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos da `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres da matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public static int IndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int IndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <param name="count">O número de elementos a serem pesquisados.</param>
        <summary>Pesquisa pelo objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo estende-se de um índice especificado a um número especificado de elementos.</summary>
        <returns>O índice da primeira ocorrência de <paramref name="value" />, se encontrado no <paramref name="array" /> do índice de <paramref name="startIndex" /> a <paramref name="startIndex" /> + <paramref name="count" /> -1; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa os elementos de um unidimensional arrayfrom `startIndex` à `startIndex` plus `count` menos 1, se `count` for maior que 0. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando o `Equals` método de todos os elementos até encontrar uma correspondência. Isso significa que, se o elemento substitui o <xref:System.Object.Equals%2A?displayProperty=nameWithType> método, que a substituição é chamada.  
  
 As matrizes de Becausemost têm um limite inferior de zero, geralmente, esse método retorna-1 quando `value` não for encontrado. No caso raro em que o limite inferior da matriz é igual a <xref:System.Int32.MinValue?displayProperty=nameWithType> (0x80000000) e `value` não for encontrado, esse método retorna <xref:System.Int32.MaxValue?displayProperty=nameWithType> (0x7FFFFFFF).  
  
 Se `startindex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1. Se `startIndex` é maior que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo chama as seguintes três sobrecargas do <xref:System.Array.IndexOf%2A> método para localizar o índice de uma cadeia de caracteres em uma matriz de cadeia de caracteres:  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" na quarta para os últimos elementos de uma matriz de cadeia de caracteres.  
  
-   <xref:System.Array.IndexOf%28System.Array%2CSystem.Object%2CSystem.Int32%2CSystem.Int32%29>, para determinar a primeira ocorrência da cadeia de caracteres "a" em uma cadeia de caracteres da matriz do elemento que segue a última correspondência bem-sucedida ao final da matriz. Para determinar o valor da `count` argumento, ele subtrai o limite superior da matriz do índice inicial e adiciona um.  
  
 [!code-cpp[Classic Array.IndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.IndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.IndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.IndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.IndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da primeira ocorrência em uma matriz unidimensional.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa todos os elementos de uma matriz unidimensional para `value`. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando o `T.Equals` método em cada elemento. Isso significa que, se `T` substitui o <xref:System.Object.Equals%2A> método, que a substituição é chamada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com o local do índice 3 e continua até o final da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo se estende de um índice especificado ao final da matriz.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos em <paramref name="array" /> que se estende do <paramref name="startIndex" /> ao último elemento, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método pesquisa uma matriz unidimensional do elemento no `startIndex` até o final da matriz. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando o `T.Equals` método em cada elemento. Isso significa que, se `T` substitui o <xref:System.Object.Equals%2A> método, que a substituição é chamada.  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A>, o método retorna - 1.If `startIndex` é maior que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos da `startIndex` ao final da `array`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com o local do índice 3 e continua até o final da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="IndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int IndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 IndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.IndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int IndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member IndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.IndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional, baseada em zero, a ser pesquisada.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa. 0 (zero) é válido em uma matriz vazia.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado em um intervalo de elementos de uma matriz unidimensional e retorna o índice da primeira ocorrência. O intervalo estende-se de um índice especificado a um número especificado de elementos.</summary>
        <returns>O índice baseado em zero da primeira ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que começa em <paramref name="startIndex" /> e que contém o número de elementos especificados no <paramref name="count" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Elementos de searchesthe esse método de uma matriz unidimensional do `startIndex` à `startIndex` plus `count` menos 1, se `count` for maior que 0. Para determinar se `value` existe na `array`, o método executa uma comparação de igualdade chamando o `T.Equals` método em cada elemento. Isso significa que, se `T` substitui o <xref:System.Object.Equals%2A> método, que a substituição é chamada.  
  
 Se `startIndex` é igual a <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método retornará -1.  Se `startIndex` é maior que <xref:System.Array.Length%2A?displayProperty=nameWithType>, o método lança um <xref:System.ArgumentOutOfRangeException>.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.IndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz desde o início e localiza a primeira ocorrência da cadeia de caracteres. O <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com o local do índice 3 e continua até o final da matriz e localiza a segunda ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.IndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de duas entradas, começando no local de índice dois; ele retornará -1, porque não há nenhuma instância da cadeia de caracteres de pesquisa nesse intervalo.  
  
 [!code-cpp[Array_IndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_IndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_IndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_IndexOf/cs/source.cs#1)]
 [!code-vb[Array_IndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_IndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.LastIndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="public void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Initialize" />
      <MemberSignature Language="VB.NET" Value="Public Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Initialize();" />
      <MemberSignature Language="F#" Value="member this.Initialize : unit -&gt; unit" Usage="array.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa todos os elementos do tipo de valor <see cref="T:System.Array" /> chamando o construtor padrão do tipo de valor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método foi projetado para ajudar a compiladores suporte a matrizes de tipo de valor; a maioria dos usuários não é necessário para esse método. Ela não deve ser usada em matrizes de tipo de referência.  
  
 Se o <xref:System.Array> não é um tipo de valor <xref:System.Array> ou se o tipo de valor não tem um construtor padrão, o <xref:System.Array> não será modificado.  
  
 O tipo de valor <xref:System.Array> pode ter qualquer limite inferior e qualquer número de dimensões.  
  
 Este método é uma operação O(`n`), em que `n` é <xref:System.Array.Length%2A>.  
  
> [!CAUTION]
>  Você pode usar esse método somente nos tipos de valor que têm construtores; No entanto, os tipos de valor são nativos no c# não tem construtores.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFixedSize">
      <MemberSignature Language="C#" Value="public bool IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsFixedSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFixedSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFixedSize : bool" Usage="System.Array.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Array" /> tem um tamanho fixo.</summary>
        <value>Esta propriedade é sempre <see langword="true" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa o <xref:System.Array.IsFixedSize%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Uma matriz com um tamanho fixo não permite a adição ou remoção de elementos após a matriz é criada, mas permite a modificação de elementos existentes.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
      </Docs>
    </Member>
    <Member MemberName="IsReadOnly">
      <MemberSignature Language="C#" Value="public bool IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReadOnly : bool" Usage="System.Array.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o <see cref="T:System.Array" /> é somente leitura.</summary>
        <value>Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa o <xref:System.Array.IsReadOnly%2A> propriedade porque ele é necessário para o <xref:System.Collections.IList?displayProperty=nameWithType> interface. Uma matriz que é somente leitura não permite a adição, remoção ou modificação de elementos após a matriz é criada.  
  
 Se você precisar de uma coleção somente leitura, use uma <xref:System.Collections> classe que implementa o <xref:System.Collections.IList?displayProperty=nameWithType> interface.  
  
 Se você converter ou converter uma matriz para um <xref:System.Collections.IList> objeto de interface, o <xref:System.Collections.IList.IsReadOnly%2A?displayProperty=nameWithType> propriedade retorna `false`. No entanto, se você converter ou converter uma matriz para um <xref:System.Collections.Generic.IList%601> interface, o `IsReadOnly` propriedade retorna `true`.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="N:System.Collections" />
        <altmember cref="T:System.Collections.Generic.IList`1" />
        <altmember cref="N:System.Collections.Generic" />
      </Docs>
    </Member>
    <Member MemberName="IsSynchronized">
      <MemberSignature Language="C#" Value="public bool IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.IsSynchronized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSynchronized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSynchronized : bool" Usage="System.Array.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o acesso à <see cref="T:System.Array" /> é sincronizado (thread-safe).</summary>
        <value>Esta propriedade é sempre <see langword="false" /> para todas as matrizes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Array> implementa o <xref:System.Array.IsSynchronized%2A> propriedade porque ele é necessário para o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada da coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 Classes que usam matrizes também podem implementar sua própria sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificação da coleção. Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.  
  
 Enumeração por meio de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear uma matriz durante toda a enumeração por meio de <xref:System.Array.SyncRoot%2A> propriedade.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.SyncRoot" />
        <altmember cref="T:System.Collections.ICollection" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LastIndexOf">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna o índice da última ocorrência de um valor em um <see cref="T:System.Array" /> unidimensional ou em uma parte do <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" /> unidimensional.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> na <paramref name="array" /> inteira, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> é pesquisado para trás começando no último elemento e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria-1 quando `value` não foi encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
 <xref:System.IComparable.CompareTo%2A> métodos do `item` parâmetro nos objetos na coleção.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial da pesquisa inversa.</param>
        <summary>Procura o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos no <see cref="T:System.Array" /> unidimensional que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que se estende do primeiro elemento a <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria-1 quando `value` não foi encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz.  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf">
      <MemberSignature Language="C#" Value="public static int LastIndexOf (Array array, object value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf(class System.Array array, object value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf(System.Array,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int LastIndexOf(Array ^ array, System::Object ^ value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : Array * obj * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência no intervalo de elementos no <see cref="T:System.Array" /> unidimensional que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice da última ocorrência de <paramref name="value" /> no intervalo de elementos em <paramref name="array" /> que contém o número de elementos especificado em <paramref name="count" /> e termina em <paramref name="startIndex" />, se encontrado; caso contrário, o limite inferior da matriz menos 1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Unidimensional <xref:System.Array> é pesquisada com versões anteriores começando `startIndex` e termina em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Se o tipo de elemento for um tipo não intrínseco (definido pelo usuário), o`Equals` implementação desse tipo é usada.  
  
 Como a maioria das matrizes terá um limite inferior de zero, esse método normalmente retornaria-1 quando `value` não foi encontrado. No caso raro do limite inferior da matriz ser igual ao <xref:System.Int32.MinValue?displayProperty=nameWithType> e `value` não ser encontrado, esse método retornará <xref:System.Int32.MaxValue?displayProperty=nameWithType>, que é `System.Int32.MinValue - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
 No .NET Framework versão 2.0, esse método usa os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do <xref:System.Array> para determinar se o <xref:System.Object> especificado pelo parâmetro `value` existe. Em versões anteriores do .NET Framework, essa determinação foi feita usando-se os métodos <xref:System.Object.Equals%2A> e <xref:System.IComparable.CompareTo%2A> do próprio `value`<xref:System.Object>.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como determinar o índice da última ocorrência de um elemento especificado em uma matriz. Observe que o <xref:System.Array.LastIndexOf%2A> método é uma pesquisa com versões anteriores; portanto, `count` deve ser menor ou igual a (`startIndex` menos o limite inferior da matriz mais 1).  
  
 [!code-cpp[Classic Array.LastIndexOf Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.LastIndexOf Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/CS/source.cs#1)]
 [!code-vb[Classic Array.LastIndexOf Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.LastIndexOf Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T -&gt; int" Usage="System.Array.LastIndexOf (array, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência dentro de toda a <see cref="T:System.Array" />.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> em todo o <paramref name="array" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisado para trás começando no último elemento e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com versões anteriores com o local do índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna -1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <summary>Procura o objeto especificado e retorna o índice da última ocorrência dentro do intervalo de elementos em <see cref="T:System.Array" /> que se estende do primeiro elemento ao índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos em <paramref name="array" /> que se estende do primeiro elemento até <paramref name="startIndex" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada começando com versões anteriores em `startIndex` e terminando no primeiro elemento.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Esse método é um O (`n`) a operação, onde `n` é o número de elementos desde o início do `array` para `startIndex`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com versões anteriores com o local do índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna -1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="LastIndexOf&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static int LastIndexOf&lt;T&gt; (T[] array, T value, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 LastIndexOf&lt;T&gt;(!!T[] array, !!T value, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.LastIndexOf``1(``0[],``0,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LastIndexOf(Of T) (array As T(), value As T, startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static int LastIndexOf(cli::array &lt;T&gt; ^ array, T value, int startIndex, int count);" />
      <MemberSignature Language="F#" Value="static member LastIndexOf : 'T[] * 'T * int * int -&gt; int" Usage="System.Array.LastIndexOf (array, value, startIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="value" Type="T" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero, a ser procurado.</param>
        <param name="value">O objeto a ser localizado em <paramref name="array" />.</param>
        <param name="startIndex">O índice inicial com base em zero da pesquisa inversa.</param>
        <param name="count">O número de elementos na seção a ser pesquisada.</param>
        <summary>Pesquisa o objeto especificado e retorna o índice da última ocorrência no intervalo de elementos na <see cref="T:System.Array" /> que contém o número de elementos especificado e termina no índice especificado.</summary>
        <returns>O índice baseado em zero da última ocorrência de <paramref name="value" /> dentro do intervalo de elementos no <paramref name="array" /> que contém o número de elementos especificado em <paramref name="count" /> e termina no <paramref name="startIndex" />, se encontrado; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Array> é pesquisada com versões anteriores começando `startIndex` e termina em `startIndex` menos `count` mais 1, se `count` for maior que 0.  
  
 Os elementos são comparados com o valor especificado usando-se o método <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Caso o tipo de elemento seja um tipo não intrínseco (definido pelo usuário), a implementação de `Equals` desse tipo é usada.  
  
 Este método é uma operação O(`n`), em que `n` é `count`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra todas as três sobrecargas genéricas do <xref:System.Array.LastIndexOf%2A> método. Uma matriz de cadeias de caracteres é criada, com uma entrada exibida duas vezes, no local do índice 0 e no local do índice 5. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga do método procura a matriz inteira do final e localiza a segunda ocorrência da cadeia de caracteres. O <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar a matriz, começando com versões anteriores com o local do índice 3 e continuando até o início da matriz e localiza a primeira ocorrência da cadeia de caracteres. Por fim, o <xref:System.Array.LastIndexOf%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Int32%2CSystem.Int32%29> sobrecarga do método é usada para pesquisar um intervalo de quatro entradas, começando no local de índice 4 e estender para trás (ou seja, ele pesquisa os itens nos locais 4, 3, 2 e 1); essa pesquisa retorna -1, porque não há nenhuma instância da pesquisa cadeia de caracteres nesse intervalo.  
  
 [!code-cpp[Array_LastIndexOf#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_LastIndexOf/cpp/source.cpp#1)]
 [!code-csharp[Array_LastIndexOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_LastIndexOf/cs/source.cs#1)]
 [!code-vb[Array_LastIndexOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_LastIndexOf/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex" /> está fora do intervalo de índices válidos para <paramref name="array" />.  
  
- ou - 
 <paramref name="count" /> é menor que zero.  
  
- ou - 
 <paramref name="startIndex" /> e <paramref name="count" /> não especificam uma seção válida em <paramref name="array" />.</exception>
        <altmember cref="Overload:System.Array.IndexOf" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Array.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Array.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</summary>
        <value>O número total de elementos em todas as dimensões do <see cref="T:System.Array" />; zero se não houver elementos na matriz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Array.Length%2A> propriedade para obter o número total de elementos em uma matriz. Ele também usa o <xref:System.Array.GetUpperBound%2A> método para determinar o número de elementos em cada dimensão de uma matriz multidimensional.  
  
 [!code-csharp[System.Array.Length#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.length/cs/length1.cs#1)]
 [!code-vb[System.Array.Length#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.length/vb/length1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">A matriz é multidimensional e contém mais de <see cref="F:System.Int32.MaxValue" /> elementos.</exception>
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="LongLength">
      <MemberSignature Language="C#" Value="public long LongLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 LongLength" />
      <MemberSignature Language="DocId" Value="P:System.Array.LongLength" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LongLength As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long LongLength { long get(); };" />
      <MemberSignature Language="F#" Value="member this.LongLength : int64" Usage="System.Array.LongLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</summary>
        <value>Um inteiro de 64 bits que representa o número total de elementos em todas as dimensões do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
        <altmember cref="P:System.Array.Length" />
        <altmember cref="P:System.Collections.ICollection.Count" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="Rank">
      <MemberSignature Language="C#" Value="public int Rank { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Rank" />
      <MemberSignature Language="DocId" Value="P:System.Array.Rank" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Rank As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Rank { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Rank : int" Usage="System.Array.Rank" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a classificação (número de dimensões) do <see cref="T:System.Array" />. Por exemplo, uma matriz unidimensional retorna 1, uma matriz bidimensional retorna 2 e assim por diante.</summary>
        <value>A classificação (número de dimensões) do <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Por exemplo, o código do Visual Basic  
  
```vb  
Dim TDArray(0,0,0) As Integer  
```  
  
 e o código c#  
  
```csharp  
int[,,] TDArray = new int[1,1,1];  
```  
  
 criar uma matriz de três dimensões com um <xref:System.Array.Rank%2A> propriedade cujo valor é 3.  
  
 Uma matriz denteada (uma matriz de matrizes) é uma matriz unidimensional; o valor do seu <xref:System.Array.Rank%2A> propriedade é 1.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo a seguir inicializa uma matriz unidimensional, uma matriz bidimensional e uma matriz denteada e recupera o <xref:System.Array.Rank%2A> propriedade de cada um.  
  
 [!code-csharp[System.Array.Rank#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.rank/cs/rank1.cs#1)]
 [!code-vb[System.Array.Rank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.rank/vb/rank1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.Length" />
        <altmember cref="M:System.Array.GetLength(System.Int32)" />
        <altmember cref="P:System.Array.LongLength" />
        <altmember cref="M:System.Array.GetLongLength(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Resize&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Resize&lt;T&gt; (ref T[] array, int newSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Resize&lt;T&gt;(!!T[]&amp; array, int32 newSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Resize``1(``0[]@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Resize(Of T) (ByRef array As T(), newSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Resize(cli::array &lt;T&gt; ^ % array, int newSize);" />
      <MemberSignature Language="F#" Value="static member Resize :  * int -&gt; unit" Usage="System.Array.Resize (array, newSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" RefType="ref" />
        <Parameter Name="newSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">A matriz unidimensional baseada em zero a ser redimensionada, ou <see langword="null" /> para criar uma nova matriz com o tamanho especificado.</param>
        <param name="newSize">O tamanho da nova matriz.</param>
        <summary>Altera o número de elementos de uma matriz unidimensional para o novo tamanho especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método aloca uma nova matriz com o tamanho especificado, copia os elementos da matriz antiga para o novo e, em seguida, substitui o array antigo pelo novo. `array` deve ser uma matriz unidimensional.  
  
 Se `array` é `null`, esse método cria uma nova matriz com o tamanho especificado.  
  
 Se `newSize` é maior que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz está alocada e todos os elementos são copiados da matriz antiga para o novo.  Se `newSize` é menor do que o <xref:System.Array.Length%2A> da matriz antiga, uma nova matriz está alocada e elementos são copiados da matriz antiga para o novo até que um novo é preenchido; o restante dos elementos na matriz antigo são ignorados.  Se `newSize` é igual ao <xref:System.Array.Length%2A> da matriz antiga, esse método não faz nada.  
  
 Este método é uma operação O(`n`), em que `n` é `newSize`.  
  
 O <xref:System.Array.Resize%2A> método redimensiona apenas uma matriz unidimensional. O <xref:System.Array> classe não inclui um método de redimensionamento de matrizes multidimensionais. Para fazer isso, você deve fornecer seu próprio código ou chamar um método especial em uma biblioteca de terceiros. O código a seguir ilustra uma possível implementação de um método que redimensiona uma matriz de *n* dimensões.  
  
 [!code-csharp[System.Array.Resize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/resizexd.cs#2)]
 [!code-vb[System.Array.Resize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/resizexd.vb#2)]  
  
   
  
## Examples  
 O exemplo a seguir mostra como redimensionar afeta a matriz.  
  
 [!code-cpp[System.Array.Resize#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Resize/CPP/System.Array.Resize.cpp#1)]
 [!code-csharp[System.Array.Resize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Resize/CS/arrayresize.cs#1)]
 [!code-vb[System.Array.Resize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Resize/VB/arrayresize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="newSize" /> é menor que zero.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Reverse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inverte a ordem dos elementos em um <see cref="T:System.Array" /> unidimensional ou em uma parte do <see cref="T:System.Array" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser invertido.</param>
        <summary>Inverte a sequência dos elementos em todo o <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` é qualquer índice na matriz, move para a `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 Como mostra o exemplo a seguir, o <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada. Inicializa uma matriz denteada com um elemento para cada mês do ano atual no calendário da cultura atual. Cada elemento contém uma matriz com tantos elementos como mês tem dias. O exemplo exibe o conteúdo da matriz, chama o <xref:System.Array.Reverse%2A> método e, em seguida, exibe o conteúdo da matriz invertida.  
  
 [!code-csharp[System.Array.Reverse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.reverse/cs/reversejagged.cs#1)]
 [!code-vb[System.Array.Reverse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.reverse/vb/reversejagged.vb#1)]  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como reverter a classificação dos valores em um <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse">
      <MemberSignature Language="C#" Value="public static void Reverse (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reverse(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : Array * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser invertido.</param>
        <param name="index">O índice inicial da seção a ser invertido.</param>
        <param name="length">O número de elementos na seção a ser invertida.</param>
        <summary>Inverte a sequência dos elementos em toda gama de elementos no <see cref="T:System.Array" /> unidimensional.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Após uma chamada para esse método, o elemento no `myArray[i]`, onde `i` é qualquer índice na matriz, move para a `myArray[j]`, onde `j` é igual a `(myArray.Length + myArray.GetLowerBound(0)) - (i - myArray.GetLowerBound(0)) - 1`.  
  
 O <xref:System.Array.Reverse%2A> método pode ser usado para reverter uma matriz denteada.  
  
 Este método é uma operação O(`n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como reverter a classificação dos valores em um intervalo de elementos em um <xref:System.Array>.  
  
 [!code-cpp[Classic Array.Reverse1 Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Array.Reverse1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/CS/source.cs#1)]
 [!code-vb[Classic Array.Reverse1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Array.Reverse1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] -&gt; unit" Usage="System.Array.Reverse array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Reverse&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Reverse&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Reverse&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Reverse``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Reverse(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Reverse(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Reverse : 'T[] * int * int -&gt; unit" Usage="System.Array.Reverse (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="array">To be added.</param>
        <param name="index">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define o elemento especificado no <see cref="T:System.Array" /> atual para o valor especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index">Um inteiro de 32 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params int[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;int&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int32[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="indices">Uma matriz unidimensional de inteiros de 32 bits que representam os índices que especificam a posição do elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 -&gt; unit" Usage="array.SetValue (value, index)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index">Um inteiro de 64 bits que representa a posição do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> unidimensional. O índice é especificado como um inteiro de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se o valor `index` está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> está fora do intervalo de índices válidos para o <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, params long[] indices);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64[] indices) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, ParamArray indices As Long())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, ... cli::array &lt;long&gt; ^ indices);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64[] -&gt; unit" Usage="array.SetValue (value, indices)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="indices" Type="System.Int64[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="indices">Uma matriz unidimensional de inteiros de 64 bits que representam os índices que especificam a posição do elemento a ser definido.</param>
        <summary>Define um valor para o elemento na posição especificada na <see cref="T:System.Array" /> multidimensional. Os índices são especificados como uma matriz de inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O número de elementos em `indices` deve igual ao número de dimensões no <xref:System.Array>. Todos os elementos na matriz `indices` devem especificar coletivamente a posição do elemento desejado no <xref:System.Array> multidimensional.  
  
 O <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> métodos podem determinar se qualquer um dos valores a `indices` matriz está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="indices" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">O número de dimensões no <see cref="T:System.Array" /> atual não é igual ao número de elementos em <paramref name="indices" />.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Qualquer elemento em <paramref name="indices" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> bidimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente duas dimensões.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" />atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, int index1, int index2, int index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int32 index1, int32 index2, int32 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Integer, index2 As Integer, index3 As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, int index1, int index2, int index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int * int * int -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int32" />
        <Parameter Name="index2" Type="System.Int32" />
        <Parameter Name="index3" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 32 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 32 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index3">Um inteiro de 32 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiro de 32 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (object value, long index1, long index2, long index3);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(object value, int64 index1, int64 index2, int64 index3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.SetValue(System.Object,System.Int64,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (value As Object, index1 As Long, index2 As Long, index3 As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Object ^ value, long index1, long index2, long index3);" />
      <MemberSignature Language="F#" Value="member this.SetValue : obj * int64 * int64 * int64 -&gt; unit" Usage="array.SetValue (value, index1, index2, index3)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="index1" Type="System.Int64" />
        <Parameter Name="index2" Type="System.Int64" />
        <Parameter Name="index3" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">O novo valor do elemento especificado.</param>
        <param name="index1">Um inteiro de 64 bits que representa o índice da primeira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index2">Um inteiro de 64 bits que representa o índice da segunda dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <param name="index3">Um inteiro de 64 bits que representa o índice da terceira dimensão do elemento <see cref="T:System.Array" /> a ser definido.</param>
        <summary>Define um valor como o elemento na posição especificada no <see cref="T:System.Array" /> tridimensional. Os índices são especificados como inteiros de 64 bits.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Os métodos <xref:System.Array.GetLowerBound%2A> e <xref:System.Array.GetUpperBound%2A> podem determinar se alguns dos índices está fora dos limites.  
  
 Para obter mais informações sobre conversões, consulte <xref:System.Convert>.  
  
 Este método é uma operação O(1).  
  
> [!NOTE]
>  Caso <xref:System.Array.SetValue%2A> seja usado para atribuir `null` a um elemento de uma matriz de tipos de valor, todos os campos do elemento são inicializados em zero. O valor do elemento não é uma referência nula, e não pode ser encontrada procurando uma referência nula.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra como definir e obter um valor específico em uma matriz unidimensional ou multidimensional.  
  
 [!code-cpp[System.Array_GetSetValue#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array_GetSetValue/CPP/array_getsetvalue.cpp#1)]
 [!code-csharp[System.Array_GetSetValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array_GetSetValue/CS/array_getsetvalue.cs#1)]
 [!code-vb[System.Array_GetSetValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array_GetSetValue/VB/array_getsetvalue.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente três dimensões.</exception>
        <exception cref="T:System.InvalidCastException"><paramref name="value" /> não pode ser convertido no tipo de elemento do <see cref="T:System.Array" /> atual.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index1" /> ou <paramref name="index2" /> ou <paramref name="index3" /> está fora do intervalo de índices válidos para a dimensão correspondente do <see cref="T:System.Array" /> atual.</exception>
        <altmember cref="M:System.Array.GetLowerBound(System.Int32)" />
        <altmember cref="M:System.Array.GetUpperBound(System.Int32)" />
        <altmember cref="Overload:System.Array.GetValue" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Sort">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Classifica os elementos em uma matriz unidimensional.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : Array -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <summary>Classifica os elementos em todo um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento da `array` deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <see langword="null" /> para classificar apenas o <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores de classificação. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
- ou - 
O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.IDictionary" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">A matriz unidimensional a ser classificada.</param>
        <param name="comparer">A implementação a ser usada ao comparar elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, cada elemento da `array` deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação não diferencia maiusculas de cadeias de caracteres.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo um `ReverseComparer` classe que inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
   
  
## Examples  
 O exemplo a seguir classifica os valores em um arrayby de cadeia de caracteres usando o comparador padrão. Ele também define um personalizado <xref:System.Collections.IComparer> implementação chamada `ReverseComparer` que inverte a ordem de classificação de padrão de um objeto durante a execução de uma comparação de cadeia de caracteres diferencia maiusculas de minúsculas. Observe que a saída pode variar dependendo da cultura atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <see langword="null" /> para classificar apenas o <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica um par objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` está `null`, cada chave na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação não diferencia maiusculas de cadeias de caracteres.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo um <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `keys`.  
  
   
  
## Examples  
 O exemplo a seguir mostra como duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores de classificação. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
- ou - 
O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando com o [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que previouslythrew <see cref="T:System.ArgumentException" /> não lançará uma exceção, pois os algoritmos de inserção sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando a implementação <see cref="T:System.IComparable" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro do intervalo especificado de elementos na `array` deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <see langword="null" /> para classificar apenas o <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica um intervalo de elementos em um par de objetos <see cref="T:System.Array" /> unidirecionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves do primeiro <see cref="T:System.Array" /> usando a implementação <see cref="T:System.IComparable" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave dentro do intervalo especificado de elementos na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores de classificação. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
- ou - 
O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array array, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array array, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ array, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="array">O <see cref="T:System.Array" /> unidimensional a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> unidimensional usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, cada elemento dentro do intervalo especificado de elementos na `array` deve implementar a <xref:System.IComparable> interface devem ser capazes de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação não diferencia maiusculas de cadeias de caracteres.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo um `ReverseComparer` classe que inverte a ordem de classificação padrão para instâncias de um tipo e executa a comparação de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como classificar os valores em um <xref:System.Array> usando a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort/CPP/arraysort.cpp#1)]
 [!code-csharp[System.Array.Sort#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort/CS/arraysort.cs#1)]
 [!code-vb[System.Array.Sort#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort/VB/arraysort.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException"><paramref name="array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" />, e um ou mais elementos em <paramref name="array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort">
      <MemberSignature Language="C#" Value="public static void Sort (Array keys, Array items, int index, int length, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort(class System.Array keys, class System.Array items, int32 index, int32 length, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort(System.Array,System.Array,System.Int32,System.Int32,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort (keys As Array, items As Array, index As Integer, length As Integer, comparer As IComparer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sort(Array ^ keys, Array ^ items, int index, int length, System::Collections::IComparer ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : Array * Array * int * int * System.Collections.IComparer -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Array" />
        <Parameter Name="items" Type="System.Array" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional que contém os itens correspondentes a cada uma das chaves no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <see langword="null" /> para classificar apenas o <paramref name="keys" /><see cref="T:System.Array" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação de <see cref="T:System.Collections.IComparer" /> a ser usada durante a comparação de elementos.  
  
- ou - 
 <see langword="null" /> para usar a implementação de <see cref="T:System.IComparable" /> de cada elemento.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> unidimensionais (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando o <see cref="T:System.Collections.IComparer" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` está `null`, cada chave dentro do intervalo especificado de elementos na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable> interface devem ser capazes de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 O .NET Framework inclui predefinidos <xref:System.Collections.IComparer> implementações listados na tabela a seguir.  
  
|Implementação|Descrição|  
|--------------------|-----------------|  
|<xref:System.Collections.CaseInsensitiveComparer?displayProperty=nameWithType>|Compara dois objetos, mas executa uma comparação não diferencia maiusculas de cadeias de caracteres.|  
|<xref:System.Collections.Comparer.Default?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura atual.|  
|<xref:System.Collections.Comparer.DefaultInvariant?displayProperty=nameWithType>|Compara dois objetos usando as convenções de classificação da cultura invariável.|  
|<xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=nameWithType>|Compara dois objetos do tipo `T` usando a ordem de classificação padrão do tipo.|  
  
 Você pode também dar suporte a comparações personalizadas, fornecendo uma instância do seu próprio <xref:System.Collections.IComparer> implementação para o `comparer` parâmetro. O exemplo faz isso definindo um personalizado <xref:System.Collections.IComparer> implementação que inverte a ordem de classificação padrão e executa a comparação de cadeia de caracteres diferencia maiusculas de minúsculas.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como duas matrizes associados em que a primeira matriz contém as chaves e a segunda matriz contém os valores de classificação. As classificações são feitas usando-se a comparação padrão e uma comparação personalizada que inverte a ordem de classificação. Observe que o resultado pode variar dependendo do <xref:System.Globalization.CultureInfo> atual.  
  
 [!code-cpp[System.Array.Sort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.Sort2/CPP/arraysort2.cpp#1)]
 [!code-csharp[System.Array.Sort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.Sort2/CS/arraysort2.cs#1)]
 [!code-vb[System.Array.Sort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.Sort2/VB/arraysort2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.RankException">O <paramref name="keys" /><see cref="T:System.Array" /> é multidimensional.  
  
- ou - 
O <paramref name="items" /><see cref="T:System.Array" /> é multidimensional.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface <see cref="T:System.IComparable" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.IComparer" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] -&gt; unit" Usage="System.Array.Sort array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</param>
        <summary>Classifica os elementos em todo um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento da `array` deve implementar a <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%29> sobrecarga de método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga de método genérico. Uma matriz de cadeias de caracteres é criada, sem nenhuma ordem específica.  
  
 A matriz é exibida, classificada e exibida novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%2A> e <xref:System.Array.BinarySearch%2A> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%29> sobrecarga de método genérico, em seguida, é usada para pesquisar cadeias de caracteres de dois, que não está na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%2A> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice, se a cadeia de caracteres for encontrada e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearch#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearch/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearch#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearch/cs/source.cs#1)]
 [!code-vb[Array_SortSearch#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearch/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, cada elemento da `array` deve implementar a <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico e o <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 A matriz é exibida, classificada e exibida novamente. Matrizes devem ser classificadas para usar o <xref:System.Array.BinarySearch%2A> método.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 O <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico, em seguida, é usada para pesquisar cadeias de caracteres de dois, que não está na matriz e um que é. A matriz e o valor de retorno de <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> método são passados para o `ShowWhere` método genérico, que exibe o valor de índice, se a cadeia de caracteres for encontrada e, caso contrário, os elementos a cadeia de caracteres de pesquisa estejam entre se estivesse na matriz. O índice é negativo caso a cadeia de caracteres não seja n na matriz, logo, o método `ShowWhere` usa o complemento bit a bit (o operador ~ no C# e no Visual C++, `Xor` -1 no Visual Basic) para obter o índice do primeiro elemento na lista que é maior do que a cadeia de caracteres de pesquisa.  
  
 [!code-cpp[Array_SortSearchComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortSearchComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortSearchComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortSearchComparer/cs/source.cs#1)]
 [!code-vb[Array_SortSearchComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortSearchComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, Comparison&lt;T&gt; comparison);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, class System.Comparison`1&lt;!!T&gt; comparison) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Comparison{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), comparison As Comparison(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, Comparison&lt;T&gt; ^ comparison);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * Comparison&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, comparison)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="comparison" Type="System.Comparison&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="comparison">O <see cref="T:System.Comparison`1" /> a ser usado na comparação de elementos.</param>
        <summary>Classifica os elementos em um <see cref="T:System.Array" /> usando o <see cref="T:System.Comparison`1" /> especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Esse método usa o algoritmo de classificação introspectiva (introsort) da seguinte maneira:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra o <xref:System.Collections.Generic.List%601.Sort%28System.Comparison%7B%600%7D%29> sobrecarga de método.  
  
 O exemplo de código define um método de comparação alternativa para cadeias de caracteres, chamado `CompareDinosByLength`. Esse método funciona da seguinte maneira: Primeiro, o comparandsare testado para`null`, e uma referência nula é tratada como menor que um não-nulo. Em segundo lugar, os comprimentos de cadeia de caracteres são comparados, e a cadeia de caracteres mais é considerada como sendo maior. Em terceiro lugar, se os tamanhos forem iguais, a comparação de cadeia de caracteres comum é usada.  
  
 Uma matriz de cadeias de caracteres é criada e preenchida com quatro cadeias de caracteres, sem nenhuma ordem específica. A lista também inclui uma cadeia de caracteres vazia e uma referência nula. A lista é exibida, classificada usando um <xref:System.Comparison%601> delegado genérico que representa o `CompareDinosByLength` método e exibida novamente.  
  
 [!code-cpp[Array_SortComparison#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortComparison/cpp/source.cpp#1)]
 [!code-csharp[Array_SortComparison#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortComparison/cs/source.cs#1)]
 [!code-vb[Array_SortComparison#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortComparison/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="comparison" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">A implementação de <paramref name="comparison" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparison" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Comparison`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int -&gt; unit" Usage="System.Array.Sort (array, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a implementação de interface genérica do <see cref="T:System.IComparable`1" /> de cada elemento do <see cref="T:System.Array" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento dentro do intervalo especificado de elementos na `array` deve implementar a <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso). O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método genérico é usada para classificar os últimos três elementos da matriz, em seguida, é exibida. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico é usada com `ReverseCompare` para classificar os últimos três elementos na ordem inversa. Dinossauros minuciosamente confundidos são exibidos novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;T&gt; (T[] array, int index, int length, System.Collections.Generic.IComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;T&gt;(!!T[] array, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of T) (array As T(), index As Integer, length As Integer, comparer As IComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static void Sort(cli::array &lt;T&gt; ^ array, int index, int length, System::Collections::Generic::IComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'T[] * int * int * System.Collections.Generic.IComparer&lt;'T&gt; -&gt; unit" Usage="System.Array.Sort (array, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional baseado em zero a ser classificado.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica os elementos em um intervalo de elementos em um <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se `comparer` está `null`, cada elemento dentro do intervalo especificado de elementos na `array` deve implementar a <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todos os outros elementos no `array`.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método genérico e o <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico para um intervalo em uma matriz de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros, consiste em três herbivores seguidos de três carnivores (tyrannosaurids, para ser preciso). O <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Int32%2CSystem.Int32%29> sobrecarga de método genérico é usada para classificar os últimos três elementos da matriz, em seguida, é exibida. O <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecarga de método genérico é usada com `ReverseCompare` para classificar os últimos três elementos na ordem inversa. Dinossauros minuciosamente confundidos são exibidos novamente.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos <xref:System.Array.Sort%60%601%28%60%600%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e <xref:System.Array.BinarySearch%60%601%28%60%600%5B%5D%2C%60%600%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> não são diferentes de chamadas para seus equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo de parâmetro de tipo genérico a partir do tipo do primeiro argumento. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_SortIntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_SortIntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_SortIntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_SortIntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_SortIntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_SortIntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="array" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido em <paramref name="array" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos em <paramref name="array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] -&gt; unit" Usage="System.Array.Sort (keys, items)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém os itens correspondentes às chaves em <paramref name="keys" /> ou <see langword="null" /> para classificar somente <paramref name="keys" />.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave de `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra as sobrecargas de método genérico <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> para pares de matrizes de classificação que representam chaves e valores.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <altmember cref="T:System.Collections.Generic.IDictionary`2" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém os itens correspondentes às chaves em <paramref name="keys" /> ou <see langword="null" /> para classificar somente <paramref name="keys" />.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` está `null`, cada chave na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 >,<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga e uma instância do `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int -&gt; unit" Usage="System.Array.Sort (keys, items, index, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém os itens correspondentes às chaves em <paramref name="keys" /> ou <see langword="null" /> para classificar somente <paramref name="keys" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a implementação da interface genérica <see cref="T:System.IComparable`1" /> de cada chave.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Cada chave dentro do intervalo especificado de elementos na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 >, e <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres, chamada `ReverseCompare`, que implementa a interface genérica `IComparer<string>` (`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++). A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29 > sobrecarga é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> é usada para classificar os três elementos mais recentes de ambas as matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.</exception>
        <exception cref="T:System.InvalidOperationException">Um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="Sort&lt;TKey,TValue&gt;">
      <MemberSignature Language="C#" Value="public static void Sort&lt;TKey,TValue&gt; (TKey[] keys, TValue[] items, int index, int length, System.Collections.Generic.IComparer&lt;TKey&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sort&lt;TKey, TValue&gt;(!!TKey[] keys, !!TValue[] items, int32 index, int32 length, class System.Collections.Generic.IComparer`1&lt;!!TKey&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.Sort``2(``0[],``1[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sort(Of TKey, TValue) (keys As TKey(), items As TValue(), index As Integer, length As Integer, comparer As IComparer(Of TKey))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TKey, typename TValue&gt;&#xA; static void Sort(cli::array &lt;TKey&gt; ^ keys, cli::array &lt;TValue&gt; ^ items, int index, int length, System::Collections::Generic::IComparer&lt;TKey&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="static member Sort : 'Key[] * 'Value[] * int * int * System.Collections.Generic.IComparer&lt;'Key&gt; -&gt; unit" Usage="System.Array.Sort (keys, items, index, length, comparer)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TKey" />
        <TypeParameter Name="TValue" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="keys" Type="TKey[]" />
        <Parameter Name="items" Type="TValue[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IComparer&lt;TKey&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TKey">O tipo dos elementos da matriz principal.</typeparam>
        <typeparam name="TValue">O tipo dos elementos da matriz de itens.</typeparam>
        <param name="keys">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém as chaves a serem classificadas.</param>
        <param name="items">O <see cref="T:System.Array" /> unidimensional, com base em zero, que contém os itens correspondentes às chaves em <paramref name="keys" /> ou <see langword="null" /> para classificar somente <paramref name="keys" />.</param>
        <param name="index">O índice inicial do intervalo a ser classificado.</param>
        <param name="length">O número de elementos no intervalo a ser classificado.</param>
        <param name="comparer">A implementação genérica da interface <see cref="T:System.Collections.Generic.IComparer`1" /> a ser usada na comparação de elementos ou <see langword="null" /> para usar a implementação genérica da interface <see cref="T:System.IComparable`1" /> de cada elemento.</param>
        <summary>Classifica uma gama de elementos em um par de objetos <see cref="T:System.Array" /> (um contém as chaves e o outro contém os itens correspondentes) com base nas chaves no primeiro <see cref="T:System.Array" /> usando a interface genérica <see cref="T:System.Collections.Generic.IComparer`1" /> especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada chave no `keys`<xref:System.Array> tem um item correspondente no `items`<xref:System.Array>. Quando uma chave é reposicionada durante a classificação, o item correspondente no `items`<xref:System.Array> é reposicionado da mesma forma. Por isso, o `items`<xref:System.Array> é classificado de acordo com a organização das chaves correspondentes no `keys`<xref:System.Array>.  
  
 Se `comparer` está `null`, cada chave dentro do intervalo especificado de elementos na `keys` <xref:System.Array> deve implementar o <xref:System.IComparable%601> interface genérica para ser capaz de comparações com todas as outras chaves.  
  
 É possível classificar se há mais itens do que chaves, mas os itens que não tiverem chaves correspondentes não serão classificados. Não será possível classificar se houver mais chaves do que itens; isso lança um <xref:System.ArgumentException>.  
  
 Caso a classificação não seja concluída com êxito, os resultados são indefinidos.  
  
 Este método usa o algoritmo introspective sort (introsort) da seguinte forma:  
  
-   Se o tamanho da partição for menos que 16 elementos, ele usa um [classificação de inserção](https://en.wikipedia.org/wiki/Insertion_sort) algoritmo.  
  
-   Se o número de partições exceda 2 * Log<sup>N</sup>, onde *N* é o intervalo da matriz de entrada, ele usa um [Heapsort](https://en.wikipedia.org/wiki/Heapsort) algoritmo.  
  
-   Caso contrário, ele usa um [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algoritmo.  
  
 Esta implementação realiza uma classificação instável; ou seja, se dois elementos são iguais, a ordem não deve ser preservada. Por outro lado, uma classificação estável preserva a ordem de elementos iguais.  
  
 Para matrizes que são classificadas usando-se os algoritmos Heapsort e Quicksort, no caso mais grave, este método é uma operação O(`n` log `n`), em que `n` é `length`.  
  
   
  
## Examples  
 O exemplo de código a seguir demonstra a <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29>, <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29>, e [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32% 2CSystem.Collections.Generic.IComparer%7b%60%600%7d%29 > sobrecargas de método genérico para pares de matrizes que representam as chaves e valores de classificação.  
  
 O exemplo de código define uma comparação alternativa para cadeias de caracteres denominada `ReverseCompare`, que implementa o `IComparer<string>`(`IComparer(Of String)` no Visual Basic, `IComparer<String^>` no Visual C++) interface genérica. A comparação chama o método <xref:System.String.CompareTo%28System.String%29>, invertendo a ordem dos comparandos de modo que as cadeias de caracteres sejam classificadas da maior para a menor, e não o contrário.  
  
 O exemplo de código cria e exibe uma matriz de nomes de dinossauros (as chaves) e uma matriz de inteiros que representam o tamanho máximo de cada dinossauro em metros (os valores). Em seguida, as matrizes são classificadas e exibidas várias vezes:  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%29> é usada para classificar ambas as matrizes na ordem dos nomes de dinossauros na primeira matriz.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29> e uma instância de `ReverseCompare` são usadas para inverter a ordem de classificação de matrizes pareadas.  
  
-   A sobrecarga de <xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%29> é usada para classificar os últimos três elementos de ambas as matrizes.  
  
-   O [\], TValue\<xref:System.Array.Sort%60%602%28%60%600%5B%5D%2C%60%601%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Collections.Generic.IComparer%7B%60%600%7D%29 > sobrecarga é usada para classificar os três últimos elementos de ambos matrizes na ordem inversa.  
  
> [!NOTE]
>  As chamadas para os métodos genéricos não têm diferenças em relação a chamadas para os equivalentes não genéricos, porque o Visual Basic, o C# e o C++ inferem o tipo do parâmetro de tipo genérico do tipo dos dois primeiros argumentos. Se você usar o [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar o Microsoft intermediate language (MSIL), você pode ver que os métodos genéricos estão sendo chamados.  
  
 [!code-cpp[Array_Sort2IntIntIComparer#1](~/samples/snippets/cpp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cpp/source.cpp#1)]
 [!code-csharp[Array_Sort2IntIntIComparer#1](~/samples/snippets/csharp/VS_Snippets_CLR/Array_Sort2IntIntIComparer/cs/source.cs#1)]
 [!code-vb[Array_Sort2IntIntIComparer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Array_Sort2IntIntIComparer/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que o limite inferior de <paramref name="keys" />.  
  
- ou - 
 <paramref name="length" /> é menor que zero.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="items" /> não é <see langword="null" />, e o limite inferior de <paramref name="keys" /> não corresponde ao limite inferior de <paramref name="items" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" />, e o tamanho de <paramref name="keys" /> é maior que o tamanho de <paramref name="items" />.  
  
- ou - 
 <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="keys" /><see cref="T:System.Array" />.  
  
- ou - 
 <paramref name="items" /> não é <see langword="null" /> e <paramref name="index" /> e <paramref name="length" /> não especificam um intervalo válido no <paramref name="items" /><see cref="T:System.Array" />.  
  
- ou - 
A implementação de <paramref name="comparer" /> causou um erro durante a classificação. Por exemplo, <paramref name="comparer" /> não pode retornar 0 ao comparar um item com ele próprio.</exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="comparer" /> é <see langword="null" /> e um ou mais elementos no <paramref name="keys" /><see cref="T:System.Array" /> não implementam a interface genérica <see cref="T:System.IComparable`1" />.</exception>
        <block subset="none" type="usage"><para>O .NET Framework 4 e as versões anteriores usavam apenas o algoritmo Quicksort. Quicksort identifica comparadores inválidos em algumas situações nas quais a operação de classificação lança uma exceção <see cref="T:System.IndexOutOfRangeException" /> e lança uma exceção <see cref="T:System.ArgumentException" /> para o chamador. Começando pelo [!INCLUDE[net_v45](~/includes/net-v45-md.md)], é possível que operações de classificação que lançavam <see cref="T:System.ArgumentException" /> não lancem uma exceção, porque os algoritmos insertion sort e heapsort não detectam uma comparação inválida. Geralmente, isso se aplica a matrizes com menos de 16 elementos.</para></block>
        <altmember cref="T:System.Collections.Generic.IComparer`1" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="Overload:System.Array.BinarySearch" />
        <related type="Article" href="~/docs/standard/globalization-localization/performing-culture-insensitive-string-operations-in-arrays.md">Executando operações de cadeia de caracteres que não levam em conta a cultura em matrizes</related>
      </Docs>
    </Member>
    <Member MemberName="SyncRoot">
      <MemberSignature Language="C#" Value="public object SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.SyncRoot" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SyncRoot As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SyncRoot : obj" Usage="System.Array.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</summary>
        <value>Um objeto que pode ser usado para sincronizar o acesso ao <see cref="T:System.Array" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa propriedade implementa o <xref:System.Collections.ICollection?displayProperty=nameWithType> interface.  
  
 Classes do .NET framework com base em <xref:System.Array> fornecer sua própria versão sincronizada da coleção usando o <xref:System.Array.SyncRoot%2A> propriedade.  
  
 Classes que usam matrizes também podem implementar sua própria sincronização usando o <xref:System.Array.SyncRoot%2A> propriedade. O código de sincronização necessário realizar operações no `SyncRoot` da coleção, não diretamente na coleção. Isso garante a operação apropriada das coleções que são derivadas de outros objetos. Especificamente, ele mantém uma sincronização adequada com outros threads que podem ser simultaneamente modificação da coleção. Observe que algumas implementações de <xref:System.Array.SyncRoot%2A> pode retornar o <xref:System.Array> em si.  
  
 Enumeração por meio de uma coleção intrinsecamente não é um procedimento de thread-safe. Mesmo quando uma coleção está sincronizada, outros threads ainda podem modificar a coleção, o que faz o enumerador lançar uma exceção. Para garantir thread-safe durante a enumeração, é possível bloquear a coleção durante toda a enumeração ou verificar as exceções resultantes das alterações feitas por outros threads.  
  
 A recuperação do valor dessa propriedade é uma operação O(1).  
  
   
  
## Examples  
 O exemplo de código a seguir mostra como bloquear uma matriz durante toda a enumeração por meio de <xref:System.Array.SyncRoot%2A> propriedade.  
  
 [!code-cpp[System.Array.SyncRoot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Array.SyncRoot/cpp/source.cpp#1)]
 [!code-csharp[System.Array.SyncRoot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Array.SyncRoot/cs/source.cs#1)]
 [!code-vb[System.Array.SyncRoot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Array.SyncRoot/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Array.IsSynchronized" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.Count">
      <MemberSignature Language="C#" Value="int System.Collections.ICollection.Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Collections.ICollection.Count" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#Count" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Count As Integer Implements ICollection.Count" />
      <MemberSignature Language="C++ CLI" Value="property int System::Collections::ICollection::Count { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de elementos contidos no <see cref="T:System.Array" />.</summary>
        <value>O número de elementos contidos na coleção.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.ICollection>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.IsSynchronized">
      <MemberSignature Language="C#" Value="bool System.Collections.ICollection.IsSynchronized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.ICollection.IsSynchronized" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#IsSynchronized" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsSynchronized As Boolean Implements ICollection.IsSynchronized" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::ICollection::IsSynchronized { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.IsSynchronized" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.IsSynchronized</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.ICollection.SyncRoot">
      <MemberSignature Language="C#" Value="object System.Collections.ICollection.SyncRoot { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.ICollection.SyncRoot" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#ICollection#SyncRoot" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property SyncRoot As Object Implements ICollection.SyncRoot" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::ICollection::SyncRoot { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.ICollection.SyncRoot" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.ICollection.SyncRoot</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Add">
      <MemberSignature Language="C#" Value="int IList.Add (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.Add(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Add (value As Object) As Integer Implements IList.Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.Add(System::Object ^ value) = System::Collections::IList::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Add(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser adicionado ao <see cref="T:System.Collections.IList" />.</param>
        <summary>A chamada desse método sempre gera uma exceção <see cref="T:System.NotSupportedException" />.</summary>
        <returns>Não há suporte à adição de um valor a uma matriz. Nenhum valor é retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Normalmente, um <xref:System.Collections.IList.Add%2A?displayProperty=nameWithType> implementação adiciona um membro a uma coleção. No entanto, como matrizes têm um tamanho fixo (o <xref:System.Array.IsFixedSize%2A> propriedade sempre retorna `true`), esse método sempre gera um <xref:System.NotSupportedException> exceção.  
  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Clear">
      <MemberSignature Language="C#" Value="void IList.Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Clear" />
      <MemberSignature Language="VB.NET" Value="Sub Clear () Implements IList.Clear" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Clear() = System::Collections::IList::Clear;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Remove todos os itens do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Contains">
      <MemberSignature Language="C#" Value="bool IList.Contains (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IList.Contains(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Contains (value As Object) As Boolean Implements IList.Contains" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IList.Contains(System::Object ^ value) = System::Collections::IList::Contains;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Contains(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser localizado na lista atual. O elemento a ser localizado pode ser <see langword="null" /> para tipos de referência.</param>
        <summary>Determina se um elemento está no <see cref="T:System.Collections.IList" />.</summary>
        <returns><see langword="true" /> se <paramref name="value" /> for encontrado no <see cref="T:System.Collections.IList" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IndexOf">
      <MemberSignature Language="C#" Value="int IList.IndexOf (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IList.IndexOf(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function IndexOf (value As Object) As Integer Implements IList.IndexOf" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IList.IndexOf(System::Object ^ value) = System::Collections::IList::IndexOf;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.IndexOf(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser localizado na lista atual.</param>
        <summary>Determina o índice de um item específico em <see cref="T:System.Collections.IList" />.</summary>
        <returns>O índice do valor se encontrado na lista; caso contrário, -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Insert">
      <MemberSignature Language="C#" Value="void IList.Insert (int index, object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Insert(int32 index, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Insert(System.Int32,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Insert (index As Integer, value As Object) Implements IList.Insert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Insert(int index, System::Object ^ value) = System::Collections::IList::Insert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Insert(System.Int32,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="index">O índice no qual o <paramref name="value" /> deve ser inserido.</param>
        <param name="value">O objeto a ser inserido.</param>
        <summary>Insere um item na <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
        <exception cref="T:System.NullReferenceException"><paramref name="value" /> é uma referência nula no <see cref="T:System.Collections.IList" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsFixedSize">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsFixedSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsFixedSize" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsFixedSize" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsFixedSize As Boolean Implements IList.IsFixedSize" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsFixedSize { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsFixedSize" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsFixedSize</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.IList.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.IList.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements IList.IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::IList::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Item">
      <MemberSignature Language="C#" Value="object System.Collections.IList.Item[int index] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IList.Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Array.System#Collections#IList#Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value=" Property Item(index As Integer) As Object Implements IList.Item" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IList::Item[int] { System::Object ^ get(int index); void set(int index, System::Object ^ value); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IList.Item" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IList.Item(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do elemento a ser obtido ou definido.</param>
        <summary>Obtém ou define o elemento no índice especificado.</summary>
        <value>O elemento no índice especificado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> é menor que zero.  
  
- ou - 
 <paramref name="index" /> é igual a ou maior que <see cref="P:System.Collections.ICollection.Count" />.</exception>
        <exception cref="T:System.ArgumentException">O <see cref="T:System.Array" /> atual não tem exatamente uma dimensão.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.Remove">
      <MemberSignature Language="C#" Value="void IList.Remove (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.Remove(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub Remove (value As Object) Implements IList.Remove" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.Remove(System::Object ^ value) = System::Collections::IList::Remove;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.Remove(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a remover do <see cref="T:System.Collections.IList" />.</param>
        <summary>Remove a primeira ocorrência de um objeto específico do <see cref="T:System.Collections.IList" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IList.RemoveAt">
      <MemberSignature Language="C#" Value="void IList.RemoveAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.IList.RemoveAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IList#RemoveAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Sub RemoveAt (index As Integer) Implements IList.RemoveAt" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.IList.RemoveAt(int index) = System::Collections::IList::RemoveAt;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IList.RemoveAt(System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">O índice do elemento a ser removido.</param>
        <summary>Remove o item <see cref="T:System.Collections.IList" /> no índice especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IList>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">não é um índice válido no <see cref="T:System.Collections.IList" />.</exception>
        <exception cref="T:System.NotSupportedException">O <see cref="T:System.Collections.IList" /> é somente leitura.  
  
- ou - 
O <see cref="T:System.Collections.IList" /> tem um tamanho fixo.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IStructuralComparable.CompareTo (object other, System.Collections.IComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralComparable.CompareTo(object other, class System.Collections.IComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralComparable#CompareTo(System.Object,System.Collections.IComparer)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (other As Object, comparer As IComparer) As Integer Implements IStructuralComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralComparable.CompareTo(System::Object ^ other, System::Collections::IComparer ^ comparer) = System::Collections::IStructuralComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralComparable.CompareTo(System.Object,System.Collections.IComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IComparer" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado com a instância atual.</param>
        <param name="comparer">Um objeto que compara o objeto atual e <paramref name="other" />.</param>
        <summary>Determina se o objeto da coleção atual precede, ocorre na mesma posição ou segue a outro objeto na ordem de classificação.</summary>
        <returns>Um inteiro que indica a relação do objeto da coleção atual para outro, conforme mostrado na tabela a seguir.  
  
 <list type="table"><listheader><term> Valor retornado 
 </term><description> Descrição 
 </description></listheader><item><term> -1 
 </term><description> A instância atual precede <paramref name="other" />.  
  
 </description></item><item><term> 0 
 </term><description> A instância atual e <paramref name="other" /> são iguais.  
  
 </description></item><item><term> 1 
 </term><description> A instância atual segue <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralComparable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.Equals">
      <MemberSignature Language="C#" Value="bool IStructuralEquatable.Equals (object other, System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Collections.IStructuralEquatable.Equals(object other, class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As Object, comparer As IEqualityComparer) As Boolean Implements IStructuralEquatable.Equals" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Collections.IStructuralEquatable.Equals(System::Object ^ other, System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::Equals;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.Equals(System.Object,System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Object" />
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="other">O objeto a ser comparado com a instância atual.</param>
        <param name="comparer">Um objeto que determina se a instância atual e <paramref name="other" /> são iguais.</param>
        <summary>Determina se um objeto é igual à instância atual.</summary>
        <returns><see langword="true" /> se os dois objetos forem iguais; do contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IStructuralEquatable.GetHashCode">
      <MemberSignature Language="C#" Value="int IStructuralEquatable.GetHashCode (System.Collections.IEqualityComparer comparer);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.Collections.IStructuralEquatable.GetHashCode(class System.Collections.IEqualityComparer comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.System#Collections#IStructuralEquatable#GetHashCode(System.Collections.IEqualityComparer)" />
      <MemberSignature Language="VB.NET" Value="Function GetHashCode (comparer As IEqualityComparer) As Integer Implements IStructuralEquatable.GetHashCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.Collections.IStructuralEquatable.GetHashCode(System::Collections::IEqualityComparer ^ comparer) = System::Collections::IStructuralEquatable::GetHashCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IStructuralEquatable.GetHashCode(System.Collections.IEqualityComparer)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.IEqualityComparer" />
      </Parameters>
      <Docs>
        <param name="comparer">Um objeto que calcula o código hash do objeto atual.</param>
        <summary>Retorna um código hash para a instância atual.</summary>
        <returns>O código hash da instância atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este membro é uma implementação do membro de interface explícita. Ele só pode ser usado quando a instância de <xref:System.Array> é convertida em uma interface de <xref:System.Collections.IStructuralEquatable>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TrueForAll&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool TrueForAll&lt;T&gt; (T[] array, Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TrueForAll&lt;T&gt;(!!T[] array, class System.Predicate`1&lt;!!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Array.TrueForAll``1(``0[],System.Predicate{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TrueForAll(Of T) (array As T(), match As Predicate(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool TrueForAll(cli::array &lt;T&gt; ^ array, Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="static member TrueForAll : 'T[] * Predicate&lt;'T&gt; -&gt; bool" Usage="System.Array.TrueForAll (array, match)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">O tipo dos elementos da matriz.</typeparam>
        <param name="array">O <see cref="T:System.Array" /> unidimensional, com base em zero a ser verificado em relação às condições.</param>
        <param name="match">O predicado que define as condições a serem verificadas nos elementos.</param>
        <summary>Determina se cada elemento na matriz corresponde às condições definidas pelo predicado especificado.</summary>
        <returns><see langword="true" /> se cada elemento no <paramref name="array" /> corresponder às condições definidas pelo predicado especificado; caso contrário, <see langword="false" />. Se não houver nenhum elemento na matriz, o valor retornado será <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Predicate%601> é um delegado para um método que retorna`true` se o objeto passado para ele corresponda às condições definidas no representante.  Os elementos de `array` são passados individualmente para o <xref:System.Predicate%601>, e o processamento é interrompido quando o delegado retorna `false` para qualquer elemento.  
  
 Este método é uma operação O(`n`), em que `n` é o <xref:System.Array.Length%2A> de `array`.  
  
   
  
## Examples  
 O exemplo a seguir determina se o último caractere de cada elemento em uma matriz de cadeia de caracteres é um número. Ele cria duas matrizes de cadeia de caracteres. A primeira arrayincludes ambas cadeias de caracteres que terminem com cadeias de caracteres que terminam com caracteres numéricos e alfabéticos. A segunda matriz consiste apenas em cadeias de caracteres que terminam com caracteres numéricos. O exemplo também define um `EndWithANumber` método cuja assinatura coincide com o <xref:System.Predicate%601> delegar. O exemplo passa cada matriz para o <xref:System.Array.TrueForAll%2A> método juntamente com um delegado que representa o `EndsWithANumber` método.  
  
 [!code-csharp[System.Array.TrueForAll#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall2.cs#2)]
 [!code-vb[System.Array.TrueForAll#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall2.vb#2)]  
  
 O exemplo a seguir é semelhante à primeira, exceto que ele passa a matriz de cadeia de caracteres para o <xref:System.Array.TrueForAll%2A> método juntamente com uma expressão lambda que determina se um elemento de matriz específico termina com a representação de cadeia de caracteres de um número.  
  
 [!code-csharp[System.Array.TrueForAll#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.array.trueforall/cs/trueforall1.cs#1)]
 [!code-vb[System.Array.TrueForAll#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.array.trueforall/vb/trueforall1.vb#1)]  
  
 Em ambos os casos, o <xref:System.Array.TrueForAll%2A> método retorna `false` assim que encontra o primeiro elemento da matriz que não terminam em um número. Caso contrário, retornará `true` após a iteração de todos os elementos na matriz.  
  
> [!NOTE]
>  Como mostram os dois exemplos, em c# e Visual Basic, não é necessário criar a `Predicate<string>` delegar (`Predicate(Of String)` no Visual Basic) explicitamente. Essas linguagens inferem o representante correto pelo contexto e criam-no automaticamente.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="array" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="match" /> é <see langword="null" />.</exception>
        <altmember cref="M:System.Array.Exists``1(``0[],System.Predicate{``0})" />
        <altmember cref="T:System.Predicate`1" />
      </Docs>
    </Member>
  </Members>
</Type>