<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="ValueType.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac53b756fc1621dab1597966503a0af93b3c8478663.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3b756fc1621dab1597966503a0af93b3c8478663</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.ValueType">
          <source>Provides the base class for value types.</source>
          <target state="translated">Fornece a classe base para tipos de valor.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source><ph id="ph1">&lt;xref:System.ValueType&gt;</ph> overrides the virtual methods from <ph id="ph2">&lt;xref:System.Object&gt;</ph> with more appropriate implementations for value types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ValueType&gt;</ph> substitui os métodos virtuais de <ph id="ph2">&lt;xref:System.Object&gt;</ph> com implementações mais apropriadas para tipos de valor.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>See also <ph id="ph1">&lt;xref:System.Enum&gt;</ph>, which inherits from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Consulte também <ph id="ph1">&lt;xref:System.Enum&gt;</ph>, que herda de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Data types are separated into value types and reference types.</source>
          <target state="translated">Tipos de dados são separados em tipos de valor e tipos de referência.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Value types are either stack-allocated or allocated inline in a structure.</source>
          <target state="translated">Tipos de valor são alocadas de pilha ou alocados embutidos em uma estrutura.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Reference types are heap-allocated.</source>
          <target state="translated">Tipos de referência são alocados no heap.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Both reference and value types are derived from the ultimate base class <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Tipos de referência e valor são derivados da classe base definitiva <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>In cases where it is necessary for a value type to behave like an object, a wrapper that makes the value type look like a reference object is allocated on the heap, and the value type's value is copied into it.</source>
          <target state="translated">Em casos em que é necessário para um tipo de valor para que atue como um objeto, um wrapper que faz o tipo de valor pareça um objeto de referência é alocado no heap e valor do tipo de valor é copiado para ele.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The wrapper is marked so the system knows that it contains a value type.</source>
          <target state="translated">O wrapper está marcado para que o sistema Saiba que ele contém um tipo de valor.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>This process is known as boxing, and the reverse process is known as unboxing.</source>
          <target state="translated">Esse processo é conhecido como conversão boxing e o processo inverso é conhecido como unboxing.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Boxing and unboxing allow any type to be treated as an object.</source>
          <target state="translated">Conversões boxing e unboxing permitem qualquer tipo deve ser tratado como um objeto.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Although <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> is the implicit base class for value types, you cannot create a class that inherits from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> directly.</source>
          <target state="translated">Embora <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> é a classe base implícita para tipos de valor, você não pode criar uma classe que herda de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> diretamente.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Instead, individual compilers provide a language keyword or construct (such as <ph id="ph1">`struct`</ph> in C# and <ph id="ph2">`Structure`</ph>…<ph id="ph3">`End Structure`</ph></source>
          <target state="translated">Em vez disso, os compiladores individuais fornecem uma palavra-chave do idioma ou construir (como <ph id="ph1">`struct`</ph> em c# e <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>in Visual Basic) to support the creation of value types.</source>
          <target state="translated">no Visual Basic) para dar suporte à criação de tipos de valor.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>Aside from serving as the base class for value types in the .NET Framework, the <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> structure is generally not used directly in code.</source>
          <target state="translated">Além de servir como a classe base para tipos de valor no .NET Framework, o <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> estrutura geralmente não é usada diretamente no código.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>However, it can be used as a parameter in method calls to restrict possible arguments to value types instead of all objects, or to permit a method to handle a number of different value types.</source>
          <target state="translated">No entanto, ele pode ser usado como um parâmetro em chamadas de método para restringir os argumentos possíveis para tipos de valor em vez de todos os objetos ou para permitir que um método para lidar com um número de tipos de valor diferentes.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The following example illustrates how <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> prevents reference types from being passed to methods.</source>
          <target state="translated">O exemplo a seguir ilustra como <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> impede que estão sendo transmitidos para métodos de tipos de referência.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>It defines a class named <ph id="ph1">`Utility`</ph> that contains four methods: <ph id="ph2">`IsNumeric`</ph>, which indicates whether its argument is a number; <ph id="ph3">`IsInteger`</ph>, which indicates whether its argument is an integer; <ph id="ph4">`IsFloat`</ph>, which indicates whether its argument is a floating-point number; and <ph id="ph5">`Compare`</ph>, which indicates the relationship between two numeric values.</source>
          <target state="translated">Define uma classe denominada <ph id="ph1">`Utility`</ph> que contém quatro métodos: <ph id="ph2">`IsNumeric`</ph>, que indica se o argumento é um número. <ph id="ph3">`IsInteger`</ph>, que indica se o argumento é um número inteiro; <ph id="ph4">`IsFloat`</ph>, que indica se o argumento é um número de ponto flutuante; e <ph id="ph5">`Compare`</ph>, que indica a relação entre dois valores numéricos.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>In each case, the method parameters are of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>, and reference types are prevented from being passed to the methods.</source>
          <target state="translated">Em cada caso, os parâmetros de método são do tipo <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>, e os tipos de referência são impedidos de sendo passados para os métodos.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.ValueType">
          <source>The following example illustrates calls to the methods of the <ph id="ph1">`Utility`</ph> class.</source>
          <target state="translated">O exemplo a seguir ilustra chamadas para os métodos do <ph id="ph1">`Utility`</ph> classe.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.ValueType.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.ValueType" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source>The object to compare with the current instance.</source>
          <target state="translated">O objeto a ser comparado com a instância atual.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source>Indicates whether this instance and a specified object are equal.</source>
          <target state="translated">Indica se essa instância e um objeto especificado são iguais.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.ValueType.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> and this instance are the same type and represent the same value; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="obj" /&gt;</ph> e essa instância forem do mesmo tipo e representarem o mesmo valor; caso contrário, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> method overrides <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> and provides the default implementation of value equality for all value types in the .NET Framework.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> substituições de método <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType&gt;</ph> e fornece a implementação padrão de igualdade de valor para todos os tipos de valor no .NET Framework.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>If none of the fields of the current instance and <ph id="ph1">`obj`</ph> are reference types, the <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method performs a byte-by-byte comparison of the two objects in memory.</source>
          <target state="translated">Se nenhum dos campos da instância atual e <ph id="ph1">`obj`</ph> são tipos de referência, o <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método executa uma comparação byte por byte dos dois objetos na memória.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Otherwise, it uses reflection to compare the corresponding fields of <ph id="ph1">`obj`</ph> and this instance.</source>
          <target state="translated">Caso contrário, ele usa reflexão para comparar os campos correspondentes de <ph id="ph1">`obj`</ph> e essa instância.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Particularly if your value type contains fields that are reference types, you should override the <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29&gt;</ph> method.</source>
          <target state="translated">Especialmente se o tipo de valor contém campos que são tipos de referência, você deve substituir o <ph id="ph1">&lt;xref:System.ValueType.Equals%28System.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>This can improve performance and enable you to more closely represent the meaning of equality for the type.</source>
          <target state="translated">Isso pode melhorar o desempenho e permitem que você representam mais de perto o significado de igualdade para o tipo.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Observações para o <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.Equals%2A&gt;</ph>.</source>
          <target state="translated">Quando você chama o <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método em um <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estrutura, ele fornece o comportamento padrão para tipos de valor não substituem <ph id="ph3">&lt;xref:System.ValueType.Equals%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Isso faz parte do suporte fornecido pelo .NET Framework para o <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework oferecem suporte para aplicativos da Windows Store e tempo de execução do Windows<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estruturas não podem substituir <ph id="ph2">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, mesmo que estão gravados com c# ou Visual Basic, porque eles não podem ter métodos.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Além disso, estruturas de <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> em si não herdam <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) No entanto, eles parecerão ter <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.Equals(System.Object)">
          <source>The following example demonstrates how the <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> method can be overridden by a derived value type.</source>
          <target state="translated">O exemplo a seguir demonstra como o <ph id="ph1">&lt;xref:System.ValueType.Equals%2A&gt;</ph> método pode ser substituído por um tipo de valor derivado.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" uid="M:System.ValueType.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Retorna o código hash para essa instância.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.ValueType.GetHashCode">
          <source>A 32-bit signed integer that is the hash code for this instance.</source>
          <target state="translated">Um inteiro com sinal de 32 bits que é o código hash para esta instância.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method applies to types derived from <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método se aplica a tipos derivados de <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>One or more fields of the derived type is used to calculate the return value.</source>
          <target state="translated">Um ou mais campos do tipo derivado é usada para calcular o valor de retorno.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>If you call the derived type's <ph id="ph1">`GetHashCode`</ph> method, the return value is not likely to be suitable for use as a key in a hash table.</source>
          <target state="translated">Se você chamar o tipo derivado <ph id="ph1">`GetHashCode`</ph> método, o valor de retorno não é provável que seja adequada para uso como uma chave em uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>Additionally, if the value of one or more of those fields changes, the return value might become unsuitable for use as a key in a hash table.</source>
          <target state="translated">Além disso, se o valor de um ou mais desses campos for alterado, o valor de retorno pode se tornar inadequado para uso como uma chave em uma tabela de hash.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>In either case, consider writing your own implementation of the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method that more closely represents the concept of a hash code for the type.</source>
          <target state="translated">Em ambos os casos, considere escrever sua própria implementação do <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> que melhor representa o conceito de um código hash para o tipo de método.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph2">&lt;xref:System.Collections.Hashtable?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações, consulte <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph> e <ph id="ph2">&lt;xref:System.Collections.Hashtable?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
          <target state="translated">Observações para o <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">Quando você chama o <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método em um <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estrutura, ele fornece o comportamento padrão para tipos de valor não substituem <ph id="ph3">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Isso faz parte do suporte fornecido pelo .NET Framework para o <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework oferecem suporte para aplicativos da Windows Store e tempo de execução do Windows<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estruturas não podem substituir <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph>, mesmo que estão gravados com c# ou Visual Basic, porque eles não podem ter métodos.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Além disso, estruturas de <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> em si não herdam <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) No entanto, eles parecerão ter <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.GetHashCode">
          <source>The following example demonstrates how the <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> method can be overridden by a derived value type.</source>
          <target state="translated">O exemplo a seguir demonstra como o <ph id="ph1">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> método pode ser substituído por um tipo de valor derivado.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.ValueType.ToString">
          <source>Returns the fully qualified type name of this instance.</source>
          <target state="translated">Retorna o nome do tipo totalmente qualificado dessa instância.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.ValueType.ToString">
          <source>The fully qualified type name.</source>
          <target state="translated">O nome de tipo totalmente qualificado.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The <ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> method and provides the default implementation of the <ph id="ph3">`ToString`</ph> method for value types.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> substituições de método de <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> método e fornece a implementação padrão da <ph id="ph3">`ToString`</ph> método para tipos de valor.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>(Value types are types defined by the <ph id="ph1">`struct`</ph> keyword in C#, and by the <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph> construct in Visual Basic.) Functionally, however, the implementation is that same as that of <ph id="ph4">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>: the method returns the fully qualified type name.</source>
          <target state="translated">(Tipos de valor são tipos definidos pelo <ph id="ph1">`struct`</ph> palavra-chave no c# e o <ph id="ph2">`Structure`</ph>... <ph id="ph3">`End Structure`</ph> construir no Visual Basic.) Funcionalmente, no entanto, a implementação é que mesmo que <ph id="ph4">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph>: o método retorna o nome de tipo totalmente qualificado.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Value types defined by the <ph id="ph1">`struct`</ph> keyword in C# and the <ph id="ph2">`Structure`</ph>...<ph id="ph3">`End Structure`</ph> construct in Visual Basic typically override the <ph id="ph4">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method to provide a more meaningful string representation of the value type.</source>
          <target state="translated">Valor de tipos definidos pelo <ph id="ph1">`struct`</ph> palavra-chave em c# e o <ph id="ph2">`Structure`</ph>... <ph id="ph3">`End Structure`</ph> construção no Visual Basic normalmente substituem o <ph id="ph4">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> método para fornecer uma representação de cadeia de caracteres mais significativa do tipo de valor.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The following example illustrates the difference.</source>
          <target state="translated">O exemplo a seguir ilustra a diferença.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>It defines two value types, <ph id="ph1">`EmployeeA`</ph> and <ph id="ph2">`EmployeeB`</ph>, creates an instance of each, and calls its <ph id="ph3">`ToString`</ph> method.</source>
          <target state="translated">Ele define dois tipos de valor, <ph id="ph1">`EmployeeA`</ph> e <ph id="ph2">`EmployeeB`</ph>, cria uma instância de cada e chama seu <ph id="ph3">`ToString`</ph> método.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Because the <ph id="ph1">`EmployeeA`</ph> structure does not override the <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> method, it displays only the fully qualified type name.</source>
          <target state="translated">Porque o <ph id="ph1">`EmployeeA`</ph> estrutura não substitui o <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph> método, ele exibe apenas o nome de tipo totalmente qualificado.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>The <ph id="ph1">`EmployeeB.ToString`</ph> method, on the other hand, provides meaningful information about the object.</source>
          <target state="translated">O <ph id="ph1">`EmployeeB.ToString`</ph> método, por outro lado, fornece informações importantes sobre o objeto.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Note that, although enumeration types are also value types, they derive from the <ph id="ph1">&lt;xref:System.Enum&gt;</ph> class, which overrides  <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Observe que, embora os tipos de enumeração também são tipos de valor, eles derivam de <ph id="ph1">&lt;xref:System.Enum&gt;</ph> de classe que substitui <ph id="ph2">&lt;xref:System.ValueType.ToString%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>Notes for the Windows Runtime</source>
          <target state="translated">Observações para o tempo de execução do Windows</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>When you call the <ph id="ph1">&lt;xref:System.ValueType.ToString%2A&gt;</ph> method on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structure, it provides the default behavior for value types that don’t override <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>.</source>
          <target state="translated">Quando você chama o <ph id="ph1">&lt;xref:System.ValueType.ToString%2A&gt;</ph> método em um <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estrutura, ele fornece o comportamento padrão para tipos de valor não substituem <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
          <target state="translated">Isso faz parte do suporte fornecido pelo .NET Framework para o <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (consulte <bpt id="p1">[</bpt>.NET Framework oferecem suporte para aplicativos da Windows Store e tempo de execução do Windows<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> structures can’t override <ph id="ph2">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, even if they’re written with C# or Visual Basic, because they can’t have methods.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> estruturas não podem substituir <ph id="ph2">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, mesmo que estão gravados com c# ou Visual Basic, porque eles não podem ter métodos.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.ValueType.ToString">
          <source>(In addition, structures in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> itself don’t inherit <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) However, they appear to have <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
          <target state="translated">(Além disso, estruturas de <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> em si não herdam <ph id="ph2">&lt;xref:System.ValueType&gt;</ph>.) No entanto, eles parecerão ter <ph id="ph3">&lt;xref:System.ValueType.ToString%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.ValueType.Equals%2A&gt;</ph>, e <ph id="ph5">&lt;xref:System.ValueType.GetHashCode%2A&gt;</ph> métodos quando usá-los em seu código c# ou Visual Basic e o .NET Framework fornece o comportamento padrão para esses métodos.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>