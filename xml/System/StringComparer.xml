<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="StringComparer.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac557e1b0b735d24c6f07b98ddefb13d0704094c2a4.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">57e1b0b735d24c6f07b98ddefb13d0704094c2a4</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.StringComparer">
          <source>Represents a string comparison operation that uses specific case and culture-based or ordinal comparison rules.</source>
          <target state="translated">Representa uma operação de comparação de cadeia de caracteres que usa regras de comparação ordinal ou com base em cultura e caso específico.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>An object derived from the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class embodies string-based comparison, equality, and hash code operations that take into account both case and culture-specific comparison rules.</source>
          <target state="translated">Um objeto derivado de <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe incorpora as operações de código de hash que levam em conta as regras de comparação específicas de cultura e caso, igualdade e comparação de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>You can use the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class to create a type-specific comparison to sort the elements in a generic collection.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe para criar uma comparação de tipo específico para classificar os elementos em uma coleção genérica.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>Classes such as <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>, and <ph id="ph4">&lt;xref:System.Collections.Generic.SortedList%602&gt;</ph> use the <ph id="ph5">&lt;xref:System.StringComparer&gt;</ph> class for sorting purposes.</source>
          <target state="translated">Classes como <ph id="ph1">&lt;xref:System.Collections.Hashtable&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.SortedList&gt;</ph>, e <ph id="ph4">&lt;xref:System.Collections.Generic.SortedList%602&gt;</ph> usar o <ph id="ph5">&lt;xref:System.StringComparer&gt;</ph> classe para fins de classificação.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>A comparison operation that is represented by the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class is defined to be either case-sensitive or case-insensitive, and use either word (culture-sensitive) or ordinal (culture-insensitive) comparison rules.</source>
          <target state="translated">Uma operação de comparação que é representada pelo <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe é definida para ser diferencia maiusculas de minúsculas ou maiusculas de minúsculas e usar o word (sensíveis à cultura) ou regras de comparação (sem diferenciação de cultura) ordinal.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>For more information about word and ordinal comparison rules, see <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para obter mais informações sobre regras de comparação ordinal e word, consulte <ph id="ph1">&lt;xref:System.Globalization.CompareOptions?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>Implemented Properties</source>
          <target state="translated">Propriedades implementadas</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>You might be confused about how to use the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class properties because of a seeming contradiction.</source>
          <target state="translated">Pode ser confuso sobre como usar o <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> propriedades da classe devido a uma contradição aparente.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class is declared <ph id="ph2">`abstract`</ph> (<ph id="ph3">`MustInherit`</ph> in Visual Basic), which means its members can be invoked only on an object of a class derived from the <ph id="ph4">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe é declarada <ph id="ph2">`abstract`</ph> (<ph id="ph3">`MustInherit`</ph> no Visual Basic), que significa que seus membros pode ser chamado apenas em um objeto de uma classe derivada do <ph id="ph4">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>The contradiction is that each property of the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class is declared <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic), which means the property can be invoked without first creating a derived class.</source>
          <target state="translated">A contradição é que cada propriedade do <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe é declarada <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> no Visual Basic), que significa que a propriedade pode ser chamado sem primeiro criar uma classe derivada.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>You can call a <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> property directly because each property actually returns an instance of an anonymous class that is derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">Você pode chamar um <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> propriedade diretamente porque cada propriedade, na verdade, retorna uma instância de uma classe anônima que é derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>Consequently, the type of each property value is <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph>, which is the base class of the anonymous class, not the type of the anonymous class itself.</source>
          <target state="translated">Consequentemente, o tipo de cada valor de propriedade é <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph>, que é a classe base da classe anônima, não o tipo do anônimo a classe em si.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>Each <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> class property returns a <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> object that supports predefined case and comparison rules.</source>
          <target state="translated">Cada <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> classe propriedade retorna um <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> objeto que dá suporte a regras predefinidas de caso e comparação.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>The following example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo a seguir demonstra as propriedades e o <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> método o <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.StringComparer">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" uid="M:System.StringComparer.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" uid="T:System.StringComparer">
          <source>Compares two objects or strings and returns an indication of their relative sort order.</source>
          <target state="translated">Compara dois objetos ou cadeias de caracteres e retorna uma indicação de sua ordem de classificação relativa.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>An object to compare to <bpt id="p1">&lt;c&gt;</bpt>y<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto a ser comparado com <bpt id="p1">&lt;c&gt;</bpt>Y<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>An object to compare to <bpt id="p1">&lt;c&gt;</bpt>x<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto a ser comparado com <bpt id="p1">&lt;c&gt;</bpt>X<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>When overridden in a derived class, compares two objects and returns an indication of their relative sort order.</source>
          <target state="translated">Quando substituído em uma classe derivada, compara dois objetos e retorna uma indicação de sua ordem de classificação relativa.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>A signed integer that indicates the relative values of <ph id="ph1">&lt;paramref name="x" /&gt;</ph> and <ph id="ph2">&lt;paramref name="y" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um inteiro assinado que indica os valores relativos de <ph id="ph1">&lt;paramref name="x" /&gt;</ph> e <ph id="ph2">&lt;paramref name="y" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> precedes  <ph id="ph4">&lt;paramref name="y" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> precede <ph id="ph4">&lt;paramref name="y" /&gt;</ph> na ordem de classificação.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="x" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="y" /&gt;</ph> is not <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="x" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="y" /&gt;</ph> não é <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> is equal to <ph id="ph4">&lt;paramref name="y" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> é igual a <ph id="ph4">&lt;paramref name="y" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="x" /&gt;</ph> and <ph id="ph2">&lt;paramref name="y" /&gt;</ph> are both <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="x" /&gt;</ph> e <ph id="ph2">&lt;paramref name="y" /&gt;</ph> são <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="y" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="y" /&gt;</ph> na ordem de classificação.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source><ph id="ph1">&lt;paramref name="y" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="x" /&gt;</ph> is not <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="y" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="x" /&gt;</ph> não é <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method is slightly more efficient than the <ph id="ph2">&lt;xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method because no conversion of the <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> arguments is needed to perform the comparison.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> método é um pouco mais eficiente do que o <ph id="ph2">&lt;xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> método porque nenhuma conversão do <ph id="ph3">`x`</ph> e <ph id="ph4">`y`</ph> argumento é necessário para executar a comparação.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.Object,System.Object)">
          <source>Neither <ph id="ph1">&lt;paramref name="x" /&gt;</ph> nor <ph id="ph2">&lt;paramref name="y" /&gt;</ph> is a <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> object, and neither <ph id="ph4">&lt;paramref name="x" /&gt;</ph> nor <ph id="ph5">&lt;paramref name="y" /&gt;</ph> implements the <ph id="ph6">&lt;see cref="T:System.IComparable" /&gt;</ph> interface.</source>
          <target state="translated">Nem <ph id="ph1">&lt;paramref name="x" /&gt;</ph> nem <ph id="ph2">&lt;paramref name="y" /&gt;</ph> é um <ph id="ph3">&lt;see cref="T:System.String" /&gt;</ph> objeto e nem <ph id="ph4">&lt;paramref name="x" /&gt;</ph> nem <ph id="ph5">&lt;paramref name="y" /&gt;</ph> implementa a interface <ph id="ph6">&lt;see cref="T:System.IComparable" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>A string to compare to <bpt id="p1">&lt;c&gt;</bpt>y<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Uma cadeia de caracteres a ser comparada com <bpt id="p1">&lt;c&gt;</bpt>Y<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>A string to compare to <bpt id="p1">&lt;c&gt;</bpt>x<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Uma cadeia de caracteres a ser comparada com <bpt id="p1">&lt;c&gt;</bpt>X<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>When overridden in a derived class, compares two strings and returns an indication of their relative sort order.</source>
          <target state="translated">Quando substituído em uma classe derivada, compara duas cadeias de caracteres e retorna uma indicação de sua ordem de classificação relativa.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>A signed integer that indicates the relative values of <ph id="ph1">&lt;paramref name="x" /&gt;</ph> and <ph id="ph2">&lt;paramref name="y" /&gt;</ph>, as shown in the following table.</source>
          <target state="translated">Um inteiro assinado que indica os valores relativos de <ph id="ph1">&lt;paramref name="x" /&gt;</ph> e <ph id="ph2">&lt;paramref name="y" /&gt;</ph>, conforme mostrado na tabela a seguir.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Value</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Valor</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Meaning</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Significado</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Less than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Menor que zero</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> precedes <ph id="ph4">&lt;paramref name="y" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> precede o <ph id="ph4">&lt;paramref name="y" /&gt;</ph> na ordem de classificação.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="x" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="y" /&gt;</ph> is not <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="x" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="y" /&gt;</ph> não é <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Zero</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> is equal to <ph id="ph4">&lt;paramref name="y" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> é igual a <ph id="ph4">&lt;paramref name="y" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="x" /&gt;</ph> and <ph id="ph2">&lt;paramref name="y" /&gt;</ph> are both <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="x" /&gt;</ph> e <ph id="ph2">&lt;paramref name="y" /&gt;</ph> são <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Greater than zero</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><ph id="ph4">&lt;term&gt;</ph> Maior que zero</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> follows <ph id="ph4">&lt;paramref name="y" /&gt;</ph> in the sort order.</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph><ph id="ph3">&lt;paramref name="x" /&gt;</ph> segue <ph id="ph4">&lt;paramref name="y" /&gt;</ph> na ordem de classificação.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>-or-</source>
          <target state="translated">- ou -</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="y" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph> and <ph id="ph3">&lt;paramref name="x" /&gt;</ph> is not <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="y" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph> e <ph id="ph3">&lt;paramref name="x" /&gt;</ph> não é <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Compare(System.String,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> method is slightly more efficient than the <ph id="ph2">&lt;xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> method because no conversion of the <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> arguments is needed to perform the comparison.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.Compare%28System.String%2CSystem.String%29?displayProperty=nameWithType&gt;</ph> método é um pouco mais eficiente do que o <ph id="ph2">&lt;xref:System.StringComparer.Compare%28System.Object%2CSystem.Object%29?displayProperty=nameWithType&gt;</ph> método porque nenhuma conversão do <ph id="ph3">`x`</ph> e <ph id="ph4">`y`</ph> argumento é necessário para executar a comparação.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source>A culture whose linguistic rules are used to perform a string comparison.</source>
          <target state="translated">Uma cultura cujas regras linguísticas são usadas para executar uma comparação de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to specify that comparison operations be case-insensitive; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to specify that comparison operations be case-sensitive.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> para especificar que as operações de comparação não diferenciam maiúsculas de minúsculas, <ph id="ph2">&lt;see langword="false" /&gt;</ph> para especificar que as comparações que diferenciam maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source>Creates a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that compares strings according to the rules of a specified culture.</source>
          <target state="translated">Cria um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que compara cadeias de caracteres de acordo com as regras de uma cultura especificada.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source>A new <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs string comparisons according to the comparison rules used by the <ph id="ph2">&lt;paramref name="culture" /&gt;</ph> parameter and the case rule specified by the <ph id="ph3">&lt;paramref name="ignoreCase" /&gt;</ph> parameter.</source>
          <target state="translated">Um novo objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que realiza comparações de cadeias de caracteres de acordo com as regras de comparação usadas pelo parâmetro <ph id="ph2">&lt;paramref name="culture" /&gt;</ph> e a regra de maiúsculas e minúsculas especificada pelo parâmetro <ph id="ph3">&lt;paramref name="ignoreCase" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source>The following code example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e o método <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> da classe <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Create(System.Globalization.CultureInfo,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="culture" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="P:System.StringComparer.CurrentCulture">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs a case-sensitive string comparison using the word comparison rules of the current culture.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa uma comparação de cadeia de caracteres que diferencia maiúsculas de minúsculas usando as regras de comparação de palavras da cultura atual.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>A new <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um novo objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> property can be used when strings are linguistically relevant.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> propriedade pode ser usada quando as cadeias de caracteres são linguisticamente relevantes.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>For example, if strings are displayed to the user, or if strings are the result of user interaction, culture-sensitive string comparison should be used to order the string data.</source>
          <target state="translated">Por exemplo, se cadeias de caracteres são exibidas para o usuário ou cadeias de caracteres são o resultado da interação do usuário, comparação de cadeia de caracteres sensíveis à cultura deve ser usada para ordenar os dados de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>The current culture is the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object associated with the current thread.</source>
          <target state="translated">A cultura atual é o <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto associado ao segmento atual.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>Each call to the <ph id="ph1">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> property <ph id="ph2">`get`</ph> accessor returns a new <ph id="ph3">&lt;xref:System.StringComparer&gt;</ph> object, as the following code shows.</source>
          <target state="translated">Cada chamada para o <ph id="ph1">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> propriedade <ph id="ph2">`get`</ph> acessador retorna um novo <ph id="ph3">&lt;xref:System.StringComparer&gt;</ph> objeto, como mostra o código a seguir.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>To improve performance, you can store the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object in a local variable rather than retrieve the value of the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> property multiple times.</source>
          <target state="translated">Para melhorar o desempenho, você pode armazenar o <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> do objeto em uma variável local em vez de recuperar o valor da <ph id="ph2">&lt;xref:System.StringComparer.CurrentCulture%2A&gt;</ph> propriedade várias vezes.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>The following code example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e o método <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> da classe <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCulture">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs case-insensitive string comparisons using the word comparison rules of the current culture.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa comparações de cadeia de caracteres que não diferenciam maiúsculas de minúsculas, usando as regras de comparação de palavras da cultura atual.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>A new <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um novo objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>The current culture is the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object associated with the current thread.</source>
          <target state="translated">A cultura atual é o <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto associado ao segmento atual.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> property can be used when strings are linguistically relevant but their case is not.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> propriedade pode ser usada quando cadeias de caracteres são linguisticamente relevantes, mas seu caso não.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>For example, if strings are displayed to the user but case is unimportant, culture-sensitive, case-insensitive string comparison should be used to order the string data.</source>
          <target state="translated">Por exemplo, se cadeias de caracteres são exibidas para o usuário, mas caso é importante, sensíveis à cultura, comparação de cadeia de caracteres de maiusculas e minúsculas deve ser usada para ordenar os dados de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>Each call to the <ph id="ph1">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> property <ph id="ph2">`get`</ph> accessor returns a new <ph id="ph3">&lt;xref:System.StringComparer&gt;</ph> object, as the following code shows.</source>
          <target state="translated">Cada chamada para o <ph id="ph1">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> propriedade <ph id="ph2">`get`</ph> acessador retorna um novo <ph id="ph3">&lt;xref:System.StringComparer&gt;</ph> objeto, como mostra o código a seguir.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.CurrentCultureIgnoreCase">
          <source>To improve performance, you can store the <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> object in a local variable rather than retrieve the value of the <ph id="ph2">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> property multiple times.</source>
          <target state="translated">Para melhorar o desempenho, você pode armazenar o <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> do objeto em uma variável local em vez de recuperar o valor da <ph id="ph2">&lt;xref:System.StringComparer.CurrentCultureIgnoreCase%2A&gt;</ph> propriedade várias vezes.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="T:System.StringComparer">
          <source>When overridden in a derived class, indicates whether two objects or strings are equal.</source>
          <target state="translated">Quando substituído em uma classe derivada, indica se dois objetos ou cadeias de caracteres são iguais.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.Object,System.Object)">
          <source>An object to compare to <bpt id="p1">&lt;c&gt;</bpt>y<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto a ser comparado com <bpt id="p1">&lt;c&gt;</bpt>Y<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.Object,System.Object)">
          <source>An object to compare to <bpt id="p1">&lt;c&gt;</bpt>x<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Um objeto a ser comparado com <bpt id="p1">&lt;c&gt;</bpt>X<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.Object,System.Object)">
          <source>When overridden in a derived class, indicates whether two objects are equal.</source>
          <target state="translated">Quando substituído em uma classe derivada, indica se dois objetos são iguais.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.Object,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="x" /&gt;</ph> and <ph id="ph3">&lt;paramref name="y" /&gt;</ph> refer to the same object, or <ph id="ph4">&lt;paramref name="x" /&gt;</ph> and <ph id="ph5">&lt;paramref name="y" /&gt;</ph> are both the same type of object and those objects are equal, or both <ph id="ph6">&lt;paramref name="x" /&gt;</ph> and <ph id="ph7">&lt;paramref name="y" /&gt;</ph> are <ph id="ph8">&lt;see langword="null" /&gt;</ph>; otherwise, <ph id="ph9">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="x" /&gt;</ph> e <ph id="ph3">&lt;paramref name="y" /&gt;</ph> se referirem ao mesmo objeto ou <ph id="ph4">&lt;paramref name="x" /&gt;</ph> e <ph id="ph5">&lt;paramref name="y" /&gt;</ph> forem o mesmo tipo de objeto e esses objetos forem iguais ou <ph id="ph6">&lt;paramref name="x" /&gt;</ph> e <ph id="ph7">&lt;paramref name="y" /&gt;</ph> forem <ph id="ph8">&lt;see langword="null" /&gt;</ph>; caso contrário, <ph id="ph9">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Equals(System.Object,System.Object)">
          <source>Because the runtime does not have to unbox <ph id="ph1">`x`</ph> or <ph id="ph2">`y`</ph> if they are value types or attempt to downcast <ph id="ph3">`x`</ph> or <ph id="ph4">`y`</ph> to strings if they are reference types, the <ph id="ph5">&lt;xref:System.StringComparer.Equals%28System.String%2CSystem.String%29&gt;</ph> method may be slightly more efficient than the <ph id="ph6">&lt;xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">Porque o tempo de execução não tem que converter <ph id="ph1">`x`</ph> ou <ph id="ph2">`y`</ph> se eles são tipos de valor ou tentar baixá-los para <ph id="ph3">`x`</ph> ou <ph id="ph4">`y`</ph> em cadeias de caracteres se eles são tipos de referência, o <ph id="ph5">&lt;xref:System.StringComparer.Equals%28System.String%2CSystem.String%29&gt;</ph> método pode ser um pouco mais eficiente do que o <ph id="ph6">&lt;xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.String,System.String)">
          <source>A string to compare to <bpt id="p1">&lt;c&gt;</bpt>y<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Uma cadeia de caracteres a ser comparada com <bpt id="p1">&lt;c&gt;</bpt>Y<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.String,System.String)">
          <source>A string to compare to <bpt id="p1">&lt;c&gt;</bpt>x<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Uma cadeia de caracteres a ser comparada com <bpt id="p1">&lt;c&gt;</bpt>X<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.String,System.String)">
          <source>When overridden in a derived class, indicates whether two strings are equal.</source>
          <target state="translated">Quando substituído em uma classe derivada, indica se duas cadeias de caracteres são iguais.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.StringComparer.Equals(System.String,System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="x" /&gt;</ph> and <ph id="ph3">&lt;paramref name="y" /&gt;</ph> refer to the same object, or <ph id="ph4">&lt;paramref name="x" /&gt;</ph> and <ph id="ph5">&lt;paramref name="y" /&gt;</ph> are equal, or <ph id="ph6">&lt;paramref name="x" /&gt;</ph> and <ph id="ph7">&lt;paramref name="y" /&gt;</ph> are <ph id="ph8">&lt;see langword="null" /&gt;</ph>; otherwise, <ph id="ph9">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> se <ph id="ph2">&lt;paramref name="x" /&gt;</ph> e <ph id="ph3">&lt;paramref name="y" /&gt;</ph> se referirem ao mesmo objeto, ou <ph id="ph4">&lt;paramref name="x" /&gt;</ph> e <ph id="ph5">&lt;paramref name="y" /&gt;</ph> forem iguais, ou <ph id="ph6">&lt;paramref name="x" /&gt;</ph> e <ph id="ph7">&lt;paramref name="y" /&gt;</ph> forem <ph id="ph8">&lt;see langword="null" /&gt;</ph>; caso contrário, <ph id="ph9">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.Equals(System.String,System.String)">
          <source>Because the runtime does not have to unbox <ph id="ph1">`x`</ph> or <ph id="ph2">`y`</ph> if they are value types or attempt to downcast <ph id="ph3">`x`</ph> or <ph id="ph4">`y`</ph> to strings if they are reference types, the <ph id="ph5">&lt;xref:System.StringComparer.Equals%28System.String%2CSystem.String%29&gt;</ph> method may be slightly more efficient than the <ph id="ph6">&lt;xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method.</source>
          <target state="translated">Porque o tempo de execução não tem que converter <ph id="ph1">`x`</ph> ou <ph id="ph2">`y`</ph> se eles são tipos de valor ou tentar baixá-los para <ph id="ph3">`x`</ph> ou <ph id="ph4">`y`</ph> em cadeias de caracteres se eles são tipos de referência, o <ph id="ph5">&lt;xref:System.StringComparer.Equals%28System.String%2CSystem.String%29&gt;</ph> método pode ser um pouco mais eficiente do que o <ph id="ph6">&lt;xref:System.StringComparer.Equals%28System.Object%2CSystem.Object%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" uid="T:System.StringComparer">
          <source>When overridden in a derived class, gets the hash code for the current <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém o código hash para o objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> atual.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>An object.</source>
          <target state="translated">Um objeto.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>When overridden in a derived class, gets the hash code for the specified object.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém o código hash para o objeto especificado.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>A 32-bit signed hash code calculated from the value of the <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter.</source>
          <target state="translated">Um código hash com sinal de 32 bits calculado do valor do parâmetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> method is more efficient than the <ph id="ph2">&lt;xref:System.StringComparer.GetHashCode%2A&gt;</ph> method because the <ph id="ph3">`obj`</ph> parameter does not have to be unboxed to perform the operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> método é mais eficiente do que o <ph id="ph2">&lt;xref:System.StringComparer.GetHashCode%2A&gt;</ph> método porque o <ph id="ph3">`obj`</ph> parâmetro não tem que ser desencaixotado para executar a operação.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.Object%29&gt;</ph> method allocates an amount of memory that is proportional to the size of <ph id="ph2">`obj`</ph> to calculate the hash code of <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.Object%29&gt;</ph> método aloca uma quantidade de memória que é proporcional ao tamanho do <ph id="ph2">`obj`</ph> para calcular o código hash de <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>In the case of large strings, trying to retrieve the hash code can throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">No caso de grandes cadeias de caracteres, ao tentar recuperar o código hash pode lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>Instead, you can use an alternate algorithm that allocates a fixed amount of memory when calculating hash codes.</source>
          <target state="translated">Em vez disso, você pode usar um algoritmo alternativo que aloca uma quantidade fixa de memória durante o cálculo de códigos hash.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>To use this algorithm, add the <bpt id="p1">[</bpt>&lt;NetFx45_CultureAwareComparerGetHashCode_LongStrings&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md)</ept> element to the <bpt id="p2">[</bpt><ph id="ph1">\&lt;</ph>runtime&gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> section of your application's configuration file.</source>
          <target state="translated">Para usar esse algoritmo, adicione o <bpt id="p1">[</bpt>&lt; NetFx45_CultureAwareComparerGetHashCode_LongStrings &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md)</ept> elemento para o <bpt id="p2">[</bpt> <ph id="ph1">\&lt;</ph>tempo de execução &gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> seção do arquivo de configuração do aplicativo.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>Not enough memory is available to allocate the buffer that is required to compute the hash code.</source>
          <target state="translated">Não há memória suficiente disponível para alocar o buffer necessário para calcular o código hash.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.Object)">
          <source>Not enough memory is available to allocate the buffer that is required to compute the hash code.</source>
          <target state="translated">Não há memória suficiente disponível para alocar o buffer necessário para calcular o código hash.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>A string.</source>
          <target state="translated">Uma cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>When overridden in a derived class, gets the hash code for the specified string.</source>
          <target state="translated">Quando substituído em uma classe derivada, obtém o código hash para a cadeia de caracteres especificada.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>A 32-bit signed hash code calculated from the value of the <ph id="ph1">&lt;paramref name="obj" /&gt;</ph> parameter.</source>
          <target state="translated">Um código hash com sinal de 32 bits calculado do valor do parâmetro <ph id="ph1">&lt;paramref name="obj" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> method is more efficient than the <ph id="ph2">&lt;xref:System.StringComparer.GetHashCode%28System.Object%29&gt;</ph> method because the <ph id="ph3">`obj`</ph> parameter does not have to be unboxed to perform the operation.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> método é mais eficiente do que o <ph id="ph2">&lt;xref:System.StringComparer.GetHashCode%28System.Object%29&gt;</ph> método porque o <ph id="ph3">`obj`</ph> parâmetro não tem que ser desencaixotado para executar a operação.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> method allocates an amount of memory that is proportional to the size of <ph id="ph2">`obj`</ph> to calculate the hash code of <ph id="ph3">`obj`</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.GetHashCode%28System.String%29&gt;</ph> método aloca uma quantidade de memória que é proporcional ao tamanho do <ph id="ph2">`obj`</ph> para calcular o código hash de <ph id="ph3">`obj`</ph>.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>In the case of large strings, trying to retrieve the hash code can throw an <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</source>
          <target state="translated">No caso de grandes cadeias de caracteres, ao tentar recuperar o código hash pode lançar um <ph id="ph1">&lt;xref:System.ArgumentException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>Instead, you can use an alternate algorithm that allocates a fixed amount of memory when calculating hash codes.</source>
          <target state="translated">Em vez disso, você pode usar um algoritmo alternativo que aloca uma quantidade fixa de memória durante o cálculo de códigos hash.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>To use this algorithm, add the <bpt id="p1">[</bpt>&lt;NetFx45_CultureAwareComparerGetHashCode_LongStrings&gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md)</ept> element to the <bpt id="p2">[</bpt><ph id="ph1">\&lt;</ph>runtime&gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> section of your application's configuration file.</source>
          <target state="translated">Para usar esse algoritmo, adicione o <bpt id="p1">[</bpt>&lt; NetFx45_CultureAwareComparerGetHashCode_LongStrings &gt;<ept id="p1">](~/docs/framework/configure-apps/file-schema/runtime/netfx45-cultureawarecomparergethashcode-longstrings-element.md)</ept> elemento para o <bpt id="p2">[</bpt> <ph id="ph1">\&lt;</ph>tempo de execução &gt;<ept id="p2">](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md)</ept> seção do arquivo de configuração do aplicativo.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>Not enough memory is available to allocate the buffer that is required to compute the hash code.</source>
          <target state="translated">Não há memória suficiente disponível para alocar o buffer necessário para calcular o código hash.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="obj" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.StringComparer.GetHashCode(System.String)">
          <source>Not enough memory is available to allocate the buffer that is required to compute the hash code.</source>
          <target state="translated">Não há memória suficiente disponível para alocar o buffer necessário para calcular o código hash.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="P:System.StringComparer.InvariantCulture">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs a case-sensitive string comparison using the word comparison rules of the invariant culture.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa uma comparação de cadeia de caracteres que diferencia maiúsculas de minúsculas usando as regras de comparação de palavras da cultura invariável.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>A new <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um novo objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.InvariantCulture%2A&gt;</ph> property compares strings in a linguistically relevant manner, but it is not suitable for display in any particular culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.InvariantCulture%2A&gt;</ph> propriedade compara cadeias de caracteres de forma linguisticamente relevante, mas não é adequado para exibição em qualquer cultura específica.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>Its major application is to order strings in a way that will be identical across cultures.</source>
          <target state="translated">Seu aplicativo principal é cadeias de caracteres de ordem de forma que sejam idênticas entre culturas.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>The invariant culture is the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A&gt;</ph> property.</source>
          <target state="translated">A cultura invariável é o <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.InvariantCulture%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.InvariantCulture%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>The following code example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e o método <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> da classe <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCulture">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs a case-insensitive string comparison using the word comparison rules of the invariant culture.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa uma comparação de cadeia de caracteres que não diferencia maiúsculas de minúsculas usando as regras de comparação de palavras da cultura invariável.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>A new <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um novo objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.InvariantCultureIgnoreCase%2A&gt;</ph> property compares strings in a linguistically relevant manner that ignores case, but it is not suitable for display in any particular culture.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.InvariantCultureIgnoreCase%2A&gt;</ph> propriedade compara cadeias de caracteres de forma linguisticamente relevante que diferencia maiusculas de minúsculas, mas não é adequado para exibição em qualquer cultura específica.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>Its major application is to order strings in a way that will be identical across cultures.</source>
          <target state="translated">Seu aplicativo principal é cadeias de caracteres de ordem de forma que sejam idênticas entre culturas.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>The invariant culture is the <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A&gt;</ph> property.</source>
          <target state="translated">A cultura invariável é o <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> objeto retornado pelo <ph id="ph2">&lt;xref:System.Globalization.CultureInfo.InvariantCulture%2A&gt;</ph> propriedade.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.InvariantCultureIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.InvariantCultureIgnoreCase%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.InvariantCultureIgnoreCase%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" uid="P:System.StringComparer.Ordinal">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs a case-sensitive ordinal string comparison.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa uma comparação de cadeia de caracteres ordinais que diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>A <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A&gt;</ph> property performs a simple byte comparison that is independent of language.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.Ordinal%2A&gt;</ph> propriedade executa uma comparação byte simples que é independente do idioma.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>This is most appropriate when comparing strings that are generated programmatically or when comparing case-sensitive resources such as passwords.</source>
          <target state="translated">Isso é mais apropriado quando a comparação de cadeias de caracteres que são gerados programaticamente ou quando comparar recursos diferencia maiusculas de minúsculas, como senhas.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.Ordinal%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.Ordinal%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>The following code example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e o método <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> da classe <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.Ordinal">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object that performs a case-insensitive ordinal string comparison.</source>
          <target state="translated">Obtém um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> que executa uma comparação de cadeia de caracteres ordinais que não diferencia maiúsculas de minúsculas.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>A <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph> object.</source>
          <target state="translated">Um objeto <ph id="ph1">&lt;see cref="T:System.StringComparer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A&gt;</ph> property treats the characters in the strings to compare as if they were converted to uppercase using the conventions of the invariant culture, and then performs a simple byte comparison that is independent of language.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> retornado pelo <ph id="ph2">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A&gt;</ph> propriedade trata os caracteres em cadeias de caracteres para comparar como se eles foram convertidos em maiusculas usando as convenções da cultura invariável e, em seguida, executa uma comparação de byte simples que é independente do idioma.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>This is most appropriate when comparing strings that are generated programmatically or when comparing case-insensitive resources such as paths and filenames.</source>
          <target state="translated">Isso é mais apropriado quando Comparando cadeias de caracteres que são gerados por meio de programação ou quando comparar recursos maiusculas de minúsculas, como caminhos e nomes de arquivo.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>The <ph id="ph1">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A&gt;</ph> property actually returns an instance of an anonymous class derived from the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.StringComparer.OrdinalIgnoreCase%2A&gt;</ph> propriedade realmente retorna uma instância de uma classe anônima derivada de <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>The following code example demonstrates the properties and the <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph> class.</source>
          <target state="translated">O exemplo de código a seguir demonstra as propriedades e o método <ph id="ph1">&lt;xref:System.StringComparer.Create%2A&gt;</ph> da classe <ph id="ph2">&lt;xref:System.StringComparer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.StringComparer.OrdinalIgnoreCase">
          <source>The example illustrates how different <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> objects sort three versions of the Latin letter I.</source>
          <target state="translated">O exemplo ilustra como objetos <ph id="ph1">&lt;xref:System.StringComparer&gt;</ph> diferentes classificam três versões da letra I em Latin.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>