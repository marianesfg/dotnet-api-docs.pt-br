<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Random.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5601795a307b1570fa0290d626c624db4c949b72e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">601795a307b1570fa0290d626c624db4c949b72e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</source>
          <target state="translated">Representa um gerador de número pseudoaleatório, que é um dispositivo que produz uma sequência de números que atendem a certos requisitos estatísticos de aleatoriedade.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</source>
          <target state="translated">Números aleatórios pseudo são escolhidos com a mesma probabilidade de um conjunto finito de números.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</source>
          <target state="translated">Os números escolhidos não são aleatórios completamente porque um algoritmo matemático é usado para selecioná-los, mas eles são suficientemente aleatórios para fins práticos.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The current implementation of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</source>
          <target state="translated">A implementação atual do <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe se baseia em uma versão modificada do subtrativas gerador algoritmo de números aleatórios de Donald E. Knuth.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For more information, see D. E.</source>
          <target state="translated">Para obter mais informações, consulte e d.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Knuth.</source>
          <target state="translated">Knuth.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>A arte do computador de programação, o Volume 2: algoritmos Seminumerical<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Addison-Wesley, Reading, MA, third edition, 1997.</source>
          <target state="translated">Addison-Wesley, leitura, MA, terceira edição, 1997.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Para gerar um número aleatório criptograficamente seguro, como aquele que é adequado para a criação de uma senha aleatória, use o <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> classe ou derivar uma classe de <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In this topic:</source>
          <target state="translated">Neste tópico:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Instantiating the random number generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Criando o gerador de número aleatório<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Avoiding multiple instantiations<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Evitando várias instâncias<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>The System.Random class and thread safety<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>A segurança de thread e a classe Random<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generating different types of random numbers<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Gerando diferentes tipos de números aleatórios<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Substituting your own algorithm<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Substituindo seu próprio algoritmo<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Como usar Random para...<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve the same sequence of random values<ept id="p1">](#Same)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar a mesma sequência de valores aleatórios<ept id="p1">](#Same)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve unique sequences of random values<ept id="p1">](#Unique)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar sequências exclusivas de valores aleatórios<ept id="p1">](#Unique)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers in a specified range<ept id="p1">](#Range)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar inteiros em um intervalo especificado<ept id="p1">](#Range)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers with a specified number of digits<ept id="p1">](#Digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar inteiros com um número especificado de dígitos<ept id="p1">](#Digits)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve floating-point values in a specified range<ept id="p1">](#Floats)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar valores de ponto flutuante em um intervalo especificado<ept id="p1">](#Floats)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random Boolean values<ept id="p1">](#Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gerar valores booleanos aleatórios<ept id="p1">](#Boolean)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random 64-bit integers<ept id="p1">](#Long)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Gerar aleatórios inteiros de 64 bits<ept id="p1">](#Long)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve bytes in a specified range<ept id="p1">](#Bytes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar bytes em um intervalo especificado<ept id="p1">](#Bytes)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve an element from an array or collection at random<ept id="p1">](#Array)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar um elemento de uma matriz ou coleção aleatório<ept id="p1">](#Array)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve a unique element from an array or collection<ept id="p1">](#UniqueArray)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Recuperar um único elemento de uma matriz ou coleção<ept id="p1">](#UniqueArray)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instantiating the random number generator</source>
          <target state="translated">Criando o gerador de número aleatório</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.</source>
          <target state="translated">Instanciar o gerador de número aleatório, fornecendo um valor de semente (um valor inicial para o algoritmo de geração de número pseudoaleatório) para um <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> construtor de classe.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can supply the seed value either explicitly or implicitly:</source>
          <target state="translated">Você pode fornecer o valor de semente explícita ou implícita:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor usa um valor de semente explícita que você fornecer.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> construtor usa o relógio do sistema para fornecer um valor de semente.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This is the most common way of instantiating the random number generator.</source>
          <target state="translated">Essa é a maneira mais comum de criar uma instância do gerador de número aleatório.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the same seed is used for separate <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.</source>
          <target state="translated">Se a mesma semente é usada para separar <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos, que irá gerar a mesma série de números aleatórios.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</source>
          <target state="translated">Isso pode ser útil para a criação de um conjunto de testes que processa valores aleatórios, ou para reproduzir jogos que derivam seus dados de números aleatórios.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, note that <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</source>
          <target state="translated">No entanto, observe que <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos em processos em execução em diferentes versões do .NET Framework podem retornar outra série de números aleatórios, mesmo se eles são instanciados com valores de semente idênticos.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</source>
          <target state="translated">Para produzir diferentes sequências de números aleatórios, você pode fazer o valor de semente dependentes de tempo, portanto, produzindo uma série diferente com cada nova instância da <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The parameterized <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.</source>
          <target state="translated">Com os parâmetros <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor pode levar uma <ph id="ph2">&lt;xref:System.Int32&gt;</ph> valor com base no número de tiques no momento, enquanto o sem parâmetros <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> construtor usa o relógio do sistema para gerar o valor de semente.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because the clock has finite resolution, using the parameterless constructor to create different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.</source>
          <target state="translated">No entanto, como o relógio tem resolução finita, usando o construtor sem parâmetros para criar diferentes <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos em sucessão fechar cria geradores de números aleatórios que produzem idênticas sequências de números aleatórios.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates how two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.</source>
          <target state="translated">O exemplo a seguir ilustra como duas <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos são instanciados em sucessão fechar geram uma série idêntica de números aleatórios.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>On most Windows systems, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.</source>
          <target state="translated">Na maioria dos sistemas Windows, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos criados em 15 milissegundos uma da outra serão prováveis que valores de semente idênticos.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To avoid this problem, create a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.</source>
          <target state="translated">Para evitar esse problema, crie um único <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto em vez de vários objetos.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Avoiding multiple instantiations</source>
          <target state="translated">Evitando várias instâncias</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</source>
          <target state="translated">Inicializar dois geradores de números aleatórios em um loop estreito, ou em sucessão rápida cria dois geradores de números aleatórios que podem produzir idênticas sequências de números aleatórios.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</source>
          <target state="translated">Na maioria dos casos, isso não é intenção do desenvolvedor e pode levar a problemas de desempenho, pois criando e inicializando um gerador de número aleatório é um processo relativamente caro.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects to generate one random number.</source>
          <target state="translated">Para melhorar o desempenho e evitar a criação inadvertidamente separados geradores de números aleatórios que geram idênticas sequências numéricas, recomendamos que você crie um <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto para gerar números aleatórios muitos ao longo do tempo, em vez de criar novos <ph id="ph2">&lt;xref:System.Random&gt;</ph> objetos para gerar um número aleatório.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class isn't thread safe.</source>
          <target state="translated">No entanto, a <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe não é thread-safe.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you call <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.</source>
          <target state="translated">Se você chamar <ph id="ph1">&lt;xref:System.Random&gt;</ph> métodos de vários threads, siga as diretrizes discutidas na próxima seção.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The System.Random class and thread safety</source>
          <target state="translated">A segurança de thread e a classe Random</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of instantiating individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.</source>
          <target state="translated">Em vez de criar uma instância individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos, é recomendável que você crie um único <ph id="ph2">&lt;xref:System.Random&gt;</ph> instância para gerar todos os números aleatórios necessários para seu aplicativo.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are not thread safe.</source>
          <target state="translated">No entanto, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos não são thread-safe.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If your app calls <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</source>
          <target state="translated">Se seu aplicativo chamar <ph id="ph1">&lt;xref:System.Random&gt;</ph> métodos de vários threads, você deve usar um objeto de sincronização para garantir que apenas um thread pode acessar o gerador de número aleatório por vez.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you don't ensure that the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</source>
          <target state="translated">Se você não garante que o <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto é acessado de uma forma thread-safe, chamadas para métodos que retornam números aleatórios retornam 0.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses the C# <bpt id="p1">[</bpt>lock Statement<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id="p2">[</bpt>SyncLock statement<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</source>
          <target state="translated">O exemplo a seguir usa o c# <bpt id="p1">[</bpt>instrução lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> e Visual Basic <bpt id="p2">[</bpt>Instrução SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> para garantir que um único número aleatório é acessado por 11 threads de uma forma thread-safe.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</source>
          <target state="translated">Cada thread gera números aleatórios de 2 milhões, conta o número de números aleatórios gerados e calcula a soma e atualiza os totais de todos os threads quando terminar de executar.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example ensures thread-safety in the following ways:</source>
          <target state="translated">O exemplo garante a segurança do thread das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo é usado para definir variáveis locais de thread que controlam o número total de números aleatórios gerados e soma para cada thread.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A lock (the <ph id="ph1">`lock`</ph> statement in C# and the <ph id="ph2">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</source>
          <target state="translated">Um bloqueio (o <ph id="ph1">`lock`</ph> instrução em c# e o <ph id="ph2">`SyncLock`</ph> instrução no Visual Basic) protege o acesso às variáveis para a contagem total e a soma de todos os números aleatórios gerados em todos os threads.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A semaphore (the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.</source>
          <target state="translated">Um semáforo (o <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> objeto) é usado para garantir que os blocos do thread principal até que todos os outros threads concluir a execução.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</source>
          <target state="translated">O exemplo verifica se o gerador de número aleatório tiver sido corrompido, determinando se duas chamadas consecutivas para métodos de geração de número aleatório retornam 0.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If corruption is detected, the example uses the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.</source>
          <target state="translated">Se o dano é detectado, o exemplo usa o <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> objeto para indicar que todos os threads devem ser cancelados.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Before generating each random number, each thread checks the state of the <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.</source>
          <target state="translated">Antes de gerar cada número aleatório, cada thread verifica o estado do <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If cancellation is requested, the example calls the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method to cancel the thread.</source>
          <target state="translated">Se cancelamento for solicitado, o exemplo chama o <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> método para cancelar o thread.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example is identical to the first, except that it uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objects.</source>
          <target state="translated">O exemplo a seguir é idêntico ao primeiro, exceto que ele usa um <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objeto e uma expressão lambda em vez de <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objetos.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It differs from the first example in the following ways:</source>
          <target state="translated">O primeiro exemplo ele difere das seguintes maneiras:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.</source>
          <target state="translated">As variáveis para controlar o número de números aleatórios gerados e soma em cada tarefa são locais para a tarefa, portanto, não há necessidade de usar o <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> atributo.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.</source>
          <target state="translated">Estático <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> método é usado para garantir que o thread principal não for concluída antes de concluir todas as tarefas.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There is no need for the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">Não é necessário para o <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> objeto.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exception that results from task cancellation is surfaced in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">A exceção que é o resultado do cancelamento da tarefa é exposta no <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the previous example, it is handled by each thread.</source>
          <target state="translated">No exemplo anterior, ela será manipulada por cada thread.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generating different types of random numbers</source>
          <target state="translated">Gerando diferentes tipos de números aleatórios</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The random number generator provides methods that let you generate the following kinds of random numbers:</source>
          <target state="translated">O gerador de número aleatório fornece métodos que permitem gerar os seguintes tipos de números aleatórios:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A series of <ph id="ph1">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">Uma série de <ph id="ph1">&lt;xref:System.Byte&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.</source>
          <target state="translated">Determinar o número de valores de byte ao passar uma matriz inicializada para o número de elementos que você deseja que o método para retornar para o <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 20 bytes.</source>
          <target state="translated">O exemplo a seguir gera 20 bytes.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single integer.</source>
          <target state="translated">Um único inteiro.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can choose whether you want an integer from 0 to a maximum value (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) by calling the <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Você pode escolher se deseja que um inteiro de 0 até um valor máximo (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) chamando o <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> método, um número inteiro entre 0 e um valor específico ao chamar o <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> método ou um número inteiro dentro do intervalo de valores, chamando o <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</source>
          <target state="translated">As sobrecargas com parâmetros, o valor máximo especificado é exclusivo; ou seja, o número real de máximo gerado é um menor do que o valor especificado.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método para gerar números aleatórios 10 entre -10 e 10.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</source>
          <target state="translated">Observe que o segundo argumento para o método Especifica o limite superior exclusivo do intervalo de valores aleatórios retornado pelo método.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In other words, the largest integer that the method can return is one less than this value.</source>
          <target state="translated">Em outras palavras, o maior inteiro que o método pode retornar é menor do que esse valor.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single floating-point value from 0.0 to less than 1.0 by calling the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Um valor único de ponto flutuante de 0,0 para menor que 1.0 chamando o <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</source>
          <target state="translated">O limite superior exclusivo do número aleatório retornado pelo método é 1, portanto, seu limite superior real é 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 10 random floating-point numbers.</source>
          <target state="translated">O exemplo a seguir gera os 10 números de ponto flutuante aleatórios.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método permite que você especifique o intervalo do número aleatório retornado.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</source>
          <target state="translated">No entanto, o <ph id="ph1">`maxValue`</ph> parâmetro, que especifica o intervalo superior retornado número, é um recurso exclusivo, não um inclusive, valor.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This means that the method call <ph id="ph1">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.</source>
          <target state="translated">Isso significa que a chamada do método <ph id="ph1">`Next(0, 100)`</ph> retorna um valor entre 0 e 99 e não entre 0 e 100.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id="p1">[</bpt>random T:System.Boolean values<ept id="p1">](#Boolean)</ept>, generating <bpt id="p2">[</bpt>random floating point values with a range other than 0 to 1<ept id="p2">](#Floats)</ept>, generating <bpt id="p3">[</bpt>random 64-bit integers<ept id="p3">](#Long)</ept>, and <bpt id="p4">[</bpt>randomly retrieving a unique element from an array or collection<ept id="p4">](#UniqueArray)</ept>.</source>
          <target state="translated">Você também pode usar o <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe para tarefas como geração <bpt id="p1">[</bpt>valores aleatórios do T:System.Boolean<ept id="p1">](#Boolean)</ept>, gerando <bpt id="p2">[</bpt>valores de ponto flutuante aleatório com um intervalo diferente de 0 a 1<ept id="p2">](#Floats)</ept>, gerando <bpt id="p3">[</bpt>inteiros de 64 bits aleatórios<ept id="p3">](#Long)</ept>, e <bpt id="p4">[</bpt>aleatoriamente recuperar um único elemento de uma matriz ou coleção<ept id="p4">](#UniqueArray)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For these and other common tasks, see the <bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept></source>
          <target state="translated">Para essas e outras tarefas comuns, consulte o <bpt id="p1">[</bpt>como usar Random para...<ept id="p1">](#Operations)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>section.</source>
          <target state="translated">seção.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Substituting your own algorithm</source>
          <target state="translated">Substituindo seu próprio algoritmo</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can implement your own random number generator by inheriting from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.</source>
          <target state="translated">Você pode implementar seu próprio gerador de número aleatório, herdando a <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe e fornecendo o algoritmo de geração de números aleatórios.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To supply your own algorithm, you must override the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.</source>
          <target state="translated">Para fornecer seu próprio algoritmo, você deve substituir o <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> método, que implementa o algoritmo de geração de números aleatórios.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You should also override the <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Você também deve substituir o <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, e <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> métodos para garantir que eles chamam o substituído <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You don't have to override the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.</source>
          <target state="translated">Você não precisa substituir o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> e <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> métodos.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For an example that derives from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.</source>
          <target state="translated">Para obter um exemplo que deriva de <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe e modifica o gerador de número pseudoaleatório do padrão, consulte o <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> página de referência.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>How do you use System.Random to…</source>
          <target state="translated">Como usar Random para...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</source>
          <target state="translated">As seções a seguir abordam e fornecem código de exemplo para algumas das maneiras em que você talvez queira usar números aleatórios em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve the same sequence of random values</source>
          <target state="translated">Recuperar a mesma sequência de valores aleatórios</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</source>
          <target state="translated">Às vezes você deseja gerar a mesma sequência de números aleatórios em cenários de teste de software em jogos.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</source>
          <target state="translated">Teste com a mesma sequência de números aleatórios permite detectar regressões e confirmar as correções de bugs.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Using the same sequence of random number in games allows you to replay previous games.</source>
          <target state="translated">Usando a mesma sequência de número aleatório em jogos permite reproduzir jogos anteriores.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can generate the same sequence of random numbers by providing the same seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Você pode gerar a mesma sequência de números aleatórios, fornecendo o mesmo valor de semente para a <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The seed value provides a starting value for the pseudo-random number generation algorithm.</source>
          <target state="translated">O valor de semente fornece um valor inicial para o algoritmo de geração de número pseudoaleatório.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses 100100 as an arbitrary seed value to instantiate the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.</source>
          <target state="translated">O exemplo a seguir usa 100100 como um valor de semente arbitrário para instanciar o <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto exibe 20 valores de ponto flutuantes aleatórios e persistir o valor de semente.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</source>
          <target state="translated">Em seguida, restaura o valor de semente, cria um novo gerador de número aleatório e exibe os mesmos valores de ponto flutuantes aleatórios 20.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</source>
          <target state="translated">Observe que o exemplo pode produzir diferentes sequências de números aleatórios se executados em diferentes versões do .NET Framework.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve unique sequences of random numbers</source>
          <target state="translated">Recuperar exclusivas sequências de números aleatórios</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Providing different seed values to instances of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.</source>
          <target state="translated">Fornecer valores de semente diferentes instâncias do <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe faz com que cada gerador de número aleatório produzir uma sequência diferente de valores.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can provide a seed value either explicitly by calling the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Você pode fornecer um valor de semente explicitamente chamando o <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor, ou implicitamente chamando o <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Most developers call the parameterless constructor, which uses the system clock.</source>
          <target state="translated">A maioria dos desenvolvedores chamar o construtor sem parâmetros, que usa o relógio do sistema.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this approach to instantiate two <ph id="ph1">&lt;xref:System.Random&gt;</ph> instances.</source>
          <target state="translated">O exemplo a seguir usa essa abordagem para instanciar dois <ph id="ph1">&lt;xref:System.Random&gt;</ph> instâncias.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each instance displays a series of 10 random integers.</source>
          <target state="translated">Cada instância exibe uma série de 10 inteiros aleatórios.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</source>
          <target state="translated">No entanto, devido a sua resolução finita, o relógio do sistema não detecta diferenças de horários que são menos de aproximadamente 15 milissegundos.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Therefore, if your code calls the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.</source>
          <target state="translated">Portanto, se seu código chama o <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> sobrecarga para instanciar dois <ph id="ph2">&lt;xref:System.Random&gt;</ph> objetos em sucessão, talvez você inadvertidamente estar fornecendo os objetos com valores de semente idênticos.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To see this in the previous example, comment out the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method call, and compile and run the example again.</source>
          <target state="translated">Para ver isso no exemplo anterior, comente a <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> chamada de método e compilar e executar o exemplo novamente.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To prevent this from happening, we recommend that you instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.</source>
          <target state="translated">Para evitar que isso aconteça, é recomendável que você criar uma instância de um único <ph id="ph1">&lt;xref:System.Random&gt;</ph> do objeto, em vez de várias.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, since <ph id="ph1">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id="p1">[</bpt>The Random class and thread safety<ept id="p1">](#ThreadSafety)</ept> earlier in this topic.</source>
          <target state="translated">No entanto, como <ph id="ph1">&lt;xref:System.Random&gt;</ph> não é thread-safe, você deve usar um dispositivo de sincronização se você acessar uma <ph id="ph2">&lt;xref:System.Random&gt;</ph> da instância de vários threads; para obter mais informações, consulte <bpt id="p1">[</bpt>aleatória a segurança de classe e thread<ept id="p1">](#ThreadSafety)</ept> anteriormente neste tópico.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Alternately, you can use a delay mechanism, such as the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</source>
          <target state="translated">Como alternativa, você pode usar um mecanismo de atraso, como o <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> método usado no exemplo anterior, para garantir que o instanciações ocorram distância de mais de 15 milissegundos.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers in a specified range</source>
          <target state="translated">Recuperar inteiros em um intervalo especificado</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can retrieve integers in a specified range by calling the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</source>
          <target state="translated">Você pode recuperar inteiros em um intervalo especificado ao chamar o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método, que permite que você especifique o inferior e o limite superior de números que você deseja que o gerador de número aleatório para retornar.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The upper bound is an exclusive, not an inclusive, value.</source>
          <target state="translated">O limite superior é um recurso exclusivo, não um inclusive, valor.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>That is, it isn't included in the range of values returned by the method.</source>
          <target state="translated">Ou seja, ele não está incluído no intervalo de valores retornados pelo método.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this method to generate random integers between -10 and 10.</source>
          <target state="translated">O exemplo a seguir usa esse método para gerar números aleatórios inteiros entre -10 e 10.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id="ph1">`maxValue`</ph> argument in the method call.</source>
          <target state="translated">Observe que ela especifica 11, que é maior do que o valor desejado, como o valor da <ph id="ph1">`maxValue`</ph> argumento na chamada do método.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers with a specified number of digits</source>
          <target state="translated">Recuperar inteiros com um número especificado de dígitos</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.</source>
          <target state="translated">Você pode chamar o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método para recuperar os números com um número especificado de dígitos.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id="ph2">`minValue`</ph> value of 1000 and a <ph id="ph3">`maxValue`</ph> value of 10000, as the following example shows.</source>
          <target state="translated">Por exemplo, para recuperar os números com quatro dígitos (ou seja, números que variam de 1000 a 9999), você chama o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método com um <ph id="ph2">`minValue`</ph> valor 1000 e um <ph id="ph3">`maxValue`</ph> valor de 10000, como mostra o exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve floating-point values in a specified range</source>
          <target state="translated">Recuperar valores de ponto flutuante em um intervalo especificado</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método retorna valores de ponto flutuante aleatórios que variam de 0 a menor que 1.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you'll often want to generate random values in some other range.</source>
          <target state="translated">No entanto, você geralmente deseja gerar valores aleatórios em algum outro intervalo.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Se o intervalo entre os valores mínimo e máximo desejados for 1, você pode adicionar a diferença entre o intervalo de início desejado e 0 para o número retornado pelo <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 10 random numbers between -1 and 0.</source>
          <target state="translated">O exemplo a seguir faz isso para gerar números aleatórios 10 entre -1 e 0.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</source>
          <target state="translated">Para gerar números de ponto flutuante aleatórios cujo limite inferior é 0, mas limite superior é maior que 1 (ou, no caso de números negativos, cujo limite inferior é menor que -1 e limite superior é 0), multiplicar o número aleatório, o limite diferente de zero.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">O exemplo a seguir faz isso para gerar números de ponto flutuante aleatórios de 20 milhões que variam de 0 a <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In also displays the distribution of the random values generated by the method.</source>
          <target state="translated">Em também exibe a distribuição dos valores aleatórios gerados pelo método.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers between two arbitrary values, like the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:</source>
          <target state="translated">Para gerar números de ponto flutuante aleatórios entre dois valores arbitrários, como o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método não para inteiros, use a seguinte fórmula:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</source>
          <target state="translated">O exemplo a seguir gera números aleatórios de 1 milhão que variam de 10.0 para 11.0 e exibe sua distribuição.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random Boolean values</source>
          <target state="translated">Gerar valores booleanos aleatórios</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe não fornece métodos que geram <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you can define your own class or method to do that.</source>
          <target state="translated">No entanto, você pode definir sua própria classe ou método para fazer isso.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example defines a class, <ph id="ph1">`BooleanGenerator`</ph>, with a single method, <ph id="ph2">`NextBoolean`</ph>.</source>
          <target state="translated">O exemplo a seguir define uma classe, <ph id="ph1">`BooleanGenerator`</ph>, com um único método, <ph id="ph2">`NextBoolean`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`BooleanGenerator`</ph> class stores a <ph id="ph2">&lt;xref:System.Random&gt;</ph> object as a private variable.</source>
          <target state="translated">O <ph id="ph1">`BooleanGenerator`</ph> classe armazena uma <ph id="ph2">&lt;xref:System.Random&gt;</ph> objeto como uma variável particular.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBoolean`</ph> method calls the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passes the result to the <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">O <ph id="ph1">`NextBoolean`</ph> chamadas de método de <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método e passa o resultado para o <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that 2 is used as the argument to specify the upper bound of the random number.</source>
          <target state="translated">Observe que 2 é usada como argumento para especificar o limite superior do número aleatório.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Since this is an exclusive value, the method call returns either 0 or 1.</source>
          <target state="translated">Como esse é um valor exclusivo, a chamada do método retorna 0 ou 1.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of creating a separate class to generate random <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.</source>
          <target state="translated">Em vez de criar uma classe separada para gerar aleatório <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> valores, o exemplo simplesmente podem ter definido um único método.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In that case, however, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance in each method call.</source>
          <target state="translated">Nesse caso, no entanto, o <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto deve ter sido definido como uma variável de nível de classe para evitar criando um novo <ph id="ph2">&lt;xref:System.Random&gt;</ph> instância em cada chamada de método.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In Visual Basic, the Random instance can be defined as a <bpt id="p1">[</bpt>Static<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id="ph1">`NextBoolean`</ph> method.</source>
          <target state="translated">No Visual Basic, a instância de Random pode ser definida como um <bpt id="p1">[</bpt>estático<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variável o <ph id="ph1">`NextBoolean`</ph> método.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example provides an implementation.</source>
          <target state="translated">O exemplo a seguir fornece uma implementação.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random 64-bit integers</source>
          <target state="translated">Gerar aleatórios inteiros de 64 bits</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método retornam inteiros de 32 bits.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, in some cases, you might want to work with 64-bit integers.</source>
          <target state="translated">No entanto, em alguns casos, convém trabalhar com números inteiros de 64 bits.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can do this as follows:</source>
          <target state="translated">Você pode fazer isso da seguinte maneira:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Call the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.</source>
          <target state="translated">Chamar o <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método para recuperar um flutuante de precisão dupla de ponto.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Multiply that value by <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Multiplicar esse valor <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</source>
          <target state="translated">O exemplo a seguir usa essa técnica para gerar inteiros longos aleatórios de 20 milhões e classifica em 10 grupos iguais.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Em seguida, avaliar a distribuição de números aleatórios contando o número de cada grupo de 0 a <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</source>
          <target state="translated">Como mostra a saída do exemplo, os números são mais ou menos igualmente distribuídos por meio do intervalo de um inteiro longo.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>An alternative technique that uses bit manipulation does not generate truly random numbers.</source>
          <target state="translated">Uma técnica alternativa que usa a manipulação de bits não gerar números aleatórios verdadeiros.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique calls <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.</source>
          <target state="translated">Essa técnica chama <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> para gerar números inteiros, esquerda-turnos um 32 bits e ORs-los juntos.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique has two limitations:</source>
          <target state="translated">Essa técnica tem duas limitações:</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</source>
          <target state="translated">Como bit 31 é o bit de sinal, o valor de bit 31 do inteiro longo resultante é sempre 0.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</source>
          <target state="translated">Isso pode ser resolvido por meio da geração aleatória 0 ou 1, deslocamento à esquerda de 31 bits e o uso de or com inteiro longo aleatório original.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>More seriously, because the probability that the value returned by <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</source>
          <target state="translated">Mais seriamente, porque a probabilidade de que o valor retornado por <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> será 0, haverá alguns números aleatórios no intervalo 0x00000000FFFFFFFF 0x0.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve bytes in a specified range</source>
          <target state="translated">Recuperar bytes em um intervalo especificado</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.</source>
          <target state="translated">As sobrecargas do <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método permite que você especifique o intervalo de números aleatórios, mas o <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> método não.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example implements a <ph id="ph1">`NextBytes`</ph> method that lets you specify the range of the returned bytes.</source>
          <target state="translated">O exemplo a seguir implementa um <ph id="ph1">`NextBytes`</ph> método que permite que você especifique o intervalo de bytes retornados.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Random2`</ph> class that derives from <ph id="ph2">&lt;xref:System.Random&gt;</ph> and overloads its <ph id="ph3">`NextBytes`</ph> method.</source>
          <target state="translated">Define uma <ph id="ph1">`Random2`</ph> classe que deriva de <ph id="ph2">&lt;xref:System.Random&gt;</ph> e sobrecargas seu <ph id="ph3">`NextBytes`</ph> método.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</source>
          <target state="translated">O <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> método ajusta uma chamada para o <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método e especifica o valor mínimo e um maior que o valor máximo (nesse caso, 0 e 101) que desejamos retornados na matriz de bytes.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because we are sure that the integer values returned by the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id="ph2">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</source>
          <target state="translated">Como estamos-se de que os valores de inteiro retornado pelo <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método estão dentro do intervalo da <ph id="ph2">&lt;xref:System.Byte&gt;</ph> tipo de dados, podemos pode com segurança converta-os (em c#) ou convertê-los (no Visual Basic) de inteiros em bytes.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve an element from an array or collection at random</source>
          <target state="translated">Recuperar um elemento de uma matriz ou coleção aleatório</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Random numbers often serve as indexes to retrieve values from arrays or collections.</source>
          <target state="translated">Números aleatórios servem frequentemente como índices para recuperar valores de matrizes ou coleções.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To retrieve a random index value, you can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id="ph2">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id="ph3">`maxValue`</ph> argument.</source>
          <target state="translated">Para recuperar um valor de índice aleatório, você pode chamar o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> método e use o limite inferior da matriz como o valor do seu <ph id="ph2">`minValue`</ph> argumento e um número maior que o limite superior da matriz como o valor do seu <ph id="ph3">`maxValue`</ph> argumento.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For a zero-based array, this is equivalent to its <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Para uma matriz com base em zero, isso é equivalente ao seu <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> propriedade ou um número maior que o valor retornado pelo <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example randomly retrieves the name of a city in the United States from an array of cities.</source>
          <target state="translated">O exemplo a seguir recupera aleatoriamente o nome de uma cidade nos Estados Unidos de uma matriz de cidades.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve a unique element from an array or collection</source>
          <target state="translated">Recuperar um único elemento de uma matriz ou coleção</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A random number generator can always return duplicate values.</source>
          <target state="translated">Um gerador de número aleatório sempre pode retornar valores duplicados.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</source>
          <target state="translated">Como o intervalo de números se torna menor, ou o número de valores gerados se torna maior, aumenta a probabilidade de duplicatas.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</source>
          <target state="translated">Se valores aleatórios devem ser exclusivos, mais números são gerados para compensar duplicatas, resultando em cada vez mais baixo desempenho.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There are a number of techniques to handle this scenario.</source>
          <target state="translated">Há várias técnicas para lidar com esse cenário.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</source>
          <target state="translated">Uma solução comum é criar uma matriz ou coleção que contém os valores a serem recuperados e uma matriz paralela que contém números de ponto flutuante aleatórios.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The second array is populated with random numbers at the time the first array is created, and the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is used to sort the first array by using the values in the parallel array.</source>
          <target state="translated">A segunda matriz é preenchida com números aleatórios no momento em que a primeira matriz é criada, e o <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> método é usado para classificar a primeira matriz usando os valores na matriz paralela.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</source>
          <target state="translated">Por exemplo, se você estiver desenvolvendo um jogo de Paciência, você deseja garantir que cada cartão é usado apenas uma vez.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</source>
          <target state="translated">Em vez de gerar números aleatórios para recuperar um cartão e controlar se o cartão já foi distribuído, você pode criar uma matriz paralela de números aleatórios que podem ser usados para classificar o conjunto.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</source>
          <target state="translated">Depois que o plano é classificado, seu aplicativo pode manter um ponteiro para indicar que o índice do próximo cartão na mesa.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates this approach.</source>
          <target state="translated">O exemplo a seguir ilustra esta abordagem.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Card`</ph> class that represents a playing card and a <ph id="ph2">`Dealer`</ph> class that deals a deck of shuffled cards.</source>
          <target state="translated">Define uma <ph id="ph1">`Card`</ph> classe que representa uma carta de jogo e uma <ph id="ph2">`Dealer`</ph> classe que trata de um conjunto de cartões embaralhados.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`Dealer`</ph> class constructor populates two arrays: a <ph id="ph2">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id="ph3">`order`</ph> array that has the same number of elements as the <ph id="ph4">`deck`</ph> array and is populated with randomly generated <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated">O <ph id="ph1">`Dealer`</ph> construtor da classe preenche duas matrizes: um <ph id="ph2">`deck`</ph> matriz que tem o escopo de classe e que representa todas as cartas na mesa; e um local <ph id="ph3">`order`</ph> matriz que tem o mesmo número de elementos como o <ph id="ph4">`deck`</ph> de matriz e é populada com gerado aleatoriamente <ph id="ph5">&lt;xref:System.Double&gt;</ph> valores.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is then called to sort the <ph id="ph2">`deck`</ph> array based on the values in the <ph id="ph3">`order`</ph> array.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> método é chamado para classificar o <ph id="ph2">`deck`</ph> matriz com base nos valores de <ph id="ph3">`order`</ph> matriz.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example creates a single random number generator and calls its <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods to generate sequences of random numbers within different ranges.</source>
          <target state="translated">O exemplo a seguir cria um único número aleatório e chama seu <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, e <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> métodos para gerar sequências de números aleatórios dentro de intervalos diferentes.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">O exemplo a seguir gera um número aleatório usado como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> required overriding the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method to define a new or modified algorithm for generating random numbers.</source>
          <target state="translated">No .NET Framework 1.0 e 1.1, uma implementação mínima de uma classe derivada do <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> necessário a substituindo o <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método para definir um algoritmo novo ou modificado para gerar números aleatórios.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The derived class could then rely on the base class implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, and <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> methods to call the derived class implementation of the <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">A classe derivada pode dependem, em seguida, a implementação da classe base a <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, e <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> métodos para chamar a implementação da classe derivada de <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 2.0 and later, the behavior of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> methods have changed so that these methods do not necessarily call the derived class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">No .NET Framework 2.0 e versões posterior, o comportamento do <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, e <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> métodos foram alterados para que esses métodos não necessariamente chamar a implementação da classe derivada de <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, classes derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> that target the .NET Framework 2.0 and later should also override these three methods.</source>
          <target state="translated">Como resultado, as classes derivadas de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> de destino do .NET Framework 2.0 e posterior, também deverá substituir esses três métodos.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The implementation of the random number generator in the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class isn't guaranteed to remain the same across major versions of the .NET Framework.</source>
          <target state="translated">A implementação do gerador de número aleatório no <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> classe não é garantida para permanecer o mesmo nas versões principais do .NET Framework.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</source>
          <target state="translated">Como resultado, você não deve presumir que a mesma semente resultará na mesma sequência pseudo-aleatório em diferentes versões do .NET Framework.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using a time-dependent default seed value.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>, usando um valor de semente padrão dependente de tempo.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The default seed value is derived from the system clock and has finite resolution.</source>
          <target state="translated">O valor de semente padrão é derivado do relógio do sistema e com resolução finita.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>As a result, different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</source>
          <target state="translated">Como resultado, diferente <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos criados por uma chamada para o construtor padrão em sucessão fechar terão valores de semente padrão idênticos e, portanto, produzirão conjuntos idênticos de números aleatórios.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This problem can be avoided by using a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.</source>
          <target state="translated">Esse problema pode ser evitado por meio de um único <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto para gerar todos os números aleatórios.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Você também pode trabalhar em torno dele, modificando o valor de semente retornado pelo relógio do sistema e, em seguida, fornecer explicitamente esse novo valor de semente para a <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Para obter mais informações, consulte o <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Call this constructor if you want your random number generator to generate a random sequence of numbers.</source>
          <target state="translated">Se você quiser que o gerador de número aleatório para gerar uma sequência aleatória de números, chame este construtor.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .</source>
          <target state="translated">Para gerar uma sequência fixa de números aleatórios que serão o mesmo para diferentes geradores de números aleatórios, chame o <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> construtor com um valor de semente fixa.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This <ph id="ph1">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.</source>
          <target state="translated">Isso <ph id="ph1">&lt;xref:System.Random&gt;</ph> sobrecarga de construtor é usada com frequência ao testar aplicativos que usam números aleatórios.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Once you've instantiated the random number generator, you call individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods, such as <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> or <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.</source>
          <target state="translated">Após instanciar o gerador de número aleatório, você pode chamar individuais <ph id="ph1">&lt;xref:System.Random&gt;</ph> métodos, como <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> ou <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>para gerar números aleatórios.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The following example uses the default constructor to instantiate three <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects and displays a sequence of five random integers for each.</source>
          <target state="translated">O exemplo a seguir usa o construtor padrão para criar uma instância de três <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos e exibe uma sequência de cinco inteiros aleatórios para cada um.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</source>
          <target state="translated">Porque as duas primeiras <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos são criados em sucessão fechar, eles são instanciados usando valores de semente idêntico com base no relógio do sistema e, portanto, eles produzem uma sequência idêntica de números aleatórios.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>On the other hand, the default constructor of the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is called after a two-second delay caused by calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Por outro lado, o construtor padrão da terceira <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto é chamado após um atraso de dois segundos causado por chamar o <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because this produces a different seed value for the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, it produces a different sequence of random numbers.</source>
          <target state="translated">Como isso produz um valor de semente diferentes para o terceiro <ph id="ph1">&lt;xref:System.Random&gt;</ph> do objeto, ele produz uma sequência diferente de números aleatórios.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>A number used to calculate a starting value for the pseudo-random number sequence.</source>
          <target state="translated">Um número usado para calcular um valor inicial para a sequência numérica pseudoaleatória.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>If a negative number is specified, the absolute value of the number is used.</source>
          <target state="translated">Se um número negativo for especificado, o valor absoluto do número será usado.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using the specified seed value.</source>
          <target state="translated">Inicializa uma nova instância da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>, usando o valor de semente especificado.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Providing an identical seed value to different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.</source>
          <target state="translated">Fornecer um valor de semente idênticos para diferentes <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos faz com que cada instância produzir idênticas sequências de números aleatórios.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This is often done when testing apps that rely on random number generators.</source>
          <target state="translated">Isso geralmente é feito ao testar aplicativos que dependem de geradores de números aleatórios.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</source>
          <target state="translated">Se seu aplicativo exigir sequências de números aleatórias diferentes, invoque esse construtor várias vezes com valores de semente diferentes.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>One way to produce a unique seed value is to make it time-dependent.</source>
          <target state="translated">É uma maneira de produzir um valor de semente exclusivo para torná-lo dependentes de tempo.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>For example, derive the seed value from the system clock, as the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.</source>
          <target state="translated">Por exemplo, derivar o valor de semente do relógio do sistema, como o <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> sobrecarga.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</source>
          <target state="translated">No entanto, o relógio do sistema pode não ter resolução suficiente para fornecer diferentes invocações desse construtor com um valor de semente diferentes.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in the following example.</source>
          <target state="translated">Isso resulta em geradores de números aleatórios que geram idênticas sequências de números pseudo-aleatório, conforme ilustrado pelas duas primeiras <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos no exemplo a seguir.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to ensure that you provide each constructor with a different seed value.</source>
          <target state="translated">Para evitar isso, aplica um algoritmo para diferenciar o valor de semente em cada invocação ou chamada de <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> método para garantir que você forneça cada construtor com um valor de semente diferentes.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Another option is to instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.</source>
          <target state="translated">Outra opção é criar uma instância de um único <ph id="ph1">&lt;xref:System.Random&gt;</ph> do objeto que você usar para gerar todos os números aleatórios em seu aplicativo.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This yields slightly better performance, since instantiating a random number generator is fairly expensive.</source>
          <target state="translated">Isso resulta em um pouco melhor desempenho, como instanciar um gerador de número aleatório é relativamente cara.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The following example creates <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</source>
          <target state="translated">O exemplo a seguir cria <ph id="ph1">&lt;xref:System.Random&gt;</ph> objetos com o construtor da classe que usa um parâmetro de semente e gera uma sequência de inteiros aleatórios e duplicatas.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The example illustrates that the same sequence is generated when the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is created again with the constructor and seed parameter.</source>
          <target state="translated">O exemplo ilustra que a mesma sequência é gerada quando o <ph id="ph1">&lt;xref:System.Random&gt;</ph> objeto é criado novamente com o parâmetro de construtor e a propagação.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Returns a random integer.</source>
          <target state="translated">Retorna um inteiro aleatório.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>Returns a non-negative random integer.</source>
          <target state="translated">Retorna um inteiro aleatório não negativo.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>A 32-bit signed integer that is greater than or equal to 0 and less than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> gera um número aleatório cujo valor varia de 0 a menos de <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number whose value ranges from 0 to some other positive number, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Para gerar um número aleatório cujo valor varia de 0 a algum outro número positivo, use o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number within a different range, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Para gerar um número aleatório dentro de um intervalo diferente, use o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example makes repeated calls to the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method to generate a specific number of random numbers requested by the user.</source>
          <target state="translated">O exemplo a seguir faz chamadas repetidas para o <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método para gerar um número específico de números aleatórios solicitados pelo usuário.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method is used to get customer input.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> método é usado para obter a entrada do cliente.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">O exemplo a seguir deriva de uma classe de <ph id="ph1">&lt;xref:System.Random&gt;</ph> para gerar uma sequência de números aleatórios cuja distribuição é diferente da distribuição uniforme gerada pelo <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> método da classe base.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method to provide the distribution of random numbers, and overrides the <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> method to use series of random numbers.</source>
          <target state="translated">Ela substitui o <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> método para fornecer a distribuição de números aleatórios e substituições de <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> método para usar a série de números aleatórios.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> e substituir o <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método, a distribuição fornecida pela implementação de classe derivada de <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método não é usado em chamadas para a classe base implementação de <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Em vez disso, a distribuição uniforme retornado por base de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> classe é usada.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Esse comportamento melhora o desempenho geral da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Para modificar esse comportamento para chamar o <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método na classe derivada, você também deve substituir o <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>The exclusive upper bound of the random number to be generated.</source>
          <target state="translated">O limite superior exclusivo do número aleatório a ser gerado.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to 0.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> deve ser maior do que ou igual a 0.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>Returns a non-negative random integer that is less than the specified maximum.</source>
          <target state="translated">Retorna um número inteiro aleatório não negativo menor que o máximo especificado.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>A 32-bit signed integer that is greater than or equal to 0, and less than <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values ordinarily includes 0 but not <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; ou seja, o intervalo de valores retornados inclui 0, mas não <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> equals 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> is returned.</source>
          <target state="translated">No entanto, se <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> for igual a 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> será retornado.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id="ph2">`maxValue`</ph> – 1.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> sobrecarga retorna inteiros aleatórios que variam de 0 a <ph id="ph2">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> is 0, the method returns 0.</source>
          <target state="translated">No entanto, se <ph id="ph1">`maxValue`</ph> for 0, o método retornará 0.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates random integers with various overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method.</source>
          <target state="translated">O exemplo a seguir gera inteiros aleatórios com várias sobrecargas do <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">O exemplo a seguir gera um número aleatório usado como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Como o maior índice da matriz é um menor do que seu tamanho, o valor da <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> propriedade é fornecida como um a <ph id="ph2">`maxValue`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> é menor que 0.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The inclusive lower bound of the random number returned.</source>
          <target state="translated">O limite inferior inclusivo do número aleatório retornado.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The exclusive upper bound of the random number returned.</source>
          <target state="translated">O limite superior exclusivo do número aleatório retornado.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> deve ser maior do que ou igual a <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Returns a random integer that is within a specified range.</source>
          <target state="translated">Retorna um inteiro aleatório que está dentro do intervalo especificado.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>A 32-bit signed integer greater than or equal to <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> and less than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values includes <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> but not <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">Um inteiro com sinal de 32 bits maior ou igual a <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> e menor que <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; ou seja, o intervalo de valores retornados inclui <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph>, mas não <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> equals <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> is returned.</source>
          <target state="translated">Se <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> for igual a <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> será retornado.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id="ph2">`minValue`</ph> to <ph id="ph3">`maxValue`</ph> – 1.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> sobrecarga retorna inteiros aleatórios que variam de <ph id="ph2">`minValue`</ph> para <ph id="ph3">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> equals <ph id="ph2">`minValue`</ph>, the method returns <ph id="ph3">`minValue`</ph>.</source>
          <target state="translated">No entanto, se <ph id="ph1">`maxValue`</ph> é igual a <ph id="ph2">`minValue`</ph>, o método retornará <ph id="ph3">`minValue`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Unlike the other overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.</source>
          <target state="translated">Ao contrário de outras sobrecargas do <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> método, que retornam apenas valores não negativos, esse método pode retornar um inteiro aleatório negativo.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to generate random integers with three distinct ranges.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> método para gerar valores inteiros aleatórios com três intervalos diferentes.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Note that the exact output from the example depends on the system-supplied seed value passed to the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class constructor.</source>
          <target state="translated">Observe que a saída exata do exemplo depende do valor de semente fornecido pelo sistema passado para o <ph id="ph1">&lt;xref:System.Random&gt;</ph> construtor de classe.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">O exemplo a seguir gera um número aleatório usado como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Como o maior índice da matriz é um menor do que seu tamanho, o valor da <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> propriedade é fornecida como um a <ph id="ph2">`maxValue`</ph> parâmetro.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> é maior que <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload if the difference between the <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> and <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parameters is greater than <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> e substituir o <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método, a distribuição fornecida pela implementação de classe derivada de <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método não é usado em chamadas para a classe base implementação do <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> sobrecarga do método se a diferença entre o <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> e <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parâmetros é maior do que <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Em vez disso, a distribuição uniforme retornado por base de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> classe é usada.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Esse comportamento melhora o desempenho geral da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload.</source>
          <target state="translated">Para modificar esse comportamento para chamar o <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método na classe derivada, você também deve substituir o <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> sobrecarga do método.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>An array of bytes to contain random numbers.</source>
          <target state="translated">Uma matriz de bytes que deverá conter números aleatórios.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Fills the elements of a specified array of bytes with random numbers.</source>
          <target state="translated">Preenche os elementos de uma matriz de bytes especificada com números aleatórios.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</source>
          <target state="translated">Cada elemento da matriz de bytes é definido como um número aleatório maior ou igual a 0 e menor ou igual a <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Por exemplo, para gerar um número aleatório adequado para a criação de uma senha aleatória criptograficamente seguro, use um método como <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method to fill an array of bytes with random byte values.</source>
          <target state="translated">O exemplo a seguir demonstra como usar o <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> método para preencher uma matriz de bytes com valores de byte aleatórios.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> é <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> e substituir o <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método, a distribuição fornecida pela implementação de classe derivada de <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método não é usado em chamadas para a classe base implementação de <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Em vez disso, a distribuição uniforme retornado por base de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> classe é usada.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Esse comportamento melhora o desempenho geral da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Para modificar esse comportamento para chamar o <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método na classe derivada, você também deve substituir o <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Retorna um número de ponto flutuante aleatório maior ou igual a 0,0 e menor que 1.0.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The actual upper bound of the random number returned by this method is 0.99999999999999978.</source>
          <target state="translated">O limite superior real do número aleatório retornado por esse método é 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class topic.</source>
          <target state="translated">Para recuperar valores de ponto flutuante aleatórios dentro de um intervalo diferente de 0.0 e 1.0, consulte a seção "Recuperar valores de ponto flutuante em um intervalo especificado" o <ph id="ph1">&lt;xref:System.Random&gt;</ph> tópico sobre a classe.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>This method is the public version of the protected method, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</source>
          <target state="translated">Esse método é a versão pública do método protegido, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate sequences of random doubles.</source>
          <target state="translated">O exemplo a seguir usa o <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método para gerar sequências de doubles aleatórios.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate 100 random numbers and displays their frequency distribution.</source>
          <target state="translated">A exemplo a seguir chama o <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método para gerar 100 aleatório números e exibe sua frequência de distribuição.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>Returns a random floating-point number between 0.0 and 1.0.</source>
          <target state="translated">Retorna um número de ponto flutuante aleatório entre 0.0 e 1.0.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To produce a different random distribution or a different random number generator principle, derive a class from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and override the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Para produzir uma distribuição aleatória diferente ou um princípio de gerador de número de aleatórios diferentes, derive uma classe do <ph id="ph1">&lt;xref:System.Random&gt;</ph> classe e substituir o <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id="ph2">`protected`</ph>, which means that it is accessible only within the <ph id="ph3">&lt;xref:System.Random&gt;</ph> class and its derived classes.</source>
          <target state="translated">O <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> método <ph id="ph2">`protected`</ph>, que significa que ele é acessível somente dentro de <ph id="ph3">&lt;xref:System.Random&gt;</ph> classe e suas classes derivadas.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To generate a random number between 0 and 1 from a <ph id="ph1">&lt;xref:System.Random&gt;</ph> instance, call the <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Para gerar um número aleatório entre 0 e 1 de um <ph id="ph1">&lt;xref:System.Random&gt;</ph> instância, chame o <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> método.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> and overrides the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method to generate a distribution of random numbers.</source>
          <target state="translated">O exemplo a seguir deriva de uma classe de <ph id="ph1">&lt;xref:System.Random&gt;</ph> e substitui o <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> método para gerar uma distribuição de números aleatórios.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This distribution is different than the uniform distribution generated by the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Essa distribuição é diferente da distribuição uniforme gerada pelo <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> método da classe base.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the following methods:</source>
          <target state="translated">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> e substituir o <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método, a distribuição fornecida pela implementação de classe derivada de <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método não é usado em chamadas para a classe base implementação dos métodos a seguir:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">O método <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method, if (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) is greater than <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">O <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> método, se (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) é maior do que <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Instead, the uniform distribution provided by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Em vez disso, a distribuição uniforme fornecida com a base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> classe é usada.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Esse comportamento melhora o desempenho geral da classe <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To modify this behavior to call the implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the behavior of these three members.</source>
          <target state="translated">Para modificar esse comportamento para chamar a implementação do <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> método na classe derivada, você também deve substituir o comportamento desses três membros.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The example provides an illustration.</source>
          <target state="translated">O exemplo fornece uma ilustração.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>