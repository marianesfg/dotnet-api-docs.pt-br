<Type Name="Random" FullName="System.Random">
  <Metadata><Meta Name="ms.openlocfilehash" Value="adf29f522d3625dba7e4bd956743ac3e35b25683" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58716523" /></Metadata><TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="959b7-101">Representa um gerador de número pseudoaleatório, que é um dispositivo que produz uma sequência de números que atendem a certos requisitos estatísticos de aleatoriedade.</span><span class="sxs-lookup"><span data-stu-id="959b7-101">Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-102">Números pseudoaleatórios são escolhidos com a mesma probabilidade de um conjunto finito de números.</span><span class="sxs-lookup"><span data-stu-id="959b7-102">Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</span></span> <span data-ttu-id="959b7-103">Os números escolhidos não são completamente aleatórios, porque um algoritmo matemático é usado para selecioná-los, mas são suficientemente aleatórios para fins práticos.</span><span class="sxs-lookup"><span data-stu-id="959b7-103">The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</span></span> <span data-ttu-id="959b7-104">A implementação atual do <xref:System.Random> classe baseia-se em uma versão modificada do subtrativa gerador algoritmo de números aleatórios de Donald E. Knuth.</span><span class="sxs-lookup"><span data-stu-id="959b7-104">The current implementation of the <xref:System.Random> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</span></span> <span data-ttu-id="959b7-105">Para obter mais informações, consulte a e D.</span><span class="sxs-lookup"><span data-stu-id="959b7-105">For more information, see D. E.</span></span> <span data-ttu-id="959b7-106">Knuth.</span><span class="sxs-lookup"><span data-stu-id="959b7-106">Knuth.</span></span> <span data-ttu-id="959b7-107">*A arte da programação, Volume 2 de computador: Algoritmos seminumerical*.</span><span class="sxs-lookup"><span data-stu-id="959b7-107">*The Art of Computer Programming, Volume 2: Seminumerical Algorithms*.</span></span> <span data-ttu-id="959b7-108">Addison-Wesley, leitura, MA, terceira edição, 1997.</span><span class="sxs-lookup"><span data-stu-id="959b7-108">Addison-Wesley, Reading, MA, third edition, 1997.</span></span>  
  
 <span data-ttu-id="959b7-109">Para gerar um número aleatório criptograficamente seguro, por exemplo, um que seja adequado para a criação de uma senha aleatória, use o <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe ou derivando uma classe de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-109">To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <xref:System.Security.Cryptography.RNGCryptoServiceProvider> class or derive a class from <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="959b7-110">Neste tópico:</span><span class="sxs-lookup"><span data-stu-id="959b7-110">In this topic:</span></span>  
  
 <span data-ttu-id="959b7-111">[Criando uma instância do gerador de número aleatório](#Instantiate) </span><span class="sxs-lookup"><span data-stu-id="959b7-111">[Instantiating the random number generator](#Instantiate) </span></span>  
 <span data-ttu-id="959b7-112">[Evitando várias instanciações](#Multiple) </span><span class="sxs-lookup"><span data-stu-id="959b7-112">[Avoiding multiple instantiations](#Multiple) </span></span>  
 <span data-ttu-id="959b7-113">[A segurança de thread e a classe Random](#ThreadSafety) </span><span class="sxs-lookup"><span data-stu-id="959b7-113">[The System.Random class and thread safety](#ThreadSafety) </span></span>  
 <span data-ttu-id="959b7-114">[Gerando tipos diferentes de números aleatórios](#Functionality) </span><span class="sxs-lookup"><span data-stu-id="959b7-114">[Generating different types of random numbers](#Functionality) </span></span>  
 <span data-ttu-id="959b7-115">[Substituindo seu próprio algoritmo](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="959b7-115">[Substituting your own algorithm](#Overriding) </span></span>  
 <span data-ttu-id="959b7-116">[Como você usar o System. Random para...](#Operations) </span><span class="sxs-lookup"><span data-stu-id="959b7-116">[How do you use System.Random to…](#Operations) </span></span>  
 [<span data-ttu-id="959b7-117">Recuperar a mesma sequência de valores aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-117">Retrieve the same sequence of random values</span></span>](#Same)  
 [<span data-ttu-id="959b7-118">Recuperar sequências exclusivas de valores aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-118">Retrieve unique sequences of random values</span></span>](#Unique)  
 [<span data-ttu-id="959b7-119">Recuperar inteiros em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-119">Retrieve integers in a specified range</span></span>](#Range)  
 [<span data-ttu-id="959b7-120">Recuperar inteiros com um número especificado de dígitos</span><span class="sxs-lookup"><span data-stu-id="959b7-120">Retrieve integers with a specified number of digits</span></span>](#Digits)  
 [<span data-ttu-id="959b7-121">Recuperar valores de ponto flutuante em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-121">Retrieve floating-point values in a specified range</span></span>](#Floats)  
 [<span data-ttu-id="959b7-122">Gerar valores aleatórios de boolianos</span><span class="sxs-lookup"><span data-stu-id="959b7-122">Generate random Boolean values</span></span>](#Boolean)  
 [<span data-ttu-id="959b7-123">Gerar inteiros de 64 bits aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-123">Generate random 64-bit integers</span></span>](#Long)  
 [<span data-ttu-id="959b7-124">Recuperar bytes em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-124">Retrieve bytes in a specified range</span></span>](#Bytes)  
 [<span data-ttu-id="959b7-125">Recuperar um elemento de uma matriz ou coleção aleatório</span><span class="sxs-lookup"><span data-stu-id="959b7-125">Retrieve an element from an array or collection at random</span></span>](#Array)  
 [<span data-ttu-id="959b7-126">Recuperar um elemento exclusivo de uma matriz ou coleção</span><span class="sxs-lookup"><span data-stu-id="959b7-126">Retrieve a unique element from an array or collection</span></span>](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a><span data-ttu-id="959b7-127">Criando uma instância do gerador de número aleatório</span><span class="sxs-lookup"><span data-stu-id="959b7-127">Instantiating the random number generator</span></span>  
 <span data-ttu-id="959b7-128">Você cria uma instância do gerador de número aleatório, fornecendo um valor de semente (um valor inicial para o algoritmo de geração de números pseudoaleatórios) para um <xref:System.Random.%23ctor%2A> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="959b7-128">You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <xref:System.Random.%23ctor%2A> class constructor.</span></span>  <span data-ttu-id="959b7-129">Você pode fornecer o valor de semente explícita ou implicitamente:</span><span class="sxs-lookup"><span data-stu-id="959b7-129">You can supply the seed value either explicitly or implicitly:</span></span>  
  
-   <span data-ttu-id="959b7-130">O <xref:System.Random.%23ctor%28System.Int32%29> construtor usa um valor de semente explícita que você fornecer.</span><span class="sxs-lookup"><span data-stu-id="959b7-130">The <xref:System.Random.%23ctor%28System.Int32%29> constructor uses an explicit seed value that you supply.</span></span>  
  
-   <span data-ttu-id="959b7-131">O <xref:System.Random.%23ctor> construtor usa o relógio do sistema para fornecer um valor de semente.</span><span class="sxs-lookup"><span data-stu-id="959b7-131">The <xref:System.Random.%23ctor> constructor uses the system clock to provide a seed value.</span></span> <span data-ttu-id="959b7-132">Isso é a maneira mais comum de criar uma instância do gerador de número aleatório.</span><span class="sxs-lookup"><span data-stu-id="959b7-132">This is the most common way of instantiating the random number generator.</span></span>  
  
 <span data-ttu-id="959b7-133">Se a mesma semente é usada para separar <xref:System.Random> objetos, eles gerarão a mesma série de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-133">If the same seed is used for separate <xref:System.Random> objects, they will generate the same series of random numbers.</span></span> <span data-ttu-id="959b7-134">Isso pode ser útil para a criação de um conjunto de testes que processa os valores aleatórios ou para reproduzir os jogos que derivam seus dados de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-134">This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</span></span> <span data-ttu-id="959b7-135">No entanto, observe que <xref:System.Random> objetos em processos em execução em diferentes versões do .NET Framework podem retornar outra série de números aleatórios, mesmo se eles são instanciados com valores de semente idênticos.</span><span class="sxs-lookup"><span data-stu-id="959b7-135">However, note that <xref:System.Random> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</span></span>  
  
 <span data-ttu-id="959b7-136">Para produzir sequências diferentes de números aleatórios, você pode fazer o valor de semente dependente de tempo, assim, produzindo uma série de diferente com cada nova instância da <xref:System.Random>.</span><span class="sxs-lookup"><span data-stu-id="959b7-136">To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <xref:System.Random>.</span></span> <span data-ttu-id="959b7-137">Com os parâmetros <xref:System.Random.%23ctor%28System.Int32%29> construtor pode levar um <xref:System.Int32> valor com base no número de tiques no momento, enquanto o Next sem parâmetros <xref:System.Random.%23ctor> construtor usa o relógio do sistema para gerar o valor de semente.</span><span class="sxs-lookup"><span data-stu-id="959b7-137">The parameterized <xref:System.Random.%23ctor%28System.Int32%29> constructor can take an <xref:System.Int32> value based on the number of ticks in the current time, whereas the parameterless <xref:System.Random.%23ctor> constructor uses the system clock to generate its seed value.</span></span> <span data-ttu-id="959b7-138">No entanto, como o relógio tem resolução finita, usando o construtor sem parâmetros para criar os diferentes <xref:System.Random> objetos em sucessão fechar cria geradores de números aleatórios que produzem idênticas sequências de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-138">However, because the clock has finite resolution, using the parameterless constructor to create different <xref:System.Random> objects in close succession creates random number generators that produce identical sequences of random numbers.</span></span> <span data-ttu-id="959b7-139">O exemplo a seguir ilustra como duas <xref:System.Random> objetos são instanciados em sucessão fechar geram uma série idêntica de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-139">The following example illustrates how two <xref:System.Random> objects that are instantiated in close succession generate an identical series of random numbers.</span></span> <span data-ttu-id="959b7-140">Na maioria dos sistemas Windows, <xref:System.Random> objetos criados em 15 milissegundos entre um e outro serão prováveis que valores de semente idênticos.</span><span class="sxs-lookup"><span data-stu-id="959b7-140">On most Windows systems, <xref:System.Random> objects created within 15 milliseconds of one another are likely to have identical seed values.</span></span>  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 <span data-ttu-id="959b7-141">Para evitar esse problema, crie um único <xref:System.Random> objeto em vez de vários objetos.</span><span class="sxs-lookup"><span data-stu-id="959b7-141">To avoid this problem, create a single <xref:System.Random> object instead of multiple objects.</span></span>  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a><span data-ttu-id="959b7-142">Evitando várias instanciações</span><span class="sxs-lookup"><span data-stu-id="959b7-142">Avoiding multiple instantiations</span></span>  
 <span data-ttu-id="959b7-143">Inicializar dois geradores de números aleatórios em um loop estreito, ou em sucessão rápida cria dois geradores de números aleatórios que podem produzir idênticas sequências de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-143">Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</span></span> <span data-ttu-id="959b7-144">Na maioria dos casos, isso não é intenção do desenvolvedor e pode levar a problemas de desempenho, como instanciar e inicializar um gerador de número aleatório são um processo relativamente caro.</span><span class="sxs-lookup"><span data-stu-id="959b7-144">In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</span></span>  
  
 <span data-ttu-id="959b7-145">Tanto para melhorar o desempenho e evitar a criação inadvertidamente separados geradores de números aleatórios que geram idênticas sequências numéricas, recomendamos que você criar um <xref:System.Random> objeto para gerar números aleatórios muitos ao longo do tempo, em vez de criar novo <xref:System.Random> objetos para gerar um número aleatório.</span><span class="sxs-lookup"><span data-stu-id="959b7-145">Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <xref:System.Random> object to generate many random numbers over time, instead of creating new <xref:System.Random> objects to generate one random number.</span></span>  
  
 <span data-ttu-id="959b7-146">No entanto, o <xref:System.Random> classe não é thread-safe.</span><span class="sxs-lookup"><span data-stu-id="959b7-146">However, the <xref:System.Random> class isn't thread safe.</span></span> <span data-ttu-id="959b7-147">Se você chamar <xref:System.Random> métodos de vários threads, siga as diretrizes abordadas na próxima seção.</span><span class="sxs-lookup"><span data-stu-id="959b7-147">If you call <xref:System.Random> methods from multiple threads, follow the guidelines discussed in the next section.</span></span>  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a><span data-ttu-id="959b7-148">A segurança de thread e a classe Random</span><span class="sxs-lookup"><span data-stu-id="959b7-148">The System.Random class and thread safety</span></span>  
 <span data-ttu-id="959b7-149">Em vez de criar uma instância individual <xref:System.Random> objetos, é recomendável que você crie um único <xref:System.Random> instância para gerar todos os números aleatórios exigidos pelo seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="959b7-149">Instead of instantiating individual <xref:System.Random> objects, we recommend that you create a single <xref:System.Random> instance to generate all the random numbers needed by your app.</span></span> <span data-ttu-id="959b7-150">No entanto, <xref:System.Random> objetos não são thread-safe.</span><span class="sxs-lookup"><span data-stu-id="959b7-150">However, <xref:System.Random> objects are not thread safe.</span></span> <span data-ttu-id="959b7-151">Se seu aplicativo chamar <xref:System.Random> métodos de vários threads, você deve usar um objeto de sincronização para garantir que apenas um thread pode acessar o gerador de número aleatório por vez.</span><span class="sxs-lookup"><span data-stu-id="959b7-151">If your app calls <xref:System.Random> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</span></span> <span data-ttu-id="959b7-152">Se você não garante que o <xref:System.Random> objeto é acessado de forma thread-safe, chamadas para métodos que retornam números aleatórios retornam 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-152">If you don't ensure that the <xref:System.Random> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</span></span>  
  
 <span data-ttu-id="959b7-153">O exemplo a seguir usa a linguagem c# [instrução lock](~/docs/csharp/language-reference/keywords/lock-statement.md) e o Visual Basic [Instrução SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) para garantir que um único número aleatório é acessado por 11 segmentos de uma maneira thread-safe.</span><span class="sxs-lookup"><span data-stu-id="959b7-153">The following example uses the C# [lock Statement](~/docs/csharp/language-reference/keywords/lock-statement.md) and the Visual Basic [SyncLock statement](~/docs/visual-basic/language-reference/statements/synclock-statement.md) to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</span></span> <span data-ttu-id="959b7-154">Cada thread gera 2 milhões de números aleatórios, conta o número de números aleatórios gerados e calcula a soma e, em seguida, atualiza os totais de todos os threads quando ele termina a execução.</span><span class="sxs-lookup"><span data-stu-id="959b7-154">Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</span></span>  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 <span data-ttu-id="959b7-155">O exemplo garante o acesso thread-safe das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="959b7-155">The example ensures thread-safety in the following ways:</span></span>  
  
-   <span data-ttu-id="959b7-156">O <xref:System.ThreadStaticAttribute> atributo é usado para definir as variáveis locais de thread que controlam o número total de números aleatórios gerados e sua soma para cada thread.</span><span class="sxs-lookup"><span data-stu-id="959b7-156">The <xref:System.ThreadStaticAttribute> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</span></span>  
  
-   <span data-ttu-id="959b7-157">Um bloqueio (o `lock` instrução em c# e o `SyncLock` instrução no Visual Basic) protege o acesso às variáveis para a contagem total e a soma de todos os números aleatórios gerados em todos os threads.</span><span class="sxs-lookup"><span data-stu-id="959b7-157">A lock (the `lock` statement in C# and the `SyncLock` statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</span></span>  
  
-   <span data-ttu-id="959b7-158">Um semáforo (o <xref:System.Threading.CountdownEvent> objeto) é usado para garantir que o thread principal bloqueia até que todos os outros threads concluir a execução.</span><span class="sxs-lookup"><span data-stu-id="959b7-158">A semaphore (the <xref:System.Threading.CountdownEvent> object) is used to ensure that the main thread blocks until all other threads complete execution.</span></span>  
  
-   <span data-ttu-id="959b7-159">O exemplo verifica se o gerador de número aleatório foi corrompido, determinando se as duas chamadas consecutivas para métodos de geração de número aleatório retornam 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-159">The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</span></span> <span data-ttu-id="959b7-160">Se estiver corrompido, o exemplo usa o <xref:System.Threading.CancellationTokenSource> objeto para sinalizar que todos os threads devem ser cancelados.</span><span class="sxs-lookup"><span data-stu-id="959b7-160">If corruption is detected, the example uses the <xref:System.Threading.CancellationTokenSource> object to signal that all threads should be canceled.</span></span>  
  
-   <span data-ttu-id="959b7-161">Antes de gerar cada número aleatório, cada thread verifica o estado do <xref:System.Threading.CancellationToken> objeto.</span><span class="sxs-lookup"><span data-stu-id="959b7-161">Before generating each random number, each thread checks the state of the <xref:System.Threading.CancellationToken> object.</span></span> <span data-ttu-id="959b7-162">Se for solicitado um cancelamento, o exemplo chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método cancele o thread.</span><span class="sxs-lookup"><span data-stu-id="959b7-162">If cancellation is requested, the example calls the <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> method to cancel the thread.</span></span>  
  
 <span data-ttu-id="959b7-163">O exemplo a seguir é idêntico ao primeiro, exceto que ele usa um <xref:System.Threading.Tasks.Task> objeto e uma expressão lambda em vez de <xref:System.Threading.Thread> objetos.</span><span class="sxs-lookup"><span data-stu-id="959b7-163">The following example is identical to the first, except that it uses a <xref:System.Threading.Tasks.Task> object and a lambda expression instead of <xref:System.Threading.Thread> objects.</span></span>  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 <span data-ttu-id="959b7-164">O primeiro exemplo ela difere das seguintes maneiras:</span><span class="sxs-lookup"><span data-stu-id="959b7-164">It differs from the first example in the following ways:</span></span>  
  
-   <span data-ttu-id="959b7-165">As variáveis para controlar o número de números aleatórios gerados e sua soma em cada tarefa são locais para a tarefa, portanto, não há necessidade de usar o <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="959b7-165">The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="959b7-166">Estático <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método é usado para garantir que o thread principal não for concluída antes de concluir todas as tarefas.</span><span class="sxs-lookup"><span data-stu-id="959b7-166">The static <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method is used to ensure that the main thread doesn't complete before all tasks have finished.</span></span> <span data-ttu-id="959b7-167">Não é necessário para o <xref:System.Threading.CountdownEvent> objeto.</span><span class="sxs-lookup"><span data-stu-id="959b7-167">There is no need for the <xref:System.Threading.CountdownEvent> object.</span></span>  
  
-   <span data-ttu-id="959b7-168">A exceção que é o resultado do cancelamento da tarefa será exposta no <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-168">The exception that results from task cancellation is surfaced in the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="959b7-169">No exemplo anterior, ele é manipulado por cada thread.</span><span class="sxs-lookup"><span data-stu-id="959b7-169">In the previous example, it is handled by each thread.</span></span>  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a><span data-ttu-id="959b7-170">Gerando tipos diferentes de números aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-170">Generating different types of random numbers</span></span>  
 <span data-ttu-id="959b7-171">O gerador de número aleatório fornece métodos que permitem que você gere os seguintes tipos de números aleatórios:</span><span class="sxs-lookup"><span data-stu-id="959b7-171">The random number generator provides methods that let you generate the following kinds of random numbers:</span></span>  
  
-   <span data-ttu-id="959b7-172">Uma série de <xref:System.Byte> valores.</span><span class="sxs-lookup"><span data-stu-id="959b7-172">A series of <xref:System.Byte> values.</span></span> <span data-ttu-id="959b7-173">Determinar o número de valores de byte ao passar uma matriz inicializada para o número de elementos que você deseja que o método para retornar para o <xref:System.Random.NextBytes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-173">You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <xref:System.Random.NextBytes%2A> method.</span></span> <span data-ttu-id="959b7-174">O exemplo a seguir gera 20 bytes.</span><span class="sxs-lookup"><span data-stu-id="959b7-174">The following example generates 20 bytes.</span></span>  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   <span data-ttu-id="959b7-175">Um único inteiro.</span><span class="sxs-lookup"><span data-stu-id="959b7-175">A single integer.</span></span> <span data-ttu-id="959b7-176">Você pode escolher se deseja que um inteiro de 0 até um valor máximo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) chamando o <xref:System.Random.Next> método, um número inteiro entre 0 e um valor específico chamando o <xref:System.Random.Next%28System.Int32%29> método ou um inteiro dentro de um intervalo de valores, chamando o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>método.</span><span class="sxs-lookup"><span data-stu-id="959b7-176">You can choose whether you want an integer from 0 to a maximum value (<xref:System.Int32.MaxValue?displayProperty=nameWithType> - 1) by calling the <xref:System.Random.Next> method, an integer between 0 and a specific value by calling the <xref:System.Random.Next%28System.Int32%29> method, or an integer within a range of values by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="959b7-177">As sobrecargas com parâmetros, o valor máximo especificado é exclusivo; ou seja, o número máximo real gerado é um menor do que o valor especificado.</span><span class="sxs-lookup"><span data-stu-id="959b7-177">In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</span></span>  
  
     <span data-ttu-id="959b7-178">A exemplo a seguir chama o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método gerar 10 números aleatórios entre -10 e 10.</span><span class="sxs-lookup"><span data-stu-id="959b7-178">The following example calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to generate 10 random numbers between -10 and 10.</span></span> <span data-ttu-id="959b7-179">Observe que o segundo argumento para o método Especifica o limite superior exclusivo do intervalo de valores aleatórios retornado pelo método.</span><span class="sxs-lookup"><span data-stu-id="959b7-179">Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</span></span> <span data-ttu-id="959b7-180">Em outras palavras, o maior inteiro que o método pode retornar é um menor do que esse valor.</span><span class="sxs-lookup"><span data-stu-id="959b7-180">In other words, the largest integer that the method can return is one less than this value.</span></span>  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   <span data-ttu-id="959b7-181">Um valor de ponto flutuante único de 0,0 a menor que 1,0 chamando o <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-181">A single floating-point value from 0.0 to less than 1.0 by calling the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="959b7-182">O limite superior exclusivo do número aleatório retornado pelo método é 1, portanto, o limite superior real é 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="959b7-182">The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</span></span> <span data-ttu-id="959b7-183">O exemplo a seguir gera 10 números de ponto flutuantes aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-183">The following example generates 10 random floating-point numbers.</span></span>  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="959b7-184">O <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método permite que você especifique o intervalo de número aleatório retornado.</span><span class="sxs-lookup"><span data-stu-id="959b7-184">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method allows you to specify the range of the returned random number.</span></span> <span data-ttu-id="959b7-185">No entanto, o `maxValue` parâmetro, que especifica o intervalo superior retornado número, é um recurso exclusivo, não um inclusivo, valor.</span><span class="sxs-lookup"><span data-stu-id="959b7-185">However, the `maxValue` parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="959b7-186">Isso significa que a chamada de método `Next(0, 100)` retorna um valor entre 0 e 99 e não entre 0 e 100.</span><span class="sxs-lookup"><span data-stu-id="959b7-186">This means that the method call `Next(0, 100)` returns a value between 0 and 99, and not between 0 and 100.</span></span>  
  
 <span data-ttu-id="959b7-187">Você também pode usar o <xref:System.Random> classe para tarefas como geração [valores aleatórios de T:System.Boolean](#Boolean), gerar [valores de ponto flutuante aleatório com um intervalo diferente de 0 a 1](#Floats), gerando [inteiros de 64 bits aleatórios](#Long), e [recuperando aleatoriamente um elemento exclusivo de uma matriz ou coleção](#UniqueArray).</span><span class="sxs-lookup"><span data-stu-id="959b7-187">You can also use the <xref:System.Random> class for such tasks as generating [random T:System.Boolean values](#Boolean), generating [random floating point values with a range other than 0 to 1](#Floats), generating [random 64-bit integers](#Long), and [randomly retrieving a unique element from an array or collection](#UniqueArray).</span></span> <span data-ttu-id="959b7-188">Para essas e outras tarefas comuns, consulte o [como você usar o System. Random para...](#Operations)</span><span class="sxs-lookup"><span data-stu-id="959b7-188">For these and other common tasks, see the [How do you use System.Random to…](#Operations)</span></span> <span data-ttu-id="959b7-189">seção.</span><span class="sxs-lookup"><span data-stu-id="959b7-189">section.</span></span>  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a><span data-ttu-id="959b7-190">Substituindo seu próprio algoritmo</span><span class="sxs-lookup"><span data-stu-id="959b7-190">Substituting your own algorithm</span></span>  
 <span data-ttu-id="959b7-191">Você pode implementar seu próprio gerador de número aleatório, herdando o <xref:System.Random> classe e fornecendo seu algoritmo de geração de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-191">You can implement your own random number generator by inheriting from the <xref:System.Random> class and supplying your random number generation algorithm.</span></span> <span data-ttu-id="959b7-192">Para fornecer seu próprio algoritmo, você deve substituir o <xref:System.Random.Sample%2A> método, que implementa o algoritmo de geração de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-192">To supply your own algorithm, you must override the <xref:System.Random.Sample%2A> method, which implements the random number generation algorithm.</span></span> <span data-ttu-id="959b7-193">Você também deve substituir a <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, e <xref:System.Random.NextBytes%2A> métodos para garantir que eles chamam seu substituído <xref:System.Random.Sample%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-193">You should also override the <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, and <xref:System.Random.NextBytes%2A> methods to ensure that they call your overridden <xref:System.Random.Sample%2A> method.</span></span> <span data-ttu-id="959b7-194">Você não tem que substituir a <xref:System.Random.Next%28System.Int32%29> e <xref:System.Random.NextDouble%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="959b7-194">You don't have to override the <xref:System.Random.Next%28System.Int32%29> and <xref:System.Random.NextDouble%2A> methods.</span></span>  
  
 <span data-ttu-id="959b7-195">Para obter um exemplo que deriva de <xref:System.Random> de classe e modifica seu gerador de número pseudoaleatório do padrão, consulte o <xref:System.Random.Sample%2A> página de referência.</span><span class="sxs-lookup"><span data-stu-id="959b7-195">For an example that derives from the <xref:System.Random> class and modifies its default pseudo-random number generator, see the <xref:System.Random.Sample%2A> reference page.</span></span>  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a><span data-ttu-id="959b7-196">Como você usar o System. Random para...</span><span class="sxs-lookup"><span data-stu-id="959b7-196">How do you use System.Random to…</span></span>  
 <span data-ttu-id="959b7-197">As seções a seguir abordam e proveem código de exemplo para algumas das maneiras que você talvez queira usar números aleatórios em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="959b7-197">The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</span></span>  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a><span data-ttu-id="959b7-198">Recuperar a mesma sequência de valores aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-198">Retrieve the same sequence of random values</span></span>  
 <span data-ttu-id="959b7-199">Às vezes você deseja gerar a mesma sequência de números aleatórios nos cenários de teste de software e em jogos.</span><span class="sxs-lookup"><span data-stu-id="959b7-199">Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</span></span> <span data-ttu-id="959b7-200">Teste com a mesma sequência de números aleatórios permite que você detecte regressões e confirmar as correções de bugs.</span><span class="sxs-lookup"><span data-stu-id="959b7-200">Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</span></span> <span data-ttu-id="959b7-201">Usando a mesma sequência de número aleatório em jogos permite a reprodução de jogos anteriores.</span><span class="sxs-lookup"><span data-stu-id="959b7-201">Using the same sequence of random number in games allows you to replay previous games.</span></span>  
  
 <span data-ttu-id="959b7-202">Você pode gerar a mesma sequência de números aleatórios, fornecendo o mesmo valor de semente para o <xref:System.Random.%23ctor%28System.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="959b7-202">You can generate the same sequence of random numbers by providing the same seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="959b7-203">O valor de semente fornece um valor inicial para o algoritmo de geração de números pseudoaleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-203">The seed value provides a starting value for the pseudo-random number generation algorithm.</span></span> <span data-ttu-id="959b7-204">O exemplo a seguir usa 100100 como um valor de semente arbitrário para instanciar o <xref:System.Random> objeto exibe 20 valores de ponto flutuantes aleatórios e persistir o valor de semente.</span><span class="sxs-lookup"><span data-stu-id="959b7-204">The following example uses 100100 as an arbitrary seed value to instantiate the <xref:System.Random> object, displays 20 random floating-point values, and persists the seed value.</span></span> <span data-ttu-id="959b7-205">Em seguida, restaura o valor de semente, cria uma instância de um novo gerador de número aleatório e exibe os mesmos valores de ponto flutuantes aleatórios 20.</span><span class="sxs-lookup"><span data-stu-id="959b7-205">It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</span></span>  <span data-ttu-id="959b7-206">Observe que o exemplo pode produzir sequências diferentes de números aleatórios se executados em diferentes versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="959b7-206">Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</span></span>  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a><span data-ttu-id="959b7-207">Recuperar sequências exclusivas de números aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-207">Retrieve unique sequences of random numbers</span></span>  
 <span data-ttu-id="959b7-208">Fornecer valores de seed diferente para instâncias do <xref:System.Random> classe faz com que cada gerador de número aleatório produzir uma sequência diferente de valores.</span><span class="sxs-lookup"><span data-stu-id="959b7-208">Providing different seed values to instances of the <xref:System.Random> class causes each random number generator to produce a different sequence of values.</span></span> <span data-ttu-id="959b7-209">Você pode fornecer um valor de semente explicitamente chamando o <xref:System.Random.%23ctor%28System.Int32%29> construtor, ou implicitamente chamando o <xref:System.Random.%23ctor> construtor.</span><span class="sxs-lookup"><span data-stu-id="959b7-209">You can provide a seed value either explicitly by calling the <xref:System.Random.%23ctor%28System.Int32%29> constructor, or implicitly by calling the <xref:System.Random.%23ctor> constructor.</span></span> <span data-ttu-id="959b7-210">A maioria dos desenvolvedores chamar o construtor sem parâmetros, que usa o relógio do sistema.</span><span class="sxs-lookup"><span data-stu-id="959b7-210">Most developers call the parameterless constructor, which uses the system clock.</span></span> <span data-ttu-id="959b7-211">O exemplo a seguir usa essa abordagem para instanciar dois <xref:System.Random> instâncias.</span><span class="sxs-lookup"><span data-stu-id="959b7-211">The following example uses this approach to instantiate two <xref:System.Random> instances.</span></span> <span data-ttu-id="959b7-212">Cada instância exibe uma série de inteiros aleatórios 10.</span><span class="sxs-lookup"><span data-stu-id="959b7-212">Each instance displays a series of 10 random integers.</span></span>  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 <span data-ttu-id="959b7-213">No entanto, devido à sua resolução finita, o relógio do sistema não detecta as diferenças de tempo que são menos de aproximadamente 15 milissegundos.</span><span class="sxs-lookup"><span data-stu-id="959b7-213">However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</span></span> <span data-ttu-id="959b7-214">Portanto, se seu código chama o <xref:System.Random.%23ctor> sobrecarga de instanciar dois <xref:System.Random> objetos em sucessão, talvez você inadvertidamente estar fornecendo os objetos com valores de semente idênticos.</span><span class="sxs-lookup"><span data-stu-id="959b7-214">Therefore, if your code calls the <xref:System.Random.%23ctor> overload to instantiate two <xref:System.Random> objects in succession, you might inadvertently be providing the objects with identical seed values.</span></span> <span data-ttu-id="959b7-215">Para ver isso no exemplo anterior, comente o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> chamada de método e compile e execute o exemplo novamente.</span><span class="sxs-lookup"><span data-stu-id="959b7-215">To see this in the previous example, comment out the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method call, and compile and run the example again.</span></span>  
  
 <span data-ttu-id="959b7-216">Para evitar que isso aconteça, é recomendável que você criar uma instância de um único <xref:System.Random> do objeto em vez de várias.</span><span class="sxs-lookup"><span data-stu-id="959b7-216">To prevent this from happening, we recommend that you instantiate a single <xref:System.Random> object rather than multiple ones.</span></span> <span data-ttu-id="959b7-217">No entanto, como <xref:System.Random> não é thread-safe, você deve usar algum dispositivo de sincronização, se você acessar uma <xref:System.Random> instância de vários threads; para obter mais informações, consulte [aleatório a segurança de classe e thread](#ThreadSafety) anteriores desta tópico.</span><span class="sxs-lookup"><span data-stu-id="959b7-217">However, since <xref:System.Random> isn't thread safe, you must use some synchronization device if you access a <xref:System.Random> instance from multiple threads; for more information, see [The Random class and thread safety](#ThreadSafety) earlier in this topic.</span></span> <span data-ttu-id="959b7-218">Como alternativa, você pode usar um mecanismo de atraso, como o <xref:System.Threading.Thread.Sleep%2A> método usado no exemplo anterior, para garantir que as instanciações ocorrerem mais de 15 milissegundos separados.</span><span class="sxs-lookup"><span data-stu-id="959b7-218">Alternately, you can use a delay mechanism, such as the <xref:System.Threading.Thread.Sleep%2A> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</span></span>  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a><span data-ttu-id="959b7-219">Recuperar inteiros em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-219">Retrieve integers in a specified range</span></span>  
 <span data-ttu-id="959b7-220">Você pode recuperar inteiros em um intervalo especificado chamando o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método, que permite que você especifique a menor e o limite superior dos números que você gostaria que o gerador de número aleatório para retornar.</span><span class="sxs-lookup"><span data-stu-id="959b7-220">You can retrieve integers in a specified range by calling the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</span></span> <span data-ttu-id="959b7-221">O limite superior é um recurso exclusivo, não um inclusivo, valor.</span><span class="sxs-lookup"><span data-stu-id="959b7-221">The upper bound is an exclusive, not an inclusive, value.</span></span> <span data-ttu-id="959b7-222">Ou seja, ele não está incluído no intervalo de valores retornados pelo método.</span><span class="sxs-lookup"><span data-stu-id="959b7-222">That is, it isn't included in the range of values returned by the method.</span></span> <span data-ttu-id="959b7-223">O exemplo a seguir usa esse método para gerar números aleatórios inteiros entre -10 e 10.</span><span class="sxs-lookup"><span data-stu-id="959b7-223">The following example uses this method to generate random integers between -10 and 10.</span></span> <span data-ttu-id="959b7-224">Observe que ela especifica 11, que é maior do que o valor desejado, como o valor da `maxValue` argumento na chamada do método.</span><span class="sxs-lookup"><span data-stu-id="959b7-224">Note that it specifies 11, which is one greater than the desired value, as the value of the `maxValue` argument in the method call.</span></span>  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a><span data-ttu-id="959b7-225">Recuperar inteiros com um número especificado de dígitos</span><span class="sxs-lookup"><span data-stu-id="959b7-225">Retrieve integers with a specified number of digits</span></span>  
 <span data-ttu-id="959b7-226">Você pode chamar o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para recuperar números com um número especificado de dígitos.</span><span class="sxs-lookup"><span data-stu-id="959b7-226">You can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method to retrieve numbers with a specified number of digits.</span></span> <span data-ttu-id="959b7-227">Por exemplo, para recuperar números com quatro dígitos (ou seja, números que variam de 1000 a 9999), que você chame o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método com um `minValue` valor de 1000 e um `maxValue` valor de 10000, como mostra o exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="959b7-227">For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method with a `minValue` value of 1000 and a `maxValue` value of 10000, as the following example shows.</span></span>  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a><span data-ttu-id="959b7-228">Recuperar valores de ponto flutuante em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-228">Retrieve floating-point values in a specified range</span></span>  
 <span data-ttu-id="959b7-229">O <xref:System.Random.NextDouble%2A> método retorna valores de ponto flutuante aleatórios que variam de 0 a menor que 1.</span><span class="sxs-lookup"><span data-stu-id="959b7-229">The <xref:System.Random.NextDouble%2A> method returns random floating-point values that range from 0 to less than 1.</span></span> <span data-ttu-id="959b7-230">No entanto, você geralmente desejará gerar valores aleatórios em algum outro intervalo.</span><span class="sxs-lookup"><span data-stu-id="959b7-230">However, you'll often want to generate random values in some other range.</span></span>  
  
 <span data-ttu-id="959b7-231">Se o intervalo entre os valores mínimo e máximo desejados for 1, você pode adicionar a diferença entre o intervalo de início desejado e 0 ao número retornado pelo <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-231">If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <xref:System.Random.NextDouble%2A> method.</span></span> <span data-ttu-id="959b7-232">O exemplo a seguir faz isso para gerar 10 números aleatórios entre -1 e 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-232">The following example does this to generate 10 random numbers between -1 and 0.</span></span>  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 <span data-ttu-id="959b7-233">Para gerar números de ponto flutuante aleatórios cujo limite inferior é 0, mas limite superior é maior que 1 (ou, no caso de números negativos, cujo limite inferior é menor que -1 e limite superior é 0), multiplique o número aleatório pelo limite diferente de zero.</span><span class="sxs-lookup"><span data-stu-id="959b7-233">To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</span></span> <span data-ttu-id="959b7-234">O exemplo a seguir faz isso para gerar números de ponto flutuante aleatórios de 20 milhões que variam de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-234">The following example does this to generate 20 million random floating-point numbers that range from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="959b7-235">No também exibe a distribuição dos valores aleatórios gerados pelo método.</span><span class="sxs-lookup"><span data-stu-id="959b7-235">In also displays the distribution of the random values generated by the method.</span></span>  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 <span data-ttu-id="959b7-236">Para gerar números de ponto flutuante aleatórios entre dois valores arbitrários, como o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método faz para números inteiros, use a seguinte fórmula:</span><span class="sxs-lookup"><span data-stu-id="959b7-236">To generate random floating-point numbers between two arbitrary values, like the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method does for integers, use the following formula:</span></span>  
  
```csharp  
Random.NextDouble() * (maxValue - minValue) + minValue  
```  
  
 <span data-ttu-id="959b7-237">O exemplo a seguir gera números aleatórios de 1 milhão que variam de 10.0 a 11.0 e exibe sua distribuição.</span><span class="sxs-lookup"><span data-stu-id="959b7-237">The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</span></span>  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a><span data-ttu-id="959b7-238">Gerar valores aleatórios de boolianos</span><span class="sxs-lookup"><span data-stu-id="959b7-238">Generate random Boolean values</span></span>  
 <span data-ttu-id="959b7-239">O <xref:System.Random> classe não fornece métodos que geram <xref:System.Boolean> valores.</span><span class="sxs-lookup"><span data-stu-id="959b7-239">The <xref:System.Random> class doesn't provide methods that generate <xref:System.Boolean> values.</span></span> <span data-ttu-id="959b7-240">No entanto, você pode definir sua própria classe ou método para fazer isso.</span><span class="sxs-lookup"><span data-stu-id="959b7-240">However, you can define your own class or method to do that.</span></span> <span data-ttu-id="959b7-241">O exemplo a seguir define uma classe, `BooleanGenerator`, com um único método, `NextBoolean`.</span><span class="sxs-lookup"><span data-stu-id="959b7-241">The following example defines a class, `BooleanGenerator`, with a single method, `NextBoolean`.</span></span> <span data-ttu-id="959b7-242">O `BooleanGenerator` classe armazena um <xref:System.Random> objeto como uma variável particular.</span><span class="sxs-lookup"><span data-stu-id="959b7-242">The `BooleanGenerator` class stores a <xref:System.Random> object as a private variable.</span></span> <span data-ttu-id="959b7-243">O `NextBoolean` chamadas de método de <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método e passa o resultado para o <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-243">The `NextBoolean` method calls the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method and passes the result to the <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="959b7-244">Observe que 2 é usado como o argumento para especificar o limite superior do número aleatório.</span><span class="sxs-lookup"><span data-stu-id="959b7-244">Note that 2 is used as the argument to specify the upper bound of the random number.</span></span> <span data-ttu-id="959b7-245">Uma vez que esse é um valor exclusivo, a chamada de método retorna 0 ou 1.</span><span class="sxs-lookup"><span data-stu-id="959b7-245">Since this is an exclusive value, the method call returns either 0 or 1.</span></span>  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 <span data-ttu-id="959b7-246">Em vez de criar uma classe separada para gerar aleatório <xref:System.Boolean> valores, o exemplo poderia simplesmente ter definido um único método.</span><span class="sxs-lookup"><span data-stu-id="959b7-246">Instead of creating a separate class to generate random <xref:System.Boolean> values, the example could simply have defined a single method.</span></span> <span data-ttu-id="959b7-247">Nesse caso, no entanto, o <xref:System.Random> objeto deve ter sido definido como uma variável de nível de classe para evitar a instanciar um novo <xref:System.Random> instância em cada chamada de método.</span><span class="sxs-lookup"><span data-stu-id="959b7-247">In that case, however, the <xref:System.Random> object should have been defined as a class-level variable to avoid instantiating a new <xref:System.Random> instance in each method call.</span></span> <span data-ttu-id="959b7-248">No Visual Basic, a instância de Random pode ser definida como um [estáticos](~/docs/visual-basic/language-reference/modifiers/static.md) variável o `NextBoolean` método.</span><span class="sxs-lookup"><span data-stu-id="959b7-248">In Visual Basic, the Random instance can be defined as a [Static](~/docs/visual-basic/language-reference/modifiers/static.md) variable in the `NextBoolean` method.</span></span>  <span data-ttu-id="959b7-249">O exemplo a seguir fornece uma implementação.</span><span class="sxs-lookup"><span data-stu-id="959b7-249">The following example provides an implementation.</span></span>  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a><span data-ttu-id="959b7-250">Gerar inteiros de 64 bits aleatórios</span><span class="sxs-lookup"><span data-stu-id="959b7-250">Generate random 64-bit integers</span></span>  
 <span data-ttu-id="959b7-251">As sobrecargas de <xref:System.Random.Next%2A> método retornam inteiros de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="959b7-251">The overloads of the <xref:System.Random.Next%2A> method return 32-bit integers.</span></span> <span data-ttu-id="959b7-252">No entanto, em alguns casos, você talvez queira trabalhar com números inteiros de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="959b7-252">However, in some cases, you might want to work with 64-bit integers.</span></span> <span data-ttu-id="959b7-253">Você pode fazer isso da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="959b7-253">You can do this as follows:</span></span>  
  
1.  <span data-ttu-id="959b7-254">Chamar o <xref:System.Random.NextDouble%2A> valor de ponto do método para recuperar um flutuante de precisão dupla.</span><span class="sxs-lookup"><span data-stu-id="959b7-254">Call the <xref:System.Random.NextDouble%2A> method to retrieve a double-precision floating point value.</span></span>  
  
2.  <span data-ttu-id="959b7-255">Multiplique esse valor por <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-255">Multiply that value by <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="959b7-256">O exemplo a seguir usa essa técnica para gerar inteiros longos aleatórios de 20 milhões e categoriza-los em 10 grupos iguais.</span><span class="sxs-lookup"><span data-stu-id="959b7-256">The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</span></span> <span data-ttu-id="959b7-257">Ele avalia a distribuição de números aleatórios pela contagem do número em cada grupo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-257">It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <xref:System.Int64.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="959b7-258">Como mostra a saída do exemplo, os números são mais ou menos igualmente distribuídos por meio do intervalo de um inteiro longo.</span><span class="sxs-lookup"><span data-stu-id="959b7-258">As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</span></span>  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 <span data-ttu-id="959b7-259">Uma técnica alternativa que usa a manipulação de bits não gera números verdadeiramente aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-259">An alternative technique that uses bit manipulation does not generate truly random numbers.</span></span> <span data-ttu-id="959b7-260">Essa técnica chama <xref:System.Random.Next> para gerar dois inteiros, desloca a esquerda um 32 bits e ORs-los juntos.</span><span class="sxs-lookup"><span data-stu-id="959b7-260">This technique calls <xref:System.Random.Next> to generate two integers, left-shifts one by 32 bits, and ORs them together.</span></span> <span data-ttu-id="959b7-261">Essa técnica tem duas limitações:</span><span class="sxs-lookup"><span data-stu-id="959b7-261">This technique has two limitations:</span></span>  
  
1.  <span data-ttu-id="959b7-262">Como o bit 31 é o bit de sinal, o valor em 31 de bit de inteiro longo resultante é sempre 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-262">Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</span></span>  <span data-ttu-id="959b7-263">Isso pode ser resolvido por meio da geração aleatória 0 ou 1, o deslocamento à esquerda de 31 bits e o uso de or-lo com o inteiro longo aleatório original.</span><span class="sxs-lookup"><span data-stu-id="959b7-263">This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</span></span>  
  
2.  <span data-ttu-id="959b7-264">Mais a sério, pois a probabilidade de que o valor retornado por <xref:System.Random.Next> será 0, haverá alguns se houver números aleatórios no intervalo 0x00000000FFFFFFFF 0x0.</span><span class="sxs-lookup"><span data-stu-id="959b7-264">More seriously, because the probability that the value returned by <xref:System.Random.Next> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</span></span>  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a><span data-ttu-id="959b7-265">Recuperar bytes em um intervalo especificado</span><span class="sxs-lookup"><span data-stu-id="959b7-265">Retrieve bytes in a specified range</span></span>  
 <span data-ttu-id="959b7-266">As sobrecargas do <xref:System.Random.Next%2A> método permitem que você especifique o intervalo de números aleatórios, mas o <xref:System.Random.NextBytes%2A> método não faz.</span><span class="sxs-lookup"><span data-stu-id="959b7-266">The overloads of the <xref:System.Random.Next%2A> method allow you to specify the range of random numbers, but the <xref:System.Random.NextBytes%2A> method does not.</span></span> <span data-ttu-id="959b7-267">O exemplo a seguir implementa um `NextBytes` método que permite que você especifique o intervalo de bytes retornados.</span><span class="sxs-lookup"><span data-stu-id="959b7-267">The following example implements a `NextBytes` method that lets you specify the range of the returned bytes.</span></span> <span data-ttu-id="959b7-268">Ele define uma `Random2` classe que deriva <xref:System.Random> e sobrecarrega sua `NextBytes` método.</span><span class="sxs-lookup"><span data-stu-id="959b7-268">It defines a `Random2` class that derives from <xref:System.Random> and overloads its `NextBytes` method.</span></span>  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 <span data-ttu-id="959b7-269">O `NextBytes(Byte[], Byte, Byte)` método encapsula uma chamada para o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método e especifica o valor mínimo e um maior que o valor máximo (nesse caso, 0 e 101) que queremos retornados na matriz de bytes.</span><span class="sxs-lookup"><span data-stu-id="959b7-269">The `NextBytes(Byte[], Byte, Byte)` method wraps a call to the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</span></span> <span data-ttu-id="959b7-270">Como temos certeza de que os valores inteiros retornados pelo <xref:System.Random.Next%2A> método estão dentro do intervalo da <xref:System.Byte> tipo de dados, podemos com segurança converta-a (em c#) ou converta-os (no Visual Basic) de inteiros em bytes.</span><span class="sxs-lookup"><span data-stu-id="959b7-270">Because we are sure that the integer values returned by the <xref:System.Random.Next%2A> method are within the range of the <xref:System.Byte> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</span></span>  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a><span data-ttu-id="959b7-271">Recuperar um elemento de uma matriz ou coleção aleatório</span><span class="sxs-lookup"><span data-stu-id="959b7-271">Retrieve an element from an array or collection at random</span></span>  
 <span data-ttu-id="959b7-272">Números aleatórios geralmente servem como índices para recuperar valores de matrizes ou coleções.</span><span class="sxs-lookup"><span data-stu-id="959b7-272">Random numbers often serve as indexes to retrieve values from arrays or collections.</span></span> <span data-ttu-id="959b7-273">Para recuperar um valor de índice aleatório, você pode chamar o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método e use o limite inferior da matriz como o valor do seu `minValue` argumento e um número maior que o limite superior da matriz como o valor do seu `maxValue` argumento.</span><span class="sxs-lookup"><span data-stu-id="959b7-273">To retrieve a random index value, you can call the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> method, and use the lower bound of the array as the value of its `minValue` argument and one greater than the upper bound of the array as the value of its `maxValue` argument.</span></span> <span data-ttu-id="959b7-274">Para uma matriz com base em zero, isso é equivalente a sua <xref:System.Array.Length%2A> propriedade ou um número maior que o valor retornado pelo <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-274">For a zero-based array, this is equivalent to its <xref:System.Array.Length%2A> property, or one greater than the value returned by the <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="959b7-275">O exemplo a seguir aleatoriamente recupera o nome de uma cidade nos Estados Unidos de uma matriz de cidades.</span><span class="sxs-lookup"><span data-stu-id="959b7-275">The following example randomly retrieves the name of a city in the United States from an array of cities.</span></span>  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a><span data-ttu-id="959b7-276">Recuperar um elemento exclusivo de uma matriz ou coleção</span><span class="sxs-lookup"><span data-stu-id="959b7-276">Retrieve a unique element from an array or collection</span></span>  
 <span data-ttu-id="959b7-277">Um gerador de número aleatório sempre pode retornar valores duplicados.</span><span class="sxs-lookup"><span data-stu-id="959b7-277">A random number generator can always return duplicate values.</span></span> <span data-ttu-id="959b7-278">Como o intervalo de números se torna menor ou o número de valores gerados se torna maior, aumenta a probabilidade de duplicatas.</span><span class="sxs-lookup"><span data-stu-id="959b7-278">As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</span></span> <span data-ttu-id="959b7-279">Se valores aleatórios devem ser exclusivos, mais números são gerados para compensar as duplicatas, resultando em cada vez mais baixo desempenho.</span><span class="sxs-lookup"><span data-stu-id="959b7-279">If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</span></span>  
  
 <span data-ttu-id="959b7-280">Há várias técnicas para lidar com esse cenário.</span><span class="sxs-lookup"><span data-stu-id="959b7-280">There are a number of techniques to handle this scenario.</span></span> <span data-ttu-id="959b7-281">Uma solução comum é criar uma matriz ou coleção que contém os valores a serem recuperados e uma matriz paralela que contém números de ponto flutuante aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-281">One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</span></span> <span data-ttu-id="959b7-282">A segunda matriz é preenchida com números aleatórios no momento em que a primeira matriz é criada, e o <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método é usado para classificar a primeira matriz usando os valores na matriz paralela.</span><span class="sxs-lookup"><span data-stu-id="959b7-282">The second array is populated with random numbers at the time the first array is created, and the <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is used to sort the first array by using the values in the parallel array.</span></span>  
  
 <span data-ttu-id="959b7-283">Por exemplo, se você estiver desenvolvendo um jogo de Paciência, convém garantir que cada cartão é usado apenas uma vez.</span><span class="sxs-lookup"><span data-stu-id="959b7-283">For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</span></span> <span data-ttu-id="959b7-284">Em vez de gerar números aleatórios para recuperar um cartão e controlar se esse cartão já lidou, você pode criar uma matriz paralela de números aleatórios que podem ser usados para classificar o baralho.</span><span class="sxs-lookup"><span data-stu-id="959b7-284">Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</span></span> <span data-ttu-id="959b7-285">Depois que o baralho é classificado, seu aplicativo pode manter um ponteiro para indicar o índice do próximo cartão no baralho.</span><span class="sxs-lookup"><span data-stu-id="959b7-285">Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</span></span>  
  
 <span data-ttu-id="959b7-286">O exemplo a seguir ilustra esta abordagem.</span><span class="sxs-lookup"><span data-stu-id="959b7-286">The following example illustrates this approach.</span></span> <span data-ttu-id="959b7-287">Ele define uma `Card` classe que representa uma carta em jogo e um `Dealer` classe que trata um baralho de cartas embaralhados.</span><span class="sxs-lookup"><span data-stu-id="959b7-287">It defines a `Card` class that represents a playing card and a `Dealer` class that deals a deck of shuffled cards.</span></span> <span data-ttu-id="959b7-288">O `Dealer` construtor de classe preenche duas matrizes: uma `deck` matriz que tem o escopo de classe e que representa todas as cartas de baralho e um local `order` matriz que tem o mesmo número de elementos como o `deck` de matriz e é preenchido com o gerado aleatoriamente <xref:System.Double> valores.</span><span class="sxs-lookup"><span data-stu-id="959b7-288">The `Dealer` class constructor populates two arrays: a `deck` array that has class scope and that represents all the cards in the deck; and a local `order` array that has the same number of elements as the `deck` array and is populated with randomly generated <xref:System.Double> values.</span></span>  <span data-ttu-id="959b7-289">O <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método é chamado, em seguida, para classificar os `deck` matriz com base nos valores da `order` matriz.</span><span class="sxs-lookup"><span data-stu-id="959b7-289">The <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> method is then called to sort the `deck` array based on the values in the `order` array.</span></span>  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 <span data-ttu-id="959b7-290">O exemplo a seguir cria um gerador de número aleatório único e chama seu <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, e <xref:System.Random.NextDouble%2A> métodos para gerar sequências de números aleatórios dentro de intervalos diferentes.</span><span class="sxs-lookup"><span data-stu-id="959b7-290">The following example creates a single random number generator and calls its <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, and <xref:System.Random.NextDouble%2A> methods to generate sequences of random numbers within different ranges.</span></span>  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 <span data-ttu-id="959b7-291">O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="959b7-291">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="959b7-292">No .NET Framework 1.0 e 1.1, uma implementação mínima de uma classe derivada de <see cref="T:System.Random" /> obrigatório substituindo o <see cref="M:System.Random.Sample" /> método para definir um algoritmo de novo ou modificado para gerar números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-292">In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <see cref="T:System.Random" /> required overriding the <see cref="M:System.Random.Sample" /> method to define a new or modified algorithm for generating random numbers.</span></span> <span data-ttu-id="959b7-293">A classe derivada, em seguida, poderia contar que a implementação da classe base a <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, e <see cref="M:System.Random.NextDouble" /> métodos para chamar a implementação da classe derivada de <see cref="M:System.Random.Sample" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-293">The derived class could then rely on the base class implementation of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, and <see cref="M:System.Random.NextDouble" /> methods to call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span>  
  
<span data-ttu-id="959b7-294">No .NET Framework 2.0 e posterior, o comportamento do <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, e <see cref="M:System.Random.NextBytes(System.Byte[])" /> métodos foram alterados para que esses métodos não necessariamente chamar a implementação da classe derivada de <see cref="M:System.Random.Sample" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-294">In the .NET Framework 2.0 and later, the behavior of the <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, and <see cref="M:System.Random.NextBytes(System.Byte[])" /> methods have changed so that these methods do not necessarily call the derived class implementation of the <see cref="M:System.Random.Sample" /> method.</span></span> <span data-ttu-id="959b7-295">Como resultado, as classes derivadas de <see cref="T:System.Random" /> que direcionar o .NET Framework 2.0 e posterior, também deverá substituir esses três métodos.</span><span class="sxs-lookup"><span data-stu-id="959b7-295">As a result, classes derived from <see cref="T:System.Random" /> that target the .NET Framework 2.0 and later should also override these three methods.</span></span></para></block>
    <block subset="none" type="usage"><para><span data-ttu-id="959b7-296">A implementação do gerador de número aleatório no <see cref="T:System.Random" /> classe não é garantido que permanecem as mesmas entre as versões principais do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="959b7-296">The implementation of the random number generator in the <see cref="T:System.Random" /> class isn't guaranteed to remain the same across major versions of the .NET Framework.</span></span> <span data-ttu-id="959b7-297">Como resultado, você não deve presumir que a mesma semente resultará na mesma sequência pseudoaleatória em diferentes versões do .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="959b7-297">As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</span></span></para></block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="959b7-298">Inicializa uma nova instância da classe <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-298">Initializes a new instance of the <see cref="T:System.Random" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="959b7-299">Inicializa uma nova instância da classe <see cref="T:System.Random" />, usando um valor de semente padrão dependente de tempo.</span><span class="sxs-lookup"><span data-stu-id="959b7-299">Initializes a new instance of the <see cref="T:System.Random" /> class, using a time-dependent default seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-300">O valor de semente padrão é derivado do relógio do sistema e tem resolução finita.</span><span class="sxs-lookup"><span data-stu-id="959b7-300">The default seed value is derived from the system clock and has finite resolution.</span></span> <span data-ttu-id="959b7-301">Como resultado, diferente <xref:System.Random> objetos que são criados em sucessão Fechar por uma chamada para o construtor padrão terão valores de semente padrão idênticos e, portanto, produzirão conjuntos idênticos de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-301">As a result, different <xref:System.Random> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</span></span> <span data-ttu-id="959b7-302">Esse problema pode ser evitado usando um único <xref:System.Random> objeto para gerar todos os números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-302">This problem can be avoided by using a single <xref:System.Random> object to generate all random numbers.</span></span> <span data-ttu-id="959b7-303">Você também pode trabalhar em torno dele, modificando o valor de semente retornado pelo relógio do sistema e, em seguida, esse novo valor de semente para fornecer explicitamente o <xref:System.Random.%23ctor%28System.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="959b7-303">You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span> <span data-ttu-id="959b7-304">Para obter mais informações, consulte o <xref:System.Random.%23ctor%28System.Int32%29> construtor.</span><span class="sxs-lookup"><span data-stu-id="959b7-304">For more information, see the <xref:System.Random.%23ctor%28System.Int32%29> constructor.</span></span>  
  
 <span data-ttu-id="959b7-305">Chame esse construtor, se você quiser que seu gerador de número aleatório para gerar uma sequência aleatória de números.</span><span class="sxs-lookup"><span data-stu-id="959b7-305">Call this constructor if you want your random number generator to generate a random sequence of numbers.</span></span> <span data-ttu-id="959b7-306">Para gerar uma sequência fixa de números aleatórios que serão o mesmo para diferentes geradores de números aleatórios, chame o <xref:System.Random.%23ctor%28System.Int32%29> construtor com um valor de semente fixa.</span><span class="sxs-lookup"><span data-stu-id="959b7-306">To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <xref:System.Random.%23ctor%28System.Int32%29> constructor with a fixed seed value .</span></span> <span data-ttu-id="959b7-307">Isso <xref:System.Random> sobrecarga de construtor é usada com frequência ao testar aplicativos que usam números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-307">This <xref:System.Random> constructor overload is frequently used when testing apps that use random numbers.</span></span>  
  
 <span data-ttu-id="959b7-308">Após instanciar o gerador de número aleatório, você pode chamar individuais <xref:System.Random> métodos, tais como <xref:System.Random.Next> ou <xref:System.Random.NextDouble>, para gerar números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-308">Once you've instantiated the random number generator, you call individual <xref:System.Random> methods, such as <xref:System.Random.Next> or <xref:System.Random.NextDouble>, to generate random numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-309">O exemplo a seguir usa o construtor padrão para instanciar três <xref:System.Random> objetos e exibe uma sequência de cinco inteiros aleatórios para cada um.</span><span class="sxs-lookup"><span data-stu-id="959b7-309">The following example uses the default constructor to instantiate three <xref:System.Random> objects and displays a sequence of five random integers for each.</span></span> <span data-ttu-id="959b7-310">Porque os dois primeiros <xref:System.Random> objetos são criados em sucessão fechar, eles são instanciados usando valores de semente idêntico com base no relógio do sistema e, portanto, eles produzem uma sequência idêntica de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-310">Because the first two <xref:System.Random> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</span></span> <span data-ttu-id="959b7-311">Por outro lado, o construtor padrão do terceiro <xref:System.Random> objeto é chamado após um atraso de dois segundos causado ao chamar o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-311">On the other hand, the default constructor of the third <xref:System.Random> object is called after a two-second delay caused by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="959b7-312">Porque isso produz um valor de semente diferentes para a terceira <xref:System.Random> do objeto, ele produz uma sequência diferente de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-312">Because this produces a different seed value for the third <xref:System.Random> object, it produces a different sequence of random numbers.</span></span>  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed"><span data-ttu-id="959b7-313">Um número usado para calcular um valor inicial para a sequência numérica pseudoaleatória.</span><span class="sxs-lookup"><span data-stu-id="959b7-313">A number used to calculate a starting value for the pseudo-random number sequence.</span></span> <span data-ttu-id="959b7-314">Se um número negativo for especificado, o valor absoluto do número será usado.</span><span class="sxs-lookup"><span data-stu-id="959b7-314">If a negative number is specified, the absolute value of the number is used.</span></span></param>
        <summary><span data-ttu-id="959b7-315">Inicializa uma nova instância da classe <see cref="T:System.Random" />, usando o valor de semente especificado.</span><span class="sxs-lookup"><span data-stu-id="959b7-315">Initializes a new instance of the <see cref="T:System.Random" /> class, using the specified seed value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-316">Fornecendo um valor de semente idênticos para diferentes <xref:System.Random> objetos faz com que cada instância produzir sequências idênticas de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-316">Providing an identical seed value to different <xref:System.Random> objects causes each instance to produce identical sequences of random numbers.</span></span> <span data-ttu-id="959b7-317">Isso é feito com frequência ao testar aplicativos que dependem de geradores de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-317">This is often done when testing apps that rely on random number generators.</span></span>  
  
 <span data-ttu-id="959b7-318">Se seu aplicativo exigir sequências diferentes de número aleatórias, chama este construtor várias vezes com valores de seed diferente.</span><span class="sxs-lookup"><span data-stu-id="959b7-318">If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</span></span> <span data-ttu-id="959b7-319">É uma maneira de produzir um valor de semente exclusivo para torná-lo dependente de tempo.</span><span class="sxs-lookup"><span data-stu-id="959b7-319">One way to produce a unique seed value is to make it time-dependent.</span></span> <span data-ttu-id="959b7-320">Por exemplo, derivar o valor de semente do relógio do sistema, como o <xref:System.Random.%23ctor> faz de sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="959b7-320">For example, derive the seed value from the system clock, as the <xref:System.Random.%23ctor> overload does.</span></span> <span data-ttu-id="959b7-321">No entanto, o relógio do sistema pode não ter resolução suficiente para fornecer diferentes invocações desse construtor com um valor de seed diferente.</span><span class="sxs-lookup"><span data-stu-id="959b7-321">However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</span></span> <span data-ttu-id="959b7-322">Isso resulta em geradores de números aleatórios que geram idênticas sequências de números pseudoaleatórios, conforme ilustrado pelas duas primeiras <xref:System.Random> objetos no exemplo a seguir.</span><span class="sxs-lookup"><span data-stu-id="959b7-322">This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <xref:System.Random> objects in the following example.</span></span> <span data-ttu-id="959b7-323">Para evitar isso, aplicar um algoritmo para diferenciar o valor de semente em cada invocação ou a chamada a <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para garantir que você forneça cada construtor com um valor de seed diferente.</span><span class="sxs-lookup"><span data-stu-id="959b7-323">To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method to ensure that you provide each constructor with a different seed value.</span></span>  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 <span data-ttu-id="959b7-324">Outra opção é criar uma instância de um único <xref:System.Random> objeto que você usar para gerar todos os números aleatórios em seu aplicativo.</span><span class="sxs-lookup"><span data-stu-id="959b7-324">Another option is to instantiate a single <xref:System.Random> object that you use to generate all the random numbers in your application.</span></span> <span data-ttu-id="959b7-325">Isso resulta em um desempenho ligeiramente melhor, já que é bastante dispendiosa, criando uma instância de um gerador de número aleatório.</span><span class="sxs-lookup"><span data-stu-id="959b7-325">This yields slightly better performance, since instantiating a random number generator is fairly expensive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-326">O exemplo a seguir cria <xref:System.Random> objetos com o construtor da classe que usa um parâmetro de semente e gera uma sequência de inteiros aleatórios e doubles.</span><span class="sxs-lookup"><span data-stu-id="959b7-326">The following example creates <xref:System.Random> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</span></span> <span data-ttu-id="959b7-327">O exemplo ilustra que a mesma sequência é gerada quando o <xref:System.Random> objeto é criado novamente com o parâmetro de construtor e a propagação.</span><span class="sxs-lookup"><span data-stu-id="959b7-327">The example illustrates that the same sequence is generated when the <xref:System.Random> object is created again with the constructor and seed parameter.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="959b7-328">Retorna um inteiro aleatório.</span><span class="sxs-lookup"><span data-stu-id="959b7-328">Returns a random integer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="959b7-329">Retorna um inteiro aleatório não negativo.</span><span class="sxs-lookup"><span data-stu-id="959b7-329">Returns a non-negative random integer.</span></span></summary>
        <returns><span data-ttu-id="959b7-330">Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-330">A 32-bit signed integer that is greater than or equal to 0 and less than <see cref="F:System.Int32.MaxValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> gera um número aleatório cujo valor varia de 0 a menos de <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-331"><xref:System.Random.Next%2A?displayProperty=nameWithType> generates a random number whose value ranges from 0 to less than <xref:System.Int32.MaxValue?displayProperty=nameWithType>.</span></span> <span data-ttu-id="959b7-332">Para gerar um número aleatório cujo valor varia de 0 para algum outro número positivo, use o <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="959b7-332">To generate a random number whose value ranges from 0 to some other positive number, use the <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="959b7-333">Para gerar um número aleatório dentro de um intervalo diferente, use o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="959b7-333">To generate a random number within a different range, use the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-334">O exemplo a seguir faz chamadas repetidas para o <xref:System.Random.Next%2A> método para gerar um número específico de números aleatórios solicitados pelo usuário.</span><span class="sxs-lookup"><span data-stu-id="959b7-334">The following example makes repeated calls to the <xref:System.Random.Next%2A> method to generate a specific number of random numbers requested by the user.</span></span> <span data-ttu-id="959b7-335">O <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método é usado para obter a entrada do cliente.</span><span class="sxs-lookup"><span data-stu-id="959b7-335">The <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> method is used to get customer input.</span></span>  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 <span data-ttu-id="959b7-336">O exemplo a seguir deriva uma classe de <xref:System.Random> para gerar uma sequência de números aleatórios cuja distribuição é diferente da distribuição uniforme gerada pelo <xref:System.Random.Sample%2A> método da classe base.</span><span class="sxs-lookup"><span data-stu-id="959b7-336">The following example derives a class from <xref:System.Random> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span> <span data-ttu-id="959b7-337">Ele substitui o <xref:System.Random.Sample%2A> método para fornecer a distribuição de números aleatórios e substituições de <xref:System.Random.Next%2A?displayProperty=nameWithType> método para usar a série de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-337">It overrides the <xref:System.Random.Sample%2A> method to provide the distribution of random numbers, and overrides the <xref:System.Random.Next%2A?displayProperty=nameWithType> method to use series of random numbers.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="959b7-338">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.Next" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-338">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next" /> method.</span></span> <span data-ttu-id="959b7-339">Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada.</span><span class="sxs-lookup"><span data-stu-id="959b7-339">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="959b7-340">Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-340">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="959b7-341">Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.Next" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-341">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next" /> method.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue"><span data-ttu-id="959b7-342">O limite superior exclusivo do número aleatório a ser gerado.</span><span class="sxs-lookup"><span data-stu-id="959b7-342">The exclusive upper bound of the random number to be generated.</span></span> <span data-ttu-id="959b7-343"><paramref name="maxValue" /> deve ser maior ou igual a 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-343"><paramref name="maxValue" /> must be greater than or equal to 0.</span></span></param>
        <summary><span data-ttu-id="959b7-344">Retorna um número inteiro aleatório não negativo menor que o máximo especificado.</span><span class="sxs-lookup"><span data-stu-id="959b7-344">Returns a non-negative random integer that is less than the specified maximum.</span></span></summary>
        <returns><span data-ttu-id="959b7-345">Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <paramref name="maxValue" />; ou seja, o intervalo de valores retornados inclui 0, mas não <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-345">A 32-bit signed integer that is greater than or equal to 0, and less than <paramref name="maxValue" />; that is, the range of return values ordinarily includes 0 but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="959b7-346">No entanto, se <paramref name="maxValue" /> for igual a 0, <paramref name="maxValue" /> será retornado.</span><span class="sxs-lookup"><span data-stu-id="959b7-346">However, if <paramref name="maxValue" /> equals 0, <paramref name="maxValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-347">O <xref:System.Random.Next%28System.Int32%29> sobrecarga retorna inteiros aleatórios que variam de 0 a `maxValue` - 1.</span><span class="sxs-lookup"><span data-stu-id="959b7-347">The <xref:System.Random.Next%28System.Int32%29> overload returns random integers that range from 0 to `maxValue` - 1.</span></span> <span data-ttu-id="959b7-348">No entanto, se `maxValue` for 0, o método retornará 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-348">However, if `maxValue` is 0, the method returns 0.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-349">O exemplo a seguir gera inteiros aleatórios com várias sobrecargas do <xref:System.Random.Next%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-349">The following example generates random integers with various overloads of the <xref:System.Random.Next%2A> method.</span></span>  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 <span data-ttu-id="959b7-350">O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="959b7-350">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="959b7-351">Como o maior índice da matriz é um menor que seu tamanho, o valor da <xref:System.Array.Length%2A?displayProperty=nameWithType> propriedade é fornecida como um o `maxValue` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="959b7-351">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="959b7-352"><paramref name="maxValue" /> é menor que 0.</span><span class="sxs-lookup"><span data-stu-id="959b7-352"><paramref name="maxValue" /> is less than 0.</span></span></exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue"><span data-ttu-id="959b7-353">O limite inferior inclusivo do número aleatório retornado.</span><span class="sxs-lookup"><span data-stu-id="959b7-353">The inclusive lower bound of the random number returned.</span></span></param>
        <param name="maxValue"><span data-ttu-id="959b7-354">O limite superior exclusivo do número aleatório retornado.</span><span class="sxs-lookup"><span data-stu-id="959b7-354">The exclusive upper bound of the random number returned.</span></span> <span data-ttu-id="959b7-355"><paramref name="maxValue" /> deve ser maior ou igual a <paramref name="minValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-355"><paramref name="maxValue" /> must be greater than or equal to <paramref name="minValue" />.</span></span></param>
        <summary><span data-ttu-id="959b7-356">Retorna um inteiro aleatório que está dentro do intervalo especificado.</span><span class="sxs-lookup"><span data-stu-id="959b7-356">Returns a random integer that is within a specified range.</span></span></summary>
        <returns><span data-ttu-id="959b7-357">Um inteiro com sinal de 32 bits maior ou igual a <paramref name="minValue" /> e menor que <paramref name="maxValue" />; ou seja, o intervalo de valores retornados inclui <paramref name="minValue" />, mas não <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-357">A 32-bit signed integer greater than or equal to <paramref name="minValue" /> and less than <paramref name="maxValue" />; that is, the range of return values includes <paramref name="minValue" /> but not <paramref name="maxValue" />.</span></span> <span data-ttu-id="959b7-358">Se <paramref name="minValue" /> for igual a <paramref name="maxValue" />, <paramref name="minValue" /> será retornado.</span><span class="sxs-lookup"><span data-stu-id="959b7-358">If <paramref name="minValue" /> equals <paramref name="maxValue" />, <paramref name="minValue" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-359">O <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> sobrecarga retorna inteiros aleatórios que vão desde `minValue` para `maxValue` - 1.</span><span class="sxs-lookup"><span data-stu-id="959b7-359">The <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> overload returns random integers that range from `minValue` to `maxValue` - 1.</span></span> <span data-ttu-id="959b7-360">No entanto, se `maxValue` é igual a `minValue`, o método retorna `minValue`.</span><span class="sxs-lookup"><span data-stu-id="959b7-360">However, if `maxValue` equals `minValue`, the method returns `minValue`.</span></span>  
  
 <span data-ttu-id="959b7-361">Ao contrário de outras sobrecargas do <xref:System.Random.Next%2A> método, que retornam apenas valores não negativos, esse método pode retornar um inteiro aleatório negativo.</span><span class="sxs-lookup"><span data-stu-id="959b7-361">Unlike the other overloads of the <xref:System.Random.Next%2A> method, which return only non-negative values, this method can return a negative random integer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-362">O exemplo a seguir usa o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para gerar inteiros aleatórios com três intervalos diferentes.</span><span class="sxs-lookup"><span data-stu-id="959b7-362">The following example uses the <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> method to generate random integers with three distinct ranges.</span></span> <span data-ttu-id="959b7-363">Observe que a saída exata do exemplo depende do valor de semente fornecido pelo sistema passado para o <xref:System.Random> construtor de classe.</span><span class="sxs-lookup"><span data-stu-id="959b7-363">Note that the exact output from the example depends on the system-supplied seed value passed to the <xref:System.Random> class constructor.</span></span>  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 <span data-ttu-id="959b7-364">O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz.</span><span class="sxs-lookup"><span data-stu-id="959b7-364">The following example generates a random integer that it uses as an index to retrieve a string value from an array.</span></span> <span data-ttu-id="959b7-365">Como o maior índice da matriz é um menor que seu tamanho, o valor da <xref:System.Array.Length%2A?displayProperty=nameWithType> propriedade é fornecida como um o `maxValue` parâmetro.</span><span class="sxs-lookup"><span data-stu-id="959b7-365">Because the highest index of the array is one less than its length, the value of the <xref:System.Array.Length%2A?displayProperty=nameWithType> property is supplied as a the `maxValue` parameter.</span></span>  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="959b7-366"><paramref name="minValue" /> é maior que <paramref name="maxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-366"><paramref name="minValue" /> is greater than <paramref name="maxValue" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="959b7-367">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga do método se a diferença entre o <paramref name="minValue" /> e <paramref name="maxValue" /> parâmetros é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-367">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload if the difference between the <paramref name="minValue" /> and <paramref name="maxValue" /> parameters is greater than <see cref="F:System.Int32.MaxValue" />.</span></span> <span data-ttu-id="959b7-368">Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada.</span><span class="sxs-lookup"><span data-stu-id="959b7-368">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="959b7-369">Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-369">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="959b7-370">Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga de método.</span><span class="sxs-lookup"><span data-stu-id="959b7-370">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method overload.</span></span></para></block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="959b7-371">Uma matriz de bytes que deverá conter números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-371">An array of bytes to contain random numbers.</span></span></param>
        <summary><span data-ttu-id="959b7-372">Preenche os elementos de uma matriz de bytes especificada com números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-372">Fills the elements of a specified array of bytes with random numbers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-373">Cada elemento da matriz de bytes é definido como um número aleatório maior ou igual a 0 e menor ou igual a <xref:System.Byte.MaxValue>.</span><span class="sxs-lookup"><span data-stu-id="959b7-373">Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <xref:System.Byte.MaxValue>.</span></span>  
  
 <span data-ttu-id="959b7-374">Por exemplo, para gerar um número aleatório criptograficamente seguro adequado para a criação de uma senha aleatória, use um método como <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="959b7-374">For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-375">O exemplo a seguir demonstra como usar o <xref:System.Random.NextBytes%2A> método para preencher uma matriz de bytes com valores de byte aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-375">The following example demonstrates how to use the <xref:System.Random.NextBytes%2A> method to fill an array of bytes with random byte values.</span></span>  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="959b7-376"><paramref name="buffer" /> é <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-376"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <block subset="none" type="overrides"><para><span data-ttu-id="959b7-377">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-377">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span> <span data-ttu-id="959b7-378">Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada.</span><span class="sxs-lookup"><span data-stu-id="959b7-378">Instead, the uniform distribution returned by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="959b7-379">Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-379">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="959b7-380">Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-380">To modify this behavior to call the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span></para></block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="959b7-381">Retorna um número de ponto flutuante aleatório maior ou igual a 0,0 e menor que 1.0.</span><span class="sxs-lookup"><span data-stu-id="959b7-381">Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</span></span></summary>
        <returns><span data-ttu-id="959b7-382">Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</span><span class="sxs-lookup"><span data-stu-id="959b7-382">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-383">O limite superior real do número aleatório retornado por esse método é 0.99999999999999978.</span><span class="sxs-lookup"><span data-stu-id="959b7-383">The actual upper bound of the random number returned by this method is 0.99999999999999978.</span></span>  
  
 <span data-ttu-id="959b7-384">Para recuperar valores de ponto flutuante aleatórios dentro de um intervalo diferente de 0,0 e 1,0, consulte a seção "Recuperar valores de ponto flutuante em um intervalo especificado" o <xref:System.Random> tópico da classe.</span><span class="sxs-lookup"><span data-stu-id="959b7-384">To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <xref:System.Random> class topic.</span></span>  
  
 <span data-ttu-id="959b7-385">Esse método é a versão pública do método protegido, <xref:System.Random.Sample%2A>.</span><span class="sxs-lookup"><span data-stu-id="959b7-385">This method is the public version of the protected method, <xref:System.Random.Sample%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-386">O exemplo a seguir usa o <xref:System.Random.NextDouble%2A> método para gerar sequências de doubles aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-386">The following example uses the <xref:System.Random.NextDouble%2A> method to generate sequences of random doubles.</span></span>  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 <span data-ttu-id="959b7-387">A exemplo a seguir chama o <xref:System.Random.NextDouble%2A> método para gerar 100 aleatório de números e exibe sua distribuição de frequência.</span><span class="sxs-lookup"><span data-stu-id="959b7-387">The following example calls the <xref:System.Random.NextDouble%2A> method to generate 100 random numbers and displays their frequency distribution.</span></span>  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="959b7-388">Retorna um número de ponto flutuante aleatório entre 0.0 e 1.0.</span><span class="sxs-lookup"><span data-stu-id="959b7-388">Returns a random floating-point number between 0.0 and 1.0.</span></span></summary>
        <returns><span data-ttu-id="959b7-389">Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</span><span class="sxs-lookup"><span data-stu-id="959b7-389">A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="959b7-390">Para produzir uma distribuição aleatória diferente ou um princípio de gerador de número de aleatórios diferentes, derive uma classe do <xref:System.Random> de classe e substituir o <xref:System.Random.Sample%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-390">To produce a different random distribution or a different random number generator principle, derive a class from the <xref:System.Random> class and override the <xref:System.Random.Sample%2A> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="959b7-391">O <xref:System.Random.Sample%2A> método for `protected`, que significa que ele é acessível somente dentro de <xref:System.Random> classe e suas classes derivadas.</span><span class="sxs-lookup"><span data-stu-id="959b7-391">The <xref:System.Random.Sample%2A> method is `protected`, which means that it is accessible only within the <xref:System.Random> class and its derived classes.</span></span> <span data-ttu-id="959b7-392">Para gerar um número aleatório entre 0 e 1 de um <xref:System.Random> da instância, chame o <xref:System.Random.NextDouble%2A> método.</span><span class="sxs-lookup"><span data-stu-id="959b7-392">To generate a random number between 0 and 1 from a <xref:System.Random> instance, call the <xref:System.Random.NextDouble%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="959b7-393">O exemplo a seguir deriva uma classe de <xref:System.Random> e substitui o <xref:System.Random.Sample%2A> método para gerar uma distribuição de números aleatórios.</span><span class="sxs-lookup"><span data-stu-id="959b7-393">The following example derives a class from <xref:System.Random> and overrides the <xref:System.Random.Sample%2A> method to generate a distribution of random numbers.</span></span> <span data-ttu-id="959b7-394">Essa distribuição é diferente da distribuição uniforme gerada pelo <xref:System.Random.Sample%2A> método da classe base.</span><span class="sxs-lookup"><span data-stu-id="959b7-394">This distribution is different than the uniform distribution generated by the <xref:System.Random.Sample%2A> method of the base class.</span></span>  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="959b7-395">Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação dos métodos a seguir:</span><span class="sxs-lookup"><span data-stu-id="959b7-395">Starting with the .NET Framework version 2.0, if you derive a class from <see cref="T:System.Random" /> and override the <see cref="M:System.Random.Sample" /> method, the distribution provided by the derived class implementation of the <see cref="M:System.Random.Sample" /> method is not used in calls to the base class implementation of the following methods:</span></span> 
<span data-ttu-id="959b7-396">-   O método <see cref="M:System.Random.NextBytes(System.Byte[])" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-396">-   The <see cref="M:System.Random.NextBytes(System.Byte[])" /> method.</span></span>  
  
<span data-ttu-id="959b7-397">-   O método <see cref="M:System.Random.Next" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-397">-   The <see cref="M:System.Random.Next" /> method.</span></span>  
  
<span data-ttu-id="959b7-398">-A <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> método, se (<paramref name="maxValue" /> - <paramref name="minValue" />) é maior que <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-398">-   The <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> method, if (<paramref name="maxValue" /> - <paramref name="minValue" />) is greater than <see cref="F:System.Int32.MaxValue" />.</span></span>  
  
<span data-ttu-id="959b7-399">Em vez disso, a distribuição uniforme fornecida com a base <see cref="T:System.Random" /> classe é usada.</span><span class="sxs-lookup"><span data-stu-id="959b7-399">Instead, the uniform distribution provided by the base <see cref="T:System.Random" /> class is used.</span></span> <span data-ttu-id="959b7-400">Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />.</span><span class="sxs-lookup"><span data-stu-id="959b7-400">This behavior improves the overall performance of the <see cref="T:System.Random" /> class.</span></span> <span data-ttu-id="959b7-401">Para modificar esse comportamento para chamar a implementação do <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o comportamento desses três membros.</span><span class="sxs-lookup"><span data-stu-id="959b7-401">To modify this behavior to call the implementation of the <see cref="M:System.Random.Sample" /> method in the derived class, you must also override the behavior of these three members.</span></span> <span data-ttu-id="959b7-402">O exemplo fornece uma ilustração.</span><span class="sxs-lookup"><span data-stu-id="959b7-402">The example provides an illustration.</span></span></para></block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>