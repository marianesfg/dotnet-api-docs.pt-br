<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a2c42b4da1c7b0ee11963dcad14520dc83134e6" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52238565" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <TypeSignature Language="F#" Value="type Random = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um gerador de número pseudoaleatório, que é um dispositivo que produz uma sequência de números que atendem a certos requisitos estatísticos de aleatoriedade.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Números pseudoaleatórios são escolhidos com a mesma probabilidade de um conjunto finito de números. Os números escolhidos não são completamente aleatórios, porque um algoritmo matemático é usado para selecioná-los, mas são suficientemente aleatórios para fins práticos. A implementação atual do <xref:System.Random> classe baseia-se em uma versão modificada do subtrativa gerador algoritmo de números aleatórios de Donald E. Knuth. Para obter mais informações, consulte a e D. Knuth. *A arte do computador de programação, Volume 2: algoritmos Seminumerical*. Addison-Wesley, leitura, MA, terceira edição, 1997.  
  
 Para gerar um número aleatório criptograficamente seguro, por exemplo, um que seja adequado para a criação de uma senha aleatória, use o <xref:System.Security.Cryptography.RNGCryptoServiceProvider> classe ou derivando uma classe de <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 Neste tópico:  
  
 [Criando uma instância do gerador de número aleatório](#Instantiate)   
 [Evitando várias instanciações](#Multiple)   
 [A segurança de thread e a classe Random](#ThreadSafety)   
 [Gerando tipos diferentes de números aleatórios](#Functionality)   
 [Substituindo seu próprio algoritmo](#Overriding)   
 [Como você usar o System. Random para...](#Operations)   
 [Recuperar a mesma sequência de valores aleatórios](#Same)  
 [Recuperar sequências exclusivas de valores aleatórios](#Unique)  
 [Recuperar inteiros em um intervalo especificado](#Range)  
 [Recuperar inteiros com um número especificado de dígitos](#Digits)  
 [Recuperar valores de ponto flutuante em um intervalo especificado](#Floats)  
 [Gerar valores aleatórios de boolianos](#Boolean)  
 [Gerar inteiros de 64 bits aleatórios](#Long)  
 [Recuperar bytes em um intervalo especificado](#Bytes)  
 [Recuperar um elemento de uma matriz ou coleção aleatório](#Array)  
 [Recuperar um elemento exclusivo de uma matriz ou coleção](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>Criando uma instância do gerador de número aleatório  
 Você cria uma instância do gerador de número aleatório, fornecendo um valor de semente (um valor inicial para o algoritmo de geração de números pseudoaleatórios) para um <xref:System.Random.%23ctor%2A> construtor de classe.  Você pode fornecer o valor de semente explícita ou implicitamente:  
  
-   O <xref:System.Random.%23ctor%28System.Int32%29> construtor usa um valor de semente explícita que você fornecer.  
  
-   O <xref:System.Random.%23ctor> construtor usa o relógio do sistema para fornecer um valor de semente. Isso é a maneira mais comum de criar uma instância do gerador de número aleatório.  
  
 Se a mesma semente é usada para separar <xref:System.Random> objetos, eles gerarão a mesma série de números aleatórios. Isso pode ser útil para a criação de um conjunto de testes que processa os valores aleatórios ou para reproduzir os jogos que derivam seus dados de números aleatórios. No entanto, observe que <xref:System.Random> objetos em processos em execução em diferentes versões do .NET Framework podem retornar outra série de números aleatórios, mesmo se eles são instanciados com valores de semente idênticos.  
  
 Para produzir sequências diferentes de números aleatórios, você pode fazer o valor de semente dependente de tempo, assim, produzindo uma série de diferente com cada nova instância da <xref:System.Random>. Com os parâmetros <xref:System.Random.%23ctor%28System.Int32%29> construtor pode levar um <xref:System.Int32> valor com base no número de tiques no momento, enquanto o Next sem parâmetros <xref:System.Random.%23ctor> construtor usa o relógio do sistema para gerar o valor de semente. No entanto, como o relógio tem resolução finita, usando o construtor sem parâmetros para criar os diferentes <xref:System.Random> objetos em sucessão fechar cria geradores de números aleatórios que produzem idênticas sequências de números aleatórios. O exemplo a seguir ilustra como duas <xref:System.Random> objetos são instanciados em sucessão fechar geram uma série idêntica de números aleatórios. Na maioria dos sistemas Windows, <xref:System.Random> objetos criados em 15 milissegundos entre um e outro serão prováveis que valores de semente idênticos.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Para evitar esse problema, crie um único <xref:System.Random> objeto em vez de vários objetos.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Evitando várias instanciações  
 Inicializar dois geradores de números aleatórios em um loop estreito, ou em sucessão rápida cria dois geradores de números aleatórios que podem produzir idênticas sequências de números aleatórios. Na maioria dos casos, isso não é intenção do desenvolvedor e pode levar a problemas de desempenho, como instanciar e inicializar um gerador de número aleatório são um processo relativamente caro.  
  
 Tanto para melhorar o desempenho e evitar a criação inadvertidamente separados geradores de números aleatórios que geram idênticas sequências numéricas, recomendamos que você criar um <xref:System.Random> objeto para gerar números aleatórios muitos ao longo do tempo, em vez de criar novo <xref:System.Random> objetos para gerar um número aleatório.  
  
 No entanto, o <xref:System.Random> classe não é thread-safe. Se você chamar <xref:System.Random> métodos de vários threads, siga as diretrizes abordadas na próxima seção.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>A segurança de thread e a classe Random  
 Em vez de criar uma instância individual <xref:System.Random> objetos, é recomendável que você crie um único <xref:System.Random> instância para gerar todos os números aleatórios exigidos pelo seu aplicativo. No entanto, <xref:System.Random> objetos não são thread-safe. Se seu aplicativo chamar <xref:System.Random> métodos de vários threads, você deve usar um objeto de sincronização para garantir que apenas um thread pode acessar o gerador de número aleatório por vez. Se você não garante que o <xref:System.Random> objeto é acessado de forma thread-safe, chamadas para métodos que retornam números aleatórios retornam 0.  
  
 O exemplo a seguir usa a linguagem c# [instrução lock](~/docs/csharp/language-reference/keywords/lock-statement.md) e o Visual Basic [Instrução SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) para garantir que um único número aleatório é acessado por 11 segmentos de uma maneira thread-safe. Cada thread gera 2 milhões de números aleatórios, conta o número de números aleatórios gerados e calcula a soma e, em seguida, atualiza os totais de todos os threads quando ele termina a execução.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 O exemplo garante o acesso thread-safe das seguintes maneiras:  
  
-   O <xref:System.ThreadStaticAttribute> atributo é usado para definir as variáveis locais de thread que controlam o número total de números aleatórios gerados e sua soma para cada thread.  
  
-   Um bloqueio (o `lock` instrução em c# e o `SyncLock` instrução no Visual Basic) protege o acesso às variáveis para a contagem total e a soma de todos os números aleatórios gerados em todos os threads.  
  
-   Um semáforo (o <xref:System.Threading.CountdownEvent> objeto) é usado para garantir que o thread principal bloqueia até que todos os outros threads concluir a execução.  
  
-   O exemplo verifica se o gerador de número aleatório foi corrompido, determinando se as duas chamadas consecutivas para métodos de geração de número aleatório retornam 0. Se estiver corrompido, o exemplo usa o <xref:System.Threading.CancellationTokenSource> objeto para sinalizar que todos os threads devem ser cancelados.  
  
-   Antes de gerar cada número aleatório, cada thread verifica o estado do <xref:System.Threading.CancellationToken> objeto. Se for solicitado um cancelamento, o exemplo chama o <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> método cancele o thread.  
  
 O exemplo a seguir é idêntico ao primeiro, exceto que ele usa um <xref:System.Threading.Tasks.Task> objeto e uma expressão lambda em vez de <xref:System.Threading.Thread> objetos.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 O primeiro exemplo ela difere das seguintes maneiras:  
  
-   As variáveis para controlar o número de números aleatórios gerados e sua soma em cada tarefa são locais para a tarefa, portanto, não há necessidade de usar o <xref:System.ThreadStaticAttribute> atributo.  
  
-   Estático <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método é usado para garantir que o thread principal não for concluída antes de concluir todas as tarefas. Não é necessário para o <xref:System.Threading.CountdownEvent> objeto.  
  
-   A exceção que é o resultado do cancelamento da tarefa será exposta no <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método. No exemplo anterior, ele é manipulado por cada thread.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Gerando tipos diferentes de números aleatórios  
 O gerador de número aleatório fornece métodos que permitem que você gere os seguintes tipos de números aleatórios:  
  
-   Uma série de <xref:System.Byte> valores. Determinar o número de valores de byte ao passar uma matriz inicializada para o número de elementos que você deseja que o método para retornar para o <xref:System.Random.NextBytes%2A> método. O exemplo a seguir gera 20 bytes.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Um único inteiro. Você pode escolher se deseja que um inteiro de 0 até um valor máximo (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) chamando o <xref:System.Random.Next> método, um número inteiro entre 0 e um valor específico chamando o <xref:System.Random.Next%28System.Int32%29> método ou um inteiro dentro de um intervalo de valores, chamando o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>método. As sobrecargas com parâmetros, o valor máximo especificado é exclusivo; ou seja, o número máximo real gerado é um menor do que o valor especificado.  
  
     A exemplo a seguir chama o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método gerar 10 números aleatórios entre -10 e 10. Observe que o segundo argumento para o método Especifica o limite superior exclusivo do intervalo de valores aleatórios retornado pelo método. Em outras palavras, o maior inteiro que o método pode retornar é um menor do que esse valor.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Um valor de ponto flutuante único de 0,0 a menor que 1,0 chamando o <xref:System.Random.NextDouble%2A> método. O limite superior exclusivo do número aleatório retornado pelo método é 1, portanto, o limite superior real é 0.99999999999999978. O exemplo a seguir gera 10 números de ponto flutuantes aleatórios.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  O <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método permite que você especifique o intervalo de número aleatório retornado. No entanto, o `maxValue` parâmetro, que especifica o intervalo superior retornado número, é um recurso exclusivo, não um inclusivo, valor. Isso significa que a chamada de método `Next(0, 100)` retorna um valor entre 0 e 99 e não entre 0 e 100.  
  
 Você também pode usar o <xref:System.Random> classe para tarefas como geração [valores aleatórios de T:System.Boolean](#Boolean), gerar [valores de ponto flutuante aleatório com um intervalo diferente de 0 a 1](#Floats), gerando [inteiros de 64 bits aleatórios](#Long), e [recuperando aleatoriamente um elemento exclusivo de uma matriz ou coleção](#UniqueArray). Para essas e outras tarefas comuns, consulte o [como você usar o System. Random para...](#Operations) seção.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Substituindo seu próprio algoritmo  
 Você pode implementar seu próprio gerador de número aleatório, herdando o <xref:System.Random> classe e fornecendo seu algoritmo de geração de números aleatórios. Para fornecer seu próprio algoritmo, você deve substituir o <xref:System.Random.Sample%2A> método, que implementa o algoritmo de geração de números aleatórios. Você também deve substituir a <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, e <xref:System.Random.NextBytes%2A> métodos para garantir que eles chamam seu substituído <xref:System.Random.Sample%2A> método. Você não tem que substituir a <xref:System.Random.Next%28System.Int32%29> e <xref:System.Random.NextDouble%2A> métodos.  
  
 Para obter um exemplo que deriva de <xref:System.Random> de classe e modifica seu gerador de número pseudoaleatório do padrão, consulte o <xref:System.Random.Sample%2A> página de referência.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Como você usar o System. Random para...  
 As seções a seguir abordam e proveem código de exemplo para algumas das maneiras que você talvez queira usar números aleatórios em seu aplicativo.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Recuperar a mesma sequência de valores aleatórios  
 Às vezes você deseja gerar a mesma sequência de números aleatórios nos cenários de teste de software e em jogos. Teste com a mesma sequência de números aleatórios permite que você detecte regressões e confirmar as correções de bugs. Usando a mesma sequência de número aleatório em jogos permite a reprodução de jogos anteriores.  
  
 Você pode gerar a mesma sequência de números aleatórios, fornecendo o mesmo valor de semente para o <xref:System.Random.%23ctor%28System.Int32%29> construtor. O valor de semente fornece um valor inicial para o algoritmo de geração de números pseudoaleatórios. O exemplo a seguir usa 100100 como um valor de semente arbitrário para instanciar o <xref:System.Random> objeto exibe 20 valores de ponto flutuantes aleatórios e persistir o valor de semente. Em seguida, restaura o valor de semente, cria uma instância de um novo gerador de número aleatório e exibe os mesmos valores de ponto flutuantes aleatórios 20.  Observe que o exemplo pode produzir sequências diferentes de números aleatórios se executados em diferentes versões do .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Recuperar sequências exclusivas de números aleatórios  
 Fornecer valores de seed diferente para instâncias do <xref:System.Random> classe faz com que cada gerador de número aleatório produzir uma sequência diferente de valores. Você pode fornecer um valor de semente explicitamente chamando o <xref:System.Random.%23ctor%28System.Int32%29> construtor, ou implicitamente chamando o <xref:System.Random.%23ctor> construtor. A maioria dos desenvolvedores chamar o construtor sem parâmetros, que usa o relógio do sistema. O exemplo a seguir usa essa abordagem para instanciar dois <xref:System.Random> instâncias. Cada instância exibe uma série de inteiros aleatórios 10.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 No entanto, devido à sua resolução finita, o relógio do sistema não detecta as diferenças de tempo que são menos de aproximadamente 15 milissegundos. Portanto, se seu código chama o <xref:System.Random.%23ctor> sobrecarga de instanciar dois <xref:System.Random> objetos em sucessão, talvez você inadvertidamente estar fornecendo os objetos com valores de semente idênticos. Para ver isso no exemplo anterior, comente o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> chamada de método e compile e execute o exemplo novamente.  
  
 Para evitar que isso aconteça, é recomendável que você criar uma instância de um único <xref:System.Random> do objeto em vez de várias. No entanto, como <xref:System.Random> não é thread-safe, você deve usar algum dispositivo de sincronização, se você acessar uma <xref:System.Random> instância de vários threads; para obter mais informações, consulte [aleatório a segurança de classe e thread](#ThreadSafety) anteriores desta tópico. Como alternativa, você pode usar um mecanismo de atraso, como o <xref:System.Threading.Thread.Sleep%2A> método usado no exemplo anterior, para garantir que as instanciações ocorrerem mais de 15 milissegundos separados.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Recuperar inteiros em um intervalo especificado  
 Você pode recuperar inteiros em um intervalo especificado chamando o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método, que permite que você especifique a menor e o limite superior dos números que você gostaria que o gerador de número aleatório para retornar. O limite superior é um recurso exclusivo, não um inclusivo, valor. Ou seja, ele não está incluído no intervalo de valores retornados pelo método. O exemplo a seguir usa esse método para gerar números aleatórios inteiros entre -10 e 10. Observe que ela especifica 11, que é maior do que o valor desejado, como o valor da `maxValue` argumento na chamada do método.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Recuperar inteiros com um número especificado de dígitos  
 Você pode chamar o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método para recuperar números com um número especificado de dígitos. Por exemplo, para recuperar números com quatro dígitos (ou seja, números que variam de 1000 a 9999), que você chame o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método com um `minValue` valor de 1000 e um `maxValue` valor de 10000, como mostra o exemplo a seguir.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Recuperar valores de ponto flutuante em um intervalo especificado  
 O <xref:System.Random.NextDouble%2A> método retorna valores de ponto flutuante aleatórios que variam de 0 a menor que 1. No entanto, você geralmente desejará gerar valores aleatórios em algum outro intervalo.  
  
 Se o intervalo entre os valores mínimo e máximo desejados for 1, você pode adicionar a diferença entre o intervalo de início desejado e 0 ao número retornado pelo <xref:System.Random.NextDouble%2A> método. O exemplo a seguir faz isso para gerar 10 números aleatórios entre -1 e 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Para gerar números de ponto flutuante aleatórios cujo limite inferior é 0, mas limite superior é maior que 1 (ou, no caso de números negativos, cujo limite inferior é menor que -1 e limite superior é 0), multiplique o número aleatório pelo limite diferente de zero. O exemplo a seguir faz isso para gerar números de ponto flutuante aleatórios de 20 milhões que variam de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. No também exibe a distribuição dos valores aleatórios gerados pelo método.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Para gerar números de ponto flutuante aleatórios entre dois valores arbitrários, como o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método faz para números inteiros, use a seguinte fórmula:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 O exemplo a seguir gera números aleatórios de 1 milhão que variam de 10.0 a 11.0 e exibe sua distribuição.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Gerar valores aleatórios de boolianos  
 O <xref:System.Random> classe não fornece métodos que geram <xref:System.Boolean> valores. No entanto, você pode definir sua própria classe ou método para fazer isso. O exemplo a seguir define uma classe, `BooleanGenerator`, com um único método, `NextBoolean`. O `BooleanGenerator` classe armazena um <xref:System.Random> objeto como uma variável particular. O `NextBoolean` chamadas de método de <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método e passa o resultado para o <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> método. Observe que 2 é usado como o argumento para especificar o limite superior do número aleatório. Uma vez que esse é um valor exclusivo, a chamada de método retorna 0 ou 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Em vez de criar uma classe separada para gerar aleatório <xref:System.Boolean> valores, o exemplo poderia simplesmente ter definido um único método. Nesse caso, no entanto, o <xref:System.Random> objeto deve ter sido definido como uma variável de nível de classe para evitar a instanciar um novo <xref:System.Random> instância em cada chamada de método. No Visual Basic, a instância de Random pode ser definida como um [estáticos](~/docs/visual-basic/language-reference/modifiers/static.md) variável o `NextBoolean` método.  O exemplo a seguir fornece uma implementação.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Gerar inteiros de 64 bits aleatórios  
 As sobrecargas de <xref:System.Random.Next%2A> método retornam inteiros de 32 bits. No entanto, em alguns casos, você talvez queira trabalhar com números inteiros de 64 bits. Você pode fazer isso da seguinte maneira:  
  
1.  Chamar o <xref:System.Random.NextDouble%2A> valor de ponto do método para recuperar um flutuante de precisão dupla.  
  
2.  Multiplique esse valor por <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 O exemplo a seguir usa essa técnica para gerar inteiros longos aleatórios de 20 milhões e categoriza-los em 10 grupos iguais. Ele avalia a distribuição de números aleatórios pela contagem do número em cada grupo de 0 a <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Como mostra a saída do exemplo, os números são mais ou menos igualmente distribuídos por meio do intervalo de um inteiro longo.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Uma técnica alternativa que usa a manipulação de bits não gera números verdadeiramente aleatórios. Essa técnica chama <xref:System.Random.Next> para gerar dois inteiros, desloca a esquerda um 32 bits e ORs-los juntos. Essa técnica tem duas limitações:  
  
1.  Como o bit 31 é o bit de sinal, o valor em 31 de bit de inteiro longo resultante é sempre 0.  Isso pode ser resolvido por meio da geração aleatória 0 ou 1, o deslocamento à esquerda de 31 bits e o uso de or-lo com o inteiro longo aleatório original.  
  
2.  Mais a sério, pois a probabilidade de que o valor retornado por <xref:System.Random.Next> será 0, haverá alguns se houver números aleatórios no intervalo 0x00000000FFFFFFFF 0x0.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Recuperar bytes em um intervalo especificado  
 As sobrecargas do <xref:System.Random.Next%2A> método permitem que você especifique o intervalo de números aleatórios, mas o <xref:System.Random.NextBytes%2A> método não faz. O exemplo a seguir implementa um `NextBytes` método que permite que você especifique o intervalo de bytes retornados. Ele define uma `Random2` classe que deriva <xref:System.Random> e sobrecarrega sua `NextBytes` método.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 O `NextBytes(Byte[], Byte, Byte)` método encapsula uma chamada para o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método e especifica o valor mínimo e um maior que o valor máximo (nesse caso, 0 e 101) que queremos retornados na matriz de bytes. Como temos certeza de que os valores inteiros retornados pelo <xref:System.Random.Next%2A> método estão dentro do intervalo da <xref:System.Byte> tipo de dados, podemos com segurança converta-a (em c#) ou converta-os (no Visual Basic) de inteiros em bytes.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Recuperar um elemento de uma matriz ou coleção aleatório  
 Números aleatórios geralmente servem como índices para recuperar valores de matrizes ou coleções. Para recuperar um valor de índice aleatório, você pode chamar o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> método e use o limite inferior da matriz como o valor do seu `minValue` argumento e um número maior que o limite superior da matriz como o valor do seu `maxValue` argumento. Para uma matriz com base em zero, isso é equivalente a sua <xref:System.Array.Length%2A> propriedade ou um número maior que o valor retornado pelo <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> método. O exemplo a seguir aleatoriamente recupera o nome de uma cidade nos Estados Unidos de uma matriz de cidades.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Recuperar um elemento exclusivo de uma matriz ou coleção  
 Um gerador de número aleatório sempre pode retornar valores duplicados. Como o intervalo de números se torna menor ou o número de valores gerados se torna maior, aumenta a probabilidade de duplicatas. Se valores aleatórios devem ser exclusivos, mais números são gerados para compensar as duplicatas, resultando em cada vez mais baixo desempenho.  
  
 Há várias técnicas para lidar com esse cenário. Uma solução comum é criar uma matriz ou coleção que contém os valores a serem recuperados e uma matriz paralela que contém números de ponto flutuante aleatórios. A segunda matriz é preenchida com números aleatórios no momento em que a primeira matriz é criada, e o <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método é usado para classificar a primeira matriz usando os valores na matriz paralela.  
  
 Por exemplo, se você estiver desenvolvendo um jogo de Paciência, convém garantir que cada cartão é usado apenas uma vez. Em vez de gerar números aleatórios para recuperar um cartão e controlar se esse cartão já lidou, você pode criar uma matriz paralela de números aleatórios que podem ser usados para classificar o baralho. Depois que o baralho é classificado, seu aplicativo pode manter um ponteiro para indicar o índice do próximo cartão no baralho.  
  
 O exemplo a seguir ilustra esta abordagem. Ele define uma `Card` classe que representa uma carta em jogo e um `Dealer` classe que trata um baralho de cartas embaralhados. O `Dealer` construtor de classe preenche duas matrizes: uma `deck` matriz que tem o escopo de classe e que representa todas as cartas de baralho e um local `order` matriz que tem o mesmo número de elementos como o `deck` de matriz e é preenchido com o gerado aleatoriamente <xref:System.Double> valores.  O <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> método é chamado, em seguida, para classificar os `deck` matriz com base nos valores da `order` matriz.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 O exemplo a seguir cria um gerador de número aleatório único e chama seu <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, e <xref:System.Random.NextDouble%2A> métodos para gerar sequências de números aleatórios dentro de intervalos diferentes.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>No .NET Framework 1.0 e 1.1, uma implementação mínima de uma classe derivada de <see cref="T:System.Random" /> obrigatório substituindo o <see cref="M:System.Random.Sample" /> método para definir um algoritmo de novo ou modificado para gerar números aleatórios. A classe derivada, em seguida, poderia contar que a implementação da classe base a <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, e <see cref="M:System.Random.NextDouble" /> métodos para chamar a implementação da classe derivada de <see cref="M:System.Random.Sample" /> método.  
  
No .NET Framework 2.0 e posterior, o comportamento do <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, e <see cref="M:System.Random.NextBytes(System.Byte[])" /> métodos foram alterados para que esses métodos não necessariamente chamar a implementação da classe derivada de <see cref="M:System.Random.Sample" /> método. Como resultado, as classes derivadas de <see cref="T:System.Random" /> que direcionar o .NET Framework 2.0 e posterior, também deverá substituir esses três métodos.</para>
    </block>
    <block subset="none" type="usage">
      <para>A implementação do gerador de número aleatório no <see cref="T:System.Random" /> classe não é garantido que permanecem as mesmas entre as versões principais do .NET Framework. Como resultado, você não deve presumir que a mesma semente resultará na mesma sequência pseudoaleatória em diferentes versões do .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Random" />, usando um valor de semente padrão dependente de tempo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de semente padrão é derivado do relógio do sistema e tem resolução finita. Como resultado, diferente <xref:System.Random> objetos que são criados em sucessão Fechar por uma chamada para o construtor padrão terão valores de semente padrão idênticos e, portanto, produzirão conjuntos idênticos de números aleatórios. Esse problema pode ser evitado usando um único <xref:System.Random> objeto para gerar todos os números aleatórios. Você também pode trabalhar em torno dele, modificando o valor de semente retornado pelo relógio do sistema e, em seguida, esse novo valor de semente para fornecer explicitamente o <xref:System.Random.%23ctor%28System.Int32%29> construtor. Para obter mais informações, consulte o <xref:System.Random.%23ctor%28System.Int32%29> construtor.  
  
 Chame esse construtor, se você quiser que seu gerador de número aleatório para gerar uma sequência aleatória de números. Para gerar uma sequência fixa de números aleatórios que serão o mesmo para diferentes geradores de números aleatórios, chame o <xref:System.Random.%23ctor%28System.Int32%29> construtor com um valor de semente fixa. Isso <xref:System.Random> sobrecarga de construtor é usada com frequência ao testar aplicativos que usam números aleatórios.  
  
 Após instanciar o gerador de número aleatório, você pode chamar individuais <xref:System.Random> métodos, tais como <xref:System.Random.Next> ou <xref:System.Random.NextDouble>, para gerar números aleatórios.  
  
   
  
## Examples  
 O exemplo a seguir usa o construtor padrão para instanciar três <xref:System.Random> objetos e exibe uma sequência de cinco inteiros aleatórios para cada um. Porque os dois primeiros <xref:System.Random> objetos são criados em sucessão fechar, eles são instanciados usando valores de semente idêntico com base no relógio do sistema e, portanto, eles produzem uma sequência idêntica de números aleatórios. Por outro lado, o construtor padrão do terceiro <xref:System.Random> objeto é chamado após um atraso de dois segundos causado ao chamar o <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método. Porque isso produz um valor de semente diferentes para a terceira <xref:System.Random> do objeto, ele produz uma sequência diferente de números aleatórios.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberSignature Language="F#" Value="new Random : int -&gt; Random" Usage="new System.Random Seed" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Um número usado para calcular um valor inicial para a sequência numérica pseudoaleatória. Se um número negativo for especificado, o valor absoluto do número será usado.</param>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Random" />, usando o valor de semente especificado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fornecendo um valor de semente idênticos para diferentes <xref:System.Random> objetos faz com que cada instância produzir sequências idênticas de números aleatórios. Isso é feito com frequência ao testar aplicativos que dependem de geradores de números aleatórios.  
  
 Se seu aplicativo exigir sequências diferentes de número aleatórias, chama este construtor várias vezes com valores de seed diferente. É uma maneira de produzir um valor de semente exclusivo para torná-lo dependente de tempo. Por exemplo, derivar o valor de semente do relógio do sistema, como o <xref:System.Random.%23ctor> faz de sobrecarga. No entanto, o relógio do sistema pode não ter resolução suficiente para fornecer diferentes invocações desse construtor com um valor de seed diferente. Isso resulta em geradores de números aleatórios que geram idênticas sequências de números pseudoaleatórios, conforme ilustrado pelas duas primeiras <xref:System.Random> objetos no exemplo a seguir. Para evitar isso, aplicar um algoritmo para diferenciar o valor de semente em cada invocação ou a chamada a <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método para garantir que você forneça cada construtor com um valor de seed diferente.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Outra opção é criar uma instância de um único <xref:System.Random> objeto que você usar para gerar todos os números aleatórios em seu aplicativo. Isso resulta em um desempenho ligeiramente melhor, já que é bastante dispendiosa, criando uma instância de um gerador de número aleatório.  
  
   
  
## Examples  
 O exemplo a seguir cria <xref:System.Random> objetos com o construtor da classe que usa um parâmetro de semente e gera uma sequência de inteiros aleatórios e doubles. O exemplo ilustra que a mesma sequência é gerada quando o <xref:System.Random> objeto é criado novamente com o parâmetro de construtor e a propagação.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retorna um inteiro aleatório.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberSignature Language="F#" Value="abstract member Next : unit -&gt; int&#xA;override this.Next : unit -&gt; int" Usage="random.Next " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um inteiro aleatório não negativo.</summary>
        <returns>Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> gera um número aleatório cujo valor varia de 0 a menos de <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Para gerar um número aleatório cujo valor varia de 0 para algum outro número positivo, use o <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> sobrecarga de método. Para gerar um número aleatório dentro de um intervalo diferente, use o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> sobrecarga de método.  
  
   
  
## Examples  
 O exemplo a seguir faz chamadas repetidas para o <xref:System.Random.Next%2A> método para gerar um número específico de números aleatórios solicitados pelo usuário. O <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> método é usado para obter a entrada do cliente.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 O exemplo a seguir deriva uma classe de <xref:System.Random> para gerar uma sequência de números aleatórios cuja distribuição é diferente da distribuição uniforme gerada pelo <xref:System.Random.Sample%2A> método da classe base. Ele substitui o <xref:System.Random.Sample%2A> método para fornecer a distribuição de números aleatórios e substituições de <xref:System.Random.Next%2A?displayProperty=nameWithType> método para usar a série de números aleatórios.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.Next" /> método. Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada. Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />. Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.Next" /> método.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int -&gt; int&#xA;override this.Next : int -&gt; int" Usage="random.Next maxValue" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">O limite superior exclusivo do número aleatório a ser gerado. <paramref name="maxValue" /> deve ser maior ou igual a 0.</param>
        <summary>Retorna um número inteiro aleatório não negativo menor que o máximo especificado.</summary>
        <returns>Um inteiro com sinal de 32 bits maior ou igual a 0 e menor que <paramref name="maxValue" />; ou seja, o intervalo de valores retornados inclui 0, mas não <paramref name="maxValue" />. No entanto, se <paramref name="maxValue" /> for igual a 0, <paramref name="maxValue" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Random.Next%28System.Int32%29> sobrecarga retorna inteiros aleatórios que variam de 0 a `maxValue` – 1. No entanto, se `maxValue` for 0, o método retornará 0.  
  
   
  
## Examples  
 O exemplo a seguir gera inteiros aleatórios com várias sobrecargas do <xref:System.Random.Next%2A> método.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz. Como o maior índice da matriz é um menor que seu tamanho, o valor da <xref:System.Array.Length%2A?displayProperty=nameWithType> propriedade é fornecida como um o `maxValue` parâmetro.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="maxValue" /> é menor que 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberSignature Language="F#" Value="abstract member Next : int * int -&gt; int&#xA;override this.Next : int * int -&gt; int" Usage="random.Next (minValue, maxValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">O limite inferior inclusivo do número aleatório retornado.</param>
        <param name="maxValue">O limite superior exclusivo do número aleatório retornado. <paramref name="maxValue" /> deve ser maior ou igual a <paramref name="minValue" />.</param>
        <summary>Retorna um inteiro aleatório que está dentro do intervalo especificado.</summary>
        <returns>Um inteiro com sinal de 32 bits maior ou igual a <paramref name="minValue" /> e menor que <paramref name="maxValue" />; ou seja, o intervalo de valores retornados inclui <paramref name="minValue" />, mas não <paramref name="maxValue" />. Se <paramref name="minValue" /> for igual a <paramref name="maxValue" />, <paramref name="minValue" /> será retornado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> sobrecarga retorna inteiros aleatórios que vão desde `minValue` para `maxValue` – 1. No entanto, se `maxValue` é igual a `minValue`, o método retorna `minValue`.  
  
 Ao contrário de outras sobrecargas do <xref:System.Random.Next%2A> método, que retornam apenas valores não negativos, esse método pode retornar um inteiro aleatório negativo.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> método para gerar inteiros aleatórios com três intervalos diferentes. Observe que a saída exata do exemplo depende do valor de semente fornecido pelo sistema passado para o <xref:System.Random> construtor de classe.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 O exemplo a seguir gera um inteiro aleatório que ele usa como um índice para recuperar um valor de cadeia de caracteres de uma matriz. Como o maior índice da matriz é um menor que seu tamanho, o valor da <xref:System.Array.Length%2A?displayProperty=nameWithType> propriedade é fornecida como um o `maxValue` parâmetro.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="minValue" /> é maior que <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga do método se a diferença entre o <paramref name="minValue" /> e <paramref name="maxValue" /> parâmetros é maior que <see cref="F:System.Int32.MaxValue" />. Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada. Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />. Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> sobrecarga de método.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : byte[] -&gt; unit&#xA;override this.NextBytes : byte[] -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Uma matriz de bytes que deverá conter números aleatórios.</param>
        <summary>Preenche os elementos de uma matriz de bytes especificada com números aleatórios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada elemento da matriz de bytes é definido como um número aleatório maior ou igual a 0 e menor ou igual a <xref:System.Byte.MaxValue>.  
  
 Por exemplo, para gerar um número aleatório criptograficamente seguro adequado para a criação de uma senha aleatória, use um método como <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como usar o <xref:System.Random.NextBytes%2A> método para preencher uma matriz de bytes com valores de byte aleatórios.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="buffer" /> é <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação do <see cref="M:System.Random.NextBytes(System.Byte[])" /> método. Em vez disso, a distribuição uniforme retornado com a base <see cref="T:System.Random" /> classe é usada. Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />. Para modificar esse comportamento para chamar o <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o <see cref="M:System.Random.NextBytes(System.Byte[])" /> método.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="abstract member NextBytes : Span&lt;byte&gt; -&gt; unit&#xA;override this.NextBytes : Span&lt;byte&gt; -&gt; unit" Usage="random.NextBytes buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberSignature Language="F#" Value="abstract member NextDouble : unit -&gt; double&#xA;override this.NextDouble : unit -&gt; double" Usage="random.NextDouble " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um número de ponto flutuante aleatório maior ou igual a 0,0 e menor que 1.0.</summary>
        <returns>Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O limite superior real do número aleatório retornado por esse método é 0.99999999999999978.  
  
 Para recuperar valores de ponto flutuante aleatórios dentro de um intervalo diferente de 0,0 e 1,0, consulte a seção "Recuperar valores de ponto flutuante em um intervalo especificado" o <xref:System.Random> tópico da classe.  
  
 Esse método é a versão pública do método protegido, <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 O exemplo a seguir usa o <xref:System.Random.NextDouble%2A> método para gerar sequências de doubles aleatórios.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 A exemplo a seguir chama o <xref:System.Random.NextDouble%2A> método para gerar 100 aleatório de números e exibe sua distribuição de frequência.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberSignature Language="F#" Value="abstract member Sample : unit -&gt; double&#xA;override this.Sample : unit -&gt; double" Usage="random.Sample " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um número de ponto flutuante aleatório entre 0.0 e 1.0.</summary>
        <returns>Um número de ponto flutuante de precisão dupla maior ou igual a 0,0 e menor que 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para produzir uma distribuição aleatória diferente ou um princípio de gerador de número de aleatórios diferentes, derive uma classe do <xref:System.Random> de classe e substituir o <xref:System.Random.Sample%2A> método.  
  
> [!IMPORTANT]
>  O <xref:System.Random.Sample%2A> método for `protected`, que significa que ele é acessível somente dentro de <xref:System.Random> classe e suas classes derivadas. Para gerar um número aleatório entre 0 e 1 de um <xref:System.Random> da instância, chame o <xref:System.Random.NextDouble%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir deriva uma classe de <xref:System.Random> e substitui o <xref:System.Random.Sample%2A> método para gerar uma distribuição de números aleatórios. Essa distribuição é diferente da distribuição uniforme gerada pelo <xref:System.Random.Sample%2A> método da classe base.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Começando com o .NET Framework versão 2.0, se você derivar uma classe de <see cref="T:System.Random" /> e substitua o <see cref="M:System.Random.Sample" /> método, a distribuição fornecida pela implementação de classe derivada de <see cref="M:System.Random.Sample" /> método não é usado em chamadas para a classe base implementação dos métodos a seguir: 
-   O método <see cref="M:System.Random.NextBytes(System.Byte[])" />.  
  
-   O método <see cref="M:System.Random.Next" />.  
  
-A <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> método, se (<paramref name="maxValue" /> - <paramref name="minValue" />) é maior que <see cref="F:System.Int32.MaxValue" />.  
  
Em vez disso, a distribuição uniforme fornecida com a base <see cref="T:System.Random" /> classe é usada. Esse comportamento melhora o desempenho geral da classe <see cref="T:System.Random" />. Para modificar esse comportamento para chamar a implementação do <see cref="M:System.Random.Sample" /> método na classe derivada, você também deve substituir o comportamento desses três membros. O exemplo fornece uma ilustração.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>