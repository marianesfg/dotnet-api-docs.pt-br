<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e93909d2c823c996b099c481764f4950992421a9" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646360" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Representa um delegado, que é uma estrutura de dados que se refere a um método estático ou a uma instância da classe e um método de instância dessa classe.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Delegate> é a classe base para tipos de delegado. No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Delegate> classe ou a partir de <xref:System.MulticastDelegate> classe. Também não é permitido para derivar um novo tipo de um tipo de delegado. O <xref:System.Delegate> classe não é considerado um tipo de delegado; é uma classe usada para derivar tipos de delegado.  
  
 Implementar a maioria das linguagens uma `delegate` palavra-chave e compiladores para essas linguagens são capazes de derivar o <xref:System.MulticastDelegate> classe; portanto, os usuários devem usar o `delegate` fornecido pela linguagem de palavra-chave.  
  
> [!NOTE]
>  O common language runtime fornece um `Invoke` método para cada tipo de delegado, com a mesma assinatura que o delegado. Não é necessário chamar esse método explicitamente do c#, Visual Basic ou Visual C++, pois os compiladores de chamá-lo automaticamente. O `Invoke` método é útil na [reflexão](~/docs/framework/reflection-and-codedom/reflection.md) quando você deseja localizar a assinatura do tipo delegado.  
  
 O common language runtime fornece a cada tipo de delegado com `BeginInvoke` e `EndInvoke` métodos, para permitir a invocação assíncrona do delegado. Para obter mais informações sobre esses métodos, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 A declaração de um tipo delegado estabelece um contrato que especifica a assinatura de um ou mais métodos. Um delegado é uma instância de um tipo de delegado que possui referências a:  
  
-   Um método de instância de um tipo e um objeto de destino pode ser atribuído a esse tipo.  
  
-   Um método de instância de um tipo, com o oculto `this` parâmetro exposto na lista de parâmetros formais. O delegado deve ser um representante de instância aberta.  
  
-   Um método estático.  
  
-   Um método estático e um objeto de destino pode ser atribuído ao primeiro parâmetro do método. O delegado deve ser fechado ao longo de seu primeiro argumento.  
  
 Para obter mais informações sobre associação de delegados, consulte o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, um delegado pode representar um método somente se a assinatura do método corresponde exatamente à assinatura especificada pelo tipo de delegado. Assim, somente os primeiros e terceiro marcadores na lista acima têm suporte e o primeiro marcador requer uma correspondência de tipo exato.  
  
 Quando um delegado representa um método de instância fechado ao longo de seu primeiro argumento (o caso mais comum), o delegado armazena uma referência ao ponto de entrada do método e uma referência a um objeto, chamado destino, que é de um tipo atribuível ao tipo de definido o método. Quando um delegado representa um método de instância aberto, ele armazena uma referência ao ponto de entrada do método. A assinatura do delegado deve incluir o oculto `this` parâmetro na lista de parâmetros formais; nesse caso, o delegado não tem uma referência a um objeto de destino e um objeto de destino deve ser fornecido quando o delegado é invocado.  
  
 Quando um delegado representa um método estático, o delegado armazena uma referência ao ponto de entrada do método. Quando um delegado representa um método estático fechado ao longo de seu primeiro argumento, o delegado armazena uma referência ao ponto de entrada do método e uma referência a um objeto de destino pode ser atribuído para o tipo do primeiro argumento de um método. Quando o delegado é invocado, o primeiro argumento do método estático recebe o objeto de destino.  
  
 A lista de invocação de um delegado é um conjunto ordenado de delegados em que cada elemento da lista invoca exatamente um dos métodos representados pelo delegado. Uma lista de invocação pode conter métodos duplicados. Durante uma invocação, os métodos são chamados na ordem em que aparecem na lista de invocação. Um delegado tenta chamar cada método em sua lista de invocação; as duplicatas são invocadas depois de cada vez que eles aparecem na lista de invocação. Os delegados são imutáveis; Depois de criado, não altera a lista de invocação de um delegado.  
  
 Delegados são chamados como multicast, ou podem ser combinadas, pois pode invocar um ou mais métodos de um delegado e pode ser usado em combinação de operações.  
  
 Combinação de operações, como <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A>, não alteram os delegados existentes. Em vez disso, essa operação retorna um novo delegado que contém os resultados da operação, um delegado inalterado, ou `null`. Retorna uma operação de combinação `null` quando o resultado da operação é um delegado que não faz referência a pelo menos um método. Uma operação de combinação retorna um delegado inalterado quando a operação solicitada não tem nenhum efeito.  
  
> [!NOTE]
>  Os gerenciados usam linguagens a <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A> métodos para implementar operações de delegado. Os exemplos incluem o `AddHandler` e `RemoveHandler` instruções no Visual Basic e os operadores + = e -= no representante de tipos em c#.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipos de delegado genérico podem ter parâmetros de tipo variantes. Parâmetros de tipo Contravariantes podem ser usados como tipos de parâmetro do delegado e um parâmetro de tipo covariante pode ser usado como o tipo de retorno. Esse recurso permite que o delegado genérico tipos construídos da mesma definição de tipo genérico para ser compatíveis com a atribuição se seus argumentos de tipo são tipos de referência com uma relação de herança, conforme explicado em [covariância e A contravariância](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, mas os dois delegados não podem ser combinados porque os tipos não correspondem exatamente.  
  
 Se um método invocado gera uma exceção, o método interromperá a execução, a exceção é passada para o chamador do delegado e métodos restantes na lista de invocação não são invocados. Capturar a exceção no chamador não altera esse comportamento.  
  
 Quando a assinatura dos métodos invocados por um delegado inclui um valor de retorno, o delegado retorna o valor retornado do último elemento na lista de invocação. Quando a assinatura inclui um parâmetro que é passado por referência, o valor final do parâmetro é o resultado de cada método na lista de invocação, executar em sequência e atualizando o valor do parâmetro.  
  
 O equivalente mais próximo de um delegado em C ou C++ é um ponteiro de função. Um delegado pode representar um método estático ou um método de instância. Quando o delegado representa um método de instância, o delegado armazena não apenas uma referência ao ponto de entrada do método, mas também uma referência para a instância da classe. Ao contrário dos ponteiros de função, delegados são orientada a objeto e fortemente tipados.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir um representante chamado `myMethodDelegate`. São criadas instâncias desse delegado para um método de instância e um método estático do aninhada `mySampleClass` classe. O delegado para o método de instância requer uma instância de `mySampleClass`. O `mySampleClass` instância é salvo em uma variável chamada `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="http://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Chamando métodos síncronos de forma assíncrona</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegados (Guia de Programação em C#)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegados (Visual Basic)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Como definir e usar delegados (C++/CLI)</related>
    <related type="Article" href="http://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Manipulando e acionando eventos</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa um novo delegado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">A instância da classe na qual o delegado invoca <c>method</c>.</param>
        <param name="method">O nome do método de instância que o delegado representa.</param>
        <summary>Inicializa um delegado que invoca o método de instância especificado na instância de classe especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor não pode ser usado no código do aplicativo. Para criar um delegado, especificando o nome de um método de instância, use uma sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método e um objeto de destino. Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> sobrecarga do método cria um delegado para um método de instância com um nome especificado.  
  
 Este construtor cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ocorreu um erro de associação ao método de destino.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">O <see cref="T:System.Type" /> que representa a classe que define <c>method</c>.</param>
        <param name="method">O nome do método estático que o delegado representa.</param>
        <summary>Inicializa um delegado que invoca o método estático especificado da classe especificada.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor não pode ser usado no código do aplicativo. Para criar um delegado, especificando o nome de um método estático, use uma sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método, mas não especifica um objeto de destino. Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> sobrecarga do método cria um delegado de estático para um método com um nome especificado.  
  
 Este construtor cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="target" /> representa um tipo genérico aberto.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria uma cópia superficial do delegado.</summary>
        <returns>Uma cópia superficial do delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O clone tem o mesmo <xref:System.Type>, lista de destino, o método e a invocação do representante original.  
  
 Uma cópia superficial cria uma nova instância do mesmo tipo que o objeto original e, em seguida, copia os campos não estáticos do objeto original. Se o campo é um tipo de valor, uma cópia de bit por bit do campo será executada. Se o campo é um tipo de referência, a referência será copiada, mas o objeto referenciado é não; Portanto, a referência no objeto original e a referência do clone apontam para o mesmo objeto. Em contraste, uma cópia em profundidade de um objeto duplica tudo direta ou indiretamente referenciado pelos campos no objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatena as listas de invocação dos delegados (combináveis) multicast especificados.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">A matriz de delegados a ser combinada.</param>
        <summary>Concatena as listas de invocação de uma matriz de delegados.</summary>
        <returns>Um novo delegado com uma lista de invocação que concatena as listas de invocação de delegados na matriz de <paramref name="delegates" />. Retornará <see langword="null" /> se <paramref name="delegates" /> for <see langword="null" />, se <paramref name="delegates" /> contiver zero elementos ou se cada entrada em <paramref name="delegates" /> for <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `delegates` matriz contém entradas que são `null`, essas entradas são ignoradas.  
  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado nas [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados, porque os tipos de fazer não corresponde exatamente.  
  
 <xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nem todas as entradas não nulas em <paramref name="delegates" /> são instâncias do mesmo tipo de delegado.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">O delegado cuja lista de invocação vem em primeiro lugar.</param>
        <param name="b">O delegado cuja lista de invocação vem em último lugar.</param>
        <summary>Concatena as listas de invocação de dois representantes.</summary>
        <returns>Um novo delegado com uma lista de invocação que concatena as listas de invocação de <paramref name="a" /> e <paramref name="b" /> nessa ordem. Retorna <paramref name="a" /> se <paramref name="b" /> for <see langword="null" />, retorna <paramref name="b" /> se <paramref name="a" /> for uma referência nula e retorna uma referência nula se <paramref name="a" /> e <paramref name="b" /> forem referências nulas.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado nas [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados, porque os tipos de fazer não corresponde exatamente.  
  
 <xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="a" /> e <paramref name="b" /> não são <see langword="null" />, enquanto <paramref name="a" /> e <paramref name="b" /> não são instâncias do mesmo tipo de delegado.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">O delegado multicast (combinável) cuja lista de invocação acrescentar ao final da lista de invocação do delegado multicast atual (combinável).</param>
        <summary>Concatena as listas de invocação do delegado (combinável) multicast especificado e do delegado (combinável) multicast atual.</summary>
        <returns>Um novo delegado (combinável) multicast com uma lista de invocação que concatena a lista de invocação do delegado (combinável) multicast atual e a lista de invocação de <paramref name="d" /> ou o delegado (combinável) multicast se <paramref name="d" /> é <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se aplica somente se o delegado atual é difundida por multicast (Combinável).  
  
 A implementação atual simplesmente gera uma <xref:System.MulticastNotSupportedException>.  
  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Sempre lançada.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um delegado do tipo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar. Há suporte apenas para métodos estáticos no .NET Framework versão 1.0 e 1.1.</param>
        <summary>Cria um delegado do tipo especificado para representar o método estático especificado.</summary>
        <returns>Um delegado do tipo especificado para representar o método estático especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na versão 1.0 e 1.1 do .NET Framework, essa sobrecarga de método cria delegados para apenas métodos estáticos. No .NET Framework versão 2.0, essa sobrecarga de método também pode criar instância aberta delegados de método; ou seja, delegados que fornecem explicitamente o primeiro argumento oculto de métodos de instância. Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, que permite que você criar todas as combinações de delegados abertos ou fechados para métodos estáticos ou de instância e, opcionalmente, para especificar um primeiro argumento.  
  
> [!NOTE]
>  Essa sobrecarga de método deve ser usada quando o delegado não é fechado ao longo de seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 No .NET Framework versão 2.0, os tipos de parâmetro e o tipo de retorno de um delegado que foi criado usando essa sobrecarga de método devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente. Isso representa um relaxamento do comportamento de associação no .NET Framework versão 1.0 e 1.1, em que os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra duas maneiras de um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deve ser lançado na falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não é um método estático, e a versão do .NET Framework é 1.0 ou 1.1.  
  
- ou - 
 <paramref name="method" /> não pode ser associado.  
  
- ou - 
 <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="firstArgument">O objeto ao qual o delegado está associado ou <see langword="null" /> para tratar <c>method</c> como <see langword="static" /> (<see langword="Shared" /> no Visual Basic).</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</param>
        <summary>Cria um delegado do tipo especificado que representa o método de instância ou estático especificado com o primeiro argumento especificado.</summary>
        <returns>Um delegado do tipo especificado que representa o método de instância ou estático especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`. Essas duas sobrecargas fornecem a maneira mais flexível para criar delegados. Você pode usá-los para criar delegados para estáticas ou métodos de instância e, opcionalmente, para especificar o primeiro argumento.  
  
> [!NOTE]
>  Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método para melhorar o desempenho.  
  
 O tipo de delegado e o método devem ter tipos de retornados compatíveis. Ou seja, o tipo de retorno `method` deve ser atribuível ao tipo de retorno de `type`.  
  
 Se `firstArgument` é fornecido, ele é passado para `method` sempre que o delegado é invocado; `firstArgument` deve ser associado ao representante, e o delegado deve ser fechado ao longo de seu primeiro argumento. Se `method` está `static` (`Shared` no Visual Basic), a lista de argumentos fornecida ao invocar o delegado inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para a instância oculta parâmetro (representado por `this` em c# ou por `Me` no Visual Basic).  
  
 Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com esse tipo.  
  
> [!IMPORTANT]
>  Se `method` está `static` (`Shared` no Visual Basic) e seu primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor. Nesse caso, `firstArgument` é automaticamente convertido. Conversão boxing automática não ocorrerá para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.  
  
 Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o delegado deve representar um método de instância aberta. Quando o delegado é invocado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta do `method`.  
  
-   Se as assinaturas dos `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o delegado deve ser fechado por uma referência nula. Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.  
  
 Se `firstArgument` é uma referência nula e `method` é estática, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), o delegado deve representar um método estático aberto. Isso é o caso mais comum para métodos estáticos. Nesse caso, você pode obter um desempenho ligeiramente melhor usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método.  
  
-   Se a assinatura do `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis e, em seguida, o delegado deve ser fechado por uma referência nula. Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1, os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinando os métodos que um delegado pode representar  
 Outra maneira útil para pensar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer delegado pode representar quatro combinações diferentes de assinatura de método e o tipo de método (estático versus instância). Considere um tipo de delegado `D` com um argumento do tipo `C`. A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ele deve corresponder em todos os casos:  
  
-   `D` pode representar qualquer método de instância que tem exatamente um argumento do tipo `C`, independentemente de qual pertence o método de instância de tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o delegado resultante deve ser fechada por essa instância. (Trivialmente, `D` também pode ser fechada ao longo de uma referência nula se `firstArgument` é uma referência nula.)  
  
-   `D` pode representar um método de instância `C` que não tem argumentos. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que aceita um argumento do tipo `C`, e que o método pode pertencer a qualquer tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método estático aberto e uma instância do `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`. O delegado resultante representa um método estático que é fechado por essa instância do `F`. Observe que, no caso em que `F` e `C` são do mesmo tipo, o método estático tem dois argumentos desse tipo. (Nesse caso, `D` é fechado por uma referência nula se `firstArgument` é uma referência nula.)  
  
   
  
## Examples  
 Esta seção contém três exemplos de código. O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado ao longo de um método de instância, abra um método de instância, abra ao longo de um método estático e fechado ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos que tipo de delegado podem representar.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra as quatro maneiras em que um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não tiver nenhum argumento.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`. Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
-   Por fim, um delegado do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`. O método é invocado para mostrar que ele usa a cadeia de caracteres associada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemplo 3**  
  
 O exemplo de código a seguir mostra todos os métodos pode representar um tipo de delegado único, usando o <xref:System.Delegate.CreateDelegate%2A> método para criar os delegados.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo de código define duas classes, `C` e `F`e um tipo de delegado `D` com um argumento do tipo `C`. As classes têm correspondência estáticos e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não tem argumentos.  
  
 Uma terceira classe denominada `Example` contém o código que cria os representantes.  
  
-   Delegados são criados por exemplo método `M1` do tipo `C` e digite `F`; cada um é fechada por uma instância do respectivo tipo. Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
-   Um delegado é criado para o método `M2` do tipo `C`. Esse é um delegado de instância aberta, na qual o argumento do delegado representa o primeiro argumento oculto no método de instância. O método não tem outros argumentos. Ele é chamado como se fosse um método estático.  
  
-   Delegados são criados para o método estático `M3` do tipo `C` e digite `F`; esses são delegados estáticos abertos.  
  
-   Por fim, os delegados são criados para o método estático `M4` do tipo `C` e digite `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, portanto, os delegados são fechados em seus primeiros argumentos . Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não pode ser associado.  
  
- ou - 
 <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">A instância de classe na qual <c>method</c> é invocado.</param>
        <param name="method">O nome do método de instância que o delegado deve representar.</param>
        <summary>Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</summary>
        <returns>Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não é um método de instância.  
  
- ou - 
 O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</param>
        <summary>Cria um delegado do tipo especificado para representar o método estático especificado, com o comportamento em falhas especificado a ser associado.</summary>
        <returns>Um delegado do tipo especificado para representar o método estático especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método pode criar delegados de método estático aberto e abrir os delegados de método de instância — ou seja, os delegados que expõem o primeiro argumento oculto de métodos de instância. Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> métodos estáticos ou sobrecarga de método, que permite que você criar todas as combinações de delegados abertos ou fechados, por exemplo.  
  
> [!NOTE]
>  Essa sobrecarga de método deve ser usada quando o delegado não é fechado ao longo de seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1, os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra duas maneiras de um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deve ser lançado na falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não pode ser associado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.  
  
- ou - 
 <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</param>
        <param name="method">O nome do método estático que o delegado deve representar.</param>
        <summary>Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada.</summary>
        <returns>Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="target" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="target" /> é um tipo genérico aberto. Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.  
  
- ou - 
 O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).  
  
- ou - 
 <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Um <see cref="T:System.Type" /> que representa o tipo de delegado a ser criado.</param>
        <param name="firstArgument">Um <see cref="T:System.Object" /> que é o primeiro argumento do método que o delegado representa. Por exemplo, para métodos, ele deve ser compatível com o tipo de instância.</param>
        <param name="method">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</param>
        <summary>Cria um delegado do tipo especificado que representa o método de instância ou estático especificado, com o primeiro argumento especificado e o comportamento especificado na falha para associação.</summary>
        <returns>Um delegado do tipo especificado que representa o método de instância ou estático especificado ou <see langword="null" /> se <paramref name="throwOnBindFailure" /> é <see langword="false" /> e o delegado não pode ser associado a <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método e o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, que sempre gera na falha de associação, fornecem a maneira mais flexível para criar delegados. Você pode usá-los para criar delegados para estáticas ou métodos de instância, com ou sem um primeiro argumento.  
  
> [!NOTE]
>  Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método para melhorar o desempenho.  
  
 O tipo de delegado e o método devem ter tipos de retornados compatíveis. Ou seja, o tipo de retorno `method` deve ser atribuível ao tipo de retorno de `type`.  
  
 Se `firstArgument` é fornecido, ele é passado para `method` sempre que o delegado é invocado; `firstArgument` deve ser associado ao representante, e o delegado deve ser fechado ao longo de seu primeiro argumento. Se `method` está `static` (`Shared` no Visual Basic), a lista de argumentos fornecida ao invocar o delegado inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para a instância oculta parâmetro (representado por `this` em c# ou por `Me` no Visual Basic).  
  
 Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com esse tipo.  
  
> [!IMPORTANT]
>  Se `method` está `static` (`Shared` no Visual Basic) e seu primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor. Nesse caso, `firstArgument` é automaticamente convertido. Conversão boxing automática não ocorrerá para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.  
  
 Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o delegado deve representar um método de instância aberta. Quando o delegado é invocado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta do `method`.  
  
-   Se as assinaturas dos `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o delegado deve ser fechado por uma referência nula. Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.  
  
 Se `firstArgument` é uma referência nula e `method` é estática, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), o delegado deve representar um método estático aberto. Isso é o caso mais comum para métodos estáticos. Nesse caso, você pode obter um desempenho ligeiramente melhor usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método.  
  
-   Se a assinatura do `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis e, em seguida, o delegado deve ser fechado por uma referência nula. Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1 os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinando os métodos que um delegado pode representar  
 Outra maneira útil para pensar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer delegado pode representar quatro combinações diferentes de assinatura de método e o tipo de método (estático versus instância). Considere um tipo de delegado `D` com um argumento do tipo `C`. A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ele deve corresponder em todos os casos:  
  
-   `D` pode representar qualquer método de instância que tem exatamente um argumento do tipo `C`, independentemente de qual pertence o método de instância de tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o delegado resultante deve ser fechada por essa instância. (Trivialmente, `D` também pode ser fechada ao longo de uma referência nula se `firstArgument` é `null`.)  
  
-   `D` pode representar um método de instância `C` que não tem argumentos. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que aceita um argumento do tipo `C`, e que o método pode pertencer a qualquer tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método estático aberto e uma instância do `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`. O delegado resultante representa um método estático que é fechado por essa instância do `F`. Observe que, no caso em que `F` e `C` são do mesmo tipo, o método estático tem dois argumentos desse tipo. (Nesse caso, `D` é fechado por uma referência nula se `firstArgument` é `null`.)  
  
   
  
## Examples  
 Esta seção contém três exemplos de código. O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado ao longo de um método de instância, abra um método de instância, abra ao longo de um método estático e fechado ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos que tipo de delegado podem representar.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra as quatro maneiras em que um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não tiver nenhum argumento.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`. Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
-   Por fim, um delegado do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`. O método é invocado para mostrar que ele usa a cadeia de caracteres associada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemplo 3**  
  
 O exemplo de código a seguir mostra todos os métodos de que um tipo de delegado única pode representar.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo de código define duas classes, `C` e `F`e um tipo de delegado `D` com um argumento do tipo `C`. As classes têm correspondência estáticos e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não tem argumentos.  
  
 Uma terceira classe denominada `Example` contém o código que cria os representantes.  
  
-   Delegados são criados por exemplo método `M1` do tipo `C` e digite `F`; cada um é fechada por uma instância do respectivo tipo. Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
-   Um delegado é criado para o método `M2` do tipo `C`. Esse é um delegado de instância aberta, na qual o argumento do delegado representa o primeiro argumento oculto no método de instância. O método não tem outros argumentos.  
  
-   Delegados são criados para o método estático `M3` do tipo `C` e digite `F`; esses são delegados estáticos abertos.  
  
-   Por fim, os delegados são criados para o método estático `M4` do tipo `C` e digite `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, portanto, os delegados são fechados em seus primeiros argumentos . Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não pode ser associado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.  
  
- ou - 
 <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">A instância de classe na qual <c>method</c> é invocado.</param>
        <param name="method">O nome do método de instância que o delegado deve representar.</param>
        <param name="ignoreCase">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</param>
        <summary>Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada.</summary>
        <returns>Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não é um método de instância.  
  
- ou - 
 O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</param>
        <param name="method">O nome do método estático que o delegado deve representar.</param>
        <param name="ignoreCase">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</param>
        <summary>Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada.</summary>
        <returns>Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="target" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="target" /> é um tipo genérico aberto. Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.  
  
- ou - 
 O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).  
  
- ou - 
 O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">A instância de classe na qual <c>method</c> é invocado.</param>
        <param name="method">O nome do método de instância que o delegado deve representar.</param>
        <param name="ignoreCase">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</param>
        <summary>Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada e o comportamento especificado na falha de associação.</summary>
        <returns>Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="method" /> não é um método de instância.  
  
- ou - 
 <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">O <see cref="T:System.Type" /> do representante a ser criado.</param>
        <param name="target">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</param>
        <param name="method">O nome do método estático que o delegado deve representar.</param>
        <param name="ignoreCase">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</param>
        <summary>Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada e o comportamento especificado na falha de associação.</summary>
        <returns>Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="target" /> é <see langword="null" />.  
  
- ou - 
 <paramref name="method" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.  
  
- ou - 
 <paramref name="type" /> não é um <see langword="RuntimeType" />. Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).  
  
- ou - 
 <paramref name="target" /> não é um <see langword="RuntimeType" />.  
  
- ou - 
 <paramref name="target" /> é um tipo genérico aberto. Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.  
  
- ou - 
 O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).  
  
- ou - 
 <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</exception>
        <exception cref="T:System.MethodAccessException">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objetos que são os argumentos a serem passados para o método representado pelo delegado atual.  
  
- ou - 
 <see langword="null" /> se o método representado pelo delegado atual não exigir argumentos.</param>
        <summary>Invoca dinamicamente (associação tardia) o método representado pelo delegado atual.</summary>
        <returns>O objeto retornado pelo método representado pelo delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o <xref:System.Delegate.DynamicInvokeImpl%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).  
  
- ou - 
O número, a ordem ou o tipo de parâmetros listados no <paramref name="args" /> é inválido.</exception>
        <exception cref="T:System.ArgumentException">O método representado pelo delegado é invocado em um objeto ou uma classe que não dá suporte a ele.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O método representado pelo delegado é um método de instância e o objeto de destino é <see langword="null" />.  
  
- ou - 
Um dos métodos encapsulados gera uma exceção.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">Uma matriz de objetos que são os argumentos a serem passados para o método representado pelo delegado atual.  
  
- ou - 
 <see langword="null" /> se o método representado pelo delegado atual não exigir argumentos.</param>
        <summary>Invoca dinamicamente (associação tardia) o método representado pelo delegado atual.</summary>
        <returns>O objeto retornado pelo método representado pelo delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa o método <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).  
  
- ou - 
O número, a ordem ou o tipo de parâmetros listados no <paramref name="args" /> é inválido.</exception>
        <exception cref="T:System.ArgumentException">O método representado pelo delegado é invocado em um objeto ou uma classe que não dá suporte a ele.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">O método representado pelo delegado é um método de instância e o objeto de destino é <see langword="null" />.  
  
- ou - 
Um dos métodos encapsulados gera uma exceção.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">O objeto a ser comparado com o delegado atual.</param>
        <summary>Determina se o objeto especificado e o delegado atual são do mesmo tipo e compartilham os mesmos destinos, métodos e lista de invocação.</summary>
        <returns>
          <see langword="true" /> se <paramref name="obj" /> e o delegado atual têm os mesmos destinos, métodos e lista de invocação; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação serão consideradas idênticas somente se eles têm a mesma ordem e os elementos correspondentes das duas listas de representarem o mesmo método e o destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna um código hash para o delegado.</summary>
        <returns>Um código hash para o delegado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno desse método não deve ser persistido por dois motivos. Em primeiro lugar, a função de hash de uma classe pode ser alterada para gerar uma distribuição melhor, renderização de todos os valores da função de hash antigo inútil. Em segundo lugar, a implementação padrão dessa classe não garante que o mesmo valor será retornado por instâncias diferentes.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retorna a lista de invocação do delegado.</summary>
        <returns>Uma matriz de delegados representando a lista de invocação do delegado atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada delegado na matriz representa exatamente um método.  
  
 A ordem dos delegados na matriz é a mesma ordem em que o delegado atual invoca os métodos que representam os delegados.  
  
   
  
## Examples  
 O exemplo a seguir atribui a três métodos a um delegado. Em seguida, ele chama o <xref:System.Delegate.GetInvocationList%2A> método para obter uma contagem total dos métodos atribuído ao delegado, para executar os delegados na ordem inversa, bem como executar os métodos cujo nome não incluem a subcadeia de caracteres "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém o método estático representado pelo delegado atual.</summary>
        <returns>Um <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático representado pelo delegado atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se aplica somente se o delegado atual representa um método estático.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Sem suporte.</param>
        <param name="context">Sem suporte.</param>
        <summary>Sem suporte.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Não há suporte para o método.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o método representado pelo delegado.</summary>
        <value>Uma <see cref="T:System.Reflection.MethodInfo" /> que descreve o método representado pelo delegado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro delegado a ser comparado.</param>
        <param name="d2">O segundo delegado a ser comparado.</param>
        <summary>Determina se os delegados especificados são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> for igual a <paramref name="d2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois delegados do mesmo tipo com os mesmos destinos, métodos e listas de invocação são considerados iguais.  
  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação serão consideradas idênticas se tiverem a mesma ordem e os elementos correspondentes de duas listas representarem o mesmo método e destino.  
  
 É o método equivalente para esse operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">O primeiro delegado a ser comparado.</param>
        <param name="d2">O segundo delegado a ser comparado.</param>
        <summary>Determina se os delegados especificados não são iguais.</summary>
        <returns>
          <see langword="true" /> se <paramref name="d1" /> não for igual a <paramref name="d2" />; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois delegados são considerados não iguais se forem de tipos diferentes, ou ter métodos diferentes, destinos diferentes ou listas de invocação diferente.  
  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados são considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação não são iguais se eles tiverem tamanhos diferentes, se eles são ordenados de forma diferente, ou se pelo menos um elemento de uma lista representa um método ou o destino que é diferente daquele representado por seu elemento correspondente em outra lista.  
  
 É o método equivalente para esse operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">O delegado do qual a lista de invocação de <c>value</c> será removida.</param>
        <param name="value">O delegado que fornece a lista de invocação a ser removida da lista de invocação de <c>source</c>.</param>
        <summary>Remove a última ocorrência da lista de invocação de um delegado da lista de invocação de outro delegado.</summary>
        <returns>Um novo delegado com uma lista de invocação formada com o uso da lista de invocação de <paramref name="source" /> e a remoção da última ocorrência da lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação de <paramref name="source" />. Retorna <paramref name="source" /> se <paramref name="value" /> for <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não for encontrada na lista de invocação de <paramref name="source" />. Retorna uma referência nula se a lista de invocação de <paramref name="value" /> for igual à lista de invocação de <paramref name="source" /> ou se <paramref name="source" /> for uma referência nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` deve ocorrer na lista de invocação de `source`. Se a lista de invocação `value` ocorre mais de uma vez na lista de invocação de `source`, a última ocorrência será removida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <exception cref="T:System.ArgumentException">Os tipos de delegado não são correspondentes.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">O delegado do qual a lista de invocação de <c>value</c> será removida.</param>
        <param name="value">O delegado que fornece a lista de invocação a ser removida da lista de invocação de <c>source</c>.</param>
        <summary>Remove todas as ocorrências da lista de invocação de um delegado da lista de invocação de outro delegado.</summary>
        <returns>Um novo delegado com uma lista de invocação formada com o uso da lista de invocação de <paramref name="source" /> e remoção de todas as ocorrências da lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação de <paramref name="source" />. Retorna <paramref name="source" /> se <paramref name="value" /> é <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não é encontrada na lista de invocação de <paramref name="source" />. Retorna uma referência nula se a lista de invocação de <paramref name="value" /> é igual à lista de invocação de <paramref name="source" />, se <paramref name="source" /> contém apenas uma série de listas de invocação que é igual à lista de invocação de <paramref name="value" /> ou se <paramref name="source" /> é uma referência nula.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` deve ocorrer na lista de invocação de `source`. Se a lista de invocação `value` ocorre mais de uma vez na lista de invocação de `source`, todas as ocorrências são removidas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <exception cref="T:System.ArgumentException">Os tipos de delegado não são correspondentes.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">O delegado que fornece a lista de invocação a ser removida da lista de invocação do delegado atual.</param>
        <summary>Remove a lista de invocação de um delegado da lista de invocação de outro delegado.</summary>
        <returns>Um novo delegado com uma lista de invocação formada tomando a lista de invocação do delegado atual e removendo a lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação do delegado. Retorna o delegado atual se <paramref name="value" /> for <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não for encontrada na lista de invocação do delegado atual. Retorna <see langword="null" /> se a lista de invocação de <paramref name="value" /> é igual à lista de invocação do delegado atual.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação do delegado atual e, em seguida, lista de invocação de `value` deve ocorrer na lista de invocação do delegado atual. Se a lista de invocação de `value` ocorre mais de uma vez na lista de invocação do delegado atual, a última ocorrência será removida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a instância da classe em que o delegado atual invoca o método de instância.</summary>
        <value>O objeto no qual o delegado atual invoca o método de instância, se o delegado representar um método de instância; <see langword="null" /> se o delegado representar um método estático.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Se o delegado invoca um ou mais métodos de instância, essa propriedade retorna o destino do último método de instância na lista de invocação.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>