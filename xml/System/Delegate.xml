<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3f0536eac77f3171e3a7eeb74486cfcf863ec3d8" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731650" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="03801-101">Representa um delegado, que é uma estrutura de dados que se refere a um método estático ou a uma instância da classe e um método de instância dessa classe.</span>
      <span class="sxs-lookup">
        <span data-stu-id="03801-101">Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-102">O <xref:System.Delegate> classe é a classe base para tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-102">The <xref:System.Delegate> class is the base class for delegate types.</span></span> <span data-ttu-id="03801-103">No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Delegate> classe ou o <xref:System.MulticastDelegate> classe.</span><span class="sxs-lookup"><span data-stu-id="03801-103">However, only the system and compilers can derive explicitly from the <xref:System.Delegate> class or from the <xref:System.MulticastDelegate> class.</span></span> <span data-ttu-id="03801-104">Também não é permitido para derivar um novo tipo de um tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-104">It is also not permissible to derive a new type from a delegate type.</span></span> <span data-ttu-id="03801-105">O <xref:System.Delegate> classe não é considerada um tipo de delegado; é uma classe usada para derivar tipos delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-105">The <xref:System.Delegate> class is not considered a delegate type; it is a class used to derive delegate types.</span></span>  
  
 <span data-ttu-id="03801-106">A maioria das linguagens implementar um `delegate` palavra-chave e compiladores para esses idiomas são capazes de derivar do <xref:System.MulticastDelegate> classe; portanto, os usuários devem usar o `delegate` fornecida pela linguagem de palavra-chave.</span><span class="sxs-lookup"><span data-stu-id="03801-106">Most languages implement a `delegate` keyword, and compilers for those languages are able to derive from the <xref:System.MulticastDelegate> class; therefore, users should use the `delegate` keyword provided by the language.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-107">O common language runtime fornece um `Invoke` método para cada tipo de delegado, com a mesma assinatura do representante.</span><span class="sxs-lookup"><span data-stu-id="03801-107">The common language runtime provides an `Invoke` method for each delegate type, with the same signature as the delegate.</span></span> <span data-ttu-id="03801-108">Você não precisa chamar este método explicitamente do c#, Visual Basic ou Visual C++, pois os compiladores chamá-lo automaticamente.</span><span class="sxs-lookup"><span data-stu-id="03801-108">You do not have to call this method explicitly from C#, Visual Basic, or Visual C++, because the compilers call it automatically.</span></span> <span data-ttu-id="03801-109">O `Invoke` método é útil em [reflexão](~/docs/framework/reflection-and-codedom/reflection.md) quando você deseja localizar a assinatura do tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-109">The `Invoke` method is useful in [reflection](~/docs/framework/reflection-and-codedom/reflection.md) when you want to find the signature of the delegate type.</span></span>  
  
 <span data-ttu-id="03801-110">O common language runtime fornece a cada tipo de delegado com `BeginInvoke` e `EndInvoke` métodos, para permitir a invocação assíncrona do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-110">The common language runtime provides each delegate type with `BeginInvoke` and `EndInvoke` methods, to enable asynchronous invocation of the delegate.</span></span> <span data-ttu-id="03801-111">Para obter mais informações sobre esses métodos, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span><span class="sxs-lookup"><span data-stu-id="03801-111">For more information about these methods, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).</span></span>  
  
 <span data-ttu-id="03801-112">A declaração de um tipo delegado estabelece um contrato que especifica a assinatura de um ou mais métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-112">The declaration of a delegate type establishes a contract that specifies the signature of one or more methods.</span></span> <span data-ttu-id="03801-113">Um delegado é uma instância de um tipo de delegado que tem referências para:</span><span class="sxs-lookup"><span data-stu-id="03801-113">A delegate is an instance of a delegate type that has references to:</span></span>  
  
-   <span data-ttu-id="03801-114">Um método de instância de um tipo e um objeto de destino pode ser atribuído a esse tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-114">An instance method of a type and a target object assignable to that type.</span></span>  
  
-   <span data-ttu-id="03801-115">Um método de instância de um tipo, ocultos `this` parâmetro exposto na lista de parâmetros formais.</span><span class="sxs-lookup"><span data-stu-id="03801-115">An instance method of a type, with the hidden `this` parameter exposed in the formal parameter list.</span></span> <span data-ttu-id="03801-116">O representante será considerado um delegado de instância aberta.</span><span class="sxs-lookup"><span data-stu-id="03801-116">The delegate is said to be an open instance delegate.</span></span>  
  
-   <span data-ttu-id="03801-117">Um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-117">A static method.</span></span>  
  
-   <span data-ttu-id="03801-118">Um método estático e um objeto de destino pode ser atribuído ao primeiro parâmetro do método.</span><span class="sxs-lookup"><span data-stu-id="03801-118">A static method and a target object assignable to the first parameter of the method.</span></span> <span data-ttu-id="03801-119">O representante deve ser fechada em seu primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-119">The delegate is said to be closed over its first argument.</span></span>  
  
 <span data-ttu-id="03801-120">Para obter mais informações sobre associação de delegado, consulte o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-120">For more information on delegate binding, see the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-121">Nas versões do .NET Framework 1.0 e 1.1, um delegado pode representar um método somente se a assinatura do método corresponde exatamente à assinatura especificada pelo tipo de delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-121">In the .NET Framework versions 1.0 and 1.1, a delegate can represent a method only if the signature of the method exactly matches the signature specified by the delegate type.</span></span> <span data-ttu-id="03801-122">Portanto, têm suporte somente os primeiro e terceiro marcadores na lista anterior e o primeiro marcador requer uma correspondência exata do tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-122">Thus, only the first and third bullets in the preceding list are supported, and the first bullet requires an exact type match.</span></span>  
  
 <span data-ttu-id="03801-123">Quando um delegado representa um método de instância fechado em seu primeiro argumento (o caso mais comum), o representante armazena uma referência ao ponto de entrada do método e uma referência a um objeto, chamado destino, que é de um tipo atribuível para o tipo definido pelo método.</span><span class="sxs-lookup"><span data-stu-id="03801-123">When a delegate represents an instance method closed over its first argument (the most common case), the delegate stores a reference to the method's entry point and a reference to an object, called the target, which is of a type assignable to the type that defined the method.</span></span> <span data-ttu-id="03801-124">Quando um delegado representa um método de instância aberto, ele armazena uma referência ao ponto de entrada do método.</span><span class="sxs-lookup"><span data-stu-id="03801-124">When a delegate represents an open instance method, it stores a reference to the method's entry point.</span></span> <span data-ttu-id="03801-125">A assinatura do delegado deve incluir oculto `this` parâmetro na lista de parâmetros formais; nesse caso, o representante não tem uma referência a um objeto de destino e um objeto de destino deve ser fornecido quando o delegado é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-125">The delegate signature must include the hidden `this` parameter in its formal parameter list; in this case, the delegate does not have a reference to a target object, and a target object must be supplied when the delegate is invoked.</span></span>  
  
 <span data-ttu-id="03801-126">Quando um delegado representa um método estático, o representante armazena uma referência ao ponto de entrada do método.</span><span class="sxs-lookup"><span data-stu-id="03801-126">When a delegate represents a static method, the delegate stores a reference to the method's entry point.</span></span> <span data-ttu-id="03801-127">Quando um delegado representa um método estático fechado em seu primeiro argumento, o representante armazena uma referência ao ponto de entrada do método e uma referência a um objeto de destino pode ser atribuído ao tipo de argumento de primeiro do método.</span><span class="sxs-lookup"><span data-stu-id="03801-127">When a delegate represents a static method closed over its first argument, the delegate stores a reference to the method's entry point and a reference to a target object assignable to the type of the method's first argument.</span></span> <span data-ttu-id="03801-128">Quando o representante é chamado, o primeiro argumento do método estático recebe o objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="03801-128">When the delegate is invoked, the first argument of the static method receives the target object.</span></span>  
  
 <span data-ttu-id="03801-129">A lista de invocação de um delegado é um conjunto ordenado de delegates em que cada elemento da lista invoca exatamente um dos métodos representados pelo delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-129">The invocation list of a delegate is an ordered set of delegates in which each element of the list invokes exactly one of the methods represented by the delegate.</span></span> <span data-ttu-id="03801-130">Uma lista de invocação pode conter métodos duplicados.</span><span class="sxs-lookup"><span data-stu-id="03801-130">An invocation list can contain duplicate methods.</span></span> <span data-ttu-id="03801-131">Durante uma chamada, os métodos são chamados na ordem em que aparecem na lista de invocação.</span><span class="sxs-lookup"><span data-stu-id="03801-131">During an invocation, methods are invoked in the order in which they appear in the invocation list.</span></span> <span data-ttu-id="03801-132">Tentativas de um delegado chamar cada método na sua lista de invocação; duplicatas são invocadas depois de cada vez que eles aparecem na lista de invocação.</span><span class="sxs-lookup"><span data-stu-id="03801-132">A delegate attempts to invoke every method in its invocation list; duplicates are invoked once for each time they appear in the invocation list.</span></span> <span data-ttu-id="03801-133">Delegados são imutáveis; Depois de criado, não altera a lista de invocação de um representante.</span><span class="sxs-lookup"><span data-stu-id="03801-133">Delegates are immutable; once created, the invocation list of a delegate does not change.</span></span>  
  
 <span data-ttu-id="03801-134">Delegados são mencionados como multicast ou podem ser combinadas, porque um delegado pode invocar um ou mais métodos e pode ser usado na combinação de operações.</span><span class="sxs-lookup"><span data-stu-id="03801-134">Delegates are referred to as multicast, or combinable, because a delegate can invoke one or more methods and can be used in combining operations.</span></span>  
  
 <span data-ttu-id="03801-135">Combinação de operações, como <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A>, não altere delegados existentes.</span><span class="sxs-lookup"><span data-stu-id="03801-135">Combining operations, such as <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A>, do not alter existing delegates.</span></span> <span data-ttu-id="03801-136">Em vez disso, essa operação retorna um novo delegado que contém os resultados da operação, um representante inalterado, ou `null`.</span><span class="sxs-lookup"><span data-stu-id="03801-136">Instead, such an operation returns a new delegate that contains the results of the operation, an unchanged delegate, or `null`.</span></span> <span data-ttu-id="03801-137">Uma operação de combinação retorna `null` quando o resultado da operação é um delegado que não faz referência a pelo menos um método.</span><span class="sxs-lookup"><span data-stu-id="03801-137">A combining operation returns `null` when the result of the operation is a delegate that does not reference at least one method.</span></span> <span data-ttu-id="03801-138">Uma operação de combinação retorna um delegado inalterado quando a operação solicitada não tem nenhum efeito.</span><span class="sxs-lookup"><span data-stu-id="03801-138">A combining operation returns an unchanged delegate when the requested operation has no effect.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-139">Gerenciado usar idiomas de <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A> métodos para implementar operações de delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-139">Managed languages use the <xref:System.Delegate.Combine%2A> and <xref:System.Delegate.Remove%2A> methods to implement delegate operations.</span></span> <span data-ttu-id="03801-140">Os exemplos incluem o `AddHandler` e `RemoveHandler` instruções no Visual Basic e os operadores + = e-= no representante de tipos em c#.</span><span class="sxs-lookup"><span data-stu-id="03801-140">Examples include the `AddHandler` and `RemoveHandler` statements in Visual Basic and the += and -= operators on delegate types in C#.</span></span>  
  
 <span data-ttu-id="03801-141">Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipos de delegado genérico podem ter parâmetros de tipo variant.</span><span class="sxs-lookup"><span data-stu-id="03801-141">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generic delegate types can have variant type parameters.</span></span> <span data-ttu-id="03801-142">Parâmetros de tipo contravariant podem ser usados como tipos de parâmetro do delegado, e um parâmetro de tipo covariant pode ser usado como o tipo de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-142">Contravariant type parameters can be used as parameter types of the delegate, and a covariant type parameter can be used as the return type.</span></span> <span data-ttu-id="03801-143">Esse recurso permite delegado genérico tipos que são construídos com a mesma definição de tipo genérico para ser compatível com o atribuição se seus argumentos de tipo são tipos de referência com uma relação de herança, conforme explicado em [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md).</span><span class="sxs-lookup"><span data-stu-id="03801-143">This feature allows generic delegate types that are constructed from the same generic type definition to be assignment-compatible if their type arguments are reference types with an inheritance relationship, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-144">Delegados genéricos que são compatíveis com atribuição devido à variação não são necessariamente podem ser combinadas.</span><span class="sxs-lookup"><span data-stu-id="03801-144">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="03801-145">Para ser combináveis, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-145">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="03801-146">Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-146">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="03801-147">Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, mas os dois delegados não podem ser combinados porque os tipos não correspondem exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-147">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="03801-148">Se um método invocado lança uma exceção, o método interrompe a execução, a exceção é passada de volta para o chamador do delegado e métodos restantes na lista de invocação não serão chamados.</span><span class="sxs-lookup"><span data-stu-id="03801-148">If an invoked method throws an exception, the method stops executing, the exception is passed back to the caller of the delegate, and remaining methods in the invocation list are not invoked.</span></span> <span data-ttu-id="03801-149">Captura a exceção no chamador não altera esse comportamento.</span><span class="sxs-lookup"><span data-stu-id="03801-149">Catching the exception in the caller does not alter this behavior.</span></span>  
  
 <span data-ttu-id="03801-150">Quando a assinatura dos métodos chamados por um delegado inclui um valor de retorno, o representante retorna o valor de retorno do último elemento na lista de invocação.</span><span class="sxs-lookup"><span data-stu-id="03801-150">When the signature of the methods invoked by a delegate includes a return value, the delegate returns the return value of the last element in the invocation list.</span></span> <span data-ttu-id="03801-151">Quando a assinatura inclui um parâmetro que é passado por referência, o valor final do parâmetro é o resultado de cada método na lista de invocação sequencialmente em execução e atualizar o valor do parâmetro.</span><span class="sxs-lookup"><span data-stu-id="03801-151">When the signature includes a parameter that is passed by reference, the final value of the parameter is the result of every method in the invocation list executing sequentially and updating the parameter's value.</span></span>  
  
 <span data-ttu-id="03801-152">O equivalente mais próximo de um delegado em C ou C++ é um ponteiro de função.</span><span class="sxs-lookup"><span data-stu-id="03801-152">The closest equivalent of a delegate in C or C++ is a function pointer.</span></span> <span data-ttu-id="03801-153">Um delegado pode representar um método estático ou um método de instância.</span><span class="sxs-lookup"><span data-stu-id="03801-153">A delegate can represent a static method or an instance method.</span></span> <span data-ttu-id="03801-154">Quando o delegate representa um método de instância, o representante armazena não apenas uma referência ao ponto de entrada do método, mas também uma referência para a instância da classe.</span><span class="sxs-lookup"><span data-stu-id="03801-154">When the delegate represents an instance method, the delegate stores not only a reference to the method's entry point, but also a reference to the class instance.</span></span> <span data-ttu-id="03801-155">Ao contrário de ponteiros de função, delegados são orientada a objeto e de tipo seguros.</span><span class="sxs-lookup"><span data-stu-id="03801-155">Unlike function pointers, delegates are object oriented and type safe.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-156">O exemplo a seguir mostra como definir um delegado chamado `myMethodDelegate`.</span><span class="sxs-lookup"><span data-stu-id="03801-156">The following example shows how to define a delegate named `myMethodDelegate`.</span></span> <span data-ttu-id="03801-157">Instâncias deste delegado são criadas para um método de instância e um método estático de aninhada `mySampleClass` classe.</span><span class="sxs-lookup"><span data-stu-id="03801-157">Instances of this delegate are created for an instance method and a static method of the nested `mySampleClass` class.</span></span> <span data-ttu-id="03801-158">O representante para o método de instância requer uma instância de `mySampleClass`.</span><span class="sxs-lookup"><span data-stu-id="03801-158">The delegate for the instance method requires an instance of `mySampleClass`.</span></span> <span data-ttu-id="03801-159">O `mySampleClass` instância é salvo em uma variável chamada `mySC`.</span><span class="sxs-lookup"><span data-stu-id="03801-159">The `mySampleClass` instance is saved in a variable named `mySC`.</span></span>  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="03801-160">Inicializa um novo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-160">Initializes a new delegate.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="03801-161">A instância da classe na qual o delegado invoca <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-161">The class instance on which the delegate invokes <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-162">O nome do método de instância que o delegado representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-162">The name of the instance method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-163">Inicializa um delegado que invoca o método de instância especificado na instância de classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-163">Initializes a delegate that invokes the specified instance method on the specified class instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-164">Este construtor não pode ser usado no código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="03801-164">This constructor cannot be used in application code.</span></span> <span data-ttu-id="03801-165">Para criar um delegado, especificando o nome de um método de instância, use uma sobrecarga de <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método e um objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="03801-165">To create a delegate by specifying the name of an instance method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name and a target object.</span></span> <span data-ttu-id="03801-166">Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> sobrecarga do método cria um delegado para um método de instância com um nome especificado.</span><span class="sxs-lookup"><span data-stu-id="03801-166">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> method overload creates a delegate for an instance method with a specified name.</span></span>  
  
 <span data-ttu-id="03801-167">Este construtor cria delegados para a instância somente métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-167">This constructor creates delegates for instance methods only.</span></span> <span data-ttu-id="03801-168">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-168">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-169">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-169">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-170">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-170">-or-</span>
          </span>
          <span data-ttu-id="03801-171">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-171">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-172">Ocorreu um erro de associação ao método de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-172">There was an error binding to the target method.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-173">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-173">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-174">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-174">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="03801-175">O <see cref="T:System.Type" /> que representa a classe que define <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-175">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-176">O nome do método estático que o delegado representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-176">The name of the static method that the delegate represents.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-177">Inicializa um delegado que invoca o método estático especificado da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-177">Initializes a delegate that invokes the specified static method from the specified class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-178">Este construtor não pode ser usado no código do aplicativo.</span><span class="sxs-lookup"><span data-stu-id="03801-178">This constructor cannot be used in application code.</span></span> <span data-ttu-id="03801-179">Para criar um delegado, especificando o nome de um método estático, use uma sobrecarga de <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método, mas não especificam um objeto de destino.</span><span class="sxs-lookup"><span data-stu-id="03801-179">To create a delegate by specifying the name of a static method, use an overload of the <xref:System.Delegate.CreateDelegate%2A> method that specifies a method name but does not specify a target object.</span></span> <span data-ttu-id="03801-180">Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> sobrecarga do método cria um delegado de estático para um método com um nome especificado.</span><span class="sxs-lookup"><span data-stu-id="03801-180">For example, the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> method overload creates a static delegate for a method with a specified name.</span></span>  
  
 <span data-ttu-id="03801-181">Este construtor cria delegados para apenas métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-181">This constructor creates delegates for static methods only.</span></span> <span data-ttu-id="03801-182">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-182">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-183">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-183">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-184">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-184">-or-</span>
          </span>
          <span data-ttu-id="03801-185">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-185">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-186">
            <paramref name="target" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-186">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-187">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-187">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-188">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-188">-or-</span>
          </span>
          <span data-ttu-id="03801-189">
            <paramref name="target" /> representa um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-189">
              <paramref name="target" /> represents an open generic type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-190">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-190">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-191">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-191">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="03801-192">Cria uma cópia superficial do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-192">Creates a shallow copy of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-193">Uma cópia superficial do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-193">A shallow copy of the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-194">O clone tem o mesmo <xref:System.Type>, lista de destino, o método e a invocação do representante original.</span><span class="sxs-lookup"><span data-stu-id="03801-194">The clone has the same <xref:System.Type>, target, method, and invocation list as the original delegate.</span></span>  
  
 <span data-ttu-id="03801-195">Uma cópia superficial cria uma nova instância do mesmo tipo que o objeto original e, em seguida, copia os campos não estáticos do objeto original.</span><span class="sxs-lookup"><span data-stu-id="03801-195">A shallow copy creates a new instance of the same type as the original object, and then copies the nonstatic fields of the original object.</span></span> <span data-ttu-id="03801-196">Se o campo é um tipo de valor, uma cópia de bit a bit do campo será executada.</span><span class="sxs-lookup"><span data-stu-id="03801-196">If the field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="03801-197">Se o campo for um tipo de referência, a referência é copiada, mas o objeto chamado é não; Portanto, a referência no objeto original e a referência do clone apontam para o mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="03801-197">If the field is a reference type, the reference is copied but the referred object is not; therefore, the reference in the original object and the reference in the clone point to the same object.</span></span> <span data-ttu-id="03801-198">Em contraste, uma cópia em profundidade de um objeto duplicatas tudo direta ou indiretamente referenciado por campos no objeto.</span><span class="sxs-lookup"><span data-stu-id="03801-198">In contrast, a deep copy of an object duplicates everything directly or indirectly referenced by the fields in the object.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-199">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-199">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-200">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-200">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="03801-201">Concatena as listas de invocação dos delegados (combináveis) multicast especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-201">Concatenates the invocation lists of the specified multicast (combinable) delegates.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">
          <span data-ttu-id="03801-202">A matriz de delegados a ser combinada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-202">The array of delegates to combine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-203">Concatena as listas de invocação de uma matriz de delegados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-203">Concatenates the invocation lists of an array of delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-204">Um novo delegado com uma lista de invocação que concatena as listas de invocação de delegados na matriz de <paramref name="delegates" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-204">A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array.</span>
          </span>
          <span data-ttu-id="03801-205">Retornará <see langword="null" /> se <paramref name="delegates" /> for <see langword="null" />, se <paramref name="delegates" /> contiver zero elementos ou se cada entrada em <paramref name="delegates" /> for <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-205">Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-206">Se o `delegates` matriz contém entradas que são `null`, essas entradas são ignoradas.</span><span class="sxs-lookup"><span data-stu-id="03801-206">If the `delegates` array contains entries that are `null`, those entries are ignored.</span></span>  
  
 <span data-ttu-id="03801-207">A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="03801-207">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-208">Delegados genéricos que são compatíveis com atribuição devido à variação não são necessariamente podem ser combinadas.</span><span class="sxs-lookup"><span data-stu-id="03801-208">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="03801-209">Para ser combináveis, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-209">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="03801-210">Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-210">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="03801-211">Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado em [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados porque os tipos não correspondem exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-211">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="03801-212"><xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.</span><span class="sxs-lookup"><span data-stu-id="03801-212"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-213">Nem todas as entradas não nulas em <paramref name="delegates" /> são instâncias do mesmo tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-213">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-214">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-214">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-215">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-215">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="03801-216">O delegado cuja lista de invocação vem em primeiro lugar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-216">The delegate whose invocation list comes first.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="03801-217">O delegado cuja lista de invocação vem em último lugar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-217">The delegate whose invocation list comes last.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-218">Concatena as listas de invocação de dois representantes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-218">Concatenates the invocation lists of two delegates.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-219">Um novo delegado com uma lista de invocação que concatena as listas de invocação de <paramref name="a" /> e <paramref name="b" /> nessa ordem.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-219">A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order.</span>
          </span>
          <span data-ttu-id="03801-220">Retorna <paramref name="a" /> se <paramref name="b" /> for <see langword="null" />, retorna <paramref name="b" /> se <paramref name="a" /> for uma referência nula e retorna uma referência nula se <paramref name="a" /> e <paramref name="b" /> forem referências nulas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-220">Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-221">A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="03801-221">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-222">Delegados genéricos que são compatíveis com atribuição devido à variação não são necessariamente podem ser combinadas.</span><span class="sxs-lookup"><span data-stu-id="03801-222">Generic delegates that are assignment-compatible because of variance are not necessarily combinable.</span></span> <span data-ttu-id="03801-223">Para ser combináveis, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-223">To be combinable, the types must match exactly.</span></span> <span data-ttu-id="03801-224">Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe denominada `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-224">For example, suppose that a class named `Derived` is derived from a class named `Base`.</span></span> <span data-ttu-id="03801-225">Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado em [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados porque os tipos não correspondem exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-225">A delegate of type `Action<Base>` (`Action(Of Base)` in Visual Basic) can be assigned to a variable of type `Action<Derived>`, as explained in [Covariance and Contravariance](~/docs/standard/generics/covariance-and-contravariance.md), but the two delegates cannot be combined because the types do not match exactly.</span></span>  
  
 <span data-ttu-id="03801-226"><xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.</span><span class="sxs-lookup"><span data-stu-id="03801-226"><xref:System.Delegate.Combine%2A> is useful for creating event handlers that call multiple methods each time an event occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-227">
            <paramref name="a" /> e <paramref name="b" /> não são <see langword="null" />, enquanto <paramref name="a" /> e <paramref name="b" /> não são instâncias do mesmo tipo de delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-227">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-228">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-228">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-229">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-229">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="03801-230">O delegado multicast (combinável) cuja lista de invocação acrescentar ao final da lista de invocação do delegado multicast atual (combinável).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-230">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-231">Concatena as listas de invocação do delegado (combinável) multicast especificado e do delegado (combinável) multicast atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-231">Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-232">Um novo delegado (combinável) multicast com uma lista de invocação que concatena a lista de invocação do delegado (combinável) multicast atual e a lista de invocação de <paramref name="d" /> ou o delegado (combinável) multicast se <paramref name="d" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-232">A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-233">Esse método se aplica somente se o representante atual é difundida via multicast (combináveis).</span><span class="sxs-lookup"><span data-stu-id="03801-233">This method applies only if the current delegate is multicast (combinable).</span></span>  
  
 <span data-ttu-id="03801-234">A implementação atual simplesmente gera uma <xref:System.MulticastNotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="03801-234">The current implementation simply throws a <xref:System.MulticastNotSupportedException>.</span></span>  
  
 <span data-ttu-id="03801-235">A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.</span><span class="sxs-lookup"><span data-stu-id="03801-235">The invocation list can contain duplicate entries; that is, entries that refer to the same method on the same object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">
          <span data-ttu-id="03801-236">Sempre lançada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-236">Always thrown.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-237">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-237">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-238">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-238">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="03801-239">Cria um delegado do tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-239">Creates a delegate of the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-240">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-240">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-241">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-241">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
          <span data-ttu-id="03801-242">Há suporte apenas para métodos estáticos no .NET Framework versão 1.0 e 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-242">Only static methods are supported in the .NET Framework version 1.0 and 1.1.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-243">Cria um delegado do tipo especificado para representar o método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-243">Creates a delegate of the specified type to represent the specified static method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-244">Um delegado do tipo especificado para representar o método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-244">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-245">No .NET Framework versão 1.0 e 1.1, essa sobrecarga de método cria delegados para apenas métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-245">In the .NET Framework version 1.0 and 1.1, this method overload creates delegates for static methods only.</span></span> <span data-ttu-id="03801-246">No .NET Framework versão 2.0, essa sobrecarga de método também pode criar instância aberta delegados de método; ou seja, delegados que fornecem explicitamente o primeiro argumento oculto da instância métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-246">In the .NET Framework version 2.0, this method overload also can create open instance method delegates; that is, delegates that explicitly supply the hidden first argument of instance methods.</span></span> <span data-ttu-id="03801-247">Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, o que permite que você criar todas as combinações de delegates abertos ou fechados instância ou de métodos estáticos e, opcionalmente, para especificar o primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-247">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods, and optionally to specify a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-248">Essa sobrecarga de método deve ser usada quando o delegado não está fechado em seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.</span><span class="sxs-lookup"><span data-stu-id="03801-248">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
 <span data-ttu-id="03801-249">Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-249">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-250">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-250">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-251">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-251">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-252">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-252">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="03801-253">Tipos de parâmetro compatíveis e tipo de retorno</span><span class="sxs-lookup"><span data-stu-id="03801-253">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="03801-254">No .NET Framework versão 2.0, os tipos de parâmetro e tipo de retorno de um delegado criado usando essa sobrecarga de método devem ser compatíveis com os tipos de parâmetro e tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-254">In the .NET Framework version 2.0, the parameter types and return type of a delegate created using this method overload must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span> <span data-ttu-id="03801-255">Isso representa uma atenuação do comportamento de associação no .NET Framework versão 1.0 e 1.1, onde os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-255">This represents a relaxation of the binding behavior in the .NET Framework version 1.0 and 1.1, where the types must match exactly.</span></span>  
  
 <span data-ttu-id="03801-256">Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.</span><span class="sxs-lookup"><span data-stu-id="03801-256">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="03801-257">Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-257">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-258">Por exemplo, um delegado com um parâmetro de tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro de tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="03801-258">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-259">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="03801-259">This section contains two code examples.</span></span> <span data-ttu-id="03801-260">O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-260">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="03801-261">O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-261">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="03801-262">**Exemplo 1**</span><span class="sxs-lookup"><span data-stu-id="03801-262">**Example 1**</span></span>  
  
 <span data-ttu-id="03801-263">O exemplo de código a seguir demonstra um delegado pode ser criado usando essa sobrecarga de duas maneiras de <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="03801-263">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-264">Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deseja gerar Falha ao associar, e o outro sempre gera.</span><span class="sxs-lookup"><span data-stu-id="03801-264">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-265">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-265">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-266">O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos delegados: `D1` usa uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="03801-266">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="03801-267">Uma segunda classe chamada `Example` contém o código que cria os representantes.</span><span class="sxs-lookup"><span data-stu-id="03801-267">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-268">Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-268">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-269">Uma instância deve ser passada quando o representante é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-269">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="03801-270">Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-270">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="03801-271">**Exemplo 2**</span><span class="sxs-lookup"><span data-stu-id="03801-271">**Example 2**</span></span>  
  
 <span data-ttu-id="03801-272">O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-272">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
 <span data-ttu-id="03801-273">O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-273">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="03801-274">A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="03801-274">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="03801-275">O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-275">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="03801-276">O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-276">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="03801-277">O método pode ser associado ao representante porque:</span><span class="sxs-lookup"><span data-stu-id="03801-277">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="03801-278">O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-278">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="03801-279">O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.</span><span class="sxs-lookup"><span data-stu-id="03801-279">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-280">O exemplo de código não produz nenhuma saída.</span><span class="sxs-lookup"><span data-stu-id="03801-280">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-281">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-281">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-282">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-282">-or-</span>
          </span>
          <span data-ttu-id="03801-283">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-283">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-284">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-284">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-285">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-285">-or-</span>
          </span>
          <span data-ttu-id="03801-286">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-286">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-287">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-287">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-288">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-288">-or-</span>
          </span>
          <span data-ttu-id="03801-289">
            <paramref name="method" /> não é um método estático, e a versão do .NET Framework é 1.0 ou 1.1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-289">
              <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.</span>
          </span>
          <span data-ttu-id="03801-290">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-290">-or-</span>
          </span>
          <span data-ttu-id="03801-291">
            <paramref name="method" /> não pode ser associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-291">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="03801-292">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-292">-or-</span>
          </span>
          <span data-ttu-id="03801-293">
            <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-293">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="03801-294">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-294">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-295">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-295">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-296">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-296">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-297">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-297">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-298">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-298">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-299">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-299">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="03801-300">O objeto ao qual o delegado está associado ou <see langword="null" /> para tratar <c>method</c> como <see langword="static" /> (<see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-300">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-301">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-301">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-302">Cria um delegado do tipo especificado que representa o método de instância ou estático especificado com o primeiro argumento especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-302">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-303">Um delegado do tipo especificado que representa o método de instância ou estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-303">A delegate of the specified type that represents the specified static or instance method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-304">Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-304">Calling this method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload and specifying `true` for `throwOnBindFailure`.</span></span> <span data-ttu-id="03801-305">Essas duas sobrecargas fornecem a maneira mais flexível para criar delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-305">These two overloads provide the most flexible way to create delegates.</span></span> <span data-ttu-id="03801-306">Você pode usá-los para criar delegados para estáticas ou métodos de instância e, opcionalmente, para especificar o primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-306">You can use them to create delegates for either static or instance methods, and optionally to specify the first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-307">Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga do método para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="03801-307">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="03801-308">O tipo de delegado e o método devem ter tipos de retorno compatíveis.</span><span class="sxs-lookup"><span data-stu-id="03801-308">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="03801-309">Ou seja, o tipo de retorno de `method` deve ser atribuível ao tipo de retorno de `type`.</span><span class="sxs-lookup"><span data-stu-id="03801-309">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="03801-310">Se `firstArgument` é fornecido, ele é passado para `method` toda vez que o delegado é invocado; `firstArgument` deve ser associado ao delegado, e o representante deve ser fechada em seu primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-310">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="03801-311">Se `method` é `static` (`Shared` no Visual Basic), o argumento fornecida ao invocar o delegado de lista inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para o parâmetro de instância oculta (representado por `this` em c#, ou por `Me` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="03801-311">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="03801-312">Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com o tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-312">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="03801-313">Se `method` é `static` (`Shared` no Visual Basic) e o primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="03801-313">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="03801-314">Nesse caso `firstArgument` é convertido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="03801-314">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="03801-315">Conversão automática não ocorre para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.</span><span class="sxs-lookup"><span data-stu-id="03801-315">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="03801-316">Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo delegado `type` e `method`:</span><span class="sxs-lookup"><span data-stu-id="03801-316">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="03801-317">Se a assinatura de `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o representante deve representar um método de instância aberta.</span><span class="sxs-lookup"><span data-stu-id="03801-317">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="03801-318">Quando o representante é chamado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta de `method`.</span><span class="sxs-lookup"><span data-stu-id="03801-318">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="03801-319">Se as assinaturas de `method` e `type` correspondem (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o representante deve ser fechada por uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-319">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="03801-320">Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.</span><span class="sxs-lookup"><span data-stu-id="03801-320">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="03801-321">Se `firstArgument` é uma referência nula e `method` é estático, o resultado depende das assinaturas do tipo delegado `type` e `method`:</span><span class="sxs-lookup"><span data-stu-id="03801-321">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="03801-322">Se a assinatura de `method` e `type` correspondem (ou seja, todos os tipos de parâmetro são compatíveis), o representante deve representar um método estático aberto.</span><span class="sxs-lookup"><span data-stu-id="03801-322">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="03801-323">Este é o caso mais comum para métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-323">This is the most common case for static methods.</span></span> <span data-ttu-id="03801-324">Nesse caso, você pode obter um pouco melhor desempenho usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-324">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span>  
  
-   <span data-ttu-id="03801-325">Se a assinatura de `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis, o representante deve ser fechada por uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-325">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="03801-326">Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.</span><span class="sxs-lookup"><span data-stu-id="03801-326">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-327">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-327">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-328">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-328">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-329">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-329">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="03801-330">Tipos de parâmetro compatíveis e tipo de retorno</span><span class="sxs-lookup"><span data-stu-id="03801-330">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="03801-331">Os tipos de parâmetro e tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-331">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-332">Na versão 1.0 e 1.1 do .NET Framework, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-332">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="03801-333">Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.</span><span class="sxs-lookup"><span data-stu-id="03801-333">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="03801-334">Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-334">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-335">Por exemplo, um delegado com um parâmetro de tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro de tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="03801-335">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="03801-336">Determinando os métodos que um delegado pode representar</span><span class="sxs-lookup"><span data-stu-id="03801-336">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="03801-337">Outra forma útil considerar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer dado delegado pode representar quatro diferentes combinações de assinatura de método e o tipo de método (estático versus instância).</span><span class="sxs-lookup"><span data-stu-id="03801-337">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="03801-338">Considere a possibilidade de um tipo de delegado `D` com um argumento do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-338">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="03801-339">A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ela deve corresponder em todos os casos:</span><span class="sxs-lookup"><span data-stu-id="03801-339">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="03801-340">`D` pode representar qualquer método de instância que tenha exatamente um argumento de tipo `C`, independentemente de qual pertence o método de instância de tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-340">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="03801-341">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o representante resultante deve ser fechada por essa instância.</span><span class="sxs-lookup"><span data-stu-id="03801-341">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="03801-342">(Facilmente, `D` também pode ser fechada por uma referência nula se `firstArgument` é uma referência nula.)</span><span class="sxs-lookup"><span data-stu-id="03801-342">(Trivially, `D` can also be closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
-   <span data-ttu-id="03801-343">`D` pode representar um método de instância `C` que não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-343">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="03801-344">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-344">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="03801-345">O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-345">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="03801-346">`D` pode representar um método estático que usa um argumento de tipo `C`, e que o método pode pertencer a qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-346">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="03801-347">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-347">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="03801-348">O delegado resultante representa um método estático open e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-348">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="03801-349">`D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-349">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="03801-350">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`.</span><span class="sxs-lookup"><span data-stu-id="03801-350">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="03801-351">O delegado resultante representa um método estático que é fechado por aquela instância do `F`.</span><span class="sxs-lookup"><span data-stu-id="03801-351">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="03801-352">Observe que no caso onde `F` e `C` são do mesmo tipo, o método estático tem dois argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-352">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="03801-353">(Nesse caso, `D` estiver fechado por uma referência nula se `firstArgument` é uma referência nula.)</span><span class="sxs-lookup"><span data-stu-id="03801-353">(In this case, `D` is closed over a null reference if `firstArgument` is a null reference.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-354">Esta seção contém três exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="03801-354">This section contains three code examples.</span></span> <span data-ttu-id="03801-355">O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado por um método de instância, abra um método de instância, abra um método estático e fechado por um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-355">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="03801-356">O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-356">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="03801-357">O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos de tipo delegado podem representar.</span><span class="sxs-lookup"><span data-stu-id="03801-357">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="03801-358">**Exemplo 1**</span><span class="sxs-lookup"><span data-stu-id="03801-358">**Example 1**</span></span>  
  
 <span data-ttu-id="03801-359">O exemplo de código a seguir demonstra as quatro maneiras em que um representante pode ser criado usando essa sobrecarga do <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="03801-359">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-360">Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre.</span><span class="sxs-lookup"><span data-stu-id="03801-360">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-361">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-361">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-362">O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos delegados: `D1` usa uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-362">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="03801-363">Uma segunda classe chamada `Example` contém o código que cria os representantes.</span><span class="sxs-lookup"><span data-stu-id="03801-363">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-364">Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-364">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-365">Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.</span><span class="sxs-lookup"><span data-stu-id="03801-365">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="03801-366">Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-366">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-367">Uma instância deve ser passada quando o representante é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-367">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="03801-368">Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-368">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="03801-369">Por fim, um representante do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-369">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="03801-370">O método é invocado para mostrar que ele usa a cadeia de caracteres associada.</span><span class="sxs-lookup"><span data-stu-id="03801-370">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="03801-371">**Exemplo 2**</span><span class="sxs-lookup"><span data-stu-id="03801-371">**Example 2**</span></span>  
  
 <span data-ttu-id="03801-372">O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-372">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-373">Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-373">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="03801-374">O uso de outras sobrecargas que usam <xref:System.Reflection.MethodInfo> é semelhante.</span><span class="sxs-lookup"><span data-stu-id="03801-374">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="03801-375">O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-375">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="03801-376">A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="03801-376">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="03801-377">O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-377">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="03801-378">O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-378">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="03801-379">O método pode ser associado ao representante porque:</span><span class="sxs-lookup"><span data-stu-id="03801-379">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="03801-380">O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-380">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="03801-381">O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.</span><span class="sxs-lookup"><span data-stu-id="03801-381">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-382">O exemplo de código não produz nenhuma saída.</span><span class="sxs-lookup"><span data-stu-id="03801-382">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="03801-383">**Exemplo 3**</span><span class="sxs-lookup"><span data-stu-id="03801-383">**Example 3**</span></span>  
  
 <span data-ttu-id="03801-384">O exemplo de código a seguir mostra todos os métodos pode representar um tipo delegado único, usando o <xref:System.Delegate.CreateDelegate%2A> método para criar delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-384">The following code example shows all the methods a single delegate type can represent, using the <xref:System.Delegate.CreateDelegate%2A> method to create the delegates.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-385">Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre.</span><span class="sxs-lookup"><span data-stu-id="03801-385">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-386">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-386">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-387">O exemplo de código define duas classes, `C` e `F`e um tipo delegado `D` com um argumento do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-387">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="03801-388">As classes têm correspondência estático e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-388">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="03801-389">Uma classe de terceiros denominada `Example` contém o código que cria os delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-389">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-390">Delegados são criados para a instância método `M1` do tipo `C` e tipo `F`; cada um é fechada em uma instância do respectivo tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-390">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="03801-391">Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada e do argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-391">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="03801-392">Um delegado é criado para o método `M2` do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-392">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="03801-393">Este é um delegado de instância aberto, em que o argumento do delegado representa o primeiro argumento oculto no método de instância.</span><span class="sxs-lookup"><span data-stu-id="03801-393">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="03801-394">O método não tem outros argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-394">The method has no other arguments.</span></span> <span data-ttu-id="03801-395">Ele é chamado como se fosse um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-395">It is called as if it were a static method.</span></span>  
  
-   <span data-ttu-id="03801-396">Delegados são criados para o método estático `M3` do tipo `C` e tipo `F`; esses são abertos delegados estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-396">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="03801-397">Por fim, os delegados são criados para o método estático `M4` do tipo `C` e tipo `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, os delegados são fechada sobre seus argumentos primeiro .</span><span class="sxs-lookup"><span data-stu-id="03801-397">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="03801-398">Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada e do argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-398">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-399">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-399">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-400">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-400">-or-</span>
          </span>
          <span data-ttu-id="03801-401">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-401">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-402">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-402">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-403">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-403">-or-</span>
          </span>
          <span data-ttu-id="03801-404">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-404">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-405">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-405">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-406">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-406">-or-</span>
          </span>
          <span data-ttu-id="03801-407">
            <paramref name="method" /> não pode ser associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-407">
              <paramref name="method" /> cannot be bound.</span>
          </span>
          <span data-ttu-id="03801-408">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-408">-or-</span>
          </span>
          <span data-ttu-id="03801-409">
            <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-409">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="03801-410">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-410">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-411">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-411">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-412">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-412">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-413">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-413">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-414">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-414">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-415">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-415">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-416">A instância de classe na qual <c>method</c> é invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-416">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-417">O nome do método de instância que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-417">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-418">Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-418">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-419">Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-419">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-420">Esse método cria delegados para a instância somente métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-420">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="03801-421">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-421">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="03801-422">Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-422">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-423">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-423">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-424">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-424">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-425">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-425">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-426">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-426">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-427">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-427">-or-</span>
          </span>
          <span data-ttu-id="03801-428">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-428">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-429">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-429">-or-</span>
          </span>
          <span data-ttu-id="03801-430">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-430">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-431">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-431">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-432">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-432">-or-</span>
          </span>
          <span data-ttu-id="03801-433">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-433">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-434">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-434">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-435">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-435">-or-</span>
          </span>
          <span data-ttu-id="03801-436">
            <paramref name="method" /> não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-436">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="03801-437">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-437">-or-</span>
          </span>
          <span data-ttu-id="03801-438">O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-438">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-439">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-439">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-440">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-440">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-441">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-441">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-442">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-442">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-443">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-443">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-444">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-444">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="03801-445">
            <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-445">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-446">Cria um delegado do tipo especificado para representar o método estático especificado, com o comportamento em falhas especificado a ser associado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-446">Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-447">Um delegado do tipo especificado para representar o método estático especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-447">A delegate of the specified type to represent the specified static method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-448">Essa sobrecarga de método pode criar delegados de método estático open e abrir delegados de método de instância — ou seja, delegados que expõem o primeiro argumento oculto da instância métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-448">This method overload can create open static method delegates and open instance method delegates — that is, delegates that expose the hidden first argument of instance methods.</span></span> <span data-ttu-id="03801-449">Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método, que permite que você crie todas as combinações de delegates abertos ou fechados para a instância ou métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-449">For a detailed explanation, see the more general <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload, which allows you to create all combinations of open or closed delegates for instance or static methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-450">Essa sobrecarga de método deve ser usada quando o delegado não está fechado em seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.</span><span class="sxs-lookup"><span data-stu-id="03801-450">This method overload should be used when the delegate is not closed over its first argument, because it is somewhat faster in that case.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-451">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-451">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-452">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-452">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-453">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-453">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="03801-454">Tipos de parâmetro compatíveis e tipo de retorno</span><span class="sxs-lookup"><span data-stu-id="03801-454">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="03801-455">Os tipos de parâmetro e tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-455">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-456">Na versão 1.0 e 1.1 do .NET Framework, os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-456">In the .NET Framework version 1.0 and 1.1, the types must match exactly.</span></span>  
  
 <span data-ttu-id="03801-457">Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.</span><span class="sxs-lookup"><span data-stu-id="03801-457">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="03801-458">Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-458">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-459">Por exemplo, um delegado com um parâmetro de tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro de tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="03801-459">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-460">Esta seção contém dois exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="03801-460">This section contains two code examples.</span></span> <span data-ttu-id="03801-461">O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-461">The first example demonstrates the two kinds of delegates that can be created with this method overload: open over an instance method and open over a static method.</span></span>  
  
 <span data-ttu-id="03801-462">O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-462">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="03801-463">**Exemplo 1**</span><span class="sxs-lookup"><span data-stu-id="03801-463">**Example 1**</span></span>  
  
 <span data-ttu-id="03801-464">O exemplo de código a seguir demonstra um delegado pode ser criado usando essa sobrecarga de duas maneiras de <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="03801-464">The following code example demonstrates the two ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-465">Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deseja gerar Falha ao associar, e o outro sempre gera.</span><span class="sxs-lookup"><span data-stu-id="03801-465">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify a <xref:System.Reflection.MethodInfo> but not a first argument; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-466">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-466">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-467">O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos delegados: `D1` usa uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.</span><span class="sxs-lookup"><span data-stu-id="03801-467">The example declares a class `C` with a static method `M2` and an instance method `M1`, and two delegate types: `D1` takes an instance of `C` and a string, and `D2` takes a string.</span></span>  
  
 <span data-ttu-id="03801-468">Uma segunda classe chamada `Example` contém o código que cria os representantes.</span><span class="sxs-lookup"><span data-stu-id="03801-468">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-469">Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-469">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-470">Uma instância deve ser passada quando o representante é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-470">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="03801-471">Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-471">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="03801-472">**Exemplo 2**</span><span class="sxs-lookup"><span data-stu-id="03801-472">**Example 2**</span></span>  
  
 <span data-ttu-id="03801-473">O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-473">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-474">Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-474">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="03801-475">O uso de outras sobrecargas que usam <xref:System.Reflection.MethodInfo> é semelhante.</span><span class="sxs-lookup"><span data-stu-id="03801-475">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="03801-476">O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-476">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="03801-477">A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="03801-477">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="03801-478">O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-478">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="03801-479">O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-479">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="03801-480">O método pode ser associado ao representante porque:</span><span class="sxs-lookup"><span data-stu-id="03801-480">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="03801-481">O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-481">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="03801-482">O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.</span><span class="sxs-lookup"><span data-stu-id="03801-482">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-483">O exemplo de código não produz nenhuma saída.</span><span class="sxs-lookup"><span data-stu-id="03801-483">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-484">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-484">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-485">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-485">-or-</span>
          </span>
          <span data-ttu-id="03801-486">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-486">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-487">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-487">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-488">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-488">-or-</span>
          </span>
          <span data-ttu-id="03801-489">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-489">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-490">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-490">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-491">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-491">-or-</span>
          </span>
          <span data-ttu-id="03801-492">
            <paramref name="method" /> não pode ser associado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-492">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="03801-493">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-493">-or-</span>
          </span>
          <span data-ttu-id="03801-494">
            <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-494">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="03801-495">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-495">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-496">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-496">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-497">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-497">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-498">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-498">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-499">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-499">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-500">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-500">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-501">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-501">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-502">O nome do método estático que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-502">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-503">Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-503">Creates a delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-504">Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-504">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-505">Esse método cria delegados para apenas métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-505">This method creates delegates for static methods only.</span></span> <span data-ttu-id="03801-506">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-506">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="03801-507">Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-507">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `false` for `ignoreCase` and `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-508">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-508">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-509">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-509">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-510">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-510">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-511">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-511">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-512">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-512">-or-</span>
          </span>
          <span data-ttu-id="03801-513">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-513">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-514">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-514">-or-</span>
          </span>
          <span data-ttu-id="03801-515">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-515">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-516">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-516">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-517">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-517">-or-</span>
          </span>
          <span data-ttu-id="03801-518">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-518">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-519">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-519">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-520">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-520">-or-</span>
          </span>
          <span data-ttu-id="03801-521">
            <paramref name="target" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-521">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-522">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-522">-or-</span>
          </span>
          <span data-ttu-id="03801-523">
            <paramref name="target" /> é um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-523">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="03801-524">Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-524">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="03801-525">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-525">-or-</span>
          </span>
          <span data-ttu-id="03801-526">O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-526">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="03801-527">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-527">-or-</span>
          </span>
          <span data-ttu-id="03801-528">
            <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-528">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-529">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-529">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-530">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-530">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-531">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-532">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-533">Um <see cref="T:System.Type" /> que representa o tipo de delegado a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-533">A <see cref="T:System.Type" /> representing the type of delegate to create.</span>
          </span>
        </param>
        <param name="firstArgument">
          <span data-ttu-id="03801-534">Um <see cref="T:System.Object" /> que é o primeiro argumento do método que o delegado representa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-534">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents.</span>
          </span>
          <span data-ttu-id="03801-535">Por exemplo, para métodos, ele deve ser compatível com o tipo de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-535">For instance methods, it must be compatible with the instance type.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-536">O <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático ou de instância que o representante deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-536">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="03801-537">
            <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-537">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-538">Cria um delegado do tipo especificado que representa o método de instância ou estático especificado, com o primeiro argumento especificado e o comportamento especificado na falha para associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-538">Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-539">Um delegado do tipo especificado que representa o método de instância ou estático especificado ou <see langword="null" /> se <paramref name="throwOnBindFailure" /> é <see langword="false" /> e o delegado não pode ser associado a <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-539">A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-540">Essa sobrecarga de método e o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, que sempre gera Falha ao associar, fornecem a maneira mais flexível para criar delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-540">This method overload and the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> method overload, which always throws on failure to bind, provide the most flexible way to create delegates.</span></span> <span data-ttu-id="03801-541">Você pode usá-los para criar delegados para estáticas ou métodos de instância, com ou sem um primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-541">You can use them to create delegates for either static or instance methods, with or without a first argument.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-542">Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga do método para melhorar o desempenho.</span><span class="sxs-lookup"><span data-stu-id="03801-542">If you do not supply a first argument, use the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload for better performance.</span></span>  
  
 <span data-ttu-id="03801-543">O tipo de delegado e o método devem ter tipos de retorno compatíveis.</span><span class="sxs-lookup"><span data-stu-id="03801-543">The delegate type and the method must have compatible return types.</span></span> <span data-ttu-id="03801-544">Ou seja, o tipo de retorno de `method` deve ser atribuível ao tipo de retorno de `type`.</span><span class="sxs-lookup"><span data-stu-id="03801-544">That is, the return type of `method` must be assignable to the return type of `type`.</span></span>  
  
 <span data-ttu-id="03801-545">Se `firstArgument` é fornecido, ele é passado para `method` toda vez que o delegado é invocado; `firstArgument` deve ser associado ao delegado, e o representante deve ser fechada em seu primeiro argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-545">If `firstArgument` is supplied, it is passed to `method` every time the delegate is invoked; `firstArgument` is said to be bound to the delegate, and the delegate is said to be closed over its first argument.</span></span> <span data-ttu-id="03801-546">Se `method` é `static` (`Shared` no Visual Basic), o argumento fornecida ao invocar o delegado de lista inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para o parâmetro de instância oculta (representado por `this` em c#, ou por `Me` no Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="03801-546">If `method` is `static` (`Shared` in Visual Basic), the argument list supplied when invoking the delegate includes all parameters except the first; if `method` is an instance method, then `firstArgument` is passed to the hidden instance parameter (represented by `this` in C#, or by `Me` in Visual Basic).</span></span>  
  
 <span data-ttu-id="03801-547">Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com o tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-547">If `firstArgument` is supplied, the first parameter of `method` must be a reference type, and `firstArgument` must be compatible with that type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="03801-548">Se `method` é `static` (`Shared` no Visual Basic) e o primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="03801-548">If `method` is `static` (`Shared` in Visual Basic) and its first parameter is of type <xref:System.Object> or <xref:System.ValueType>, then `firstArgument` can be a value type.</span></span> <span data-ttu-id="03801-549">Nesse caso `firstArgument` é convertido automaticamente.</span><span class="sxs-lookup"><span data-stu-id="03801-549">In this case `firstArgument` is automatically boxed.</span></span> <span data-ttu-id="03801-550">Conversão automática não ocorre para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.</span><span class="sxs-lookup"><span data-stu-id="03801-550">Automatic boxing does not occur for any other arguments, as it would in a C# or Visual Basic function call.</span></span>  
  
 <span data-ttu-id="03801-551">Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo delegado `type` e `method`:</span><span class="sxs-lookup"><span data-stu-id="03801-551">If `firstArgument` is a null reference and `method` is an instance method, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="03801-552">Se a assinatura de `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o representante deve representar um método de instância aberta.</span><span class="sxs-lookup"><span data-stu-id="03801-552">If the signature of `type` explicitly includes the hidden first parameter of `method`, the delegate is said to represent an open instance method.</span></span> <span data-ttu-id="03801-553">Quando o representante é chamado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta de `method`.</span><span class="sxs-lookup"><span data-stu-id="03801-553">When the delegate is invoked, the first argument in the argument list is passed to the hidden instance parameter of `method`.</span></span>  
  
-   <span data-ttu-id="03801-554">Se as assinaturas de `method` e `type` correspondem (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o representante deve ser fechada por uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-554">If the signatures of `method` and `type` match (that is, all parameter types are compatible), then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="03801-555">Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.</span><span class="sxs-lookup"><span data-stu-id="03801-555">Invoking the delegate is like calling an instance method on a null instance, which is not a particularly useful thing to do.</span></span>  
  
 <span data-ttu-id="03801-556">Se `firstArgument` é uma referência nula e `method` é estático, o resultado depende das assinaturas do tipo delegado `type` e `method`:</span><span class="sxs-lookup"><span data-stu-id="03801-556">If `firstArgument` is a null reference and `method` is static, the result depends on the signatures of the delegate type `type` and of `method`:</span></span>  
  
-   <span data-ttu-id="03801-557">Se a assinatura de `method` e `type` correspondem (ou seja, todos os tipos de parâmetro são compatíveis), o representante deve representar um método estático aberto.</span><span class="sxs-lookup"><span data-stu-id="03801-557">If the signature of `method` and `type` match (that is, all parameter types are compatible), the delegate is said to represent an open static method.</span></span> <span data-ttu-id="03801-558">Este é o caso mais comum para métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-558">This is the most common case for static methods.</span></span> <span data-ttu-id="03801-559">Nesse caso, você pode obter um pouco melhor desempenho usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-559">In this case, you can get slightly better performance by using the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> method overload.</span></span>  
  
-   <span data-ttu-id="03801-560">Se a assinatura de `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis, o representante deve ser fechada por uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-560">If the signature of `type` begins with the second parameter of `method` and the rest of the parameter types are compatible, then the delegate is said to be closed over a null reference.</span></span> <span data-ttu-id="03801-561">Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.</span><span class="sxs-lookup"><span data-stu-id="03801-561">When the delegate is invoked, a null reference is passed to the first parameter of `method`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-562">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-562">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-563">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-563">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-564">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-564">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
## <a name="compatible-parameter-types-and-return-type"></a><span data-ttu-id="03801-565">Tipos de parâmetro compatíveis e tipo de retorno</span><span class="sxs-lookup"><span data-stu-id="03801-565">Compatible Parameter Types and Return Type</span></span>  
 <span data-ttu-id="03801-566">Os tipos de parâmetro e tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-566">The parameter types and return type of a delegate must be compatible with the parameter types and return type of the method the delegate represents; the types do not have to match exactly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-567">No .NET Framework versão 1.0 e 1.1 os tipos devem corresponder exatamente.</span><span class="sxs-lookup"><span data-stu-id="03801-567">In the .NET Framework version 1.0 and 1.1 the types must match exactly.</span></span>  
  
 <span data-ttu-id="03801-568">Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.</span><span class="sxs-lookup"><span data-stu-id="03801-568">A parameter of a delegate is compatible with the corresponding parameter of a method if the type of the delegate parameter is more restrictive than the type of the method parameter, because this guarantees that an argument passed to the delegate can be passed safely to the method.</span></span>  
  
 <span data-ttu-id="03801-569">Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-569">Similarly, the return type of a delegate is compatible with the return type of a method if the return type of the method is more restrictive than the return type of the delegate, because this guarantees that the return value of the method can be cast safely to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-570">Por exemplo, um delegado com um parâmetro de tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro de tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.</span><span class="sxs-lookup"><span data-stu-id="03801-570">For example, a delegate with a parameter of type <xref:System.Collections.Hashtable> and a return type of <xref:System.Object> can represent a method with a parameter of type <xref:System.Object> and a return value of type <xref:System.Collections.Hashtable>.</span></span>  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a><span data-ttu-id="03801-571">Determinando os métodos que um delegado pode representar</span><span class="sxs-lookup"><span data-stu-id="03801-571">Determining the Methods a Delegate Can Represent</span></span>  
 <span data-ttu-id="03801-572">Outra forma útil considerar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer dado delegado pode representar quatro diferentes combinações de assinatura de método e o tipo de método (estático versus instância).</span><span class="sxs-lookup"><span data-stu-id="03801-572">Another useful way to think of the flexibility provided by this overload of <xref:System.Delegate.CreateDelegate%2A> is that any given delegate can represent four different combinations of method signature and method kind (static versus instance).</span></span> <span data-ttu-id="03801-573">Considere a possibilidade de um tipo de delegado `D` com um argumento do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-573">Consider a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="03801-574">A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ela deve corresponder em todos os casos:</span><span class="sxs-lookup"><span data-stu-id="03801-574">The following describes the methods `D` can represent, ignoring the return type since it must match in all cases:</span></span>  
  
-   <span data-ttu-id="03801-575">`D` pode representar qualquer método de instância que tenha exatamente um argumento de tipo `C`, independentemente de qual pertence o método de instância de tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-575">`D` can represent any instance method that has exactly one argument of type `C`, regardless of what type the instance method belongs to.</span></span> <span data-ttu-id="03801-576">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o representante resultante deve ser fechada por essa instância.</span><span class="sxs-lookup"><span data-stu-id="03801-576">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of the type `method` belongs to, and the resulting delegate is said to be closed over that instance.</span></span> <span data-ttu-id="03801-577">(Facilmente, `D` também pode ser fechada por uma referência nula se `firstArgument` é `null`.)</span><span class="sxs-lookup"><span data-stu-id="03801-577">(Trivially, `D` can also be closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
-   <span data-ttu-id="03801-578">`D` pode representar um método de instância `C` que não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-578">`D` can represent an instance method of `C` that has no arguments.</span></span> <span data-ttu-id="03801-579">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-579">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="03801-580">O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-580">The resulting delegate represents an open instance method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="03801-581">`D` pode representar um método estático que usa um argumento de tipo `C`, e que o método pode pertencer a qualquer tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-581">`D` can represent a static method that takes one argument of type `C`, and that method can belong to any type.</span></span> <span data-ttu-id="03801-582">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula.</span><span class="sxs-lookup"><span data-stu-id="03801-582">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is a null reference.</span></span> <span data-ttu-id="03801-583">O delegado resultante representa um método estático open e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-583">The resulting delegate represents an open static method, and an instance of `C` must be supplied each time it is invoked.</span></span>  
  
-   <span data-ttu-id="03801-584">`D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-584">`D` can represent a static method that belongs to type `F` and has two arguments, of type `F` and type `C`.</span></span> <span data-ttu-id="03801-585">Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`.</span><span class="sxs-lookup"><span data-stu-id="03801-585">When <xref:System.Delegate.CreateDelegate%2A> is called, `firstArgument` is an instance of `F`.</span></span> <span data-ttu-id="03801-586">O delegado resultante representa um método estático que é fechado por aquela instância do `F`.</span><span class="sxs-lookup"><span data-stu-id="03801-586">The resulting delegate represents a static method that is closed over that instance of `F`.</span></span> <span data-ttu-id="03801-587">Observe que no caso onde `F` e `C` são do mesmo tipo, o método estático tem dois argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-587">Note that in the case where `F` and `C` are the same type, the static method has two arguments of that type.</span></span> <span data-ttu-id="03801-588">(Nesse caso, `D` estiver fechado por uma referência nula se `firstArgument` é `null`.)</span><span class="sxs-lookup"><span data-stu-id="03801-588">(In this case, `D` is closed over a null reference if `firstArgument` is `null`.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-589">Esta seção contém três exemplos de código.</span><span class="sxs-lookup"><span data-stu-id="03801-589">This section contains three code examples.</span></span> <span data-ttu-id="03801-590">O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado por um método de instância, abra um método de instância, abra um método estático e fechado por um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-590">The first example demonstrates the four kinds of delegates that can be created: closed over an instance method, open over an instance method, open over a static method, and closed over a static method.</span></span>  
  
 <span data-ttu-id="03801-591">O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-591">The second code example demonstrates compatible parameter types and return types.</span></span>  
  
 <span data-ttu-id="03801-592">O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos de tipo delegado podem representar.</span><span class="sxs-lookup"><span data-stu-id="03801-592">The third code example defines a single delegate type, and shows all the methods that delegate type can represent.</span></span>  
  
 <span data-ttu-id="03801-593">**Exemplo 1**</span><span class="sxs-lookup"><span data-stu-id="03801-593">**Example 1**</span></span>  
  
 <span data-ttu-id="03801-594">O exemplo de código a seguir demonstra as quatro maneiras em que um representante pode ser criado usando essa sobrecarga do <xref:System.Delegate.CreateDelegate%2A> método.</span><span class="sxs-lookup"><span data-stu-id="03801-594">The following code example demonstrates the four ways a delegate can be created using this overload of the <xref:System.Delegate.CreateDelegate%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-595">Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre.</span><span class="sxs-lookup"><span data-stu-id="03801-595">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-596">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-596">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-597">O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos delegados: `D1` usa uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-597">The example declares a class `C` with a static method `M2` and an instance method `M1`, and three delegate types: `D1` takes an instance of `C` and a string, `D2` takes a string, and `D3` has no arguments.</span></span>  
  
 <span data-ttu-id="03801-598">Uma segunda classe chamada `Example` contém o código que cria os representantes.</span><span class="sxs-lookup"><span data-stu-id="03801-598">A second class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-599">Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-599">A delegate of type `D2`, closed over an instance of `C`, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-600">Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.</span><span class="sxs-lookup"><span data-stu-id="03801-600">It is invoked with different strings, to show that the bound instance of `C` is always used.</span></span>  
  
-   <span data-ttu-id="03801-601">Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`.</span><span class="sxs-lookup"><span data-stu-id="03801-601">A delegate of type `D1`, representing an open instance method, is created for the instance method `M1`.</span></span> <span data-ttu-id="03801-602">Uma instância deve ser passada quando o representante é invocado.</span><span class="sxs-lookup"><span data-stu-id="03801-602">An instance must be passed when the delegate is invoked.</span></span>  
  
-   <span data-ttu-id="03801-603">Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-603">A delegate of type `D2`, representing an open static method, is created for the static method `M2`.</span></span>  
  
-   <span data-ttu-id="03801-604">Por fim, um representante do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`.</span><span class="sxs-lookup"><span data-stu-id="03801-604">Finally, a delegate of type `D3`, closed over a string, is created for the static method `M2`.</span></span> <span data-ttu-id="03801-605">O método é invocado para mostrar que ele usa a cadeia de caracteres associada.</span><span class="sxs-lookup"><span data-stu-id="03801-605">The method is invoked to show that it uses the bound string.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 <span data-ttu-id="03801-606">**Exemplo 2**</span><span class="sxs-lookup"><span data-stu-id="03801-606">**Example 2**</span></span>  
  
 <span data-ttu-id="03801-607">O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.</span><span class="sxs-lookup"><span data-stu-id="03801-607">The following code example demonstrates compatibility of parameter types and return types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-608">Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga do método.</span><span class="sxs-lookup"><span data-stu-id="03801-608">This code example uses the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> method overload.</span></span> <span data-ttu-id="03801-609">O uso de outras sobrecargas que usam <xref:System.Reflection.MethodInfo> é semelhante.</span><span class="sxs-lookup"><span data-stu-id="03801-609">The use of other overloads that take <xref:System.Reflection.MethodInfo> is similar.</span></span>  
  
 <span data-ttu-id="03801-610">O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-610">The code example defines a base class named `Base` and a class named `Derived` that derives from `Base`.</span></span> <span data-ttu-id="03801-611">A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`.</span><span class="sxs-lookup"><span data-stu-id="03801-611">The derived class has a `static` (`Shared` in Visual Basic) method named `MyMethod` with one parameter of type `Base` and a return type of `Derived`.</span></span> <span data-ttu-id="03801-612">O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.</span><span class="sxs-lookup"><span data-stu-id="03801-612">The code example also defines a delegate named `Example` that has one parameter of type `Derived` and a return type of `Base`.</span></span>  
  
 <span data-ttu-id="03801-613">O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-613">The code example demonstrates that the delegate named `Example` can be used to represent the method `MyMethod`.</span></span> <span data-ttu-id="03801-614">O método pode ser associado ao representante porque:</span><span class="sxs-lookup"><span data-stu-id="03801-614">The method can be bound to the delegate because:</span></span>  
  
-   <span data-ttu-id="03801-615">O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.</span><span class="sxs-lookup"><span data-stu-id="03801-615">The parameter type of the delegate (`Derived`) is more restrictive than the parameter type of `MyMethod` (`Base`), so that it is always safe to pass the argument of the delegate to `MyMethod`.</span></span>  
  
-   <span data-ttu-id="03801-616">O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.</span><span class="sxs-lookup"><span data-stu-id="03801-616">The return type of `MyMethod` (`Derived`) is more restrictive than the parameter type of the delegate (`Base`), so that it is always safe to cast the return type of the method to the return type of the delegate.</span></span>  
  
 <span data-ttu-id="03801-617">O exemplo de código não produz nenhuma saída.</span><span class="sxs-lookup"><span data-stu-id="03801-617">The code example produces no output.</span></span>  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 <span data-ttu-id="03801-618">**Exemplo 3**</span><span class="sxs-lookup"><span data-stu-id="03801-618">**Example 3**</span></span>  
  
 <span data-ttu-id="03801-619">O exemplo de código a seguir mostra todos os métodos que pode representar um tipo delegado único.</span><span class="sxs-lookup"><span data-stu-id="03801-619">The following code example shows all the methods a single delegate type can represent.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-620">Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre.</span><span class="sxs-lookup"><span data-stu-id="03801-620">There are two overloads of the <xref:System.Delegate.CreateDelegate%2A> method that specify `firstArgument` and a <xref:System.Reflection.MethodInfo>; their functionality is the same except that one allows you to specify whether to throw on failure to bind, and the other always throws.</span></span> <span data-ttu-id="03801-621">Este exemplo de código usa ambas as sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="03801-621">This code example uses both overloads.</span></span>  
  
 <span data-ttu-id="03801-622">O exemplo de código define duas classes, `C` e `F`e um tipo delegado `D` com um argumento do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-622">The code example defines two classes, `C` and `F`, and a delegate type `D` with one argument of type `C`.</span></span> <span data-ttu-id="03801-623">As classes têm correspondência estático e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não possui argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-623">The classes have matching static and instance methods `M1`, `M3`, and `M4`, and class `C` also has an instance method `M2` that has no arguments.</span></span>  
  
 <span data-ttu-id="03801-624">Uma classe de terceiros denominada `Example` contém o código que cria os delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-624">A third class named `Example` contains the code that creates the delegates.</span></span>  
  
-   <span data-ttu-id="03801-625">Delegados são criados para a instância método `M1` do tipo `C` e tipo `F`; cada um é fechada em uma instância do respectivo tipo.</span><span class="sxs-lookup"><span data-stu-id="03801-625">Delegates are created for instance method `M1` of type `C` and type `F`; each is closed over an instance of the respective type.</span></span> <span data-ttu-id="03801-626">Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada e do argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-626">Method `M1` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
-   <span data-ttu-id="03801-627">Um delegado é criado para o método `M2` do tipo `C`.</span><span class="sxs-lookup"><span data-stu-id="03801-627">A delegate is created for method `M2` of type `C`.</span></span> <span data-ttu-id="03801-628">Este é um delegado de instância aberto, em que o argumento do delegado representa o primeiro argumento oculto no método de instância.</span><span class="sxs-lookup"><span data-stu-id="03801-628">This is an open instance delegate, in which the argument of the delegate represents the hidden first argument on the instance method.</span></span> <span data-ttu-id="03801-629">O método não tem outros argumentos.</span><span class="sxs-lookup"><span data-stu-id="03801-629">The method has no other arguments.</span></span>  
  
-   <span data-ttu-id="03801-630">Delegados são criados para o método estático `M3` do tipo `C` e tipo `F`; esses são abertos delegados estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-630">Delegates are created for static method `M3` of type `C` and type `F`; these are open static delegates.</span></span>  
  
-   <span data-ttu-id="03801-631">Por fim, os delegados são criados para o método estático `M4` do tipo `C` e tipo `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, os delegados são fechada sobre seus argumentos primeiro .</span><span class="sxs-lookup"><span data-stu-id="03801-631">Finally, delegates are created for static method `M4` of type `C` and type `F`; each method has the declaring type as its first argument, and an instance of the type is supplied, so the delegates are closed over their first arguments.</span></span> <span data-ttu-id="03801-632">Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada e do argumento.</span><span class="sxs-lookup"><span data-stu-id="03801-632">Method `M4` of type `C` displays the `ID` properties of the bound instance and of the argument.</span></span>  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-633">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-633">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-634">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-634">-or-</span>
          </span>
          <span data-ttu-id="03801-635">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-635">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-636">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-636">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-637">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-637">-or-</span>
          </span>
          <span data-ttu-id="03801-638">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-638">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-639">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-639">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-640">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-640">-or-</span>
          </span>
          <span data-ttu-id="03801-641">
            <paramref name="method" /> não pode ser associado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-641">
              <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="03801-642">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-642">-or-</span>
          </span>
          <span data-ttu-id="03801-643">
            <paramref name="method" /> não é um <see langword="RuntimeMethodInfo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-643">
              <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />.</span>
          </span>
          <span data-ttu-id="03801-644">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-644">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-645">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-645">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-646">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-646">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-647">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-647">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-648">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-648">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-649">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-649">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-650">A instância de classe na qual <c>method</c> é invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-650">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-651">O nome do método de instância que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-651">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="03801-652">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-652">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-653">Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-653">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-654">Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-654">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-655">Esse método cria delegados para a instância somente métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-655">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="03801-656">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-656">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="03801-657">Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-657">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-658">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-658">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-659">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-659">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-660">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-660">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-661">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-661">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-662">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-662">-or-</span>
          </span>
          <span data-ttu-id="03801-663">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-663">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-664">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-664">-or-</span>
          </span>
          <span data-ttu-id="03801-665">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-665">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-666">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-666">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-667">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-667">-or-</span>
          </span>
          <span data-ttu-id="03801-668">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-668">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-669">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-669">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-670">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-670">-or-</span>
          </span>
          <span data-ttu-id="03801-671">
            <paramref name="method" /> não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-671">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="03801-672">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-672">-or-</span>
          </span>
          <span data-ttu-id="03801-673">O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-673">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-674">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-674">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-675">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-675">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-676">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-676">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-677">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-677">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-678">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-678">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-679">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-679">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-680">O nome do método estático que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-680">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="03801-681">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-681">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-682">Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-682">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-683">Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-683">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-684">Esse método cria delegados para apenas métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-684">This method creates delegates for static methods only.</span></span> <span data-ttu-id="03801-685">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-685">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="03801-686">Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.</span><span class="sxs-lookup"><span data-stu-id="03801-686">This method overload is equivalent to calling the <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload, specifying `true` for `throwOnBindFailure`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-687">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-687">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-688">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-688">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-689">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-689">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-690">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-690">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-691">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-691">-or-</span>
          </span>
          <span data-ttu-id="03801-692">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-692">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-693">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-693">-or-</span>
          </span>
          <span data-ttu-id="03801-694">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-694">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-695">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-695">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-696">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-696">-or-</span>
          </span>
          <span data-ttu-id="03801-697">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-697">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-698">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-698">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-699">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-699">-or-</span>
          </span>
          <span data-ttu-id="03801-700">
            <paramref name="target" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-700">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-701">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-701">-or-</span>
          </span>
          <span data-ttu-id="03801-702">
            <paramref name="target" /> é um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-702">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="03801-703">Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-703">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="03801-704">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-704">-or-</span>
          </span>
          <span data-ttu-id="03801-705">O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-705">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="03801-706">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-706">-or-</span>
          </span>
          <span data-ttu-id="03801-707">O <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-707">
              <paramref name="method" /> cannot be bound, for example because it cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-708">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-708">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-709">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-709">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-710">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-710">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-711">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-711">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-712">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-712">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-713">A instância de classe na qual <c>method</c> é invocado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-713">The class instance on which <c>method</c> is invoked.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-714">O nome do método de instância que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-714">The name of the instance method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="03801-715">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-715">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="03801-716">
            <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-716">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-717">Cria um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada e o comportamento especificado na falha de associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-717">Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-718">Um delegado do tipo especificado que representa o método de instância especificado a ser invocado na instância da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-718">A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-719">Esse método cria delegados para a instância somente métodos.</span><span class="sxs-lookup"><span data-stu-id="03801-719">This method creates delegates for instance methods only.</span></span> <span data-ttu-id="03801-720">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-720">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-721">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-721">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-722">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-722">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-723">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-723">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-724">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-724">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-725">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-725">-or-</span>
          </span>
          <span data-ttu-id="03801-726">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-726">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-727">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-727">-or-</span>
          </span>
          <span data-ttu-id="03801-728">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-728">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-729">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-729">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-730">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-730">-or-</span>
          </span>
          <span data-ttu-id="03801-731">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-731">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-732">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-732">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-733">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-733">-or-</span>
          </span>
          <span data-ttu-id="03801-734">
            <paramref name="method" /> não é um método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-734">
              <paramref name="method" /> is not an instance method.</span>
          </span>
          <span data-ttu-id="03801-735">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-735">-or-</span>
          </span>
          <span data-ttu-id="03801-736">
            <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-736">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-737">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-737">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-738">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-738">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-739">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-739">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-740">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-740">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="03801-741">O <see cref="T:System.Type" /> do representante a ser criado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-741">The <see cref="T:System.Type" /> of delegate to create.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="03801-742">O <see cref="T:System.Type" /> que representa a classe que implementa <c>method</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-742">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</span>
          </span>
        </param>
        <param name="method">
          <span data-ttu-id="03801-743">O nome do método estático que o delegado deve representar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-743">The name of the static method that the delegate is to represent.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="03801-744">Um booliano indicando se é necessário ignorar as maiúsculas durante a comparação do nome do método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-744">A Boolean indicating whether to ignore the case when comparing the name of the method.</span>
          </span>
        </param>
        <param name="throwOnBindFailure">
          <span data-ttu-id="03801-745">
            <see langword="true" /> para lançar uma exceção caso <c>method</c> não possa ser associado; do contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-745">
              <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-746">Cria um delegado do tipo especificado que representa o método estático especificado da classe especificada, com a diferenciação de maiúsculas e minúsculas especificada e o comportamento especificado na falha de associação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-746">Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-747">Um delegado do tipo especificado que representa o método especificado estático da classe especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-747">A delegate of the specified type that represents the specified static method of the specified class.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-748">Esse método cria delegados para apenas métodos estáticos.</span><span class="sxs-lookup"><span data-stu-id="03801-748">This method creates delegates for static methods only.</span></span> <span data-ttu-id="03801-749">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-749">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="03801-750">Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele.</span><span class="sxs-lookup"><span data-stu-id="03801-750">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public methods if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public methods is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="03801-751">(Consulte [considerações de segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="03801-751">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="03801-752">Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.</span><span class="sxs-lookup"><span data-stu-id="03801-752">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="03801-753">
            <paramref name="type" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-753">
              <paramref name="type" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-754">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-754">-or-</span>
          </span>
          <span data-ttu-id="03801-755">
            <paramref name="target" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-755">
              <paramref name="target" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-756">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-756">-or-</span>
          </span>
          <span data-ttu-id="03801-757">
            <paramref name="method" /> é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-757">
              <paramref name="method" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-758">
            <paramref name="type" /> não herda <see cref="T:System.MulticastDelegate" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-758">
              <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.</span>
          </span>
          <span data-ttu-id="03801-759">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-759">-or-</span>
          </span>
          <span data-ttu-id="03801-760">
            <paramref name="type" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-760">
              <paramref name="type" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-761">Consulte [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858) (Tipos de tempo de execução na reflexão).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-761">See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</span>
          </span>
          <span data-ttu-id="03801-762">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-762">-or-</span>
          </span>
          <span data-ttu-id="03801-763">
            <paramref name="target" /> não é um <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-763">
              <paramref name="target" /> is not a <see langword="RuntimeType" />.</span>
          </span>
          <span data-ttu-id="03801-764">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-764">-or-</span>
          </span>
          <span data-ttu-id="03801-765">
            <paramref name="target" /> é um tipo genérico aberto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-765">
              <paramref name="target" /> is an open generic type.</span>
          </span>
          <span data-ttu-id="03801-766">Ou seja, sua propriedade <see cref="P:System.Type.ContainsGenericParameters" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-766">That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.</span>
          </span>
          <span data-ttu-id="03801-767">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-767">-or-</span>
          </span>
          <span data-ttu-id="03801-768">O <paramref name="method" /> não é um método <see langword="static" /> (método <see langword="Shared" /> no Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-768">
              <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).</span>
          </span>
          <span data-ttu-id="03801-769">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-769">-or-</span>
          </span>
          <span data-ttu-id="03801-770">
            <paramref name="method" /> não pode ser associado, por exemplo, porque não foi encontrado e <paramref name="throwOnBindFailure" /> é <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-770">
              <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="03801-771">O método <see langword="Invoke" /> de <paramref name="type" /> não foi encontrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-771">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="03801-772">O chamador não tem as permissões necessárias para acessar <paramref name="method" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-772">The caller does not have the permissions necessary to access <paramref name="method" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-773">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-773">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-774">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-774">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</span>
          </span>
        </permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="03801-775">Uma matriz de objetos que são os argumentos a serem passados para o método representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-775">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="03801-776">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-776">-or-</span>
          </span>
          <span data-ttu-id="03801-777">
            <see langword="null" /> se o método representado pelo delegado atual não exigir argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-777">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-778">Invoca dinamicamente (associação tardia) o método representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-778">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-779">O objeto retornado pelo método representado pelo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-779">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-780">Este método chama o <xref:System.Delegate.DynamicInvokeImpl%2A> método.</span><span class="sxs-lookup"><span data-stu-id="03801-780">This method calls the <xref:System.Delegate.DynamicInvokeImpl%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-781">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-781">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="03801-782">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-782">-or-</span>
          </span>
          <span data-ttu-id="03801-783">O número, a ordem ou o tipo de parâmetros listados no <paramref name="args" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-783">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-784">O método representado pelo delegado é invocado em um objeto ou uma classe que não dá suporte a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-784">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="03801-785">O método representado pelo delegado é um método de instância e o objeto de destino é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-785">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-786">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-786">-or-</span>
          </span>
          <span data-ttu-id="03801-787">Um dos métodos encapsulados gera uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-787">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-788">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-788">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-789">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-789">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="03801-790">Uma matriz de objetos que são os argumentos a serem passados para o método representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-790">An array of objects that are the arguments to pass to the method represented by the current delegate.</span>
          </span>
          <span data-ttu-id="03801-791">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-791">-or-</span>
          </span>
          <span data-ttu-id="03801-792">
            <see langword="null" /> se o método representado pelo delegado atual não exigir argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-792">
              <see langword="null" />, if the method represented by the current delegate does not require arguments.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-793">Invoca dinamicamente (associação tardia) o método representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-793">Dynamically invokes (late-bound) the method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-794">O objeto retornado pelo método representado pelo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-794">The object returned by the method represented by the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-795">Este método implementa o método <xref:System.Delegate.DynamicInvoke%2A>.</span><span class="sxs-lookup"><span data-stu-id="03801-795">This method implements the <xref:System.Delegate.DynamicInvoke%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-796">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-796">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
          <span data-ttu-id="03801-797">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-797">-or-</span>
          </span>
          <span data-ttu-id="03801-798">O número, a ordem ou o tipo de parâmetros listados no <paramref name="args" /> é inválido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-798">The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-799">O método representado pelo delegado é invocado em um objeto ou uma classe que não dá suporte a ele.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-799">The method represented by the delegate is invoked on an object or a class that does not support it.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="03801-800">O método representado pelo delegado é um método de instância e o objeto de destino é <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-800">The method represented by the delegate is an instance method and the target object is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="03801-801">- ou -</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-801">-or-</span>
          </span>
          <span data-ttu-id="03801-802">Um dos métodos encapsulados gera uma exceção.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-802">One of the encapsulated methods throws an exception.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-803">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-803">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-804">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-804">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="03801-805">O objeto a ser comparado com o delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-805">The object to compare with the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-806">Determina se o objeto especificado e o delegado atual são do mesmo tipo e compartilham os mesmos destinos, métodos e lista de invocação.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-806">Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-807">
            <see langword="true" /> se <paramref name="obj" /> e o delegado atual têm os mesmos destinos, métodos e lista de invocação; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-807">
              <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-808">Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-808">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="03801-809">No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="03801-809">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="03801-810">Os métodos e os destinos são comparados de igualdade, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="03801-810">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="03801-811">Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-811">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-812">Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-812">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-813">Caso contrário, os métodos não são considerados iguais e os destinos também são considerados não são iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-813">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="03801-814">Duas listas de invocação serão consideradas idênticas somente se eles tiverem a mesma ordem e os elementos correspondentes das duas listas de representam o mesmo método e destino.</span><span class="sxs-lookup"><span data-stu-id="03801-814">Two invocation lists are considered identical only if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-815">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-815">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-816">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-816">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-817">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-817">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="03801-818">Retorna um código hash para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-818">Returns a hash code for the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-819">Um código hash para o delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-819">A hash code for the delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-820">O valor de retorno deste método não deve ser persistido por dois motivos.</span><span class="sxs-lookup"><span data-stu-id="03801-820">The return value of this method must not be persisted for two reasons.</span></span> <span data-ttu-id="03801-821">Primeiro, a função de hash de uma classe pode ser alterada para gerar uma distribuição melhor, tornando os valores da função de hash antigo inúteis.</span><span class="sxs-lookup"><span data-stu-id="03801-821">First, the hash function of a class might be altered to generate a better distribution, rendering any values from the old hash function useless.</span></span> <span data-ttu-id="03801-822">Em segundo lugar, a implementação padrão dessa classe não garante que o mesmo valor será retornado por instâncias diferentes.</span><span class="sxs-lookup"><span data-stu-id="03801-822">Second, the default implementation of this class does not guarantee that the same value will be returned by different instances.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-823">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-823">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-824">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-824">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="03801-825">Retorna a lista de invocação do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-825">Returns the invocation list of the delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-826">Uma matriz de delegados representando a lista de invocação do delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-826">An array of delegates representing the invocation list of the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-827">Cada representante na matriz representa exatamente um método.</span><span class="sxs-lookup"><span data-stu-id="03801-827">Each delegate in the array represents exactly one method.</span></span>  
  
 <span data-ttu-id="03801-828">A ordem de delegates na matriz é a mesma ordem em que o representante atual invoca os métodos que representam os delegados.</span><span class="sxs-lookup"><span data-stu-id="03801-828">The order of the delegates in the array is the same order in which the current delegate invokes the methods that those delegates represent.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="03801-829">O exemplo a seguir atribui três métodos para um representante.</span><span class="sxs-lookup"><span data-stu-id="03801-829">The following example assigns three methods to a delegate.</span></span> <span data-ttu-id="03801-830">Depois, ele chama o <xref:System.Delegate.GetInvocationList%2A> método para obter uma contagem total dos métodos atribuído ao delegado, para executar os delegados na ordem inversa, bem como executar os métodos cujos nomes não incluem a subcadeia de caracteres "File".</span><span class="sxs-lookup"><span data-stu-id="03801-830">It then calls the  <xref:System.Delegate.GetInvocationList%2A> method to get a total count of the methods assigned to the delegate, to execute the delegates in reverse order, and to execute the methods whose name do not include the substring "File".</span></span>  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-831">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-831">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-832">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-832">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="03801-833">Obtém o método estático representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-833">Gets the static method represented by the current delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-834">Um <see cref="T:System.Reflection.MethodInfo" /> que descreve o método estático representado pelo delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-834">A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-835">Esse método se aplica somente se o delegado atual representa um método estático.</span><span class="sxs-lookup"><span data-stu-id="03801-835">This method applies only if the current delegate represents a static method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-836">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-836">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-837">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-837">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-838">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-838">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="03801-839">Sem suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-839">Not supported.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="03801-840">Sem suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-840">Not supported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-841">Sem suporte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-841">Not supported.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="03801-842">Não há suporte para o método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-842">This method is not supported.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="03801-843">Requer confiança total para o chamador imediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-843">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="03801-844">Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-844">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="03801-845">Obtém o método representado pelo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-845">Gets the method represented by the delegate.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="03801-846">Uma <see cref="T:System.Reflection.MethodInfo" /> que descreve o método representado pelo delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-846">A <see cref="T:System.Reflection.MethodInfo" /> describing the method represented by the delegate.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-847">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-847">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-848">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-848">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-849">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-849">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="03801-850">O primeiro delegado a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-850">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="03801-851">O segundo delegado a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-851">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-852">Determina se os delegados especificados são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-852">Determines whether the specified delegates are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-853">
            <see langword="true" /> se <paramref name="d1" /> for igual a <paramref name="d2" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-853">
              <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-854">Dois delegados do mesmo tipo com o mesmo destino, métodos e listas de invocação são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-854">Two delegates of the same type with the same targets, methods, and invocation lists are considered equal.</span></span>  
  
 <span data-ttu-id="03801-855">Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-855">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="03801-856">No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="03801-856">In the .NET Framework version 1.0 and 1.1, two delegates were considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="03801-857">Os métodos e os destinos são comparados de igualdade, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="03801-857">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="03801-858">Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-858">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-859">Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-859">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-860">Caso contrário, os métodos não são considerados iguais e os destinos também são considerados não são iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-860">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="03801-861">Duas listas de invocação serão consideradas idênticas se tiverem a mesma ordem e os elementos correspondentes das duas listas representarem o mesmo método e destino.</span><span class="sxs-lookup"><span data-stu-id="03801-861">Two invocation lists are considered identical if they have the same order and the corresponding elements from the two lists represent the same method and target.</span></span>  
  
 <span data-ttu-id="03801-862">O método equivalente para esse operador é <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="03801-862">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-863">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-863">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-864">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-864">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">
          <span data-ttu-id="03801-865">O primeiro delegado a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-865">The first delegate to compare.</span>
          </span>
        </param>
        <param name="d2">
          <span data-ttu-id="03801-866">O segundo delegado a ser comparado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-866">The second delegate to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-867">Determina se os delegados especificados não são iguais.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-867">Determines whether the specified delegates are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-868">
            <see langword="true" /> se <paramref name="d1" /> não for igual a <paramref name="d2" />; caso contrário, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-868">
              <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-869">Dois delegados são considerados não iguais se forem de tipos diferentes, ou ter métodos diferentes, destinos diferentes ou listas de invocação diferente.</span><span class="sxs-lookup"><span data-stu-id="03801-869">Two delegates are considered not equal if they are of different types, or have different methods, different targets, or different invocation lists.</span></span>  
  
 <span data-ttu-id="03801-870">Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-870">If the two delegates are not of the same type, they are not considered equal.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="03801-871">No .NET Framework versão 1.0 e 1.1, dois delegados são considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="03801-871">In the .NET Framework version 1.0 and 1.1, two delegates are considered equal if their targets, methods, and invocation list were equal, even if the delegates were of different types.</span></span>  
  
 <span data-ttu-id="03801-872">Os métodos e os destinos são comparados de igualdade, da seguinte maneira:</span><span class="sxs-lookup"><span data-stu-id="03801-872">The methods and targets are compared for equality as follows:</span></span>  
  
-   <span data-ttu-id="03801-873">Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-873">If the two methods being compared are both static and are the same method on the same class, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-874">Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-874">If the two methods being compared are instance methods and are the same method on the same object, the methods are considered equal and the targets are also considered equal.</span></span>  
  
-   <span data-ttu-id="03801-875">Caso contrário, os métodos não são considerados iguais e os destinos também são considerados não são iguais.</span><span class="sxs-lookup"><span data-stu-id="03801-875">Otherwise, the methods are not considered to be equal and the targets are also not considered to be equal.</span></span>  
  
 <span data-ttu-id="03801-876">Duas listas de invocação não são iguais se eles têm tamanhos diferentes, se eles são ordenados de forma diferente, ou se pelo menos um elemento de uma lista representa um método ou o destino é diferente da que é representado pelo elemento correspondente na lista de outros.</span><span class="sxs-lookup"><span data-stu-id="03801-876">Two invocation lists are not equal if they have different sizes, if they are ordered differently, or if at least one element from one list represents a method or target that is different from that represented by its corresponding element in the other list.</span></span>  
  
 <span data-ttu-id="03801-877">O método equivalente para esse operador é <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="03801-877">The equivalent method for this operator is <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-878">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-878">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-879">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-879">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="03801-880">O delegado do qual a lista de invocação de <c>value</c> será removida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-880">The delegate from which to remove the invocation list of <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="03801-881">O delegado que fornece a lista de invocação a ser removida da lista de invocação de <c>source</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-881">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-882">Remove a última ocorrência da lista de invocação de um delegado da lista de invocação de outro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-882">Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-883">Um novo delegado com uma lista de invocação formada com o uso da lista de invocação de <paramref name="source" /> e a remoção da última ocorrência da lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-883">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="03801-884">Retorna <paramref name="source" /> se <paramref name="value" /> for <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não for encontrada na lista de invocação de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-884">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="03801-885">Retorna uma referência nula se a lista de invocação de <paramref name="value" /> for igual à lista de invocação de <paramref name="source" /> ou se <paramref name="source" /> for uma referência nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-885">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-886">Se a lista de invocação de `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` ocorre dentro da lista de invocação de `source`.</span><span class="sxs-lookup"><span data-stu-id="03801-886">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="03801-887">Se a lista de invocação de `value` ocorre mais de uma vez na lista de invocação `source`, a última ocorrência será removida.</span><span class="sxs-lookup"><span data-stu-id="03801-887">If the invocation list of `value` occurs more than once in the invocation list of `source`, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-888">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-888">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-889">Os tipos de delegado não são correspondentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-889">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-890">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-890">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-891">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-891">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">
          <span data-ttu-id="03801-892">O delegado do qual a lista de invocação de <c>value</c> será removida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-892">The delegate from which to remove the invocation list of <c>value</c>.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="03801-893">O delegado que fornece a lista de invocação a ser removida da lista de invocação de <c>source</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-893">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-894">Remove todas as ocorrências da lista de invocação de um delegado da lista de invocação de outro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-894">Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-895">Um novo delegado com uma lista de invocação formada com o uso da lista de invocação de <paramref name="source" /> e remoção de todas as ocorrências da lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-895">A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="03801-896">Retorna <paramref name="source" /> se <paramref name="value" /> é <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não é encontrada na lista de invocação de <paramref name="source" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-896">Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />.</span>
          </span>
          <span data-ttu-id="03801-897">Retorna uma referência nula se a lista de invocação de <paramref name="value" /> é igual à lista de invocação de <paramref name="source" />, se <paramref name="source" /> contém apenas uma série de listas de invocação que é igual à lista de invocação de <paramref name="value" /> ou se <paramref name="source" /> é uma referência nula.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-897">Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-898">Se a lista de invocação de `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` ocorre dentro da lista de invocação de `source`.</span><span class="sxs-lookup"><span data-stu-id="03801-898">If the invocation list of `value` matches a contiguous set of elements in the invocation list of `source`, then the invocation list of `value` is said to occur within the invocation list of `source`.</span></span> <span data-ttu-id="03801-899">Se a lista de invocação de `value` ocorre mais de uma vez na lista de invocação `source`, todas as ocorrências são removidas.</span><span class="sxs-lookup"><span data-stu-id="03801-899">If the invocation list of `value` occurs more than once in the invocation list of `source`, all occurrences are removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-900">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-900">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="03801-901">Os tipos de delegado não são correspondentes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-901">The delegate types do not match.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-902">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-902">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-903">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-903">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">
          <span data-ttu-id="03801-904">O delegado que fornece a lista de invocação a ser removida da lista de invocação do delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-904">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="03801-905">Remove a lista de invocação de um delegado da lista de invocação de outro delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-905">Removes the invocation list of a delegate from the invocation list of another delegate.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="03801-906">Um novo delegado com uma lista de invocação formada tomando a lista de invocação do delegado atual e removendo a lista de invocação de <paramref name="value" />, se a lista de invocação de <paramref name="value" /> for encontrada na lista de invocação do delegado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-906">A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="03801-907">Retorna o delegado atual se <paramref name="value" /> for <see langword="null" /> ou se a lista de invocação de <paramref name="value" /> não for encontrada na lista de invocação do delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-907">Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list.</span>
          </span>
          <span data-ttu-id="03801-908">Retorna <see langword="null" /> se a lista de invocação de <paramref name="value" /> é igual à lista de invocação do delegado atual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-908">Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-909">Se a lista de invocação de `value` corresponde a um conjunto contíguo de elementos na lista de invocação do delegado e, em seguida, a lista de invocação de `value` ocorre dentro da lista de invocação do delegado.</span><span class="sxs-lookup"><span data-stu-id="03801-909">If the invocation list of `value` matches a contiguous set of elements in the current delegate's invocation list, then the invocation list of `value` is said to occur within the current delegate's invocation list.</span></span> <span data-ttu-id="03801-910">Se a lista de invocação de `value` ocorre mais de uma vez na lista de invocação do delegado, a última ocorrência será removida.</span><span class="sxs-lookup"><span data-stu-id="03801-910">If the invocation list of `value` occurs more than once in the current delegate's invocation list, the last occurrence is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">
          <span data-ttu-id="03801-911">O chamador não tem acesso ao método representado pelo representante (por exemplo, caso o método seja privado).</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-911">The caller does not have access to the method represented by the delegate (for example, if the method is private).</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-912">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-912">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-913">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-913">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="03801-914">Obtém a instância da classe em que o delegado atual invoca o método de instância.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-914">Gets the class instance on which the current delegate invokes the instance method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="03801-915">O objeto no qual o delegado atual invoca o método de instância, se o delegado representar um método de instância; <see langword="null" /> se o delegado representar um método estático.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-915">The object on which the current delegate invokes the instance method, if the delegate represents an instance method; <see langword="null" /> if the delegate represents a static method.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="03801-916">Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.</span><span class="sxs-lookup"><span data-stu-id="03801-916">An instance method is a method that is associated with an instance of a class; a static method is a method that is associated with the class itself.</span></span>  
  
 <span data-ttu-id="03801-917">Se o representante invoca um ou mais métodos de instância, essa propriedade retorna o destino do último método de instância na lista de invocação.</span><span class="sxs-lookup"><span data-stu-id="03801-917">If the delegate invokes one or more instance methods, this property returns the target of the last instance method in the invocation list.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="03801-918">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-918">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
          <span data-ttu-id="03801-919">Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="03801-919">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
  </Members>
</Type>