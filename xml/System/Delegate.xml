<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0456aa37bceeab49a6fac813bdba77750d99b8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481524" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Delegate> é a classe base para tipos de delegado. No entanto, somente o sistema e os compiladores podem derivar explicitamente o <xref:System.Delegate> classe ou a partir de <xref:System.MulticastDelegate> classe. Também não é permitido para derivar um novo tipo de um tipo de delegado. O <xref:System.Delegate> classe não é considerado um tipo de delegado; é uma classe usada para derivar tipos de delegado.  
  
 Implementar a maioria das linguagens uma `delegate` palavra-chave e compiladores para essas linguagens são capazes de derivar o <xref:System.MulticastDelegate> classe; portanto, os usuários devem usar o `delegate` fornecido pela linguagem de palavra-chave.  
  
> [!NOTE]
>  O common language runtime fornece um `Invoke` método para cada tipo de delegado, com a mesma assinatura que o delegado. Não é necessário chamar esse método explicitamente do c#, Visual Basic ou Visual C++, pois os compiladores de chamá-lo automaticamente. O `Invoke` método é útil na [reflexão](~/docs/framework/reflection-and-codedom/reflection.md) quando você deseja localizar a assinatura do tipo delegado.  
  
 O common language runtime fornece a cada tipo de delegado com `BeginInvoke` e `EndInvoke` métodos, para permitir a invocação assíncrona do delegado. Para obter mais informações sobre esses métodos, consulte [chamando métodos síncronos assincronamente](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 A declaração de um tipo delegado estabelece um contrato que especifica a assinatura de um ou mais métodos. Um delegado é uma instância de um tipo de delegado que possui referências a:  
  
-   Um método de instância de um tipo e um objeto de destino pode ser atribuído a esse tipo.  
  
-   Um método de instância de um tipo, com o oculto `this` parâmetro exposto na lista de parâmetros formais. O delegado deve ser um representante de instância aberta.  
  
-   Um método estático.  
  
-   Um método estático e um objeto de destino pode ser atribuído ao primeiro parâmetro do método. O delegado deve ser fechado ao longo de seu primeiro argumento.  
  
 Para obter mais informações sobre associação de delegados, consulte o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método.  
  
> [!NOTE]
>  Nas versões do .NET Framework 1.0 e 1.1, um delegado pode representar um método somente se a assinatura do método corresponde exatamente à assinatura especificada pelo tipo de delegado. Assim, somente os primeiros e terceiro marcadores na lista acima têm suporte e o primeiro marcador requer uma correspondência de tipo exato.  
  
 Quando um delegado representa um método de instância fechado ao longo de seu primeiro argumento (o caso mais comum), o delegado armazena uma referência ao ponto de entrada do método e uma referência a um objeto, chamado destino, que é de um tipo atribuível ao tipo de definido o método. Quando um delegado representa um método de instância aberto, ele armazena uma referência ao ponto de entrada do método. A assinatura do delegado deve incluir o oculto `this` parâmetro na lista de parâmetros formais; nesse caso, o delegado não tem uma referência a um objeto de destino e um objeto de destino deve ser fornecido quando o delegado é invocado.  
  
 Quando um delegado representa um método estático, o delegado armazena uma referência ao ponto de entrada do método. Quando um delegado representa um método estático fechado ao longo de seu primeiro argumento, o delegado armazena uma referência ao ponto de entrada do método e uma referência a um objeto de destino pode ser atribuído para o tipo do primeiro argumento de um método. Quando o delegado é invocado, o primeiro argumento do método estático recebe o objeto de destino.  
  
 A lista de invocação de um delegado é um conjunto ordenado de delegados em que cada elemento da lista invoca exatamente um dos métodos representados pelo delegado. Uma lista de invocação pode conter métodos duplicados. Durante uma invocação, os métodos são chamados na ordem em que aparecem na lista de invocação. Um delegado tenta chamar cada método em sua lista de invocação; as duplicatas são invocadas depois de cada vez que eles aparecem na lista de invocação. Os delegados são imutáveis; Depois de criado, não altera a lista de invocação de um delegado.  
  
 Delegados são chamados como multicast, ou podem ser combinadas, pois pode invocar um ou mais métodos de um delegado e pode ser usado em combinação de operações.  
  
 Combinação de operações, como <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A>, não alteram os delegados existentes. Em vez disso, essa operação retorna um novo delegado que contém os resultados da operação, um delegado inalterado, ou `null`. Retorna uma operação de combinação `null` quando o resultado da operação é um delegado que não faz referência a pelo menos um método. Uma operação de combinação retorna um delegado inalterado quando a operação solicitada não tem nenhum efeito.  
  
> [!NOTE]
>  Os gerenciados usam linguagens a <xref:System.Delegate.Combine%2A> e <xref:System.Delegate.Remove%2A> métodos para implementar operações de delegado. Os exemplos incluem o `AddHandler` e `RemoveHandler` instruções no Visual Basic e os operadores + = e -= no representante de tipos em c#.  
  
 Começando com o [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], tipos de delegado genérico podem ter parâmetros de tipo variantes. Parâmetros de tipo Contravariantes podem ser usados como tipos de parâmetro do delegado e um parâmetro de tipo covariante pode ser usado como o tipo de retorno. Esse recurso permite que o delegado genérico tipos construídos da mesma definição de tipo genérico para ser compatíveis com a atribuição se seus argumentos de tipo são tipos de referência com uma relação de herança, conforme explicado em [covariância e A contravariância](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, mas os dois delegados não podem ser combinados porque os tipos não correspondem exatamente.  
  
 Se um método invocado gera uma exceção, o método interromperá a execução, a exceção é passada para o chamador do delegado e métodos restantes na lista de invocação não são invocados. Capturar a exceção no chamador não altera esse comportamento.  
  
 Quando a assinatura dos métodos invocados por um delegado inclui um valor de retorno, o delegado retorna o valor retornado do último elemento na lista de invocação. Quando a assinatura inclui um parâmetro que é passado por referência, o valor final do parâmetro é o resultado de cada método na lista de invocação, executar em sequência e atualizando o valor do parâmetro.  
  
 O equivalente mais próximo de um delegado em C ou C++ é um ponteiro de função. Um delegado pode representar um método estático ou um método de instância. Quando o delegado representa um método de instância, o delegado armazena não apenas uma referência ao ponto de entrada do método, mas também uma referência para a instância da classe. Ao contrário dos ponteiros de função, delegados são orientada a objeto e fortemente tipados.  
  
   
  
## Examples  
 O exemplo a seguir mostra como definir um representante chamado `myMethodDelegate`. São criadas instâncias desse delegado para um método de instância e um método estático do aninhada `mySampleClass` classe. O delegado para o método de instância requer uma instância de `mySampleClass`. O `mySampleClass` instância é salvo em uma variável chamada `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new delegate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The class instance on which the delegate invokes <c>method</c>.</param>
        <param name="method">The name of the instance method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified instance method on the specified class instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor não pode ser usado no código do aplicativo. Para criar um delegado, especificando o nome de um método de instância, use uma sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método e um objeto de destino. Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> sobrecarga do método cria um delegado para um método de instância com um nome especificado.  
  
 Este construtor cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">There was an error binding to the target method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified static method from the specified class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este construtor não pode ser usado no código do aplicativo. Para criar um delegado, especificando o nome de um método estático, use uma sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método que especifica um nome de método, mas não especifica um objeto de destino. Por exemplo, o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> sobrecarga do método cria um delegado de estático para um método com um nome especificado.  
  
 Este construtor cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> represents an open generic type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the delegate.</summary>
        <returns>A shallow copy of the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O clone tem o mesmo <xref:System.Type>, lista de destino, o método e a invocação do representante original.  
  
 Uma cópia superficial cria uma nova instância do mesmo tipo que o objeto original e, em seguida, copia os campos não estáticos do objeto original. Se o campo é um tipo de valor, uma cópia de bit por bit do campo será executada. Se o campo é um tipo de referência, a referência será copiada, mas o objeto referenciado é não; Portanto, a referência no objeto original e a referência do clone apontam para o mesmo objeto. Em contraste, uma cópia em profundidade de um objeto duplica tudo direta ou indiretamente referenciado pelos campos no objeto.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegates.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">The array of delegates to combine.</param>
        <summary>Concatenates the invocation lists of an array of delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o `delegates` matriz contém entradas que são `null`, essas entradas são ignoradas.  
  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado nas [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados, porque os tipos de fazer não corresponde exatamente.  
  
 <xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list comes first.</param>
        <param name="b">The delegate whose invocation list comes last.</param>
        <summary>Concatenates the invocation lists of two delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
> [!NOTE]
>  Delegados genéricos que são compatíveis com a atribuição devido à variação não são necessariamente podem ser combinadas. Para ser combináveis, os tipos devem corresponder exatamente. Por exemplo, suponha que uma classe denominada `Derived` é derivado de uma classe chamada `Base`. Um delegado do tipo `Action<Base>` (`Action(Of Base)` no Visual Basic) pode ser atribuído a uma variável do tipo `Action<Derived>`, conforme explicado nas [covariância e contravariância](~/docs/standard/generics/covariance-and-contravariance.md), mas os dois delegados não podem ser combinados, porque os tipos de fazer não corresponde exatamente.  
  
 <xref:System.Delegate.Combine%2A> é útil para a criação de manipuladores de eventos que ocorre um evento de tempo de vários métodos de chamada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</param>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</summary>
        <returns>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se aplica somente se o delegado atual é difundida por multicast (Combinável).  
  
 A implementação atual simplesmente gera uma <xref:System.MulticastNotSupportedException>.  
  
 A lista de invocação pode conter entradas duplicadas; ou seja, as entradas que se referem ao mesmo método no mesmo objeto.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Always thrown.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a delegate of the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Na versão 1.0 e 1.1 do .NET Framework, essa sobrecarga de método cria delegados para apenas métodos estáticos. No .NET Framework versão 2.0, essa sobrecarga de método também pode criar instância aberta delegados de método; ou seja, delegados que fornecem explicitamente o primeiro argumento oculto de métodos de instância. Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, que permite que você criar todas as combinações de delegados abertos ou fechados para métodos estáticos ou de instância e, opcionalmente, para especificar um primeiro argumento.  
  
> [!NOTE]
>  Essa sobrecarga de método deve ser usada quando o delegado não é fechado ao longo de seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 No .NET Framework versão 2.0, os tipos de parâmetro e o tipo de retorno de um delegado que foi criado usando essa sobrecarga de método devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente. Isso representa um relaxamento do comportamento de associação no .NET Framework versão 1.0 e 1.1, em que os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra duas maneiras de um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deve ser lançado na falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="firstArgument">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Chamar essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método e especificando `true` para `throwOnBindFailure`. Essas duas sobrecargas fornecem a maneira mais flexível para criar delegados. Você pode usá-los para criar delegados para estáticas ou métodos de instância e, opcionalmente, para especificar o primeiro argumento.  
  
> [!NOTE]
>  Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método para melhorar o desempenho.  
  
 O tipo de delegado e o método devem ter tipos de retornados compatíveis. Ou seja, o tipo de retorno `method` deve ser atribuível ao tipo de retorno de `type`.  
  
 Se `firstArgument` é fornecido, ele é passado para `method` sempre que o delegado é invocado; `firstArgument` deve ser associado ao representante, e o delegado deve ser fechado ao longo de seu primeiro argumento. Se `method` está `static` (`Shared` no Visual Basic), a lista de argumentos fornecida ao invocar o delegado inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para a instância oculta parâmetro (representado por `this` em c# ou por `Me` no Visual Basic).  
  
 Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com esse tipo.  
  
> [!IMPORTANT]
>  Se `method` está `static` (`Shared` no Visual Basic) e seu primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor. Nesse caso, `firstArgument` é automaticamente convertido. Conversão boxing automática não ocorrerá para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.  
  
 Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o delegado deve representar um método de instância aberta. Quando o delegado é invocado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta do `method`.  
  
-   Se as assinaturas dos `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o delegado deve ser fechado por uma referência nula. Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.  
  
 Se `firstArgument` é uma referência nula e `method` é estática, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), o delegado deve representar um método estático aberto. Isso é o caso mais comum para métodos estáticos. Nesse caso, você pode obter um desempenho ligeiramente melhor usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método.  
  
-   Se a assinatura do `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis e, em seguida, o delegado deve ser fechado por uma referência nula. Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1, os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinando os métodos que um delegado pode representar  
 Outra maneira útil para pensar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer delegado pode representar quatro combinações diferentes de assinatura de método e o tipo de método (estático versus instância). Considere um tipo de delegado `D` com um argumento do tipo `C`. A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ele deve corresponder em todos os casos:  
  
-   `D` pode representar qualquer método de instância que tem exatamente um argumento do tipo `C`, independentemente de qual pertence o método de instância de tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o delegado resultante deve ser fechada por essa instância. (Trivialmente, `D` também pode ser fechada ao longo de uma referência nula se `firstArgument` é uma referência nula.)  
  
-   `D` pode representar um método de instância `C` que não tem argumentos. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que aceita um argumento do tipo `C`, e que o método pode pertencer a qualquer tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método estático aberto e uma instância do `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`. O delegado resultante representa um método estático que é fechado por essa instância do `F`. Observe que, no caso em que `F` e `C` são do mesmo tipo, o método estático tem dois argumentos desse tipo. (Nesse caso, `D` é fechado por uma referência nula se `firstArgument` é uma referência nula.)  
  
   
  
## Examples  
 Esta seção contém três exemplos de código. O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado ao longo de um método de instância, abra um método de instância, abra ao longo de um método estático e fechado ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos que tipo de delegado podem representar.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra as quatro maneiras em que um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não tiver nenhum argumento.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`. Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
-   Por fim, um delegado do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`. O método é invocado para mostrar que ele usa a cadeia de caracteres associada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemplo 3**  
  
 O exemplo de código a seguir mostra todos os métodos pode representar um tipo de delegado único, usando o <xref:System.Delegate.CreateDelegate%2A> método para criar os delegados.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo de código define duas classes, `C` e `F`e um tipo de delegado `D` com um argumento do tipo `C`. As classes têm correspondência estáticos e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não tem argumentos.  
  
 Uma terceira classe denominada `Example` contém o código que cria os representantes.  
  
-   Delegados são criados por exemplo método `M1` do tipo `C` e digite `F`; cada um é fechada por uma instância do respectivo tipo. Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
-   Um delegado é criado para o método `M2` do tipo `C`. Esse é um delegado de instância aberta, na qual o argumento do delegado representa o primeiro argumento oculto no método de instância. O método não tem outros argumentos. Ele é chamado como se fosse um método estático.  
  
-   Delegados são criados para o método estático `M3` do tipo `C` e digite `F`; esses são delegados estáticos abertos.  
  
-   Por fim, os delegados são criados para o método estático `M4` do tipo `C` e digite `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, portanto, os delegados são fechados em seus primeiros argumentos . Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método pode criar delegados de método estático aberto e abrir os delegados de método de instância — ou seja, os delegados que expõem o primeiro argumento oculto de métodos de instância. Para obter uma explicação detalhada, consulte o mais geral <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> métodos estáticos ou sobrecarga de método, que permite que você criar todas as combinações de delegados abertos ou fechados, por exemplo.  
  
> [!NOTE]
>  Essa sobrecarga de método deve ser usada quando o delegado não é fechado ao longo de seu primeiro argumento, porque ele é um pouco mais rápido, nesse caso.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1, os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Esta seção contém dois exemplos de código. O primeiro exemplo demonstra os dois tipos de delegados que podem ser criados com essa sobrecarga de método: Abra um método de instância e ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra duas maneiras de um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do <xref:System.Delegate.CreateDelegate%2A> método que especifica um <xref:System.Reflection.MethodInfo> , mas não é um primeiro argumento; sua funcionalidade é a mesma, exceto que um permite que você especifique se deve ser lançado na falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e dois tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, e `D2` usa uma cadeia de caracteres.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `false` para `ignoreCase` e `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the type of delegate to create.</param>
        <param name="firstArgument">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Essa sobrecarga de método e o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> sobrecarga de método, que sempre gera na falha de associação, fornecem a maneira mais flexível para criar delegados. Você pode usá-los para criar delegados para estáticas ou métodos de instância, com ou sem um primeiro argumento.  
  
> [!NOTE]
>  Se você não fornecer um primeiro argumento, use o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método para melhorar o desempenho.  
  
 O tipo de delegado e o método devem ter tipos de retornados compatíveis. Ou seja, o tipo de retorno `method` deve ser atribuível ao tipo de retorno de `type`.  
  
 Se `firstArgument` é fornecido, ele é passado para `method` sempre que o delegado é invocado; `firstArgument` deve ser associado ao representante, e o delegado deve ser fechado ao longo de seu primeiro argumento. Se `method` está `static` (`Shared` no Visual Basic), a lista de argumentos fornecida ao invocar o delegado inclui todos os parâmetros, exceto o primeiro; se `method` é um método de instância, em seguida, `firstArgument` é passado para a instância oculta parâmetro (representado por `this` em c# ou por `Me` no Visual Basic).  
  
 Se `firstArgument` for fornecido, o primeiro parâmetro de `method` deve ser um tipo de referência, e `firstArgument` devem ser compatíveis com esse tipo.  
  
> [!IMPORTANT]
>  Se `method` está `static` (`Shared` no Visual Basic) e seu primeiro parâmetro é do tipo <xref:System.Object> ou <xref:System.ValueType>, em seguida, `firstArgument` pode ser um tipo de valor. Nesse caso, `firstArgument` é automaticamente convertido. Conversão boxing automática não ocorrerá para quaisquer outros argumentos, como seria em um c# ou Visual Basic função chamada.  
  
 Se `firstArgument` é uma referência nula e `method` é um método de instância, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `type` inclua explicitamente o primeiro parâmetro oculto de `method`, o delegado deve representar um método de instância aberta. Quando o delegado é invocado, o primeiro argumento na lista de argumentos é passado para o parâmetro de instância oculta do `method`.  
  
-   Se as assinaturas dos `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), em seguida, o delegado deve ser fechado por uma referência nula. Invocar o delegado é como chamar um método de instância em uma instância nula, o que não é uma coisa particularmente útil para fazer.  
  
 Se `firstArgument` é uma referência nula e `method` é estática, o resultado depende das assinaturas do tipo de delegado `type` e de `method`:  
  
-   Se a assinatura do `method` e `type` corresponder (ou seja, todos os tipos de parâmetro são compatíveis), o delegado deve representar um método estático aberto. Isso é o caso mais comum para métodos estáticos. Nesse caso, você pode obter um desempenho ligeiramente melhor usando o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> sobrecarga de método.  
  
-   Se a assinatura do `type` começa com o segundo parâmetro do `method` e o restante dos tipos de parâmetro são compatíveis e, em seguida, o delegado deve ser fechado por uma referência nula. Quando o delegado é invocado, uma referência nula é passada para o primeiro parâmetro de `method`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Tipos de parâmetro compatíveis e tipo de retorno  
 Os tipos de parâmetro e o tipo de retorno de um delegado devem ser compatíveis com os tipos de parâmetro e o tipo de retorno do método que o delegado representa; os tipos não precisam corresponder exatamente.  
  
> [!NOTE]
>  No .NET Framework versão 1.0 e 1.1 os tipos devem corresponder exatamente.  
  
 Um parâmetro de um delegado será compatível com o parâmetro correspondente de um método se o tipo do parâmetro de delegado for mais restritivo do que o tipo do parâmetro de método, porque isso garante que um argumento passado para o delegado possa ser passado com segurança para o método.  
  
 Da mesma forma, o tipo de retorno de um delegado será compatível com o tipo de retorno de um método se o tipo de retorno do método for mais restritivo do que o tipo de retorno do delegado, porque isso garante que o valor retornado do método possa ser convertido com segurança para o tipo retorno do delegado.  
  
 Por exemplo, um delegado com um parâmetro do tipo <xref:System.Collections.Hashtable> e um tipo de retorno <xref:System.Object> pode representar um método com um parâmetro do tipo <xref:System.Object> e um valor de retorno do tipo <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Determinando os métodos que um delegado pode representar  
 Outra maneira útil para pensar a flexibilidade fornecida por essa sobrecarga de <xref:System.Delegate.CreateDelegate%2A> é que qualquer delegado pode representar quatro combinações diferentes de assinatura de método e o tipo de método (estático versus instância). Considere um tipo de delegado `D` com um argumento do tipo `C`. A seguir descreve os métodos `D` podem representar, ignorando o tipo de retorno, pois ele deve corresponder em todos os casos:  
  
-   `D` pode representar qualquer método de instância que tem exatamente um argumento do tipo `C`, independentemente de qual pertence o método de instância de tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância do tipo `method` pertence, e o delegado resultante deve ser fechada por essa instância. (Trivialmente, `D` também pode ser fechada ao longo de uma referência nula se `firstArgument` é `null`.)  
  
-   `D` pode representar um método de instância `C` que não tem argumentos. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método de instância aberta e uma instância de `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que aceita um argumento do tipo `C`, e que o método pode pertencer a qualquer tipo. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma referência nula. O delegado resultante representa um método estático aberto e uma instância do `C` deve ser fornecido a cada vez que ele é invocado.  
  
-   `D` pode representar um método estático que pertence ao tipo `F` e tem dois argumentos de tipo `F` e digite `C`. Quando <xref:System.Delegate.CreateDelegate%2A> é chamado, `firstArgument` é uma instância de `F`. O delegado resultante representa um método estático que é fechado por essa instância do `F`. Observe que, no caso em que `F` e `C` são do mesmo tipo, o método estático tem dois argumentos desse tipo. (Nesse caso, `D` é fechado por uma referência nula se `firstArgument` é `null`.)  
  
   
  
## Examples  
 Esta seção contém três exemplos de código. O primeiro exemplo demonstra os quatro tipos de delegados que podem ser criados: fechado ao longo de um método de instância, abra um método de instância, abra ao longo de um método estático e fechado ao longo de um método estático.  
  
 O segundo exemplo de código demonstra tipos de parâmetro correspondentes e tipos de retorno.  
  
 O terceiro exemplo de código define um tipo de delegado único e mostra todos os métodos que tipo de delegado podem representar.  
  
 **Exemplo 1**  
  
 O exemplo de código a seguir demonstra as quatro maneiras em que um delegado pode ser criado usando essa sobrecarga da <xref:System.Delegate.CreateDelegate%2A> método.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo declara uma classe `C` com um método estático `M2` e um método de instância `M1`, e três tipos de delegado: `D1` leva a uma instância do `C` e uma cadeia de caracteres, `D2` usa uma cadeia de caracteres e `D3`não tiver nenhum argumento.  
  
 Uma segunda classe chamada `Example` contém o código que cria os representantes.  
  
-   Um delegado do tipo `D2`, fechado em uma instância do `C`, é criado para o método de instância `M1`. Ele é invocado com cadeias de caracteres diferentes, para mostrar que a instância associada do `C` sempre é usado.  
  
-   Um representante de tipo `D1`, representando um método de instância aberto, é criado para o método de instância `M1`. Uma instância deve ser passada quando o representante é invocado.  
  
-   Um representante de tipo `D2`, representando um método estático aberto, é criado para o método estático `M2`.  
  
-   Por fim, um delegado do tipo `D3`, fechado por uma cadeia de caracteres, que é criado para o método estático `M2`. O método é invocado para mostrar que ele usa a cadeia de caracteres associada.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Exemplo 2**  
  
 O exemplo de código a seguir demonstra a compatibilidade dos tipos de parâmetro e de retorno.  
  
> [!NOTE]
>  Este exemplo de código usa o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> sobrecarga de método. O uso das outras sobrecargas que aceitam <xref:System.Reflection.MethodInfo> é semelhante.  
  
 O exemplo de código define uma classe base chamada `Base` e uma classe chamada `Derived` derivada de `Base`. A classe derivada tem um método `static` (`Shared` no Visual Basic) chamado `MyMethod` com um parâmetro do tipo `Base` e um retorno do tipo de `Derived`. O exemplo de código também define um representante chamado `Example` que tem um parâmetro do tipo `Derived` e um tipo de retorno de `Base`.  
  
 O exemplo de código demonstra que o representante chamado `Example` pode ser usado para representar o método `MyMethod`. O método pode ser associado ao representante porque:  
  
-   O tipo de parâmetro do representante (`Derived`) é mais restritivo do que o tipo de parâmetro `MyMethod` (`Base`), logo, é sempre seguro passar o argumento do representante para `MyMethod`.  
  
-   O tipo de retorno de `MyMethod` (`Derived`) é mais restritivo do que o tipo de parâmetro do representante (`Base`), logo, é sempre seguro converter o tipo de retorno do método no tipo de retorno do representante.  
  
 O exemplo de código não produz nenhuma saída.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Exemplo 3**  
  
 O exemplo de código a seguir mostra todos os métodos de que um tipo de delegado única pode representar.  
  
> [!NOTE]
>  Há duas sobrecargas do método <xref:System.Delegate.CreateDelegate%2A> que especificam `firstArgument` e <xref:System.Reflection.MethodInfo>; sua funcionalidade é a mesma, exceto por uma permitir especificar se é necessário lançar falha de associação e a outra lançar sempre. Este exemplo de código usa ambas as sobrecargas.  
  
 O exemplo de código define duas classes, `C` e `F`e um tipo de delegado `D` com um argumento do tipo `C`. As classes têm correspondência estáticos e métodos de instância `M1`, `M3`, e `M4`e a classe `C` também tem um método de instância `M2` que não tem argumentos.  
  
 Uma terceira classe denominada `Example` contém o código que cria os representantes.  
  
-   Delegados são criados por exemplo método `M1` do tipo `C` e digite `F`; cada um é fechada por uma instância do respectivo tipo. Método `M1` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
-   Um delegado é criado para o método `M2` do tipo `C`. Esse é um delegado de instância aberta, na qual o argumento do delegado representa o primeiro argumento oculto no método de instância. O método não tem outros argumentos.  
  
-   Delegados são criados para o método estático `M3` do tipo `C` e digite `F`; esses são delegados estáticos abertos.  
  
-   Por fim, os delegados são criados para o método estático `M4` do tipo `C` e digite `F`; cada método tem o tipo de declaração como seu primeiro argumento e uma instância do tipo for fornecida, portanto, os delegados são fechados em seus primeiros argumentos . Método `M4` do tipo `C` exibe o `ID` propriedades da instância associada do e do argumento.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Essa sobrecarga de método é equivalente a chamar o <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga do método, especificando `true` para `throwOnBindFailure`.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados por exemplo apenas métodos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método cria delegados para apenas métodos estáticos. Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
> [!NOTE]
>  Começando pelo [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], esse método pode ser usado para acessar métodos não públicos caso o chamador tenha recebido <xref:System.Security.Permissions.ReflectionPermission> com o sinalizador <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> e caso o conjunto de concessões dos métodos não públicos seja restrito ao conjunto de concessões do chamador, ou um subconjunto dele. (Consulte [considerações sobre segurança para reflexão](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Para usar essa funcionalidade, seu aplicativo deve ser direcionado ao [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] ou posterior.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método chama o <xref:System.Delegate.DynamicInvokeImpl%2A> método.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método implementa o método <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current delegate.</param>
        <summary>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação serão consideradas idênticas somente se eles têm a mesma ordem e os elementos correspondentes das duas listas de representarem o mesmo método e o destino.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for the delegate.</summary>
        <returns>A hash code for the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor de retorno desse método não deve ser persistido por dois motivos. Em primeiro lugar, a função de hash de uma classe pode ser alterada para gerar uma distribuição melhor, renderização de todos os valores da função de hash antigo inútil. Em segundo lugar, a implementação padrão dessa classe não garante que o mesmo valor será retornado por instâncias diferentes.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the invocation list of the delegate.</summary>
        <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cada delegado na matriz representa exatamente um método.  
  
 A ordem dos delegados na matriz é a mesma ordem em que o delegado atual invoca os métodos que representam os delegados.  
  
   
  
## Examples  
 O exemplo a seguir atribui a três métodos a um delegado. Em seguida, ele chama o <xref:System.Delegate.GetInvocationList%2A> método para obter uma contagem total dos métodos atribuído ao delegado, para executar os delegados na ordem inversa, bem como executar os métodos cujo nome não incluem a subcadeia de caracteres "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the static method represented by the current delegate.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esse método se aplica somente se o delegado atual representa um método estático.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Not supported.</param>
        <param name="context">Not supported.</param>
        <summary>Not supported.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Requer confiança total para o chamador imediato. Este membro não pode ser usado pelo código transparente ou parcialmente confiável.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the method represented by the delegate.</summary>
        <value>Uma <see cref="T:System.Reflection.MethodInfo" /> que descreve o método representado pelo delegado.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois delegados do mesmo tipo com os mesmos destinos, métodos e listas de invocação são considerados iguais.  
  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados foram considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação serão consideradas idênticas se tiverem a mesma ordem e os elementos correspondentes de duas listas representarem o mesmo método e destino.  
  
 É o método equivalente para esse operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dois delegados são considerados não iguais se forem de tipos diferentes, ou ter métodos diferentes, destinos diferentes ou listas de invocação diferente.  
  
 Se os dois delegados não são do mesmo tipo, eles não são considerados iguais.  
  
> [!IMPORTANT]
>  No .NET Framework versão 1.0 e 1.1, dois delegados são considerados iguais se seus destinos, métodos e lista de invocação fossem iguais, mesmo que os delegados de tipos diferentes.  
  
 Os métodos e os destinos são comparados quanto à igualdade, da seguinte maneira:  
  
-   Se os dois métodos que estão sendo comparados são estáticos em são o mesmo método na mesma classe, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Se os dois métodos que estão sendo comparados são métodos de instância em o mesmo método no mesmo objeto, os métodos são considerados iguais e os destinos também são considerados iguais.  
  
-   Caso contrário, os métodos não são considerados iguais e os destinos também não são considerados iguais.  
  
 Duas listas de invocação não são iguais se eles tiverem tamanhos diferentes, se eles são ordenados de forma diferente, ou se pelo menos um elemento de uma lista representa um método ou o destino que é diferente daquele representado por seu elemento correspondente em outra lista.  
  
 É o método equivalente para esse operador <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` deve ocorrer na lista de invocação de `source`. Se a lista de invocação `value` ocorre mais de uma vez na lista de invocação de `source`, a última ocorrência será removida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação de `source`, em seguida, a lista de invocação de `value` deve ocorrer na lista de invocação de `source`. Se a lista de invocação `value` ocorre mais de uma vez na lista de invocação de `source`, todas as ocorrências são removidas.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</param>
        <summary>Removes the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se a lista de invocação `value` corresponde a um conjunto contíguo de elementos na lista de invocação do delegado atual e, em seguida, lista de invocação de `value` deve ocorrer na lista de invocação do delegado atual. Se a lista de invocação de `value` ocorre mais de uma vez na lista de invocação do delegado atual, a última ocorrência será removida.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class instance on which the current delegate invokes the instance method.</summary>
        <value>O objeto no qual o delegado atual invoca o método de instância, se o delegado representar um método de instância; <see langword="null" /> se o delegado representar um método estático.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Método de instância é um método associado a uma instância de uma classe; método estático é um método associado à própria classe.  
  
 Se o delegado invoca um ou mais métodos de instância, essa propriedade retorna o destino do último método de instância na lista de invocação.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">quando invocado com associação tardia por meio de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Enumeração associada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>